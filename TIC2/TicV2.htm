<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title>Thinking in C++ 2nd ed Volume 2</title>

<style id="dynCom" type="text/css"><!-- --></style>
<script language="JavaScript"><!--
function msoCommentShow(anchor_id, com_id)
{
	if(msoBrowserCheck()) 
		{
		c = document.all(com_id);
		a = document.all(anchor_id);
		if (null != c && null == c.length && null != a && null == a.length)
			{
			var cw = c.offsetWidth;
			var ch = c.offsetHeight;
			var aw = a.offsetWidth;
			var ah = a.offsetHeight;
			var x  = a.offsetLeft;
			var y  = a.offsetTop;
			var el = a;
			while (el.tagName != "BODY") 
				{
				el = el.offsetParent;
				x = x + el.offsetLeft;
				y = y + el.offsetTop;
				}
			var bw = document.body.clientWidth;
			var bh = document.body.clientHeight;
			var bsl = document.body.scrollLeft;
			var bst = document.body.scrollTop;
			if (x + cw + ah / 2 > bw + bsl && x + aw - ah / 2 - cw >= bsl ) 
				{ c.style.left = x + aw - ah / 2 - cw; }
			else 
				{ c.style.left = x + ah / 2; }
			if (y + ch + ah / 2 > bh + bst && y + ah / 2 - ch >= bst ) 
				{ c.style.top = y + ah / 2 - ch; }
			else 
				{ c.style.top = y + ah / 2; }
			c.style.visibility = "visible";
}	}	}
function msoCommentHide(com_id) 
{
	if(msoBrowserCheck())
		{
		c = document.all(com_id);
		if (null != c && null == c.length)
		{
		c.style.visibility = "hidden";
		c.style.left = -1000;
		c.style.top = -1000;
		} } 
}
function msoBrowserCheck()
{
	ms = navigator.appVersion.indexOf("MSIE");
	vers = navigator.appVersion.substring(ms + 5, ms + 6);
	ie4 = (ms > 0) && (parseInt(vers) >= 4);
	return ie4;
}
if (msoBrowserCheck())
{
	document.styleSheets.dynCom.addRule(".msocomanchor","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomoff","display: none");
	document.styleSheets.dynCom.addRule(".msocomtxt","visibility: hidden");
	document.styleSheets.dynCom.addRule(".msocomtxt","position: absolute");
	document.styleSheets.dynCom.addRule(".msocomtxt","top: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","left: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","width: 33%");
	document.styleSheets.dynCom.addRule(".msocomtxt","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomtxt","color: infotext");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-top: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-right: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-bottom: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-left: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","padding: 3pt 3pt 3pt 3pt");
	document.styleSheets.dynCom.addRule(".msocomtxt","z-index: 100");
}
// --></script>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimHei;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 3 5 7 5 2 3 3;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangella Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Times;
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"American Typewriter";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Georgia;
	panose-1:2 4 5 2 5 4 5 2 3 3;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:"Andale Mono";
	panose-1:2 11 5 9 0 0 0 0 0 4;}
@font-face
	{font-family:"Serifa 55";}
@font-face
	{font-family:Marlett;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Lucida Console";
	panose-1:2 11 6 9 4 5 4 2 2 4;}
@font-face
	{font-family:"Lucida Sans Unicode";
	panose-1:2 11 6 2 3 5 4 2 2 4;}
@font-face
	{font-family:"Arial Black";
	panose-1:2 11 10 4 2 1 2 2 2 4;}
@font-face
	{font-family:"Comic Sans MS";
	panose-1:3 15 7 2 3 3 2 2 2 4;}
@font-face
	{font-family:Impact;
	panose-1:2 11 8 6 3 9 2 5 2 4;}
@font-face
	{font-family:"Palatino Linotype";
	panose-1:2 4 5 2 5 5 5 3 3 4;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;}
@font-face
	{font-family:Webdings;
	panose-1:5 3 1 2 1 5 9 6 7 3;}
@font-face
	{font-family:"Microsoft Sans Serif";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"Arial Narrow";
	panose-1:2 11 5 6 2 2 2 3 2 4;}
@font-face
	{font-family:"Book Antiqua";
	panose-1:2 4 6 2 5 3 5 3 3 4;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;}
@font-face
	{font-family:"Century Gothic";
	panose-1:2 11 5 2 2 2 2 2 2 4;}
@font-face
	{font-family:Garamond;
	panose-1:2 2 4 4 3 3 1 1 8 3;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;}
@font-face
	{font-family:"Wingdings 2";
	panose-1:5 2 1 2 1 5 7 7 7 7;}
@font-face
	{font-family:"Wingdings 3";
	panose-1:5 4 1 2 1 8 7 7 7 7;}
@font-face
	{font-family:"Clarendon Condensed";
	panose-1:2 4 7 6 4 7 5 4 2 4;}
@font-face
	{font-family:"CG Times";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"CG Omega";
	panose-1:2 11 5 2 5 5 8 2 3 4;}
@font-face
	{font-family:"Albertus Extra Bold";
	panose-1:2 14 8 2 4 3 4 2 2 4;}
@font-face
	{font-family:"Albertus Medium";
	panose-1:2 14 6 2 3 3 4 2 3 4;}
@font-face
	{font-family:SymbolPS;
	panose-1:5 5 1 2 1 6 7 2 6 7;}
@font-face
	{font-family:Palatino;
	panose-1:2 4 5 2 5 5 5 3 3 4;}
@font-face
	{font-family:"New Century Schoolbook";
	panose-1:2 4 6 3 5 7 5 2 3 4;}
@font-face
	{font-family:"Helvetica Narrow";
	panose-1:2 11 6 6 2 2 2 3 2 4;}
@font-face
	{font-family:"ITC Zapf Dingbats";
	panose-1:5 2 1 2 1 7 4 2 6 9;}
@font-face
	{font-family:CourierPS;
	panose-1:2 7 6 9 2 2 5 2 4 4;}
@font-face
	{font-family:"ITC Zapf Chancery";
	panose-1:3 2 7 2 4 4 3 8 8 4;}
@font-face
	{font-family:"ITC Bookman Demi";
	panose-1:2 5 8 4 4 5 5 2 2 4;}
@font-face
	{font-family:"ITC Bookman Light";
	panose-1:2 5 6 4 5 5 5 2 2 4;}
@font-face
	{font-family:"ITC Avant Garde Gothic Demi";
	panose-1:2 11 8 2 2 2 2 2 2 4;}
@font-face
	{font-family:"ITC Avant Garde Gothic";
	panose-1:2 11 6 2 2 2 2 2 2 4;}
@font-face
	{font-family:"Univers Condensed";
	panose-1:2 11 6 6 2 2 2 6 2 4;}
@font-face
	{font-family:Univers;
	panose-1:2 11 6 3 2 2 2 3 2 4;}
@font-face
	{font-family:"Antique Olive";
	panose-1:2 11 6 3 2 2 4 3 2 4;}
@font-face
	{font-family:Marigold;
	panose-1:3 2 7 2 4 4 2 2 5 4;}
@font-face
	{font-family:"Letter Gothic";
	panose-1:2 11 4 9 2 2 2 3 2 4;}
@font-face
	{font-family:Coronet;
	panose-1:3 3 5 2 4 4 6 7 6 5;}
@font-face
	{font-family:Haettenschweiler;
	panose-1:2 11 7 6 4 9 2 6 2 4;}
@font-face
	{font-family:"Letter Gothic MT";
	panose-1:2 11 5 9 2 1 2 2 2 4;}
@font-face
	{font-family:"Century Schoolbook";
	panose-1:2 4 6 4 5 5 5 2 3 4;}
@font-face
	{font-family:"Times New Roman MT Extra Bold";
	panose-1:2 2 10 6 6 3 1 2 3 3;}
@font-face
	{font-family:OpenSymbol;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:ZWAdobeF;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sydnie;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
h1
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:81.35pt;
	page-break-after:avoid;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-.1in;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;
	font-weight:bold;}
h3
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Verdana;
	font-weight:bold;}
h4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:Verdana;
	font-weight:bold;}
h5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	line-height:13.5pt;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:Georgia;
	font-weight:bold;}
h6
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:11.0pt;
	font-family:Georgia;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;
	font-style:italic;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
p.MsoIndex1, li.MsoIndex1, div.MsoIndex1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex2, li.MsoIndex2, div.MsoIndex2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:24.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex3, li.MsoIndex3, div.MsoIndex3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex4, li.MsoIndex4, div.MsoIndex4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:48.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex5, li.MsoIndex5, div.MsoIndex5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:60.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex6, li.MsoIndex6, div.MsoIndex6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex7, li.MsoIndex7, div.MsoIndex7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:84.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex8, li.MsoIndex8, div.MsoIndex8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:96.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoIndex9, li.MsoIndex9, div.MsoIndex9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.5in;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:13.5pt;
	font-size:9.0pt;
	font-family:Georgia;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:18.0pt;
	page-break-after:avoid;
	background:black;
	font-size:14.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Verdana;}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.7in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	font-size:8.0pt;
	font-family:Verdana;}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:30.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:40.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:50.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:60.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:70.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:80.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:13.0pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:Times;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Verdana;}
p.MsoIndexHeading, li.MsoIndexHeading, div.MsoIndexHeading
	{margin-top:.25in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	border:none;
	padding:0in;
	font-size:10.5pt;
	font-family:Verdana;
	font-weight:bold;
	font-style:italic;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;
	font-weight:bold;}
p.MsoTof, li.MsoTof, div.MsoTof
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:20.0pt;
	text-indent:-20.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoEnvelopeAddress, li.MsoEnvelopeAddress, div.MsoEnvelopeAddress
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:2.0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;}
p.MsoEnvelopeReturn, li.MsoEnvelopeReturn, div.MsoEnvelopeReturn
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;}
span.MsoFootnoteReference
	{font-family:Verdana;
	position:relative;
	top:-3.0pt;}
p.MsoEndnoteText, li.MsoEndnoteText, div.MsoEndnoteText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoToa, li.MsoToa, div.MsoToa
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:10.0pt;
	text-indent:-10.0pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoMacroText, li.MsoMacroText, div.MsoMacroText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:normal;
	font-size:10.0pt;
	font-family:"Courier New";}
p.MsoToaHeading, li.MsoToaHeading, div.MsoToaHeading
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoList, li.MsoList, div.MsoList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListBullet, li.MsoListBullet, div.MsoListBullet
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.5in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListNumber, li.MsoListNumber, div.MsoListNumber
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoList2, li.MsoList2, div.MsoList2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoList3, li.MsoList3, div.MsoList3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoList4, li.MsoList4, div.MsoList4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoList5, li.MsoList5, div.MsoList5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListBullet2, li.MsoListBullet2, div.MsoListBullet2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListBullet3, li.MsoListBullet3, div.MsoListBullet3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListBullet4, li.MsoListBullet4, div.MsoListBullet4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListBullet5, li.MsoListBullet5, div.MsoListBullet5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListNumber2, li.MsoListNumber2, div.MsoListNumber2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListNumber3, li.MsoListNumber3, div.MsoListNumber3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListNumber4, li.MsoListNumber4, div.MsoListNumber4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListNumber5, li.MsoListNumber5, div.MsoListNumber5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	text-align:center;
	font-size:16.0pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoClosing, li.MsoClosing, div.MsoClosing
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:3.0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoSignature, li.MsoSignature, div.MsoSignature
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:3.0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13.5pt;
	font-size:10.0pt;
	font-family:Georgia;}
p.MsoListContinue, li.MsoListContinue, div.MsoListContinue
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListContinue2, li.MsoListContinue2, div.MsoListContinue2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListContinue3, li.MsoListContinue3, div.MsoListContinue3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListContinue4, li.MsoListContinue4, div.MsoListContinue4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoListContinue5, li.MsoListContinue5, div.MsoListContinue5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoMessageHeader, li.MsoMessageHeader, div.MsoMessageHeader
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.75in;
	text-indent:-.75in;
	line-height:12.0pt;
	background:#CCCCCC;
	border:none;
	padding:0in;
	font-size:10.5pt;
	font-family:Times;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	text-align:center;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Arial;}
p.MsoSalutation, li.MsoSalutation, div.MsoSalutation
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoDate, li.MsoDate, div.MsoDate
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoBodyTextFirstIndent, li.MsoBodyTextFirstIndent, div.MsoBodyTextFirstIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:10.5pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;
	font-weight:bold;}
p.MsoBodyTextFirstIndent2, li.MsoBodyTextFirstIndent2, div.MsoBodyTextFirstIndent2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:10.5pt;
	line-height:13.5pt;
	font-size:12.0pt;
	font-family:Georgia;}
p.MsoNoteHeading, li.MsoNoteHeading, div.MsoNoteHeading
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoBodyText2, li.MsoBodyText2, div.MsoBodyText2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	text-align:center;
	font-size:16.0pt;
	font-family:"Times New Roman";}
p.MsoBodyText3, li.MsoBodyText3, div.MsoBodyText3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:8.0pt;
	font-family:Georgia;}
p.MsoBodyTextIndent2, li.MsoBodyTextIndent2, div.MsoBodyTextIndent2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:200%;
	font-size:10.5pt;
	font-family:Georgia;}
p.MsoBodyTextIndent3, li.MsoBodyTextIndent3, div.MsoBodyTextIndent3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:8.0pt;
	font-family:Georgia;}
p.MsoBlockText, li.MsoBlockText, div.MsoBlockText
	{margin-top:0in;
	margin-right:1.0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
a:link, span.MsoHyperlink
	{color:red;
	text-decoration:none;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	background:navy;
	font-size:10.5pt;
	font-family:Tahoma;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:"Courier New";}
p.MsoAutoSig, li.MsoAutoSig, div.MsoAutoSig
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
address
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;
	font-style:italic;}
code
	{font-family:"Courier New";}
pre
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.0pt;
	font-family:"Courier New";}
tt
	{font-family:"Courier New";}
p.Intro, li.Intro, div.Intro
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:0in;
	line-height:17.0pt;
	font-size:13.0pt;
	font-family:Verdana;}
p.Preformatted, li.Preformatted, div.Preformatted
	{margin-top:5.0pt;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:"Courier New";}
p.Numbered, li.Numbered, div.Numbered
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.7in;
	text-indent:-.45in;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.contents, li.contents, div.contents
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:81.35pt;
	page-break-after:avoid;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.CodeChar, li.CodeChar, div.CodeChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Andale Mono";}
p.CodeInlineCharChar, li.CodeInlineCharChar, div.CodeInlineCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Andale Mono";}
p.CodeInlineTrailerCharChar, li.CodeInlineTrailerCharChar, div.CodeInlineTrailerCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:normal;
	font-size:3.0pt;
	font-family:"Andale Mono";}
p.NumberList, li.NumberList, div.NumberList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.25in;
	margin-bottom:.0001pt;
	text-indent:-.3in;
	line-height:normal;
	font-size:9.5pt;
	font-family:Times;
	color:black;}
p.TableHead, li.TableHead, div.TableHead
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:14.0pt;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.Table, li.Table, div.Table
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.Figure, li.Figure, div.Figure
	{margin-top:3.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Times;}
p.AfterTable, li.AfterTable, div.AfterTable
	{margin-top:9.0pt;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:Times;}
p.BulletTIJ, li.BulletTIJ, div.BulletTIJ
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.75in;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:Times;}
p.drawingtext, li.drawingtext, div.drawingtext
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:.25in;
	font-size:10.5pt;
	font-family:Times;
	font-weight:bold;}
p.Exercises, li.Exercises, div.Exercises
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
span.Typewriter
	{font-family:"Courier New";}
span.CODE
	{font-family:"Courier New";}
p.AfterPicture, li.AfterPicture, div.AfterPicture
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
span.Illustration
	{font-family:"Serifa 55";
	font-style:italic;}
span.pro
	{color:fuchsia;}
span.r
	{color:red;}
p.Guidelines, li.Guidelines, div.Guidelines
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-.1in;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.BulletSeminar, li.BulletSeminar, div.BulletSeminar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	font-size:14.0pt;
	font-family:"Times New Roman";}
p.TOCspace, li.TOCspace, div.TOCspace
	{margin:0in;
	margin-bottom:.0001pt;
	line-height:25%;
	font-size:10.5pt;
	font-family:Georgia;}
p.STLAlgorithmCharChar, li.STLAlgorithmCharChar, div.STLAlgorithmCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Andale Mono";}
span.STLAlgorithmCharCharChar
	{font-family:"Andale Mono";}
span.CodeCharChar
	{font-family:"Andale Mono";}
span.CodeInlineCharCharChar
	{font-family:"Andale Mono";}
span.CodeInlineTrailerCharCharChar
	{font-family:"Andale Mono";}
span.Heading3Char1Char
	{font-family:Verdana;
	font-weight:bold;}
span.CodeCharCharChar
	{font-family:"Andale Mono";}
p.ChapterTitle, li.ChapterTitle, div.ChapterTitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:.5in;
	background:white;
	font-size:32.0pt;
	font-family:Georgia;}
p.CodeInline, li.CodeInline, div.CodeInline
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Andale Mono";}
p.CodeInlineTrailer, li.CodeInlineTrailer, div.CodeInlineTrailer
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:1.0pt;
	margin-left:.85in;
	line-height:normal;
	font-size:3.0pt;
	font-family:Georgia;}
p.Bullet, li.Bullet, div.Bullet
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.2in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:normal;
	font-size:12.0pt;
	font-family:"Tms Rmn";
	color:black;}
p.EmphasisP, li.EmphasisP, div.EmphasisP
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:-.1in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:Georgia;
	font-weight:bold;
	font-style:italic;}
p.makeapoint, li.makeapoint, div.makeapoint
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.8in;
	font-size:14.0pt;
	font-family:Georgia;
	font-style:italic;}
p.DrawingObject, li.DrawingObject, div.DrawingObject
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:0in;
	text-align:center;
	line-height:11.0pt;
	font-size:10.5pt;
	font-family:Arial;
	color:black;
	letter-spacing:-.2pt;
	layout-grid-mode:line;}
p.Comments, li.Comments, div.Comments
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:22.0pt;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;}
p.TitleNoTOC, li.TitleNoTOC, div.TitleNoTOC
	{margin-top:0in;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:49.7pt;
	text-indent:-.75in;
	page-break-after:avoid;
	background:white;
	font-size:38.0pt;
	font-family:Verdana;
	color:black;}
p.TitlePage1, li.TitlePage1, div.TitlePage1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	text-align:center;
	font-size:79.0pt;
	font-family:Georgia;
	letter-spacing:-1.0pt;}
p.TitlePage2, li.TitlePage2, div.TitlePage2
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	background:white;
	font-size:32.0pt;
	font-family:Georgia;}
p.TitlePage3, li.TitlePage3, div.TitlePage3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.25in;
	margin-left:0in;
	text-align:center;
	line-height:72.0pt;
	background:white;
	font-size:80.0pt;
	font-family:Georgia;
	color:black;
	letter-spacing:-1.0pt;}
p.TitlePage4, li.TitlePage4, div.TitlePage4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.25in;
	margin-left:0in;
	text-align:center;
	background:white;
	font-size:20.0pt;
	font-family:Georgia;}
p.TitlePage5, li.TitlePage5, div.TitlePage5
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	background:white;
	font-size:32.0pt;
	font-family:Georgia;}
p.TitlePage6, li.TitlePage6, div.TitlePage6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:0in;
	text-align:center;
	background:white;
	font-size:20.0pt;
	font-family:Georgia;}
p.TabularText, li.TabularText, div.TabularText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.5in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.TableFollower, li.TableFollower, div.TableFollower
	{margin-top:9.0pt;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.Quote, li.Quote, div.Quote
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.25in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.LicenseAgreement, li.LicenseAgreement, div.LicenseAgreement
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13.0pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.DefinitionList, li.DefinitionList, div.DefinitionList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:"Times New Roman";
	layout-grid-mode:line;}
p.tocspace0, li.tocspace0, div.tocspace0
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:3.0pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.TOCPart, li.TOCPart, div.TOCPart
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:18.0pt;
	page-break-after:avoid;
	background:#E0E0E0;
	font-size:14.0pt;
	font-family:Verdana;}
p.parttitle, li.parttitle, div.parttitle
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:81.35pt;
	page-break-after:avoid;
	font-size:48.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.Partbleed, li.Partbleed, div.Partbleed
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:normal;
	page-break-after:avoid;
	background:#E0E0E0;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.tabletext, li.tabletext, div.tabletext
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13.5pt;
	font-size:10.5pt;
	font-family:Georgia;}
p.tablehead0, li.tablehead0, div.tablehead0
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13.5pt;
	font-size:12.0pt;
	font-family:Verdana;
	font-weight:bold;}
span.CodeInlineChar
	{font-family:"Andale Mono";}
span.CodeCharChar1
	{font-family:"Andale Mono";}
span.CodeInlineCharCharChar1
	{font-family:"Andale Mono";}
ins
	{text-decoration:none;}
span.msoIns
	{text-decoration:underline;}
span.msoDel
	{text-decoration:line-through;
	color:red;}
 /* Page Definitions */
 @page Section1
	{size:8.5in 11.0in;
	margin:135.0pt 1.5in 135.0pt 1.75in;}
div.Section1
	{page:Section1;}
@page Section2
	{size:8.5in 11.0in;
	margin:135.0pt 1.5in 135.0pt 1.75in;}
div.Section2
	{page:Section2;}
@page Section3
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section3
	{page:Section3;}
@page Section4
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section4
	{page:Section4;}
@page Section5
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section5
	{page:Section5;}
@page Section6
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section6
	{page:Section6;}
@page Section7
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section7
	{page:Section7;}
@page Section8
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section8
	{page:Section8;}
@page Section9
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section9
	{page:Section9;}
@page Section10
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section10
	{page:Section10;}
@page Section11
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section11
	{page:Section11;}
@page Section12
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section12
	{page:Section12;}
@page Section13
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section13
	{page:Section13;}
@page Section14
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section14
	{page:Section14;}
@page Section15
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section15
	{page:Section15;}
@page Section16
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section16
	{page:Section16;}
@page Section17
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section17
	{page:Section17;}
@page Section18
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section18
	{page:Section18;}
@page Section19
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section19
	{page:Section19;}
@page Section20
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section20
	{page:Section20;}
@page Section21
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section21
	{page:Section21;}
@page Section22
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section22
	{page:Section22;}
@page Section23
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section23
	{page:Section23;}
@page Section24
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section24
	{page:Section24;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=red vlink=purple>

<div class=Section1>

<p class=MsoNormal><a><b><span lang=EN>Note</span></b></a><span lang=EN>: </span><span
class=MsoCommentReference><span style='font-size:8.0pt;font-family:Times'><a
class=msocomanchor id="_anchor_1"
onmouseover="msoCommentShow('_anchor_1','_com_1')"
onmouseout="msoCommentHide('_com_1')" href="#_msocom_1" language=JavaScript
name="_msoanchor_1">[DwH1]</a><span style='display:none'>&nbsp;</span></span></span><span
lang=EN>This document requires the installation of the fonts Georgia, Verdana
and Andale Mono (code font) for proper viewing. These can be found at: <a
href="http://sourceforge.net/project/showfiles.php?group_id=34153&amp;release_id=105355">http://sourceforge.net/project/showfiles.php?group_id=34153&amp;release_id=105355</a></span></p>

<p class=MsoNormal><b>Revision 17 – (July 8, 2003)</b></p>

<p class=MsoNormal>Chapters 5 and 11 are much closer to being done! </p>

<p class=MsoNormal>Re: Chapter 11. Note that the <b>ZThreads library is in the
midst of a significant modification</b>, so there will come a time when the
default Zthread library will not work with this chapter. At that point you
should watch for an upgrade of the chapter.</p>

<p class=MsoNormal><b>Revision 16 – (June 25, 2003)</b></p>

<p class=MsoNormal>Chapter 5 text is almost complete, but enough has been added
worthy of a separate posting. The example programs for Chapter 11 are also
fairly complete. Added a matrix multiplication example to the <b>valarray</b>
material in chapter 7. Chapter 7 has been tech-edited. Many corrections due to
comments from users have been integrated into the text (thanks!).</p>

<p class=MsoNormal><b>Revision 15 – (March 1 ,2003)</b></p>

<p class=MsoNormal>Fixed an omission in C10:CuriousSingleton.cpp. Chapters 9
and 10 have been tech-edited.</p>

<p class=MsoNormal><b>Revision 14 – (January ,2003)</b></p>

<p class=MsoNormal>Fixed a number of fuzzy explanations in response to reader
feedback (thanks!). Chapter 9 has been copy-edited.</p>

<p class=MsoNormal><b>Revision 13 – (December 31, 2002)</b></p>

<p class=MsoNormal>Updated the exercises for Chapter 7. Finished rewriting
Chapter 9. Added a template variation of Singleton to chapter 10. Updated the
build directives. Fixed lotsa stuff. Chapters 5 and 11 still await rewrite. </p>

<p class=MsoNormal><b>Revision 12 – (December 23, 2002)</b></p>

<p class=MsoNormal>Added material on Design Patterns as Chapter 10 (Concurrency
will move to Chapter 11). Added exercises for Chapter 6. Here is the status of
all chapters:</p>

<p class=MsoNormal><i>100% complete</i>: 1-4, 6, 8</p>

<p class=MsoNormal>Copy-edited, waiting for tech edit: 7, 10</p>

<p class=MsoNormal>Incomplete: 5, 9, 11</p>

<p class=MsoNormal><b>Revision 11 (</b><b>December 13, 2002</b><b>) –</b></p>

<p class=MsoNormal>Chapter 7 has been updated. Chapter 6 has been copy-edited
and a few bugs were fixed. Chapter 4 has been tech-edited. The exercises are
still out of date except for chapters 1-3.</p>

<p class=MsoNormal><b>Revision 10 (</b><b>October 15, 2002</b><b>) –</b></p>

<p class=MsoNormal>Chapters 1 through 3 are now 100% complete (copy-edited and
tech-edited). Chapter 4 has been copy-edited. Updated Chapter 6 to fit in its
new position and adding introductory material. (Chapters 5 and 7-10 are still
unfinished at this point).</p>

<p class=MsoNormal><b>Revision 9 (</b><b>August 29, 2002</b><b>) –</b></p>

<p class=MsoNormal>Finished Chapter 4 (IOStreams). Reordered the material and
added material on wide stream and locales. Removed references to strstreams.
Edited the “Iostreams examples” section. Added new exercises.</p>

<p class=MsoNormal><b>Revision 8 (</b><b>August 6, 2002</b><b>) --</b></p>

<p class=MsoNormal>Made <b>ExtractCode.cpp</b> in Chapter 3 work for GNU C++.</p>

<p class=MsoNormal>Copy-edited Chapters 1 through 3.</p>

<p class=MsoNormal><b>Revision 7 (</b><b>July 31, 2002</b><b>) --</b></p>

<p class=MsoNormal>Fixed omissions in comments for code extraction throughout
text.</p>

<p class=MsoNormal>Edited Chapter 3:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='margin-left:.5in'>Added a wide-character version of
     <b>ichar_traits</b></li>
 <li class=MsoNormal style='margin-left:.5in'>Replaced <b>SiteMapConvert.cpp</b>
     with <b>ExtractCode.cpp</b></li>
 <li class=MsoNormal style='margin-left:.5in'>Added exercises</li>
</ul>

<p class=MsoNormal><b>Revision 6 (</b><b>July 27, 2002</b><b>) --</b></p>

<p class=MsoNormal>Finished Chapter 3 (Strings)</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='margin-left:.5in'>Mentioned caveat about reference
     counting with multithreading.</li>
 <li class=MsoNormal style='margin-left:.5in'>Removed first (out-of-date) HTML
     example</li>
 <li class=MsoNormal style='margin-left:.5in'>Fixed the <b>ichar_traits</b>
     example</li>
 <li class=MsoNormal style='margin-left:.5in'>Fixed stupid <b>MemCheck.cpp</b>
     error in Chapter 2</li>
</ul>

<p class=MsoNormal><b>Revision 5 (</b><b>July 20, 2002</b><b>) --</b></p>

<p class=MsoNormal>Chapters 1 and 2 are “finished”.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='margin-left:.5in'>Reordered the material in Chapter
     1:</li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal style='margin-left:.5in'>Placed exception specifications
      last, and warned of their dangers with template classes</li>
  <li class=MsoNormal style='margin-left:.5in'>Added a section on Exception Safety.</li>
  <li class=MsoNormal style='margin-left:.5in'>Added material on <b>auto_ptr</b></li>
  <li class=MsoNormal style='margin-left:.5in'>Added material illustrating <b>bad_exception</b></li>
  <li class=MsoNormal style='margin-left:.5in'>Explained the internal
      implementation of exceptions and the Zero-cost Model</li>
 </ul>
 <li class=MsoNormal style='margin-left:.5in'>Merged Chapter 3 (Debugging) into
     Chapter 2:</li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal style='margin-left:.5in'>Added material on invariants,
      assertions and Design-by-contract</li>
  <li class=MsoNormal style='margin-left:.5in'>Placed the <b>TestSuite</b> in
      its own namespace</li>
  <li class=MsoNormal style='margin-left:.5in'>Finished the <b>MemCheck</b>
      system for tracking memory errors</li>
 </ul>
 <li class=MsoNormal style='margin-left:.5in'>Removed Chapter 11 (Design
     Patterns)</li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal style='margin-left:.5in'>Will be replaced by Chapter 10
      (Concurrent Programming) </li>
 </ul>
</ul>

<p class=MsoNormal><b>Revision 4, </b><b>August 19, 2001</b><b> --</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='margin-left:.5in'>Restructured the book; this is
     the first version with <a href="http://www.freshsources.com"><span
     style='color:windowtext'>Chuck Allison</span></a> coauthoring.
     Incorporated Chuck's testing framework, which will be used throughout the
     book and automatically included as part of the book's build process in the
     makefiles.</li>
 <li class=MsoNormal style='margin-left:.5in'>In the code subdirectory of the
     unpacked distribution, you can now use make to compile for Borland,
     Microsoft, Gnu g++2.95 (distributed with Cygwin) and Gnu g++3.0 (tested
     under Linux).</li>
 <li class=MsoNormal style='margin-left:.5in'>Under Windows98/NT/2000, you will
     get best results running under the free Cygwin environment
     (www.Cygwin.com), even if you're compiling for Borland or Microsoft. In
     particular, some linker command lines for Microsoft are too long for Win98
     COMMAND.COM, but work just fine under Cygwin.</li>
 <li class=MsoNormal style='margin-left:.5in'>Made many code changes to allow
     programs to be run inside the test framework, in particular removing the
     need for user input when executing programs.</li>
 <li class=MsoNormal style='margin-left:.5in'>Added //{L} ../TestSuite/Test in
     all the programs where the unit test framework is used that can be run
     without user input, to cause the makefile builder to generate calls to the
     programs as part of the build process.</li>
</ul>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal>“This book is a tremendous achievement. You owe it to
yourself to have a copy on your shelf. The chapter on iostreams is the most
comprehensive and understandable treatment of that subject I’ve seen to date.”</p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:14.0pt'>Al Stevens <br>
Contributing Editor, Doctor Dobbs Journal</span></b></p>

<p class=MsoNormal>“Eckel’s book is the only one to so clearly explain how to
rethink program construction for object orientation. That the book is also an
excellent tutorial on the ins and outs of C++ is an added bonus.”</p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:14.0pt'>Andrew Binstock<br>
Editor, Unix Review</span></b></p>

<p class=MsoNormal>“Bruce continues to amaze me with his insight into C++, and <i>Thinking
in C++</i> is his best collection of ideas yet. If you want clear answers to
difficult questions about C++, buy this outstanding book.”</p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:14.0pt'>Gary Entsminger<br>
Author, <i>The Tao of Objects</i></span></b></p>

<p class=MsoNormal>“<i>Thinking in C++</i> patiently and methodically explores
the issues of when and how to use inlines, references, operator overloading,
inheritance and dynamic objects, as well as advanced topics such as the proper
use of templates, exceptions and multiple inheritance. The entire effort is
woven in a fabric that includes Eckel’s own philosophy of object and program
design. A must for every C++ developer’s bookshelf, <i>Thinking in C++</i> is
the one C++ book you must have if you’re doing serious development with C++.”</p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:14.0pt'>Richard Hale Shaw<br>
Contributing Editor, PC Magazine</span></b></p>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span></div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section2>

<p class=MsoNormal style='line-height:1.0pt'>&nbsp;</p>

<p class=MsoNormal><span style='font-size:80.0pt'>Thinking</span></p>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-size:48.0pt'>In</span></p>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-size:75.0pt;letter-spacing:-2.8pt'>C++</span></p>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-size:20.0pt'>2<sup>nd</sup> Edition<br>
</span><span style='font-size:24.0pt'>Volume 2: Practical Programming</span></p>

<p class=MsoBodyText2>Bruce Eckel, President, MindView Inc.<br>
Chuck Allison, Utah Valley State College</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='margin-top:6.0pt'><img width=77 height=58
src="TicV2_files/image002.gif" align=left hspace=12><i><span style='font-size:
11.0pt'><br clear=all style='page-break-before:always'>
</span></i></p>

<p class=MsoNormal style='margin-top:6.0pt'><i><span style='font-size:11.0pt'>&nbsp;</span></i></p>

<p class=MsoNormal style='margin-top:6.0pt'><span style='font-size:13.0pt'>©2003
MindView, Inc.<br>
<br>
</span></p>

<p class=MsoNormal><img width=77 height=58 src="TicV2_files/image002.gif"
align=left hspace=12><span style='font-size:9.0pt'>The information in this book
is distributed on an “as is” basis, without warranty. While every precaution
has been taken in the preparation of this book, neither the author nor the
publisher shall have any liability to any person or entitle with respect to any
liability, loss or damage caused or alleged to be caused directly or indirectly
by instructions contained in this book or by the computer software or hardware
products described herein.</span></p>

<p class=MsoNormal style='margin-top:6.0pt'><span style='font-size:9.0pt'>All
rights reserved. No part of this book may be reproduced in any form or by any
electronic or mechanical means including information storage and retrieval
systems without permission in writing from the publisher or authors, except by
a reviewer who may quote brief passages in a review. Any of the names used in
the examples and text of this book are fictional; any relationship to persons
living or dead or to fictional characters in other works is purely
coincidental.</span></p>

<span style='font-size:24.0pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal><span style='font-size:24.0pt'>Dedication</span></p>

<p class=MsoNormal align=right style='text-align:right'>To all those who have
worked tirelessly<br>
on the development of the C++ language</p>

<span style='font-size:14.0pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span></div>

<span style='font-size:14.0pt;font-family:Georgia'><br clear=all
style='page-break-before:auto'>
</span>

<div class=Section3>

<p class=MsoNormal align=right style='text-align:right'><span style='font-size:
14.0pt'>&nbsp;</span></p>

<p class=contents style='margin-left:-81.35pt'>What’s inside...<a
name=AAAtableOfContents></a></p>

</div>

<b><span style='font-size:14.0pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span></b>

<div class=Section4>

<p class=MsoToc1>Preface                                                       19</p>

<p class=MsoToc2>Goals........................................ 19</p>

<p class=MsoToc2>Chapters................................... 20</p>

<p class=MsoToc2>Exercises................................... 22</p>

<p class=MsoToc3>Exercise solutions............. 22</p>

<p class=MsoToc2>Source code............................... 22</p>

<p class=MsoToc2>Language standards................... 24</p>

<p class=MsoToc3>Language support............. 24</p>

<p class=MsoToc2>Seminars, CD-ROMs &amp; consulting. 24</p>

<p class=MsoToc2>Errors....................................... 24</p>

<p class=MsoToc2>About the cover......................... 25</p>

<p class=MsoToc2>Acknowledgements..................... 25</p>

<p class=MsoToc1>Building Stable Systems                             29</p>

<p class=MsoToc1>1: Exception handling                                31</p>

<p class=MsoToc2>Error handling in C...................... 32</p>

<p class=MsoToc2>Throwing an exception................ 34</p>

<p class=MsoToc2>Catching an exception................. 36</p>

<p class=MsoToc3>The try block.................... 36</p>

<p class=MsoToc3>Exception handlers........... 36</p>

<p class=MsoToc2>Exception matching..................... 39</p>

<p class=MsoToc3>Catching any exception..... 42</p>

<p class=MsoToc3>Re-throwing an exception.. 42</p>

<p class=MsoToc3>Uncaught exceptions......... 43</p>

<p class=MsoToc2>Cleaning up................................ 45</p>

<p class=MsoToc3>Resource management..... 47</p>

<p class=MsoToc3>Making everything an object 49</p>

<p class=MsoToc3>auto_ptr.......................... 52</p>

<p class=MsoToc3>Function-level try blocks.... 53</p>

<p class=MsoToc2>Standard exceptions................... 55</p>

<p class=MsoToc2>Exception specifications............... 59</p>

<p class=MsoToc3>Better exception specifications?          64</p>

<p class=MsoToc3>Exception specifications and inheritance           65</p>

<p class=MsoToc3>When <i>not</i> to use exception specifications         66</p>

<p class=MsoToc2>Exception safety......................... 67</p>

<p class=MsoToc2>Programming with exceptions....... 72</p>

<p class=MsoToc3>When to avoid exceptions.. 72</p>

<p class=MsoToc3>Typical uses of exceptions. 74</p>

<p class=MsoToc2>Overhead................................... 78</p>

<p class=MsoToc2>Summary................................... 80</p>

<p class=MsoToc2>Exercises................................... 81</p>

<p class=MsoToc1>2: Defensive programming                         83</p>

<p class=MsoToc2>Assertions................................. 86</p>

<p class=MsoToc2>A simple framework for unit testing 90</p>

<p class=MsoToc3>Automated testing............ 92</p>

<p class=MsoToc3>The TestSuite Framework.. 97</p>

<p class=MsoToc3>Test suites..................... 101</p>

<p class=MsoToc3>The test framework code. 102</p>

<p class=MsoToc2>Debugging techniques............... 110</p>

<p class=MsoToc3>Trace macros................. 110</p>

<p class=MsoToc3>Trace file....................... 111</p>

<p class=MsoToc3>Finding memory leaks..... 112</p>

<p class=MsoToc2>Summary................................. 119</p>

<p class=MsoToc2>Exercises................................. 120</p>

<p class=MsoToc1>The Standard C++ Library                        125</p>

<p class=MsoToc1>3: Strings in depth                                   127</p>

<p class=MsoToc2>What’s in a string?.................... 128</p>

<p class=MsoToc2>Creating and initializing C++ strings 130</p>

<p class=MsoToc2>Operating on strings................. 133</p>

<p class=MsoToc3>Appending, inserting,  and concatenating strings           134</p>

<p class=MsoToc3>Replacing string characters 136</p>

<p class=MsoToc3>Concatenation using  nonmember overloaded operators           141</p>

<p class=MsoToc2>Searching in strings.................. 142</p>

<p class=MsoToc2>String searching member functions and their general uses     143</p>

<p class=MsoToc3>Finding in reverse........... 147</p>

<p class=MsoToc3>Finding first/last of a set of characters 149</p>

<p class=MsoToc3>Removing characters from strings       150</p>

<p class=MsoToc3>Comparing strings.......... 153</p>

<p class=MsoToc3>Strings and character traits 158</p>

<p class=MsoToc2>A string application................... 164</p>

<p class=MsoToc2>Summary................................. 170</p>

<p class=MsoToc2>Exercises................................. 171</p>

<p class=MsoToc1>4: Iostreams                                             172</p>

<p class=MsoToc2>Why iostreams?........................ 172</p>

<p class=MsoToc2>Iostreams to the rescue............ 177</p>

<p class=MsoToc3>Inserters and extractors.. 177</p>

<p class=MsoToc3>Common usage.............. 183</p>

<p class=MsoToc3>Line-oriented input.......... 185</p>

<p class=MsoToc2>Handling stream errors.............. 187</p>

<p class=MsoToc2>File iostreams........................... 190</p>

<p class=MsoToc3>A File-Processing Example 192</p>

<p class=MsoToc3>Open modes................... 194</p>

<p class=MsoToc2>Iostream buffering.................... 195</p>

<p class=MsoToc2>Seeking in iostreams................. 198</p>

<p class=MsoToc2>String iostreams....................... 202</p>

<p class=MsoToc3>Input string streams........ 203</p>

<p class=MsoToc3>Output string streams...... 205</p>

<p class=MsoToc2>Output stream formatting.......... 209</p>

<p class=MsoToc3>Format flags................... 209</p>

<p class=MsoToc3>Format fields.................. 211</p>

<p class=MsoToc3>Width, fill, and precision.. 213</p>

<p class=MsoToc3>An exhaustive example... 214</p>

<p class=MsoToc2>Manipulators............................. 218</p>

<p class=MsoToc3>Manipulators with arguments 219</p>

<p class=MsoToc3>Creating manipulators..... 223</p>

<p class=MsoToc3>Effectors........................ 224</p>

<p class=MsoToc2>Iostream examples.................... 227</p>

<p class=MsoToc3>Maintaining class library source code   227</p>

<p class=MsoToc3>Detecting compiler errors 232</p>

<p class=MsoToc3>A simple datalogger........ 235</p>

<p class=MsoToc2>Internationalization................... 240</p>

<p class=MsoToc3>Wide Streams................. 240</p>

<p class=MsoToc3>Locales.......................... 243</p>

<p class=MsoToc2>Summary................................. 246</p>

<p class=MsoToc2>Exercises................................. 246</p>

<p class=MsoToc1>5: Templates in depth                              249</p>

<p class=MsoToc2>Template parameters................. 249</p>

<p class=MsoToc3>Non-type template parameters           250</p>

<p class=MsoToc3>Default template arguments 252</p>

<p class=MsoToc3>Template template parameters           254</p>

<p class=MsoToc3>The typename keyword... 261</p>

<p class=MsoToc3>Using the template keyword as a hint  264</p>

<p class=MsoToc3>Member Templates......... 266</p>

<p class=MsoToc2>Function template issues........... 269</p>

<p class=MsoToc3>Type deduction of function template arguments            269</p>

<p class=MsoToc3>Function template overloading            274</p>

<p class=MsoToc3>Taking the address of a generated function template    275</p>

<p class=MsoToc3>Applying a function to an STL sequence           279</p>

<p class=MsoToc3>Partial ordering of function templates  282</p>

<p class=MsoToc2>Template specialization............... 284</p>

<p class=MsoToc3>Explicit specialization....... 284</p>

<p class=MsoToc3>Partial Specialization....... 286</p>

<p class=MsoToc3>A practical example........ 289</p>

<p class=MsoToc3>Preventing template code bloat           293</p>

<p class=MsoToc2>Name lookup issues.................. 298</p>

<p class=MsoToc3>Names in templates........ 298</p>

<p class=MsoToc3>Templates and friends..... 304</p>

<p class=MsoToc2>Template programming idioms.... 311</p>

<p class=MsoToc3>Traits............................. 311</p>

<p class=MsoToc3>Policies.......................... 317</p>

<p class=MsoToc3>The curiously-recurring template pattern         321</p>

<p class=MsoToc2>Template metaprogramming....... 324</p>

<p class=MsoToc3>Compile-time programming 325</p>

<p class=MsoToc3>Expression templates...... 334</p>

<p class=MsoToc2>Template compilation models...... 334</p>

<p class=MsoToc3>Explicit instantiation........ 334</p>

<p class=MsoToc2>Summary................................. 335</p>

<p class=MsoToc2>Exercises................................. 335</p>

<p class=MsoToc1>6: Generic algorithms                               337</p>

<p class=MsoToc2>A first look............................... 337</p>

<p class=MsoToc3>Predicates...................... 341</p>

<p class=MsoToc3>Stream iterators............. 343</p>

<p class=MsoToc3>Algorithm complexity...... 346</p>

<p class=MsoToc2>Function objects....................... 347</p>

<p class=MsoToc3>Classification of function objects         349</p>

<p class=MsoToc3>Automatic creation of function objects 350</p>

<p class=MsoToc3>Adaptable function objects 354</p>

<p class=MsoToc3>More function object examples            356</p>

<p class=MsoToc3>Function pointer adapters 365</p>

<p class=MsoToc3>Writing your own function object adapters        372</p>

<p class=MsoToc2>A catalog of STL algorithms....... 376</p>

<p class=MsoToc3>Support tools for example creation      379</p>

<p class=MsoToc3>Filling and generating...... 383</p>

<p class=MsoToc3>Counting........................ 385</p>

<p class=MsoToc3>Manipulating sequences... 386</p>

<p class=MsoToc3>Searching and replacing.. 392</p>

<p class=MsoToc3>Comparing ranges.......... 401</p>

<p class=MsoToc3>Removing elements........ 405</p>

<p class=MsoToc3>Sorting and operations on sorted ranges          409</p>

<p class=MsoToc3>Heap operations............. 420</p>

<p class=MsoToc3>Applying an operation to each element in a range         422</p>

<p class=MsoToc3>Numeric algorithms......... 431</p>

<p class=MsoToc3>General utilities.............. 435</p>

<p class=MsoToc2>Creating your own STL-style algorithms  437</p>

<p class=MsoToc2>Summary................................. 439</p>

<p class=MsoToc2>Exercises................................. 439</p>

<p class=MsoToc1>7: Generic containers                               447</p>

<p class=MsoToc2>Containers and iterators............ 447</p>

<p class=MsoToc3>STL reference documentation 449</p>

<p class=MsoToc2>A first look............................... 450</p>

<p class=MsoToc3>Containers of strings....... 456</p>

<p class=MsoToc3>Inheriting from STL containers            458</p>

<p class=MsoToc2>A plethora of iterators............... 461</p>

<p class=MsoToc3>Iterators in reversible containers        463</p>

<p class=MsoToc3>Iterator categories.......... 464</p>

<p class=MsoToc3>Predefined iterators........ 467</p>

<p class=MsoToc2>The basic sequences:  vector, list, deque 473</p>

<p class=MsoToc3>Basic sequence operations 473</p>

<p class=MsoToc3>vector............................ 477</p>

<p class=MsoToc3>deque............................ 484</p>

<p class=MsoToc3>Converting between sequences           487</p>

<p class=MsoToc3>Checked random-access. 490</p>

<p class=MsoToc3>list................................. 491</p>

<p class=MsoToc3>Swapping basic sequences 498</p>

<p class=MsoToc2>set.......................................... 499</p>

<p class=MsoToc3>A completely reusable tokenizer         502</p>

<p class=MsoToc2>stack....................................... 508</p>

<p class=MsoToc2>queue...................................... 512</p>

<p class=MsoToc2>Priority queues......................... 517</p>

<p class=MsoToc2>Holding bits.............................. 527</p>

<p class=MsoToc3>bitset&lt;n&gt;....................... 528</p>

<p class=MsoToc3>vector&lt;bool&gt;................. 533</p>

<p class=MsoToc2>Associative containers............... 534</p>

<p class=MsoToc3>Generators and fillers for associative containers           540</p>

<p class=MsoToc3>The magic of maps......... 543</p>

<p class=MsoToc3>Multimaps and duplicate keys 545</p>

<p class=MsoToc3>Multisets........................ 549</p>

<p class=MsoToc2>Combining STL containers.......... 553</p>

<p class=MsoToc2>Cleaning up  containers of pointers 556</p>

<p class=MsoToc2>Creating your own containers..... 558</p>

<p class=MsoToc2>STL extensions......................... 561</p>

<p class=MsoToc2>Non-STL containers.................. 563</p>

<p class=MsoToc2>Summary................................. 568</p>

<p class=MsoToc2>Exercises................................. 569</p>

<p class=MsoToc1>Special Topics                                          573</p>

<p class=MsoToc1>8: Runtime type identification                  575</p>

<p class=MsoToc2>Runtime casts.......................... 575</p>

<p class=MsoToc2>The typeid operator.................. 581</p>

<p class=MsoToc3>Casting to intermediate levels 584</p>

<p class=MsoToc3>void pointers.................. 585</p>

<p class=MsoToc3>Using RTTI with templates 586</p>

<p class=MsoToc2>Multiple inheritance.................... 587</p>

<p class=MsoToc2>Sensible uses for RTTI............... 588</p>

<p class=MsoToc3>A trash recycler.............. 589</p>

<p class=MsoToc2>Mechanism and overhead of RTTI 594</p>

<p class=MsoToc2>Summary................................. 595</p>

<p class=MsoToc2>Exercises................................. 596</p>

<p class=MsoToc1>9: Multiple inheritance                             597</p>

<p class=MsoToc2>Perspective............................... 597</p>

<p class=MsoToc2>Interface inheritance.................. 599</p>

<p class=MsoToc2>Implementation inheritance........ 603</p>

<p class=MsoToc2>Duplicate subobjects................. 610</p>

<p class=MsoToc2>Virtual base classes................... 615</p>

<p class=MsoToc2>Name lookup issues.................. 625</p>

<p class=MsoToc2>Avoiding MI.............................. 629</p>

<p class=MsoToc2>Extending an interface............... 630</p>

<p class=MsoToc2>Summary................................. 635</p>

<p class=MsoToc2>Exercises................................. 635</p>

<p class=MsoToc1>10: Design patterns                                  637</p>

<p class=MsoToc2>The pattern concept.................. 637</p>

<p class=MsoToc2>The singleton........................... 639</p>

<p class=MsoToc3>Variations on singleton.... 640</p>

<p class=MsoToc2>Classifying patterns................... 645</p>

<p class=MsoToc3>Features, idioms, patterns 646</p>

<p class=MsoToc2>Building complex objects........... 647</p>

<p class=MsoToc2>Factories: encapsulating object creation  655</p>

<p class=MsoToc3>Polymorphic factories...... 658</p>

<p class=MsoToc3>Abstract factories............ 661</p>

<p class=MsoToc3>Virtual constructors......... 664</p>

<p class=MsoToc2>Observer.................................. 672</p>

<p class=MsoToc3>The “inner class” idiom.... 675</p>

<p class=MsoToc3>The observer example.... 679</p>

<p class=MsoToc2>Multiple dispatching................... 683</p>

<p class=MsoToc3>Multiple dispatching with Visitor           687</p>

<p class=MsoToc2>Exercises................................. 690</p>

<p class=MsoToc1>11: Concurrency                                       692</p>

<p class=MsoToc2>Motivation................................ 693</p>

<p class=MsoToc2>Concurrency in C++.................. 694</p>

<p class=MsoToc2>Installing Zthreads.................... 695</p>

<p class=MsoToc2>Defining Tasks.......................... 697</p>

<p class=MsoToc2>Using Threads.......................... 699</p>

<p class=MsoToc3>Joining Threads.............. 700</p>

<p class=MsoToc3>Creating responsive user interfaces    701</p>

<p class=MsoToc3>Managing Tasks.............. 703</p>

<p class=MsoToc3>Simplifying with Executors 704</p>

<p class=MsoToc3>Yielding.......................... 708</p>

<p class=MsoToc3>Sleeping........................ 710</p>

<p class=MsoToc3>Priority.......................... 712</p>

<p class=MsoToc2>Sharing limited resources........... 714</p>

<p class=MsoToc3>Improperly accessing resources          715</p>

<p class=MsoToc3>Controlling access........... 718</p>

<p class=MsoToc3>Simplified coding with Guards 721</p>

<p class=MsoToc2>Terminating tasks...................... 724</p>

<p class=MsoToc3>The Ornamental Garden.. 724</p>

<p class=MsoToc3>Terminating when blocked 729</p>

<p class=MsoToc3>Interruption.................... 730</p>

<p class=MsoToc2>Cooperation between threads..... 737</p>

<p class=MsoToc3>Wait and signal............... 737</p>

<p class=MsoToc3>Bounded Resources........ 743</p>

<p class=MsoToc3>Solving Threading problems with Queues         747</p>

<p class=MsoToc3>The barbershop.............. 748</p>

<p class=MsoToc3>Synchronizing classes..... 753</p>

<p class=MsoToc2>Deadlock.................................. 755</p>

<p class=MsoToc2>Summary................................. 763</p>

<p class=MsoToc2>Exercises................................. 765</p>

<p class=MsoToc1>A: Recommended reading                         769</p>

<p class=MsoToc2>C............................................ 769</p>

<p class=MsoToc2>General C++............................ 769</p>

<p class=MsoToc3>Bruce’s books................. 770</p>

<p class=MsoToc2>Depth &amp; dark corners................ 770</p>

<p class=MsoToc2>The STL................................... 771</p>

<p class=MsoToc2>Design Patterns........................ 771</p>

<p class=MsoToc1>B: Etc                                                       773</p>

<p class=MsoToc1>Index                                                       781</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section5>

<h1 style='margin-left:-81.35pt'><a name="_Toc45439939"></a><a
name="_Toc462305061"></a><a name="_Toc312373768">Preface</a></h1>

<p class=Intro>In Volume 1 of this book, you learn the fundamentals of C and
C++. In this volume, we look at more advanced features, with an eye towards
developing techniques and ideas that produce robust C++ programs. </p>

<p class=MsoNormal>Thus, in this volume we are assuming that you are familiar
with the material developed in Volume 1. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0011"
title="Add Comment A0011">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439940"></a><a name="_Toc462305068"></a><a
name="_Toc312373771">Goals</a></h2>

<p class=MsoNormal>Our goals in this book are to:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0017"
title="Add Comment A0017">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Present the material a simple step at a time, so the reader can
easily digest each concept before moving on.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Teach “practical programming” techniques that you can use on a
day-to-day basis.</p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Give you what we think is important for you to understand about
the language, rather than everything we know. We believe there is an
“information importance hierarchy,” and there are some facts that 95% of
programmers will never need to know, but that would just confuse people and add
to their perception of the complexity of the language. To take an example from
C, if you memorize the operator precedence table (we never did) you can write
clever code. But if <i>you</i> have to think about it, it will confuse the
reader/maintainer of that code. So forget about precedence, and use parentheses
when things aren’t clear. This same attitude will be taken with some
information in the C++ language, which is more important for compiler writers
than for programmers.</p>

<p class=Numbered><span style='font-family:Verdana'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Keep each section focused enough so the lecture time – and the
time between exercise periods – is small. Not only does this keep the audience’
minds more active and involved during a hands-on seminar, but it gives the
reader a greater sense of accomplishment.</p>

<p class=Numbered><span style='font-family:Verdana'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>We have endeavored not to use any particular vendor’s version of
C++. We have tested the code on all the implementations we could, and when one
implementation absolutely refused to work because it doesn’t conform to the C++
Standard, we’ve flagged that fact in the example (you’ll see the flags in the
source code) to exclude it from the build process.</p>

<p class=Numbered><span style='font-family:Verdana'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Automate the compiling and testing of the code in the book. We
have discovered that code that isn’t compiled and tested is probably broken, so
in this volume we’ve instrumented the examples with test code. In addition, the
code that you can download from http://www.MindView.net has been extracted
directly from the text of the book using programs that also automatically
create makefiles to compile and run the tests. This way we know that the code
in the book is correct.</p>

<h2 style='margin-left:0in'><a name="_Toc45439941"></a><a name="_Toc462305069"></a><a
name="_Toc312373772">Chapters</a></h2>

<p class=MsoNormal>Here is a brief description of the chapters contained in
this book:</p>

<p class=MsoNormal><b>Part 1: Building Stable Systems</b></p>

<p class=MsoNormal><b>1. Exception handling</b>. Error handling has always been
a problem in programming. Even if you dutifully return error information or set
a flag, the function caller may simply ignore it. Exception handling is a
primary feature in C++ that solves this problem by allowing you to “throw” an
object out of your function when a critical error happens. You throw different
types of objects for different errors, and the function caller “catches” these
objects in separate error handling routines. If you throw an exception, it
cannot be ignored, so you can guarantee that <i>something</i> will happen in
response to your error.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0024"
title="Add Comment A0024">Comment</a></sup></p>

<p class=MsoNormal><b>2. Defensive Programming.</b> (Description)</p>

<p class=MsoNormal><b>Part 2: The Standard C++ Library</b></p>

<p class=MsoNormal><b>3. Strings in Depth.</b> (Description)</p>

<p class=MsoNormal><b> 4. Iostreams</b>. One of the original C++ libraries –
the one that provides the essential I/O facility – is called iostreams.
Iostreams is intended to replace C’s <b>stdio.h </b>with an I/O library that is
easier to use, more flexible, and extensible – you can adapt it to work with
your new classes. This chapter teaches you the ins and outs of how to make the
best use of the existing iostream library for standard I/O, file I/O, and
in-memory formatting.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0022"
title="Add Comment A0022">Comment</a></sup></p>

<p class=MsoNormal><b>5. Templates in Depth.</b> (Description)</p>

<p class=MsoNormal><b>6.</b> <b>STL Algorithms. </b>(Description)</p>

<p class=MsoNormal><b>7.</b> <b>STL Containers &amp; Iterators</b>
(Description)</p>

<p class=MsoNormal><b>Part 3: Special Topics</b></p>

<p class=MsoNormal><b>8. Run-time type identification</b>.<b> </b>Run-time type
identification (RTTI) lets you find the exact type of an object when you only
have a pointer or reference to the base type. Normally, you’ll want to
intentionally ignore the exact type of an object and let the virtual function
mechanism implement the correct behavior for that type. But occasionally it is
very helpful to know the exact type of an object for which you only have a base
pointer; often this information allows you to perform a special-case operation
more efficiently. This chapter explains what RTTI is for and how to use it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0025"
title="Add Comment A0025">Comment</a></sup></p>

<p class=MsoNormal><b>9. Multiple inheritance</b>. This sounds simple at first:
A new class is inherited from more than one existing class. However, you can
end up with ambiguities and multiple copies of base-class objects. That problem
is solved with virtual base classes, but the bigger issue remains: When do you
use it? Multiple inheritance is only essential when you need to manipulate an
object through more than one common base class. This chapter explains the
syntax for multiple inheritance, and shows alternative approaches – in
particular, how templates solve one common problem. The use of multiple
inheritance to repair a “damaged” class interface is demonstrated as a
genuinely valuable use of this feature.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0023"
title="Add Comment A0023">Comment</a></sup></p>

<p class=MsoNormal><b>10. Design Patterns.</b></p>

<p class=MsoNormal><b>11. Concurrent Programming. </b></p>

<h2 style='margin-left:0in'><a name="_Toc45439942"></a><a name="_Toc462305070"></a><a
name="_Toc312373773">Exercises</a></h2>

<p class=MsoNormal>We have discovered that simple exercises are exceptionally
useful during a seminar to complete a student’s understanding, so you’ll find a
set at the end of each chapter.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0026"
title="Add Comment A0026">Comment</a></sup></p>

<p class=MsoNormal>These are fairly simple, so they can be finished in a
reasonable amount of time in a classroom situation while the instructor
observes, making sure all the students are absorbing the material. Some
exercises are a bit more challenging to keep advanced students entertained.
They’re all designed to be solved in a short time and are only there to test
and polish your knowledge rather than present major challenges (presumably,
you’ll find those on your own – or more likely they’ll find you).<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0027"
title="Add Comment A0027">Comment</a></sup></p>

<h3><a name="_Toc45439943">Exercise solutions</a></h3>

<p class=MsoNormal>Solutions to exercises can be found in the electronic
document <i>The C++ Annotated Solution Guide</i>, Volume 2, available for a
small fee from <a href="http://www.bruceeckel.com/"><span style='color:windowtext'>www.MindView.net</span></a>.
[[ Note this is not yet available ]]<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0028"
title="Add Comment A0028">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439944"></a><a name="_Toc462305071"></a><a
name="_Toc312373774"></a><a name="_Ref310733137">Source code</a></h2>

<p class=MsoNormal>The source code for this book is copyrighted freeware,
distributed via the web site http://www.MindView.net. The copyright prevents
you from republishing the code in print media without permission.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0029"
title="Add Comment A0029">Comment</a></sup></p>

<p class=MsoNormal>In the starting directory where you unpacked the code you
will find the following copyright notice:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0030"
title="Add Comment A0030">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//:! :CopyRight.txt</p>

<p class=CodeChar style='margin-left:0in'>Copyright (c) MindView, Inc., 2003</p>

<p class=CodeChar style='margin-left:0in'>Source code file from the book </p>

<p class=CodeChar style='margin-left:0in'>&quot;Thinking in C++, 2nd Edition,
Volume 2.&quot;</p>

<p class=CodeChar style='margin-left:0in'>All rights reserved EXCEPT as allowed
by the</p>

<p class=CodeChar style='margin-left:0in'>following statements: You can freely
use this file</p>

<p class=CodeChar style='margin-left:0in'>for your own work (personal or
commercial),</p>

<p class=CodeChar style='margin-left:0in'>including modifications and
distribution in</p>

<p class=CodeChar style='margin-left:0in'>executable form only. Permission is
granted to use</p>

<p class=CodeChar style='margin-left:0in'>this file in classroom situations, including
its</p>

<p class=CodeChar style='margin-left:0in'>use in presentation materials, as
long as the book</p>

<p class=CodeChar style='margin-left:0in'>&quot;Thinking in C++&quot; is cited
as the source. </p>

<p class=CodeChar style='margin-left:0in'>Except in classroom situations, you
cannot copy</p>

<p class=CodeChar style='margin-left:0in'>and distribute this code; instead,
the sole</p>

<p class=CodeChar style='margin-left:0in'>distribution point is
http://www.MindView.net </p>

<p class=CodeChar style='margin-left:0in'>(and official mirror sites) where it
is</p>

<p class=CodeChar style='margin-left:0in'>freely available. You cannot remove
this</p>

<p class=CodeChar style='margin-left:0in'>copyright and notice. You cannot
distribute</p>

<p class=CodeChar style='margin-left:0in'>modified versions of the source code
in this</p>

<p class=CodeChar style='margin-left:0in'>package. You cannot use this file in
printed</p>

<p class=CodeChar style='margin-left:0in'>media without the express permission
of the</p>

<p class=CodeChar style='margin-left:0in'>author. Bruce Eckel makes no
representation about</p>

<p class=CodeChar style='margin-left:0in'>the suitability of this software for
any purpose.</p>

<p class=CodeChar style='margin-left:0in'>It is provided &quot;as is&quot;
without express or implied</p>

<p class=CodeChar style='margin-left:0in'>warranty of any kind, including any
implied</p>

<p class=CodeChar style='margin-left:0in'>warranty of merchantability, fitness
for a</p>

<p class=CodeChar style='margin-left:0in'>particular purpose or non-infringement.
The entire</p>

<p class=CodeChar style='margin-left:0in'>risk as to the quality and
performance of the</p>

<p class=CodeChar style='margin-left:0in'>software is with you. Bruce Eckel and
the</p>

<p class=CodeChar style='margin-left:0in'>publisher shall not be liable for any
damages</p>

<p class=CodeChar style='margin-left:0in'>suffered by you or any third party as
a result of</p>

<p class=CodeChar style='margin-left:0in'>using or distributing software. In no
event will</p>

<p class=CodeChar style='margin-left:0in'>Bruce Eckel or the publisher be
liable for any</p>

<p class=CodeChar style='margin-left:0in'>lost revenue, profit, or data, or for
direct,</p>

<p class=CodeChar style='margin-left:0in'>indirect, special, consequential,
incidental, or</p>

<p class=CodeChar style='margin-left:0in'>punitive damages, however caused and
regardless of</p>

<p class=CodeChar style='margin-left:0in'>the theory of liability, arising out
of the use of</p>

<p class=CodeChar style='margin-left:0in'>or inability to use software, even if
Bruce Eckel</p>

<p class=CodeChar style='margin-left:0in'>and the publisher have been advised
of the</p>

<p class=CodeChar style='margin-left:0in'>possibility of such damages. Should
the software</p>

<p class=CodeChar style='margin-left:0in'>prove defective, you assume the cost
of all</p>

<p class=CodeChar style='margin-left:0in'>necessary servicing, repair, or
correction. If you</p>

<p class=CodeChar style='margin-left:0in'>think you've found an error, please
submit the</p>

<p class=CodeChar style='margin-left:0in'>correction using the form you will
find at</p>

<p class=CodeChar style='margin-left:0in'>www.MindView.net. (Please use the
same</p>

<p class=CodeChar style='margin-left:0in'>form for non-code errors found in the
book.)</p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='font-size:
9.0pt'>///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You may use the code in your projects and in the classroom
as long as the copyright notice is retained. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0031"
title="Add Comment A0031">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439945"></a><a name="_Toc462305072"></a><a
name="_Toc312373776">Language standards</a></h2>

<p class=MsoNormal>Throughout this book, when referring to conformance to the
ANSI/ISO C standard, we will be referring to the 1989 standard, and will
generally just say ‘<b>C</b>.’ Only if it is necessary to distinguish between
Standard 1989 C and older, pre-Standard versions of C will we make the
distinction. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0032"
title="Add Comment A0032">Comment</a></sup></p>

<p class=MsoNormal>At this writing the ANSI/ISO C++ committee was finished working on the language. Thus, we will use the term <i>Standard C++</i> to refer to the standardized language. If we simply refer to C++ you should assume
we mean “Standard C++.” <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0033"
title="Add Comment A0033">Comment</a></sup></p>

<h3><a name="_Toc45439946"></a><a name="_Toc462305073"></a><a
name="_Toc312373777">Language support</a></h3>

<p class=MsoNormal>Your compiler may not support all the features discussed in
this book, especially if you don’t have the newest version of your compiler.
Implementing a language like C++ is a Herculean task, and you can expect that
the features will appear in pieces rather than all at once. But if you attempt
one of the examples in the book and get a lot of errors from the compiler, it’s
not necessarily a bug in the code or the compiler – it may simply not be implemented
in your particular compiler yet. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0034"
title="Add Comment A0034">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439947"></a><a name="_Toc462305075"></a><a
name="_Toc312373778">Seminars, </a>CD-ROMs &amp; consulting</h2>

<p class=MsoNormal>Bruce Eckel’s company, MindView, Inc., provides public
hands-on training seminars based on the material in this book, and also for
advanced topics. Selected material from each chapter represents a lesson, which
is followed by a monitored exercise period so each student receives personal
attention. We also provide on-site training, consulting, mentoring, and design
&amp; code walkthroughs. Information and sign-up forms for upcoming seminars
and other contact information can be found at <b>http://www.MindView.net</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0035"
title="Add Comment A0035">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439948"></a><a name="_Toc462305076"></a><a
name="_Toc312373779">Errors</a></h2>

<p class=MsoNormal>No matter how many tricks a writer uses to detect errors,
some always creep in and these often leap off the page for a fresh reader. If
you discover anything you believe to be an error, please use the feedback
system built into the electronic version of this book, which you will find at <b>http://www.MindView.net</b>.
The feedback system uses unique identifiers on the paragraphs in the book, so
you should click on the identifier next to the paragraph that you wish to
comment on. Your help is appreciated. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0036"
title="Add Comment A0036">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc462305077"></a><a name="_Toc312373780"></a><a
name="_Toc45439949">About the cover</a></h2>

<p class=MsoNormal>The cover artwork was painted by Larry O’Brien’s wife, Tina
Jensen (yes, the Larry O’Brien who was the editor of Software Development
Magazine for so many years, and who is the primary author of <i>Thinking in C#</i>).
Not only are the pictures beautiful, but they are excellent suggestions of
polymorphism. The idea for using these images came from Daniel Will-Harris, the
cover designer (www.Will-Harris.com), working with Bruce Eckel.</p>

<h2 style='margin-left:0in'><a name="_Toc45439950">Acknowledgements</a></h2>

<p class=MsoNormal>Volume 2 of this book languished in a half-completed state
for a long time while Bruce got distracted with other things, notably Java,
Design Patterns and especially Python (see www.Python.org). If Chuck hadn’t
been willing (foolishly, he has sometimes thought) to finish the other half,
this book almost certainly wouldn’t have happened. There aren’t that many
people whom Bruce would have felt comfortable entrusting this book to. Chuck’s
penchant for precision, correctness and clear explanation is what has made this
book as good as it is.</p>

<p class=MsoNormal>Jamie King acted as an intern during the completion of this
book. He has been instrumental in making sure the book got finished, not only
by providing feedback for Chuck, but especially because of his relentless
questioning and picking of every single possible nit that he didn’t completely
understand. If your questions are answered by this book, it’s probably because
Jamie asked them first. Jamie also created many of the exercises at the end of
each chapter.</p>

<p class=MsoNormal>The ideas and understanding in this book have come from many
other sources, as well: friends like Andrea Provaglio, Dan Saks, Scott Meyers,
Charles Petzold, and Michael Wilk; pioneers of the language like Bjarne
Stroustrup, Andrew Koenig, and Rob Murray; members of the C++ Standards
Committee like Nathan Myers (who was particularly helpful and generous with his
insights), Herb Sutter, PJ Plauger, Pete Becker, Kevlin Henney, David Abrahams,
Tom Plum, Reg Charney, Tom Penello, Sam Druker, and Uwe Steinmueller; people
who have spoken in the C++ track at the Software Development Conference (which
Bruce created and developed, and Chuck spoke in); and very often students in
seminars, who ask the questions we need to hear in order to make the material
clearer. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0037"
title="Add Comment A0037">Comment</a></sup></p>

<p class=MsoNormal>The book design, cover design, and cover photo were created
by Bruce’s friend Daniel Will-Harris, noted author and designer, who used to
play with rub-on letters in junior high school while he awaited the invention
of computers and desktop publishing. However, we produced the camera-ready
pages ourselves, so the typesetting errors are ours. Microsoft<sup>®</sup> Word
XP was used to write the book and to create camera-ready pages. The body
typeface is Georgia and the headlines are in Verdana. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0039"
title="Add Comment A0039">Comment</a></sup></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Georgia'>We also wish to thank the
generous professionals at the Edison Design Group and Dinkumware, Ltd., for
giving us complimentary copies of their compiler and library (respectively).
Without their assistance some of the examples in this book could not have been
tested.</span></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Georgia'>A special thanks to all
our teachers, and all our students (who are our teachers as well).</span></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Georgia'>Evan Cofsky (Evan@TheUnixMan.com)
provided all sorts of assistance on the server as well as development of
programs in his now-favorite language, Python. Sharlynn Cobaugh and Paula
Steuer were instrumental assistants, preventing Bruce from being washed away in
a flood of projects.</span></p>

<p class=MsoNormal>Dawn McGee provided much-appreciated inspiration and
enthusiasm during this project. The supporting cast of friends includes, but is
not limited to: Mark Western, Gen Kiyooka, Kraig Brockschmidt, Zack Urlocker,
Andrew Binstock, Neil Rubenking, Steve Sinofsky, JD Hildebrandt, Brian
McElhinney, Brinkley Barr, Larry O’Brien, Bill Gates at Midnight Engineering
Magazine, Larry Constantine &amp; Lucy Lockwood, Tom Keffer, Greg Perry, Dan
Putterman, Christi Westphal, Gene Wang, Dave Mayer, David Intersimone, Claire
Sawyers, The Italians (Andrea Provaglio, Laura Fallai, Marco Cantu, Corrado,
Ilsa and Christina Giustozzi), Chris &amp; Laura Strand, The Almquists, Brad
Jerbic, John Kruth &amp; Marilyn Cvitanic, Holly Payne (yes, the famous
novelist!), Mark Mabry, The Robbins Families, The Moelter Families (&amp; the
McMillans), The Wilks, Dave Stoner, Laurie Adams, The Cranstons, Larry Fogg,
Mike &amp; Karen Sequeira, Gary Entsminger &amp; Allison Brody, Chester
Andersen, Joe Lordi, Dave &amp; Brenda Bartlett, The Rentschlers, The Sudeks,
Lynn &amp; Todd, and their families. And of course, <a>Mom &amp; Dad. </a><span
class=MsoCommentReference><span style='font-size:8.0pt;font-family:Times'><a
class=msocomanchor id="_anchor_2"
onmouseover="msoCommentShow('_anchor_2','_com_2')"
onmouseout="msoCommentHide('_com_2')" href="#_msocom_2" language=JavaScript
name="_msoanchor_2">[DwH2]</a><span style='display:none'>&nbsp;</span></span></span></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section6>

<h1 style='margin-left:0in'><img width=734 height=118
src="TicV2_files/image003.gif" align=left hspace=12 alt="Text Box: 	Part 1&#13;&#10;"><a
name="_Toc45439951">Building Stable Systems</a></h1>

<p class=Intro><span style='font-size:20.0pt'>&nbsp;</span></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section7>

<h1 style='margin-left:-81.35pt'><a name="_Toc45439952"></a><a
name="_Toc312374110"></a><a name="_Toc305628767"></a><a name="_Toc305593295">1:
Exception handling</a></h1>

<p class=Intro style='margin-left:.25in'>Improving error recovery is one of the most powerful ways you can increase the robustness of your code.</p>

<p class=MsoNormal>Unfortunately, it’s almost accepted practice to ignore error
conditions, as if we’re in a state of denial about errors. One reason, no
doubt, is the tediousness and code bloat of checking for many errors. For
example, <b>printf(&nbsp;)</b> returns the number of characters that were
successfully printed, but virtually no one checks this value. The proliferation
of code alone would be disgusting, not to mention the difficulty it would add
in reading the code. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0040"
title="Add Comment A0040">Comment</a></sup></p>

<p class=MsoNormal>The problem with C’s approach to error handling could be
thought of as coupling—the user of a function must tie the error-handling code
so closely to that function that it becomes too ungainly and awkward to use. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0041"
title="Add Comment A0041">Comment</a></sup></p>

<p class=MsoNormal>One of the major features in C++ is <i>exception handling</i>,
which is a better way of thinking about and handling errors. With exception
handling the following statements apply: <sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0042"
title="Add Comment A0042">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Error-handling code is not nearly so tedious to write, and it
doesn't become mixed up with your &quot;normal&quot; code. You write the code
you <i>want</i> to happen; later in a separate section you write the code to
cope with the problems. If you make multiple calls to a function, you handle
the errors from that function once, in one place.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Errors cannot be ignored. If a function needs to send an error
message to the caller of that function, it “throws” an object representing that
error out of the function. If the caller doesn’t “catch” the error and handle
it, it goes to the next enclosing dynamic scope, and so on until the error is
either caught or the program terminates because there was no handler to catch
that type of exception. </p>

<p class=MsoNormal>This chapter examines C’s approach to error handling (such
as it is), discusses why it did not work well for C, and explains why it won’t
work at all for C++. This chapter also covers <b>try</b>, <b>throw</b>,<b> </b>and
<b>catch</b>, the C++ keywords that support exception handling. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0043"
title="Add Comment A0043">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439953"></a><a name="_Toc312374111"></a><a
name="_Toc305628768"></a><a name="_Toc305593296">Error handling in C</a></h2>

<p class=MsoNormal>In most of the examples in these volumes, we use <b>assert(&nbsp;)</b>
as it was intended: for debugging during development with code that can be
disabled with <b>#define</b> <b>NDEBUG</b> for the shipping product. Runtime
error checking uses the <b>require.h</b> functions (<b>assure( )</b> and <b>require(
)</b>) developed in Chapter 9 in Volume 1. These functions are a convenient way
to say, “There’s a problem here you’ll probably want to handle with some more
sophisticated code, but you don’t need to be distracted by it in this example.”
The <b>require.h</b> functions might be enough for small programs, but for
complicated products you might need to write more sophisticated error-handling
code. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0044"
title="Add Comment A0044">Comment</a></sup></p>

<p class=MsoNormal>Error handling is quite straightforward in situations in
which you know exactly what to do because you have all the necessary
information in that context. Of course, you just handle the error at that
point. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0045"
title="Add Comment A0045">Comment</a></sup></p>

<p class=MsoNormal>The problem occurs when you <i>don’t</i> have enough
information in that context, and you need to pass the error information into a
different context where that information does exist. In C, you can handle this
situation using three approaches: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0046"
title="Add Comment A0046">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Return error information from the function or, if the return
value cannot be used this way, set a global error condition flag. (Standard C
provides <b>errno</b> and <b>perror(&nbsp;)</b> to support this.) As mentioned
earlier, the programmer is likely to ignore the error information because
tedious and obfuscating error checking must occur with each function call. In
addition, returning from a function that hits an exceptional condition might
not make sense.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use the little-known Standard C library signal-handling system,
implemented with the <b>signal(&nbsp;)</b> function (to determine what happens
when the event occurs) and <b>raise(&nbsp;)</b> (to generate an event). Again,
this approach involves high coupling because it requires the user of any library
that generates signals to understand and install the appropriate
signal-handling mechanism; also in large projects the signal numbers from
different libraries might clash.</p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use the <i>nonlocal goto</i> functions in the Standard C library: <b>setjmp(&nbsp;)</b> and <b>longjmp(&nbsp;)</b>. With <b>setjmp(&nbsp;)</b> you save a known good state in the program, and if you
get into trouble, <b>longjmp(&nbsp;)</b> will restore that state. Again, there
is high coupling between the place where the state is stored and the place
where the error occurs.</p>

<p class=MsoNormal>When considering error-handling schemes with C++, there’s an
additional very critical problem: The C techniques of signals and <b>setjmp(&nbsp;)</b>/<b>longjmp(&nbsp;)</b>
do not call destructors, so objects aren’t properly cleaned up. (In fact, if <b>longjmp(&nbsp;)</b>
jumps past the end of a scope where destructors should be called, the behavior
of the program is undefined.) This makes it virtually impossible to effectively
recover from an exceptional condition because you’ll always leave objects
behind that haven’t been cleaned up and that can no longer be accessed. The
following example demonstrates this with <b>setjmp/longjmp</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0047"
title="Add Comment A0047">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Nonlocal.cpp</p>

<p class=CodeChar style='margin-left:0in'>// setjmp() &amp; longjmp()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;csetjmp&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Rainbow {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Rainbow() { cout &lt;&lt;
&quot;Rainbow()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Rainbow() { cout &lt;&lt;
&quot;~Rainbow()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>jmp_buf kansas;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void oz() {</p>

<p class=CodeChar style='margin-left:0in'>  Rainbow rb;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 3; i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;there's no
place like home\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  longjmp(kansas, 47);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  if(setjmp(kansas) == 0) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;tornado,
witch, munchkins...\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    oz();</p>

<p class=CodeChar style='margin-left:0in'>  } else {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Auntie Em!
&quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;I had the
strangest dream...&quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>setjmp(&nbsp;)</b> function is odd because if you
call it directly, it stores all the relevant information about the current
processor state (such as the contents of the instruction pointer and runtime
stack pointer) in the <b>jmp_buf</b> and returns zero. In this case it behaves
like an ordinary function. However, if you call <b>longjmp(&nbsp;)</b> using
the same <b>jmp_buf</b>, it’s as if you’re returning from <b>setjmp(&nbsp;)</b>
again—you pop right out the back end of the <b>setjmp(&nbsp;)</b>. This time,
the value returned is the second argument to <b>longjmp(&nbsp;)</b>, so you can
detect that you’re actually coming back from a <b>longjmp(&nbsp;)</b>. You can
imagine that with many different <b>jmp_buf</b>s, you could pop around to many
different places in the program. The difference between a local <b>goto</b>
(with a label) and this nonlocal goto is that you can return to any
pre-determined location higher up in the runtime stack with <b>setjmp(&nbsp;)</b>/<b>longjmp(&nbsp;)</b>
(wherever you’ve placed a call to <b>setjmp(&nbsp;)</b>). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0048"
title="Add Comment A0048">Comment</a></sup></p>

<p class=MsoNormal>The problem in C++ is that <b>longjmp(&nbsp;)</b> doesn’t
respect objects; in particular it doesn’t call destructors when it jumps out of
a scope.<a href="#_ftn1" name="_ftnref1" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[1]</span></sup></span></span></sup></span></a> Destructor
calls are essential, so this approach won’t work with C++. In fact, the C++
standard states that branching into a scope with <b>goto</b> (effectively
bypassing constructor calls), or branching out of a scope with <b>longjmp(&nbsp;)</b>
where an object on the stack has a destructor, constitutes undefined behavior. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0049"
title="Add Comment A0049">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439954"></a><a name="_Toc312374112"></a><a
name="_Toc305628769"></a><a name="_Toc305593297">Throwing an exception</a></h2>

<p class=MsoNormal>If you encounter an exceptional situation in your code—that
is, one in which you don’t have enough information in the current context to
decide what to do—you can send information about the error into a larger
context by creating an object that contains that information and “throwing” it
out of your current context. This is called <i>throwing an exception</i>.
Here’s what it looks like: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0050"
title="Add Comment A0050">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:MyError.cpp</p>

<p class=CodeChar style='margin-left:0in'>class MyError {</p>

<p class=CodeChar style='margin-left:0in'>   const char* const data;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   MyError(const char* const msg = 0)
: data (msg) {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f() {</p>

<p class=CodeChar style='margin-left:0in'>   // Here we &quot;throw&quot; an
exception object:</p>

<p class=CodeChar style='margin-left:0in'>   throw MyError(&quot;something bad
happened&quot;);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   // As you’ll see shortly, </p>

<p class=CodeChar style='margin-left:0in'>   // we’ll want a &quot;try
block&quot; here:</p>

<p class=CodeChar style='margin-left:0in'>   f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><b>MyError</b> is an ordinary class, which in this case
takes a <b>char*</b> as a constructor argument. You can use any type when you
throw (including built-in types), but usually you’ll create special classes for
throwing exceptions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0051"
title="Add Comment A0051">Comment</a></sup></p>

<p class=MsoNormal>The keyword <b>throw</b> causes a number of relatively
magical things to happen. First, it creates a copy of the object you’re
throwing and, in effect, “returns” it from the function containing the throw
expression, even though that object type isn’t normally what the function is
designed to return. A naïve way to think about exception handling is as an
alternate return mechanism (although you find you can get into trouble if you
take the analogy too far). You can also exit from ordinary scopes by throwing
an exception. In any case, a value is returned, and the function or scope
exits. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0052"
title="Add Comment A0052">Comment</a></sup></p>

<p class=MsoNormal>Any similarity to function returns ends there because <i>where</i>
you return is some place completely different from where a normal function call
returns. (You end up in an appropriate part of the code—called an exception
handler—that might be far removed from where the exception was thrown.) In
addition, any local objects created by the time the exception occurs are
destroyed. This automatic cleanup of local objects is often called “stack
unwinding.” <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0053"
title="Add Comment A0053">Comment</a></sup></p>

<p class=MsoNormal>In addition, you can throw as many different types of
objects as you want. Typically, you’ll throw a different type for each category
of error. The idea is to store the information in the object and in the <i>name</i>
of its class so that someone in a calling context can figure out what to do
with your exception. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0054"
title="Add Comment A0054">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439955"></a><a name="_Toc312374113"></a><a
name="_Toc305628770"></a><a name="_Toc305593298">Catching an exception</a></h2>

<p class=MsoNormal>As mentioned earlier, one of the advantages of C++ exception
handling is that it allows you to concentrate on the problem you’re actually
trying to solve in one place, and then deal with the errors from that code in
another place. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0055"
title="Add Comment A0055">Comment</a></sup></p>

<h3><a name="_Toc45439956"></a><a name="_Toc312374114">The </a><span
style='font-weight:normal'>try</span> block</h3>

<p class=MsoNormal>If you’re inside a function and you throw an exception (or a
called function throws an exception), the function exits in the process of
throwing. If you don’t want a <b>throw </b>to leave a function, you can set up
a special block within the function where you try to solve your actual
programming problem (and potentially generate exceptions). This block is called
the <i>try</i> <i>block</i> because you try your various function calls there.
The try block is an ordinary scope, preceded by the keyword <b>try</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0056"
title="Add Comment A0056">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>try {</p>

<p class=CodeChar style='margin-left:0in'>  // Code that may generate
exceptions</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If you check for errors by carefully examining the return
codes from the functions you use, you need to surround every function call with
setup and test code, even if you call the same function several times. With
exception handling, you put everything in a <b>try</b> block and handle
exceptions after the <b>try</b> block. Thus, your code is a lot easier to write
and easier to read because the goal of the code is not confused with the error
checking. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0057"
title="Add Comment A0057">Comment</a></sup></p>

<h3><a name="_Toc45439957"></a><a name="_Toc312374115">Exception handlers</a></h3>

<p class=MsoNormal>Of course, the thrown exception must end up some place. This
place is the <i>exception handler</i>, and you need one exception handler for every exception type you want to catch. Exception handlers immediately follow
the <b>try</b> block and are denoted by the keyword <b>catch</b>: <sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0058"
title="Add Comment A0058">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>try {</p>

<p class=CodeChar style='margin-left:0in'>  // Code that may generate
exceptions</p>

<p class=CodeChar style='margin-left:0in'>} catch(type1 id1) {</p>

<p class=CodeChar style='margin-left:0in'>  // Handle exceptions of type1</p>

<p class=CodeChar style='margin-left:0in'>} catch(type2 id2) {</p>

<p class=CodeChar style='margin-left:0in'>  // Handle exceptions of type2</p>

<p class=CodeChar style='margin-left:0in'>} catch(type3 id3)</p>

<p class=CodeChar style='margin-left:0in'>  // Etc...</p>

<p class=CodeChar style='margin-left:0in'>} catch(typeN idN)</p>

<p class=CodeChar style='margin-left:0in'>  // Handle exceptions of typeN</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>// Normal execution resumes
here...</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The syntax of a <b>catch</b> clause resembles functions that
take a single argument. The identifier (<b>id1</b>, <b>id2</b>, and so on) can
be used inside the handler, just like a function argument, although you can
omit the identifier if it’s not needed in the handler. The exception type
usually gives you enough information to deal with it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0059"
title="Add Comment A0059">Comment</a></sup></p>

<p class=MsoNormal>The handlers must appear directly after the <b>try</b>
block. If an exception is thrown, the exception-handling mechanism goes hunting
for the first handler with an argument that matches the type of the exception.
It then enters that <b>catch</b> clause, and the exception is considered
handled. (The search for handlers stops once the <b>catch</b> clause is found.)
Only the matching <b>catch</b> clause executes; control then resumes after the
last handler associated with that try block. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0060"
title="Add Comment A0060">Comment</a></sup></p>

<p class=MsoNormal>Notice that, within the <b>try</b> block, a number of
different function calls might generate the same type of exception, but you
need only one handler. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0061"
title="Add Comment A0061">Comment</a></sup></p>

<p class=MsoNormal>To illustrate using <b>try</b> and <b>catch</b>, the
following variation of <b>Nonlocal.cpp</b> replaces the call to <b>setjmp( )</b>
with a <b>try</b> block and replaces the call to <b>longjmp( )</b> with a <b>throw</b>
statement. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0062"
title="Add Comment A0062">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Nonlocal2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates exceptions</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Rainbow {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Rainbow() { cout &lt;&lt;
&quot;Rainbow()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Rainbow() { cout &lt;&lt;
&quot;~Rainbow()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void oz() {</p>

<p class=CodeChar style='margin-left:0in'>  Rainbow rb;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 3; i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;there's no
place like home\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  throw 47;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;tornado,
witch, munchkins...\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    oz();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (int) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Auntie Em!
&quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;I had the
strangest dream...&quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When the <b>throw</b> statement in <b>oz( )</b> executes,
program control backtracks until it finds the <b>catch</b> clause that takes an
<b>int</b> parameter, at which point execution resumes with the body of that <b>catch</b>
clause. The most important difference between this program and <b>Nonlocal.cpp</b>
is that the destructor for the object <b>rb</b> is called when the <b>throw</b>
statement causes execution to leave the function <b>oz( )</b>.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0063"
title="Add Comment A0063">Comment</a></sup></p>

<p class=MsoNormal>There are two basic models in exception-handling theory: termination and resumption. In <i>termination</i> (which is what C++
supports), you assume the error is so critical that there’s no way to
automatically resume execution at the point where the exception occurred. In
other words, “whoever” threw the exception decided there was no way to salvage
the situation, and they don’t <i>want</i> to come back. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0064"
title="Add Comment A0064">Comment</a></sup></p>

<p class=MsoNormal>The alternative error-handling model is called <i>resumption</i>,
first introduced with the PL/I language in the 1960s<a href="#_ftn2"
name="_ftnref2" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[2]</span></sup></span></span></sup></span></a>. Using resumption
semantics means that the exception handler is expected to do something to
rectify the situation, and then the faulting code is automatically retried,
presuming success the second time. If you want resumption in C++, you must
explicitly transfer execution back to the code where the error occurred, usually
by repeating the function call that sent you there in the first place. It is
not unusual, therefore, to place your <b>try</b> block inside a <b>while</b>
loop that keeps reentering the <b>try</b> block until the result is
satisfactory. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0065"
title="Add Comment A0065">Comment</a></sup></p>

<p class=MsoNormal>Historically, programmers using operating systems that
supported resumptive exception handling eventually ended up using
termination-like code and skipping resumption. Although resumption sounds
attractive at first, it seems it isn’t quite so useful in practice. One reason
may be the distance that can occur between the exception and its handler; it is
one thing to terminate to a handler that’s far away, but to jump to that
handler and then back again may be too conceptually difficult for large systems
on which the exception can be generated from many points. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0066"
title="Add Comment A0066">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc312374118"></a><a name="_Toc45439958"></a><a
name="_Toc312374124"></a><a name="_Toc305628773"></a><a name="_Toc305593301">Exception
matching</a></h2>

<p class=MsoNormal>When an exception is thrown, the exception-handling system
looks through the “nearest” handlers in the order they appear in the source
code. When it finds a match, the exception is considered handled and no further
searching occurs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0067"
title="Add Comment A0067"><sup>Comment</sup></a></p>

<p class=MsoNormal>Matching an exception doesn’t require a perfect correlation
between the exception and its handler. An object or reference to a
derived-class object will match a handler for the base class. (However, if the
handler is for an object rather than a reference, the exception object is
“sliced”— truncated to the base type — as it is passed to the handler; this does no damage but loses all the derived-type information.) For this reason, as
well as to avoid making yet another copy of the exception object, it is always
better to catch an exception by <i>reference</i> instead of by value<a
href="#_ftn3" name="_ftnref3" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[3]</span></sup></span></span></sup></span></a>. If a pointer is
thrown, the usual standard pointer conversions are used to match the exception.
However, no automatic type conversions are used to convert from one exception type to another in the process of matching, for example: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0068"
title="Add Comment A0068"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Autoexcp.cpp</p>

<p class=CodeChar style='margin-left:0in'>// No matching conversions</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Except1 {};</p>

<p class=CodeChar style='margin-left:0in'>class Except2 {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Except2(const Except1&amp;) {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f() { throw Except1(); }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try { f();</p>

<p class=CodeChar style='margin-left:0in'>  } catch (Except2&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside
catch(Except2)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  } catch (Except1&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside
catch(Except1)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Even though you might think the first handler could be used
by converting an <b>Except1</b> object into an <b>Except2</b> using the
constructor conversion, the system will not perform such a conversion during
exception handling, and you’ll end up at the <b>Except1</b> handler. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0069"
title="Add Comment A0069"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example shows how a base-class handler can
catch a derived-class exception: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0070"
title="Add Comment A0070"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Basexcpt.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Exception hierarchies</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class X {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class Trouble {};</p>

<p class=CodeChar style='margin-left:0in'>  class Small : public Trouble {};</p>

<p class=CodeChar style='margin-left:0in'>  class Big : public Trouble {};</p>

<p class=CodeChar style='margin-left:0in'>  void f() { throw Big(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  X x;</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    x.f();</p>

<p class=CodeChar style='margin-left:0in'>  } catch(X::Trouble&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught
Trouble&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Hidden by previous handler:</p>

<p class=CodeChar style='margin-left:0in'>  } catch(X::Small&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught Small
Trouble&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  } catch(X::Big&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught Big
Trouble&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here, the exception-handling mechanism will always match a <b>Trouble</b>
object, <i>or anything that is a</i> <b>Trouble</b> (through public inheritance<a
href="#_ftn4" name="_ftnref4" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[4]</span></sup></span></span></sup></span></a>), to the first
handler. That means the second and third handlers are never called because the
first one captures them all. It makes more sense to catch the derived types
first and put the base type at the end to catch anything less specific. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0071"
title="Add Comment A0071"><sup>Comment</sup></a></p>

<p class=MsoNormal>Notice that these examples catch exceptions by reference,
although for these classes it isn’t important because there are no additional
members in the derived classes, and there are no argument identifiers in the
handlers anyway. You’ll usually want to use reference arguments rather than
value arguments in your handlers to avoid slicing off information. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0072"
title="Add Comment A0072"><sup>Comment</sup></a></p>

<h3><a name="_Toc45439959">Catching any exception</a></h3>

<p class=MsoNormal> Sometimes you want to create a handler that <i>catches</i>
any type of exception. You do this using the ellipsis in the argument list: <sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0073"
title="Add Comment A0073">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>catch(...) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;an exception
was thrown&quot; &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>An ellipsis catches any exception, so you’ll want to put it
at the <i>end</i> of your list of handlers to avoid pre-empting any that follow
it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0074"
title="Add Comment A0074">Comment</a></sup></p>

<p class=MsoNormal>Because the ellipsis gives you no possibility to have an
argument, you can’t know anything about the exception or its type. It’s a
“catchall.” Such a <b>catch</b> clause is often used to clean up some resources
and then rethrow the exception. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0075"
title="Add Comment A0075">Comment</a></sup></p>

<h3><a name="_Toc45439960"></a><a name="_Toc312374119">Re-throwing an exception</a></h3>

<p class=MsoNormal>You usually want to re-throw an exception when you have some
resource that needs to be released, such as a network connection or heap memory
that needs to be deallocated. (See the section “Resource Management” later in
this chapter for more detail). If an exception occurs, you don’t necessarily
care what error caused the exception—you just want to close the connection you
opened previously. After that, you’ll want to let some other context closer to
the user (that is, higher up in the call chain) handle the exception. In this
case the ellipsis specification is just what you want. You want to catch <i>any</i>
exception, clean up your resource, and then re-throw the exception so that it
can be handled elsewhere. You re-throw an exception by using <b>throw</b> with no argument inside a handler: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0076"
title="Add Comment A0076">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>catch(...) {</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>cout &lt;&lt;
&quot;an exception was thrown&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>// Deallocate your
resource here, and then re-throw…</p>

<p class=CodeChar style='margin-left:0in'>  throw;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Any further <b>catch</b> clauses for the same <b>try</b>
block are still ignored—the <b>throw</b> causes the exception to go to the
exception handlers in the next-higher context. In addition, everything about
the exception object is preserved, so the handler at the higher context that
catches the specific exception type can extract any information the object may
contain. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0077"
title="Add Comment A0077">Comment</a></sup></p>

<h3><a name="_Toc45439961"></a><a name="_Toc312374120">Uncaught exceptions</a></h3>

<p class=MsoNormal>As we explained in the beginning of this chapter, exception
handling is considered better than the traditional return-an-error-code
technique because exceptions can’t be ignored. If none of the exception handlers following a particular <b>try</b> block matches an exception, that
exception moves to the next-higher context, that is, the function or <b>try</b>
block surrounding the <b>try</b> block that did not catch the exception. (The
location of this <b>try</b> block is not always obvious at first glance, since
it’s higher up in the call chain.) This process continues until, at some level,
a handler matches the exception. At that point, the exception is considered
“caught,” and no further searching occurs. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0078"
title="Add Comment A0078">Comment</a></sup></p>

<h4><span style='font-weight:normal'>The </span>terminate(&nbsp;)<span
style='font-weight:normal'> function</span></h4>

<p class=MsoNormal>If no handler at any level catches the exception, the special
library function <b>terminate(&nbsp;)</b> (declared in the <b>&lt;exception&gt;</b>
header) is automatically called. By default, <b>terminate( )</b> calls the
Standard C library function <b>abort(&nbsp;)</b>, which abruptly exits the program. On Unix systems, <b>abort(&nbsp;)</b> also causes a core dump. When <b>abort(
)</b> is called, no calls to normal program termination functions occur, which
means that destructors for global and static objects do not execute. The <b>terminate(
)</b> function also executes if a destructor for a local object throws an
exception during stack unwinding (interrupting the exception that was in
progress) or if a global or static object’s constructor or destructor throws an
exception. In general, do not allow a destructor to throw an exception. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0081"
title="Add Comment A0081">Comment</a></sup></p>

<h4><span style='font-weight:normal'>The </span>set_terminate(&nbsp;)<span
style='font-weight:normal'> function</span></h4>

<p class=MsoNormal>You can install your own <b>terminate(&nbsp;)</b> function
using the standard <b>set_terminate(&nbsp;)</b> function, which returns a pointer to the <b>terminate(&nbsp;)</b> function you are replacing (which will be
the default library version the first time you call it), so you can restore it
later if you want. Your custom <b>terminate(&nbsp;)</b> must take no arguments
and have a <b>void</b> return value. In addition, any <b>terminate(&nbsp;)</b>
handler you install must not return or throw an exception, but instead must
execute some sort of program-termination logic. If <b>terminate(&nbsp;)</b> is
called, the problem is unrecoverable. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0082"
title="Add Comment A0082">Comment</a></sup></p>

<p class=MsoNormal>The following example shows the use of <b>set_terminate(&nbsp;)</b>.
Here, the return value is saved and restored so that the <b>terminate(&nbsp;)</b>
function can be used to help isolate the section of code in which the uncaught
exception is occurring: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0084"
title="Add Comment A0084">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Terminator.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Use of set_terminate()</p>

<p class=CodeChar style='margin-left:0in'>// Also shows uncaught exceptions</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;exception&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void terminator() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;I'll be
back!&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  exit(0);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void (*old_terminate)()</p>

<p class=CodeChar style='margin-left:0in'>  = set_terminate(terminator);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Botch {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class Fruit {};</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Botch::f()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    throw Fruit();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Botch() { throw 'c'; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    Botch b;</p>

<p class=CodeChar style='margin-left:0in'>    b.f();</p>

<p class=CodeChar style='margin-left:0in'>  } catch(...) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside catch(...)&quot;
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The definition of <b>old_terminate</b> looks a bit confusing
at first: it not only creates a pointer to a function, but it initializes that pointer to the return value of <b>set_terminate(&nbsp;)</b>. Even though you
might be familiar with seeing a semicolon right after a pointer-to-function
declaration, here it’s just another kind of variable and can be initialized
when it is defined. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0085"
title="Add Comment A0085">Comment</a></sup></p>

<p class=MsoNormal>The class <b>Botch</b> not only throws an exception inside <b>f(&nbsp;)</b>,
but also in its destructor. As we explained earlier, this situation causes a
call to <b>terminate(&nbsp;)</b>, as you can see in <b>main(&nbsp;)</b>. Even
though the exception handler says <b>catch(...)</b>, which would seem to catch
everything and leave no cause for <b>terminate(&nbsp;)</b> to be called, <b>terminate(&nbsp;)
</b>is called anyway. In the process of cleaning up the objects on the stack to
handle one exception, the <b>Botch</b> destructor is called, and that generates
a second exception, forcing a call to <b>terminate(&nbsp;)</b>. Thus, a
destructor that throws an exception or causes one to be thrown is usually a
sign of poor design or sloppy coding. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0086"
title="Add Comment A0086">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439962"></a><a name="_Toc312374121"></a><a
name="_Toc305628771"></a><a name="_Toc305593299">Cleaning up</a></h2>

<p class=MsoNormal>Part of the magic of exception handling is that you can pop from normal program flow into the appropriate exception handler. Doing so
wouldn’t be useful, however, if things weren’t cleaned up properly as the
exception was thrown. C++ exception handling guarantees that as you leave a
scope, all objects in that scope <i>whose constructors have been completed</i>
will have destructors called. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0087"
title="Add Comment A0087">Comment</a></sup></p>

<p class=MsoNormal>Here’s an example that demonstrates that constructors that aren’t completed don’t have the associated destructors called. It also shows
what happens when an exception is thrown in the middle of the creation of an
array of objects: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0088"
title="Add Comment A0088">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Cleanup.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Exceptions clean up complete
objects only</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Trace {</p>

<p class=CodeChar style='margin-left:0in'>  static int counter;</p>

<p class=CodeChar style='margin-left:0in'>  int objid;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Trace() {</p>

<p class=CodeChar style='margin-left:0in'>    objid = counter++;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;constructing
Trace #&quot; &lt;&lt; objid &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    if(objid == 3) throw 3;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Trace() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;destructing
Trace #&quot; &lt;&lt; objid &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int Trace::counter = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    Trace n1;</p>

<p class=CodeChar style='margin-left:0in'>    // Throws exception:</p>

<p class=CodeChar style='margin-left:0in'>    Trace array[5];</p>

<p class=CodeChar style='margin-left:0in'>    Trace n2;  // won't get here</p>

<p class=CodeChar style='margin-left:0in'>  } catch(int i) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught &quot;
&lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The class <b>Trace</b> keeps track of objects so that you
can trace program progress. It keeps a count of the number of objects created
with a <b>static</b> data member <b>counter</b> and tracks the number of the
particular object with <b>objid </b><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0089"
title="Add Comment A0089">Comment</a></sup></p>

<p class=MsoNormal>The main program creates a single object, <b>n1</b> (<b>objid</b>
0), and then attempts to create an array of five <b>Trace</b> objects, but an
exception is thrown before the third object is fully created. The object <b>n2</b>
is never created. You can see the results in the output of the program: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0092"
title="Add Comment A0092">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>constructing Trace #0</p>

<p class=CodeChar style='margin-left:0in'>constructing Trace #1</p>

<p class=CodeChar style='margin-left:0in'>constructing Trace #2</p>

<p class=CodeChar style='margin-left:0in'>constructing Trace #3</p>

<p class=CodeChar style='margin-left:0in'>destructing Trace #2</p>

<p class=CodeChar style='margin-left:0in'>destructing Trace #1</p>

<p class=CodeChar style='margin-left:0in'>destructing Trace #0</p>

<p class=CodeChar style='margin-left:0in'>caught 3</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Three array elements are successfully created, but in the
middle of the constructor for the fourth element, an exception is thrown.
Because the fourth construction in <b>main( )</b> (for <b>array[2]</b>) never
completes, only the destructors for objects <b>array[1]</b> and <b>array[0]</b>
are called. Finally, object <b>n1</b> is destroyed, but not object <b>n2</b>,
because it was never created. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0093"
title="Add Comment A0093">Comment</a></sup></p>

<h3><a name="_Toc45439963">Resource management</a></h3>

<p class=MsoNormal>When writing code with exceptions, it’s particularly
important that you always ask, “If an exception occurs, will my resources be
properly cleaned up?” Most of the time you’re fairly safe, but in constructors
there’s a particular problem: if an exception is thrown before a constructor is
completed, the associated destructor will not be called for that object. Thus,
you must be especially diligent while writing your constructor. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0097"
title="Add Comment A0097">Comment</a></sup></p>

<p class=MsoNormal>The general difficulty is allocating resources in
constructors. If an exception occurs in the constructor, the destructor doesn’t
get a chance to deallocate the resource. This problem occurs most often with
“naked” pointers. For example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0098"
title="Add Comment A0098">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Rawp.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Naked pointers</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Cat {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Cat() { cout &lt;&lt;
&quot;Cat()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Cat() { cout &lt;&lt;
&quot;~Cat()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Dog {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void* operator new(size_t sz) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;allocating a
Dog&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    throw 47;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void operator delete(void* p) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;deallocating
a Dog&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    ::operator delete(p);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class UseResources {</p>

<p class=CodeChar style='margin-left:0in'>  Cat* bp;</p>

<p class=CodeChar style='margin-left:0in'>  Dog* op;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  UseResources(int count = 1) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;UseResources()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    bp = new Cat[count];</p>

<p class=CodeChar style='margin-left:0in'>    op = new Dog;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~UseResources() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;~UseResources()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    delete [] bp; // Array delete</p>

<p class=CodeChar style='margin-left:0in'>    delete op;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    UseResources ur(3);</p>

<p class=CodeChar style='margin-left:0in'>  } catch(int) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside
handler&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The output is the following: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0099"
title="Add Comment A0099">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>UseResources()</p>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>allocating a Dog</p>

<p class=CodeInlineCharChar style='margin-left:0in'>inside handler</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>UseResources</b> constructor is entered, and the <b>Cat</b>
constructor is successfully completed for the three array objects. However,
inside <b>Dog::operator new(&nbsp;)</b>, an exception is thrown (to simulate an
out-of-memory error). Suddenly, you end up inside the handler, <i>without</i>
the <b>UseResources</b> destructor being called. This is correct because the <b>UseResources</b>
constructor was unable to finish, but it also means the <b>Cat</b> objects that
were successfully created on the heap were never destroyed. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0100"
title="Add Comment A0100">Comment</a></sup></p>

<h3><a name="_Toc45439964"></a><a name="_Toc312374123">Making everything an
object</a></h3>

<p class=MsoNormal>To prevent such resource leaks, you must guard against these
“raw” resource allocations in one of two ways:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You can catch exceptions inside the constructor and then release
the resource.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You can place the allocations inside an object’s constructor, and
you can place the deallocations inside an object’s destructor. </p>

<p class=MsoNormal>Using the latter approach, each allocation becomes atomic, by virtue of being part of the lifetime of a local object, and if it fails, the
other resource allocation objects are properly cleaned up during stack
unwinding. This technique is called Resource Acquisition Is Initialization
(RAII for short), because it equates resource control with object lifetime.
Using templates is an excellent way to modify the previous example to achieve
this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0101"
title="Add Comment A0101">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Wrapped.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Safe, atomic pointers</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Simplified. Yours may have other
arguments.</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, int SZ = 1&gt;
class PWrap {</p>

<p class=CodeChar style='margin-left:0in'>  T* ptr;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class RangeError {}; // Exception
class</p>

<p class=CodeChar style='margin-left:0in'>  PWrap() {</p>

<p class=CodeChar style='margin-left:0in'>    ptr = new T[SZ];</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;PWrap
constructor&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~PWrap() {</p>

<p class=CodeChar style='margin-left:0in'>    delete [] ptr;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;PWrap
destructor&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T&amp; operator[](int i)
throw(RangeError) {</p>

<p class=CodeChar style='margin-left:0in'>    if(i &gt;= 0 &amp;&amp; i &lt;
SZ) return ptr[i];</p>

<p class=CodeChar style='margin-left:0in'>    throw RangeError();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Cat {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Cat() { cout &lt;&lt;
&quot;Cat()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Cat() { cout &lt;&lt;
&quot;~Cat()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  void g() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Dog {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void* operator new[](size_t) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Allocating a
Dog&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    throw 47;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void operator delete[](void* p) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Deallocating
a Dog&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    ::operator delete[](p);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class UseResources {</p>

<p class=CodeChar style='margin-left:0in'>  PWrap&lt;Cat, 3&gt; cats;</p>

<p class=CodeChar style='margin-left:0in'>  PWrap&lt;Dog&gt; dog;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  UseResources() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;UseResources()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~UseResources() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;~UseResources()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void f() { cats[1].g(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    UseResources ur;</p>

<p class=CodeChar style='margin-left:0in'>  } catch(int) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside
handler&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  } catch(...) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;inside
catch(...)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The difference is the use of the template to wrap the
pointers and make them into objects. The constructors for these objects are
called <i>before</i> the body of the <b>UseResources</b> constructor, and any
of these constructors that complete before an exception is thrown will have
their associated destructors called during stack unwinding. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0102"
title="Add Comment A0102">Comment</a></sup></p>

<p class=MsoNormal>The <b>PWrap</b> template shows a more typical use of
exceptions than you’ve seen so far: A nested class called <b>RangeError</b> is
created to use in <b>operator[ ]</b> if its argument is out of range. Because <b>operator[
]</b> returns a reference, it cannot return zero. (There are no null
references.) This is a true exceptional condition—you don’t know what to do in
the current context, and you can’t return an improbable value. In this example,
<b>RangeError</b> is simple and assumes all the necessary information is in the
class name, but you might also want to add a member that contains the value of
the index, if that is useful. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0103"
title="Add Comment A0103">Comment</a></sup></p>

<p class=MsoNormal>Now the output is: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0104"
title="Add Comment A0104">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>Cat()</p>

<p class=CodeChar style='margin-left:0in'>PWrap constructor</p>

<p class=CodeChar style='margin-left:0in'>allocating a Dog</p>

<p class=CodeChar style='margin-left:0in'>~Cat()</p>

<p class=CodeChar style='margin-left:0in'>~Cat()</p>

<p class=CodeChar style='margin-left:0in'>~Cat()</p>

<p class=CodeChar style='margin-left:0in'>PWrap destructor</p>

<p class=CodeInlineCharChar style='margin-left:0in'>inside handler</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Again, the storage allocation for <b>Dog</b> throws an
exception, but this time the array of <b>Cat</b> objects is properly cleaned
up, so there is no memory leak. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0105"
title="Add Comment A0105">Comment</a></sup></p>

<h3><a name="_Toc312374125"></a><a name="_Toc305628774"></a><a
name="_Toc305593302"></a><a name="_Toc45439965">auto_ptr</a></h3>

<p class=MsoNormal>Since dynamic memory is the most frequent resource used in a
typical C++ program, the standard provides an RAII wrapper for pointers to heap
memory that automatically frees the memory. The <b>auto_ptr</b> class template,
defined in the <b>&lt;memory&gt;</b> header, has a constructor that takes a
pointer to its generic type (whatever you use in your code). The <b>auto_ptr</b>
class template also overloads the pointer operators <b>*</b> and <b>-&gt;</b>
to forward these operations to the original pointer the <b>auto_ptr</b> object
is holding. You can, therefore, use the <b>auto_ptr</b> object as if it were a
raw pointer. Here’s how it works: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1500"
title="Add Comment A1500"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Auto_ptr.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates the RAII nature of
auto_ptr</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;memory&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class TraceHeap {</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static void* operator new(size_t
siz) {</p>

<p class=CodeChar style='margin-left:0in'>    void* p = ::operator new(siz);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Allocating
TraceHeap object on the heap &quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;at address
&quot; &lt;&lt; p &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    return p;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static void operator delete(void*
p) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Deleting
TraceHeap object at address &quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; p &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    ::operator delete(p);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  TraceHeap(int i) : i(i) {}</p>

<p class=CodeChar style='margin-left:0in'>  int getVal() const {</p>

<p class=CodeChar style='margin-left:0in'>    return i;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  auto_ptr&lt;TraceHeap&gt;
pMyObject(new TraceHeap(5));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
pMyObject-&gt;getVal() &lt;&lt; endl;  // prints 5</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>TraceHeap</b> class overloads the <b>operator new</b>
and <b>operator delete</b> so you can see exactly what’s happening. Notice
that, like any other class template, you specify the type you’re going to use
in a template parameter. You don’t say <b>TraceHeap*</b>, however; <b>auto_ptr</b>
already knows that it will be storing a pointer to your type. The second line
of <b>main( )</b> verifies that <b>auto_ptr</b>’s <b>operator-&gt;( )</b>
function applies the indirection to the original, underlying pointer. Most
important, even though we didn’t explicitly delete the original pointer (in
fact we can’t here, since we didn’t save its address in a variable anywhere), <b>pMyObject</b>’s
destructor deletes the original pointer during stack unwinding, as the
following output verifies: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1499"
title="Add Comment A1499"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Allocating TraceHeap object on the
heap at address 8930040</p>

<p class=CodeChar style='margin-left:0in'>5</p>

<p class=CodeChar style='margin-left:0in'>Deleting TraceHeap object at address
8930040</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><b>The auto_ptr</b> class template is also handy for pointer
data members. Since class objects contained by value are always destructed, <b>auto_ptr</b>
members always delete the raw pointer they wrap when the containing object is
destructed<a href="#_ftn5" name="_ftnref5" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[5]</span></sup></span></span></sup></span></a>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1498"
title="Add Comment A1498"><sup>Comment</sup></a></p>

<h3><a name="_Toc45439966">Function-level try blocks</a></h3>

<p class=MsoNormal>Since constructors can routinely throw exceptions, you might
want to handle exceptions that occur when an object’s member or base subobjects
are initialized. To do this, you can place the initialization of such
subobjects in a <i>function-level try block</i>. In a departure from the usual
syntax, the <b>try</b> block for constructor initializers is the constructor
body, and the associated <b>catch</b> block follows the body of the
constructor, as in the following example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0106"
title="Add Comment A0106"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:InitExcept.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Handles exceptions from subobjects</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Base {</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class BaseExcept {};</p>

<p class=CodeChar style='margin-left:0in'>  Base(int i) : i(i) {</p>

<p class=CodeChar style='margin-left:0in'>    throw BaseExcept();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Derived : public Base {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class DerivedExcept {</p>

<p class=CodeChar style='margin-left:0in'>    const char* msg;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    DerivedExcept(const char* msg) :
msg(msg) {}</p>

<p class=CodeChar style='margin-left:0in'>    const char* what() const {</p>

<p class=CodeChar style='margin-left:0in'>      return msg;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  Derived(int j)</p>

<p class=CodeChar style='margin-left:0in'>  try </p>

<p class=CodeChar style='margin-left:0in'>    : Base(j) {</p>

<p class=CodeChar style='margin-left:0in'>    // Constructor body</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;This won't
print\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (BaseExcept&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    throw DerivedExcept(&quot;Base
subobject threw&quot;);;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    Derived d(3);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (Derived::DerivedExcept&amp;
d) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; d.what() &lt;&lt;
endl;  // &quot;Base subobject threw&quot;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that the initializer list in the constructor for <b>Derived</b>
goes after the <b>try</b> keyword but before the constructor body. If an
exception does indeed occur, the contained object is not constructed, so it
makes no sense to return to the code that created it. For this reason, the only
sensible thing to do is to throw an exception in the function-level <b>catch</b>
clause. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1497"
title="Add Comment A1497"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although it is not terribly useful, C++ also allows
function-level <b>try</b> blocks for <i>any</i> function, as the following
example illustrates:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:FunctionTryBlock.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Function-level try blocks</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() try {</p>

<p class=CodeChar style='margin-left:0in'>  throw &quot;main&quot;;</p>

<p class=CodeChar style='margin-left:0in'>} catch(const char* msg) {</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>cout &lt;&lt; msg
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>return 1;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this case, the <b>catch</b> block can return in the same
manner that the function body normally returns. Using this type of
function-level <b>try</b> block isn’t much different from inserting a <b>try-catch</b>
around the code inside of the function body. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1496"
title="Add Comment A1496"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45439967">Standard exceptions</a></h2>

<p class=MsoNormal>The set of exceptions used with the Standard C++ library is also available for your use. Generally it’s easier and faster to start with a
standard exception class than to try to define your own. If the standard class
doesn’t do exactly what you need, you can derive from it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0107"
title="Add Comment A0107">Comment</a></sup></p>

<p class=MsoNormal>All standard exception classes derive ultimately from the
class <b>exception</b>, defined in the header <b>&lt;exception&gt;</b>. The two
main derived classes are <b>logic_error</b> and <b>runtime_error</b>, which are
found in <b>&lt;stdexcept&gt;</b> (which itself includes <b>&lt;exception&gt;</b>).
The class <b>logic_error</b> represents errors in programming logic, such as
passing an invalid argument. Runtime errors are those that occur as the result
of unforeseen forces such as hardware failure or memory exhaustion. Both <b>runtime_error</b>
and <b>logic_error</b> provide a constructor that takes a <b>std::string</b>
argument so that you can store a message in the exception object and extract it
later with <b>exception::what( )</b>, as the following program illustrates. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1501"
title="Add Comment A1501">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:StdExcept.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Derives an exception class from
std::runtime_error</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class MyError : public runtime_error
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  MyError(const string&amp; msg =
&quot;&quot;) : runtime_error(msg) {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    throw MyError(&quot;my message&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (MyError&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; x.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Although the <b>runtime_error</b> constructor passes the
message up to its <b>std::exception</b> subobject to hold, <b>std::exception</b>
does not provide a constructor that takes a <b>std::string</b> argument.
Therefore, you usually want to derive your exception classes from either <b>runtime_error</b>
or <b>logic_error</b> (or one of their derivatives), and not from <b>std::exception</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1502"
title="Add Comment A1502">Comment</a></sup></p>

<p class=MsoNormal>The following tables describe the standard exception
classes. </p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse'>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext><a><b>exception</b></a><span class=MsoCommentReference><b><span
  style='font-size:8.0pt;font-family:Times'><a class=msocomanchor id="_anchor_3"
  onmouseover="msoCommentShow('_anchor_3','_com_3')"
  onmouseout="msoCommentHide('_com_3')" href="#_msocom_3" language=JavaScript
  name="_msoanchor_3">[DwH3]</a><span style='display:none'>&nbsp;</span></span></b></span></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext>The base class for all the exceptions thrown by the C++
  standard library. You can ask <b>what(&nbsp;)</b> and retrieve the optional
  string with which the exception was initialized.</p>
  </td>
 </tr>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext><b>logic_error</b></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext>Derived from <b>exception</b>. Reports program logic
  errors, which could presumably be detected by inspection.</p>
  </td>
 </tr>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext><b>runtime_error</b></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt'>
  <p class=tabletext>Derived from <b>exception</b>.<b> </b>Reports runtime
  errors, which can presumably be detected only when the program executes.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The iostream exception class <b>ios::failure</b> is also
derived from <b>exception</b>, but it has no further subclasses. <sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0109" title="Add Comment A0109">Comment</a></sup></p>

<p class=MsoNormal>You can use the classes in both of the following tables as
they are, or you can use them as base classes from which to derive your own
more specific types of exceptions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0110"
title="Add Comment A0110">Comment</a></sup></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse'>
 <thead>
  <tr>
   <td width=427 colspan=2 valign=top style='width:4.45in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>Exception classes derived from logic_error</p>
   </td>
  </tr>
 </thead>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>domain_error</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports violations of a precondition.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>invalid_argument</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Indicates an invalid argument to the function from which
  it’s thrown.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>length_error</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Indicates an attempt to produce an object whose length is
  greater than or equal to <b>npos</b> (the largest representable value of type
  <b>size_t</b>).</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>out_of_range</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports an out-of-range argument.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>bad_cast</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Thrown for executing an invalid <b>dynamic_cast</b>
  expression in runtime type identification (see Chapter 8).</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>bad_typeid</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports a null pointer <b>p</b> in an expression <b>typeid(*p)</b>.
  (Again, a runtime type identification feature in Chapter 8).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0111" title="Add Comment A0111">Comment</a></sup></p>

<sup><span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span></sup>

<p class=MsoNormal>&nbsp;</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse'>
 <thead>
  <tr>
   <td width=427 colspan=2 valign=top style='width:4.45in;border:none;
   border-bottom:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0><a>Exception </a><span class=MsoCommentReference><span
   style='font-size:8.0pt;font-family:Times'><a class=msocomanchor
   id="_anchor_4" onmouseover="msoCommentShow('_anchor_4','_com_4')"
   onmouseout="msoCommentHide('_com_4')" href="#_msocom_4" language=JavaScript
   name="_msoanchor_4">[DwH4]</a><span style='display:none'>&nbsp;</span></span></span>classes
   derived from runtime_error</p>
   </td>
  </tr>
 </thead>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>range_error</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports violation of a postcondition.</p>
  </td>
 </tr>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>overflow_error</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports an arithmetic overflow.</p>
  </td>
 </tr>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>bad_alloc</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Reports a failure to allocate storage.</p>
  </td>
 </tr>
</table>

<h2 style='margin-left:0in'><a name="_Toc45439968"></a><a name="_Toc312374116">Exception
specification</a>s</h2>

<p class=MsoNormal>You’re not required to inform the people using your function
what exceptions you might throw. Failure to do so can be considered
uncivilized, however, because it means that users cannot be sure what code to
write to catch all potential exceptions. Of course, if they have your source
code, they can hunt through and look for <b>throw</b> statements, but often a
library doesn’t come with sources. Good documentation can help alleviate this
problem, but how many software projects are well documented? C++ provides
syntax that allows you to tell the user what exceptions this function throws,
so the user can handle them. This is the optional <i>exception specification</i>,
which adorns a function’s declaration, appearing after the argument list. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0112"
title="Add Comment A0112">Comment</a></sup></p>

<p class=MsoNormal>The exception specification reuses the keyword <b>throw</b>,
followed by a parenthesized list of all the types of potential exceptions that
the function can throw. Your function declaration might look like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0113"
title="Add Comment A0113">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f() throw(toobig,
toosmall, divzero);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As far as exceptions are concerned, the traditional function
declaration</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>means that <i>any</i> type of exception can be thrown from
the function. If you say</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f() throw();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><i>no exceptions whatsoever</i> will be thrown from the
function (so you’d better be sure that no functions farther down in the call
chain let any exceptions propagate up!).<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0116"
title="Add Comment A0116">Comment</a></sup></p>

<p class=MsoNormal>For good coding policy, good documentation, and ease-of-use
for the function caller, always consider using exception specifications when
you write functions that throw exceptions. (Exceptions to this guideline are
discussed later in this chapter.)<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0117"
title="Add Comment A0117">Comment</a></sup></p>

<h4><span style='font-weight:normal'>The </span>unexpected(&nbsp;)<span
style='font-weight:normal'> function</span></h4>

<p class=MsoNormal>If your exception specification claims you’re going to throw
a certain set of exceptions and then you throw something that isn’t in that
set, what’s the penalty? The special function <b>unexpected(&nbsp;)</b> is
called when you throw something other than what appears in the exception
specification. Should this unfortunate situation occur, the default implementation
of <b>unexpected</b> calls the <b>terminate( )</b> function mentioned earlier
in this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0118"
title="Add Comment A0118">Comment</a></sup></p>

<h4><span style='font-weight:normal'>The </span>set_unexpected(&nbsp;)<span
style='font-weight:normal'> function</span></h4>

<p class=MsoNormal>Like <b>terminate( )</b>, the <b>unexpected( )</b> mechanism
allows you to install your own function to respond to unexpected exceptions.
You do so with a function called <b>set_unexpected(&nbsp;),</b> which, like <b>set_terminate(&nbsp;)</b>, takes the address of a function with no
arguments and <b>void</b> return value. Also, because it returns the previous
value of the <b>unexpected(&nbsp;)</b> pointer, you can save it and restore it
later. To use <b>set_unexpected(&nbsp;)</b>, you must include the header file <b>&lt;exception&gt;</b>.
Here’s an example that shows a simple use of the features discussed so far in
this section: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0119"
title="Add Comment A0119">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:Unexpected.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Exception specifications &amp;
unexpected()</p>

<p class=CodeChar style='margin-left:0in'>//{-msc} Doesn’t terminate properly</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;exception&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Up {};</p>

<p class=CodeChar style='margin-left:0in'>class Fit {};</p>

<p class=CodeChar style='margin-left:0in'>void g();</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f(int i) throw (Up, Fit) {</p>

<p class=CodeChar style='margin-left:0in'>  switch(i) {</p>

<p class=CodeChar style='margin-left:0in'>    case 1: throw Up();</p>

<p class=CodeChar style='margin-left:0in'>    case 2: throw Fit();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  g();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// void g() {} // Version 1</p>

<p class=CodeChar style='margin-left:0in'>void g() { throw 47; } // Version 2</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void my_unexpected() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;unexpected
exception thrown&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  exit(0);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  set_unexpected(my_unexpected);</p>

<p class=CodeChar style='margin-left:0in'>  // (ignores return value)</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 1; i &lt;=3; i++)</p>

<p class=CodeChar style='margin-left:0in'>    try {</p>

<p class=CodeChar style='margin-left:0in'>      f(i);</p>

<p class=CodeChar style='margin-left:0in'>    } catch(Up) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Up
caught&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    } catch(Fit) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Fit
caught&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The classes <b>Up</b> and <b>Fit</b> are created solely to
throw as exceptions. Often exception classes will be small, but they can
certainly hold additional information so that the handlers can query for it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0120"
title="Add Comment A0120">Comment</a></sup></p>

<p class=MsoNormal>The<b> f(&nbsp;)</b> function promises in its exception
specification to throw only exceptions of type <b>Up</b> and <b>Fit</b>, and
from looking at the function definition, this seems plausible. Version one of <b>g(&nbsp;)</b>,
called by <b>f(&nbsp;)</b>, doesn’t throw any exceptions, so this is true. But
if someone changes <b>g(&nbsp;)</b> so that it throws a different type of
exception (like the second version in this example, which throws an <b>int</b>),
the exception specification for <b>f( )</b> is violated. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0121"
title="Add Comment A0121">Comment</a></sup></p>

<p class=MsoNormal>The <b>my_unexpected(&nbsp;)</b> function has no arguments
or return value, following the proper form for a custom <b>unexpected(&nbsp;)</b>
function. It simply displays a message so that you can see that it has been
called and then exits the program (<b>exit(0)</b> is used here so that the
book’s <b>make</b> process is not aborted). Your new <b>unexpected(&nbsp;)</b>
function should not have a <b>return</b> statement.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0122"
title="Add Comment A0122">Comment</a></sup></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, the <b>try</b> block is within a <b>for</b>
loop, so all the possibilities are exercised. In this way, you can achieve
something like resumption. Nest the <b>try</b> block inside a <b>for</b>, <b>while</b>,
<b>do</b>, or <b>if</b> and cause any exceptions to attempt to repair the
problem; then attempt the <b>try</b> block again. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0124"
title="Add Comment A0124">Comment</a></sup></p>

<p class=MsoNormal>Only the <b>Up</b> and <b>Fit</b> exceptions are caught
because those are the only exceptions that the programmer of <b>f(&nbsp;)</b>
said would be thrown. Version two of <b>g(&nbsp;)</b> causes <b>my_unexpected(&nbsp;)</b>
to be called because <b>f(&nbsp;)</b> then throws an <b>int</b>.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0125"
title="Add Comment A0125">Comment</a></sup></p>

<p class=MsoNormal>In the call to <b>set_unexpected(&nbsp;)</b>, the return
value is ignored, but it can also be saved in a pointer to function and be
restored later, as we did in the <b>set_terminate( )</b> example earlier in
this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0126"
title="Add Comment A0126">Comment</a></sup></p>

<p class=MsoNormal>A typical <b>unexpected</b> handler logs the error and
terminates the program by calling <b>exit( )</b>. It can, however, throw
another exception (or re-throw the same exception) or call <b>abort(&nbsp;)</b>.
If it throws an exception of a type allowed by the function whose specification
was originally violated, the search resumes at the <i>call</i> of the function
with this exception specification. (This behavior is unique to <b>unexpected(&nbsp;)</b>.)</p>

<p class=MsoNormal>If the exception thrown from your <b>unexpected</b> handler
is not allowed by the original function’s specification, one of the following
occurs:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>If
<b>std::bad_exception</b> (defined in <b>&lt;exception&gt;</b>) was in the
function’s exception specification, the exception thrown from the unexpected
handler is replaced with a <b>std::bad_exception</b> object, and the search
resumes from the function as before.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>If
the original function’s specification did not include <b>std::bad_exception</b>,
<b>terminate( )</b> is called.</p>

<p class=MsoNormal>The following program illustrates this behavior. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1503"
title="Add Comment A1503">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:BadException.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;exception&gt;    // for
std::bad_exception</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Exception classes:</p>

<p class=CodeChar style='margin-left:0in'>class A {};</p>

<p class=CodeChar style='margin-left:0in'>class B {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// terminate() handler</p>

<p class=CodeChar style='margin-left:0in'>void my_thandler() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;terminate
called\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  exit(0);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// unexpected() handlers</p>

<p class=CodeChar style='margin-left:0in'>void my_uhandler1() {</p>

<p class=CodeChar style='margin-left:0in'>  throw A();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void my_uhandler2() {</p>

<p class=CodeChar style='margin-left:0in'>  throw;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// If we embed this throw statement
in f or g,</p>

<p class=CodeChar style='margin-left:0in'>// the compiler detects the violation
and reports</p>

<p class=CodeChar style='margin-left:0in'>// an error, so we put it in its own
function.</p>

<p class=CodeChar style='margin-left:0in'>void t() {</p>

<p class=CodeChar style='margin-left:0in'>  throw B();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f() throw(A) {</p>

<p class=CodeChar style='margin-left:0in'>  t();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void g() throw(A, bad_exception) {</p>

<p class=CodeChar style='margin-left:0in'>  t();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  set_terminate(my_thandler);</p>

<p class=CodeChar style='margin-left:0in'>  set_unexpected(my_uhandler1);</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    f();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (A&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught an A
from f\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  set_unexpected(my_uhandler2);</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    g();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (bad_exception&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;caught a
bad_exception from g\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    f();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (...) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;This will
never print\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar><a name="_Toc312374117">&nbsp;</a></p>

<p class=MsoNormal>The<b> my_uhandler1( )</b> handler throws an acceptable
exception (<b>A</b>), so execution resumes at the first catch, which succeeds.
The <b>my_uhandler2( )</b> handler does not throw a valid exception (<b>B</b>),
but since <b>g</b> specifies <b>bad_exception</b>, the <b>B</b> exception is
replaced by a <b>bad_exception</b> object, and the second catch also succeeds.
Since <b>f</b> does not include <b>bad_exception</b> in its specification, <b>my_thandler(
)</b> is called as a terminate handler. Thus, the output from this program is
as follows: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1506"
title="Add Comment A1506"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>caught an A from f</p>

<p class=CodeChar style='margin-left:0in'>caught a bad_exception from g</p>

<p class=CodeChar style='margin-left:0in'>terminate called</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<h3><a name="_Toc45439969">Better exception specifications?</a></h3>

<p class=MsoNormal>You may feel that the existing exception specification rules
aren’t very safe, and that</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><i>should</i> mean that no exceptions are thrown from this
function. If the programmer wants to throw any type of exception, you might
think he or she <i>should </i>have to say <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1505"
title="Add Comment A1505">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f() throw(...); // Not
in C++</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This would surely be an improvement because function
declarations would be more explicit. Unfortunately, you can’t always know by
looking at the code in a function whether an exception will be thrown—it could
happen because of a memory allocation, for example. Worse, existing functions
written before exception handling was introduced may find themselves
inadvertently throwing exceptions because of the functions they call (which
might be linked into new, exception-throwing versions). Hence, the
uninformative situation whereby <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1504"
title="Add Comment A1504">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>means, “Maybe I’ll throw an exception, maybe I won’t.” This
ambiguity is necessary to avoid hindering code evolution. If you want to
specify that <b>f</b> throws no exceptions, you must use the empty list, as in:
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0130"
title="Add Comment A0130">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>void f() throw();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc312374126"></a><a name="_Toc305628775"></a><a
name="_Toc305593303"></a><a name="_Toc45439970">Exception specifications and
inheritance</a></h3>

<p class=MsoNormal>Each public function in a class essentially forms a contract
with the user; if you pass it certain arguments, it will perform certain operations
and/or return a result. The same contract must hold true in derived classes;
otherwise the expected “is-a” relationship between derived and base classes is
violated. Since exception specifications are logically part of a function’s
declaration, they too must remain consistent across an inheritance hierarchy.
For example, if a member function in a base class says it will only throw an
exception of type <b>A</b>, an override of that function in a derived class
must not add any other exception types to the specification list, because that
would result in unexpected exceptions for the user, breaking any programs that
adhere to the base class interface. You can, however, specify <i>fewer</i>
exceptions or <i>none at all</i>, since that doesn’t require the user to do
anything differently. You can also specify anything that “is-a” <b>A</b> in
place of <b>A</b> in the derived function’s specification. Here’s an example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1507"
title="Add Comment A1507"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// C01:Covariance.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Compile Only!</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Base {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class BaseException {};</p>

<p class=CodeChar style='margin-left:0in'>  class DerivedException : public
BaseException {};</p>

<p class=CodeChar style='margin-left:0in'>  virtual void f() throw
(DerivedException) {</p>

<p class=CodeChar style='margin-left:0in'>    throw DerivedException();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void g() throw
(BaseException) {</p>

<p class=CodeChar style='margin-left:0in'>    throw BaseException();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Derived : public Base {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() throw (BaseException) {</p>

<p class=CodeChar style='margin-left:0in'>    throw BaseException();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void g() throw
(DerivedException) {</p>

<p class=CodeChar style='margin-left:0in'>    throw DerivedException();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A compiler should flag the override of <b>Derived::f( )</b>
with an error (or at least a warning) since it changes its exception
specification in a way that violates the specification of <b>Base::f( )</b>.
The specification for <b>Derived::g( )</b> is acceptable because <b>DerivedException</b>
“is-a” <b>BaseException</b> (not the other way around). You can think of <b>Base/Derived</b>
and <b>BaseException/DerivedException</b> as parallel class hierarchies; when
you are in <b>Derived</b>, you can replace references to <b>BaseException</b>
in exception specifications and return values with <b>DerivedException</b>.
This behavior is called <i>covariance</i> (since both sets of classes vary down
their respective hierarchies together). (Reminder from Volume 1: parameter
types are <i>not</i> covariant—you are not allowed to change the signature of
an overridden virtual function.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1508"
title="Add Comment A1508"><sup>Comment</sup></a></p>

<h3><a name="_Toc45439971">When <i>not</i> to use exception specifications</a></h3>

<p class=MsoNormal>If you peruse the function declarations throughout the
Standard C++ library, you’ll find that not a single exception specification
occurs anywhere! Although this might seem strange, there is a good reason for
this seeming incongruity: the library consists mainly of templates, and you
never know what a generic might do. For example, suppose you are developing a
generic stack template and attempt to affix an exception specification to your
pop function, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>T pop() throw(logic_error);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since the only error you anticipate is a stack underflow,
you might think it’s safe to specify a <b>logic_error</b> or some other
appropriate exception type. But since you don’t know much about the type <b>T</b>,
what if its copy constructor could possibly throw an exception (it’s not
unreasonable, after all)? Then <b>unexpected(&nbsp;)</b> would be called, and
your program would terminate. The point is that you shouldn’t make guarantees
that you can’t stand behind. If you don’t know what exceptions might occur,
don’t use exception specifications. That’s why template classes, which
constitute 90 percent of the Standard C++ library, do not use exception
specifications—they specify the exceptions they know about in <i>documentation</i>
and leave the rest to you. Exception specifications are mainly for non-template
classes. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1509"
title="Add Comment A1509"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45439972">Exception safety</a></h2>

<p class=MsoNormal>Speaking of popping a stack, in Chapter 7 we’ll take an
in-depth look at the containers in the Standard C++ library, including the
stack container. One thing you’ll notice is that the declaration of the <b>pop(
)</b> member function looks like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>void pop();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You might think it strange that <b>pop( )</b> doesn’t return
a value. Instead, it just removes the element at the top of the stack. To
retrieve the top value, you must call <b>top( )</b> before you call <b>pop( )</b>.
There is an important reason for this behavior, and it has to do with <i>exception
safety</i>, a crucial consideration in library design. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1510"
title="Add Comment A1510"><sup>Comment</sup></a></p>

<p class=MsoNormal>Suppose you are implementing a stack with a dynamic array
(we’ll call it <b>data</b> and the counter integer <b>count</b>), and you try
to write <b>pop( )</b> so that it returns a value. The code for such a <b>pop(
)</b> might look something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>T stack&lt;T&gt;::pop() {</p>

<p class=CodeChar style='margin-left:0in'>  if (count == 0)</p>

<p class=CodeChar style='margin-left:0in'>    throw logic_error(&quot;stack
underflow&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>    return data[--count];</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>What happens if the copy constructor that is called for the
return value in the last line throws an exception when the value is returned?
The popped element is not returned because of the exception, and yet <b>count</b>
has already been decremented, so the top element you wanted has been lost
forever! The problem is that this function attempts to do two things at once:
(1) return a value, and (2) change the state of the stack. It is better to
separate these two actions into two separate member functions, which is exactly
what the standard <b>stack</b> class does. (In other words, follow the
time-worn design practice of <i>cohesion</i>—every function should do <i>one
thing well</i>.) Exception-safe code leaves objects in a consistent state and
does not leak resources. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1511"
title="Add Comment A1511"><sup>Comment</sup></a></p>

<p class=MsoNormal>You also need to be careful writing custom assignment
operators. In Chapter 12 of Volume 1, you saw that <b>operator=</b> should
adhere to the following pattern:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Make
sure you’re not assigning to self. If you are, go to step 6. (This is strictly
an optimization.)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Allocate
new memory required by pointer data members.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Copy
data from the old memory to the new.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Delete
the old memory.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Update
the object’s state by assigning the new heap pointers to the pointer data
members.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Return
<b>*this</b>.</p>

<p class=MsoNormal>It’s important to not change the state of your object until
all the new pieces have been safely allocated and initialized. A good technique
is to move all of steps 2 and 3 into a separate function, often called <b>clone(&nbsp;)</b>.
The following example does this for a class that has two pointer members, <b>theString</b>
and <b>theInts</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1512"
title="Add Comment A1512"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C01:SafeAssign.cpp</p>

<p class=CodeChar style='margin-left:0in'>//  Shows an Exception-safe operator=</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;new&gt;       // For
std::bad_alloc</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A class that has two pointer
members using the heap</p>

<p class=CodeChar style='margin-left:0in'>class HasPointers {</p>

<p class=CodeChar style='margin-left:0in'>  // A Handle class to hold the data</p>

<p class=CodeChar style='margin-left:0in'>  struct MyData {</p>

<p class=CodeChar style='margin-left:0in'>    const char* theString;</p>

<p class=CodeChar style='margin-left:0in'>    const int* theInts;</p>

<p class=CodeChar style='margin-left:0in'>    size_t numInts;</p>

<p class=CodeChar style='margin-left:0in'>    MyData(const char* pString, const
int* pInts,</p>

<p class=CodeChar style='margin-left:0in'>           size_t nInts)</p>

<p class=CodeChar style='margin-left:0in'>    : theString(pString),
theInts(pInts),  </p>

<p class=CodeChar style='margin-left:0in'>    numInts(nInts) {}</p>

<p class=CodeChar style='margin-left:0in'>  } *theData;  // The handle</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // clone and cleanup functions</p>

<p class=CodeChar style='margin-left:0in'>  static MyData* clone(const char*
otherString,</p>

<p class=CodeChar style='margin-left:0in'>                       const int*
otherInts, size_t nInts){</p>

<p class=CodeChar style='margin-left:0in'>    char* newChars = new
char[strlen(otherString)+1];</p>

<p class=CodeChar style='margin-left:0in'>    int* newInts;</p>

<p class=CodeChar style='margin-left:0in'>    try {</p>

<p class=CodeChar style='margin-left:0in'>      newInts = new int[nInts];</p>

<p class=CodeChar style='margin-left:0in'>    } catch (bad_alloc&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>      delete [] newChars;</p>

<p class=CodeChar style='margin-left:0in'>      throw;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    try {</p>

<p class=CodeChar style='margin-left:0in'>      // This example uses built-in
types, so it won't</p>

<p class=CodeChar style='margin-left:0in'>      // throw, but for class types
it could throw, so we</p>

<p class=CodeChar style='margin-left:0in'>      // use a try block for
illustration. (This is the</p>

<p class=CodeChar style='margin-left:0in'>      // point of the example!)</p>

<p class=CodeChar style='margin-left:0in'>      strcpy(newChars, otherString);</p>

<p class=CodeChar style='margin-left:0in'>      for (size_t i = 0; i &lt;
nInts; ++i)</p>

<p class=CodeChar style='margin-left:0in'>        newInts[i] = otherInts[i];</p>

<p class=CodeChar style='margin-left:0in'>    } catch (...) {</p>

<p class=CodeChar style='margin-left:0in'>      delete [] newInts;</p>

<p class=CodeChar style='margin-left:0in'>      delete [] newChars;</p>

<p class=CodeChar style='margin-left:0in'>      throw;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return new MyData(newChars,
newInts, nInts);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static MyData* clone(const MyData*
otherData) {</p>

<p class=CodeChar style='margin-left:0in'>    return
clone(otherData-&gt;theString,</p>

<p class=CodeChar style='margin-left:0in'>                 otherData-&gt;theInts,</p>

<p class=CodeChar style='margin-left:0in'>                
otherData-&gt;numInts);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static void cleanup(const MyData*
theData) {</p>

<p class=CodeChar style='margin-left:0in'>    delete [] theData-&gt;theString;</p>

<p class=CodeChar style='margin-left:0in'>    delete [] theData-&gt;theInts;</p>

<p class=CodeChar style='margin-left:0in'>    delete theData;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  HasPointers(const char* someString,
const int* someInts,</p>

<p class=CodeChar style='margin-left:0in'>              size_t numInts) {</p>

<p class=CodeChar style='margin-left:0in'>    theData = clone(someString,
someInts, numInts);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  HasPointers(const HasPointers&amp;
source) {</p>

<p class=CodeChar style='margin-left:0in'>    theData = clone(source.theData);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  HasPointers&amp; operator=(const
HasPointers&amp; rhs) {</p>

<p class=CodeChar style='margin-left:0in'>    if (this != &amp;rhs) {</p>

<p class=CodeChar style='margin-left:0in'>      MyData* newData =</p>

<p class=CodeChar style='margin-left:0in'>     
clone(rhs.theData-&gt;theString,</p>

<p class=CodeChar style='margin-left:0in'>            rhs.theData-&gt;theInts,</p>

<p class=CodeChar style='margin-left:0in'>            rhs.theData-&gt;numInts);</p>

<p class=CodeChar style='margin-left:0in'>      cleanup(theData);</p>

<p class=CodeChar style='margin-left:0in'>      theData = newData;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return *this;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~HasPointers() {</p>

<p class=CodeChar style='margin-left:0in'>    cleanup(theData);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os,</p>

<p class=CodeChar style='margin-left:0in'>                             const
HasPointers&amp; obj) {</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt;
obj.theData-&gt;theString &lt;&lt; &quot;: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t i = 0; i &lt;
obj.theData-&gt;numInts; ++i)</p>

<p class=CodeChar style='margin-left:0in'>      os &lt;&lt;
obj.theData-&gt;theInts[i] &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>    return os;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int someNums[] = {1, 2, 3, 4};</p>

<p class=CodeChar style='margin-left:0in'>  size_t someCount = sizeof someNums
/ sizeof someNums[0];</p>

<p class=CodeChar style='margin-left:0in'>  int someMoreNums[] = {5, 6, 7};</p>

<p class=CodeChar style='margin-left:0in'>  size_t someMoreCount =</p>

<p class=CodeChar style='margin-left:0in'>  sizeof someMoreNums / sizeof
someMoreNums[0];</p>

<p class=CodeChar style='margin-left:0in'>  HasPointers h1(&quot;Hello&quot;,
someNums, someCount);</p>

<p class=CodeChar style='margin-left:0in'>  HasPointers h2(&quot;Goodbye&quot;,
someMoreNums, someMoreCount);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; h1 &lt;&lt; endl;  //
Hello: 1 2 3 4</p>

<p class=CodeChar style='margin-left:0in'>  h1 = h2;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; h1 &lt;&lt; endl;  //
Goodbye: 5 6 7</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar><span class=CODE>&nbsp;</span></p>

<p class=MsoNormal>For convenience, <b>HasPointers</b> uses the <b>MyData</b>
class as a handle to the two pointers. Whenever it’s time to allocate more
memory, whether during construction or assignment, the first <b>clone</b>
function is ultimately called to do the job. If memory fails for the first call
to the <b>new</b> operator, a <b>bad_alloc</b> exception is thrown
automatically. If it happens on the second allocation (for <b>theInts</b>), we
have to clean up the memory for <b>theString</b>—hence the first <b>try</b>
block that catches a <b>bad_alloc</b> exception. The second <b>try</b> block
isn’t crucial here because we’re just copying <b>int</b>s and pointers (so no
exceptions will occur), but whenever you copy objects, their assignment
operators can possibly cause an exception, in which case everything needs to be
cleaned up. In both exception handlers, notice that we <i>rethrow</i> the
exception. That’s because we’re just managing resources here; the user still
needs to know that something went wrong, so we let the exception propagate up
the dynamic chain. Software libraries that don’t silently swallow exceptions
are called <i>exception neutral</i>. You should always strive to write libraries
that are both exception safe and exception neutral.<a href="#_ftn6"
name="_ftnref6" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[6]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1513"
title="Add Comment A1513"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you inspect the previous code closely, you’ll notice that
none of the <b>delete</b> operations will throw an exception. This code
actually depends on that fact. Recall that when you call <b>delete</b> on an
object, the object’s destructor is called. It turns out to be practically
impossible, therefore, to design exception-safe code without assuming that
destructors don’t throw exceptions. Don’t let destructors throw exceptions!
(We’re going to remind you about this once more before this chapter is done).<a
href="#_ftn7" name="_ftnref7" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[7]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1514"
title="Add Comment A1514"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45439973">Programming with exceptions</a></h2>

<p class=MsoNormal>For most programmers, especially C programmers, exceptions
are not available in their existing language and take a bit of adjustment. Here
are some guidelines for programming with exceptions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0131"
title="Add Comment A0131">Comment</a></sup></p>

<h3><a name="_Toc45439974"></a><a name="_Toc312374127">When to avoid exceptions</a></h3>

<p class=MsoNormal>Exceptions aren’t the answer to all problems. In fact, if
you simply go looking for something to pound with your new hammer, you’ll cause
trouble. The following sections point out situations in which exceptions are <i>not</i>
warranted. Probably the best advice for deciding when to use exceptions is to
throw exceptions only when a function fails to meet its specification. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0132"
title="Add Comment A0132">Comment</a></sup></p>

<h4>Not for asynchronous events</h4>

<p class=MsoNormal>The Standard C <b>signal(&nbsp;)</b><b> </b>system and any similar system handle asynchronous events: events that
happen outside the flow of a program, and thus events the program cannot
anticipate. You cannot use C++ exceptions to handle asynchronous events because
the exception and its handler are on the same call stack. That is, exceptions
rely on the dynamic chain of function calls on the program’s runtime stack
(dynamic scope, if you will), whereas asynchronous events must be handled by
completely separate code that is not part of the normal program flow
(typically, interrupt service routines or event loops). Don’t throw exceptions
from interrupt handlers. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0133"
title="Add Comment A0133">Comment</a></sup></p>

<p class=MsoNormal>This is not to say that asynchronous events cannot be <i>associated</i>
with exceptions. But the interrupt handler should do its job as quickly as
possible and then return. The typical way to handle this situation is to set a
flag in the interrupt handler, and check it synchronously in the mainline code.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0134"
title="Add Comment A0134">Comment</a></sup></p>

<h4>Not for benign error conditions</h4>

<p class=MsoNormal>If you have enough information to handle an error, it’s not
an exception. Take care of it in the current context rather than throwing an
exception to a larger context. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0135"
title="Add Comment A0135">Comment</a></sup></p>

<p class=MsoNormal>Also, C++ exceptions are not thrown for machine-level events
such as divide-by-zero<a href="#_ftn8" name="_ftnref8" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[8]</span></sup></span></span></sup></span></a>.
It’s assumed that some other mechanism, such as the operating system or
hardware, deals with these events. In this way, C++ exceptions can be
reasonably efficient, and their use is isolated to program-level exceptional
conditions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0136"
title="Add Comment A0136">Comment</a></sup></p>

<h4>Not for flow-of-control</h4>

<p class=MsoNormal>An exception looks somewhat like an alternate return
mechanism and somewhat like a <b>switch</b> statement, so you might be tempted
to use an exception instead of these ordinary language mechanisms. This is a
bad idea, partly because the exception-handling system is significantly less
efficient than normal program execution; exceptions are a rare event, so the
normal program shouldn’t pay for them. Also, exceptions from anything other
than error conditions are quite confusing to the user of your class or
function. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0137"
title="Add Comment A0137">Comment</a></sup></p>

<h4>You’re not forced to use exceptions</h4>

<p class=MsoNormal>Some programs are quite simple (small utilities, for
example). You might only need to take input and perform some processing. In
these programs, you might attempt to allocate memory and fail, try to open a
file and fail, and so on. It is acceptable in these programs to display a
message and exit the program, allowing the system to clean up the mess, rather
than to work hard to catch all exceptions and recover all the resources
yourself. Basically, if you don’t need to use exceptions, you don’t have to use
them. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0138"
title="Add Comment A0138">Comment</a></sup></p>

<h4>New exceptions, old code</h4>

<p class=MsoNormal>Another situation that arises is the modification of an
existing program that doesn’t use exceptions. You might introduce a library
that <i>does</i> use exceptions and wonder if you need to modify all your code
throughout the program. Assuming you have an acceptable error-handling scheme
already in place, the most straightforward thing to do is surround the largest
block that uses the new library (this might be all the code in <b>main(&nbsp;)</b>)<b>
</b>with a <b>try</b> block, followed by a <b>catch(...)</b> and basic error
message). You can refine this to whatever degree necessary by adding more
specific handlers, but, in any case, the code you’re forced to add can be
minimal. It’s even better, of course, to isolate your exception-generating code
in a <b>try</b> block and write handlers to convert the exceptions into your
existing error-handling scheme. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0140"
title="Add Comment A0140">Comment</a></sup></p>

<p class=MsoNormal>It’s truly important to think about exceptions when you’re
creating a library for someone else to use, especially in situations in which
you can’t know how they need to respond to critical error conditions (recall
the earlier discussions on exception safety and why there are no exception
specifications in the Standard C++ Library). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0141"
title="Add Comment A0141">Comment</a></sup></p>

<h3><a name="_Toc45439975"></a><a name="_Toc312374128">Typical uses of
exceptions</a></h3>

<p class=MsoNormal>Do use exceptions to do the following: </p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Fix the problem and call the function which caused the exception
again.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Patch things up and continue without retrying the function.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Do whatever you can in the current context and rethrow the <i>same</i>
exception to a higher context.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Do whatever you can in the current context and throw a <i>different</i>
exception to a higher context.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Terminate the program.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Wrap functions (especially C library functions) that use ordinary
error schemes so they produce exceptions instead.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Simplify. If your exception scheme makes things more complicated,
it is painful and annoying to use.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make your library and program safer. This is a short-term
investment (for debugging) and a long-term investment (for application
robustness). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1552"
title="Add Comment A1552">Comment</a></sup></p>

<h4>When to use exception specifications</h4>

<p class=MsoNormal>The exception specification is like a function prototype: it
tells the user to write exception-handling code and what exceptions to handle.
It tells the compiler the exceptions that might come out of this function so
that it can detect violations at runtime. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0143"
title="Add Comment A0143">Comment</a></sup></p>

<p class=MsoNormal>Of course, you can’t always look at the code and anticipate
which exceptions will arise from a particular function. Sometimes, the
functions it calls produce an unexpected exception, and sometimes an old
function that didn’t throw an exception is replaced with a new one that does,
and you get a call to <b>unexpected(&nbsp;)</b>. Any time you use exception
specifications or call functions that do, consider creating your own <b>unexpected(&nbsp;)</b>
function that logs a message and then either throws an exception or aborts the
program. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0144"
title="Add Comment A0144">Comment</a></sup></p>

<p class=MsoNormal>As we explained earlier, you should avoid using exception
specifications in template classes, since you can’t anticipate what types of
exceptions the template parameter classes might throw. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1518"
title="Add Comment A1518">Comment</a></sup></p>

<h4>Start with standard exceptions</h4>

<p class=MsoNormal>Check out the Standard C++ library exceptions before
creating your own. If a standard exception does what you need, chances are it’s
a lot easier for your user to understand and handle. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0145"
title="Add Comment A0145">Comment</a></sup></p>

<p class=MsoNormal>If the exception type you want isn’t part of the standard
library, try to derive one from an existing standard exception. It’s nice if
your users can always write their code to expect the <b>what(&nbsp;) </b>function
defined in the <b>exception(&nbsp;)</b> class interface. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0146"
title="Add Comment A0146">Comment</a></sup></p>

<h4>Nest your own exceptions</h4>

<p class=MsoNormal>If you create exceptions for your particular class, it’s a
good idea to nest the exception classes either inside your class or inside a
namespace containing your class, to provide a clear message to the reader that
this exception is used only for your class. In addition, it prevents the
pollution of the global namespace. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0147"
title="Add Comment A0147">Comment</a></sup></p>

<p class=MsoNormal>You can nest your exceptions even if you’re deriving them
from C++ standard exceptions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0148"
title="Add Comment A0148">Comment</a></sup></p>

<h4>Use exception hierarchies</h4>

<p class=MsoNormal>Using exception hierarchies is a valuable way to classify the types of critical errors that might be encountered with your class or
library. This gives helpful information to users, assists them in organizing
their code, and gives them the option of ignoring all the specific types of
exceptions and just catching the base-class type. Also, any exceptions added
later by inheriting from the same base class will not force all existing code
to be rewritten—the base-class handler will catch the new exception. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0149"
title="Add Comment A0149">Comment</a></sup></p>

<p class=MsoNormal>Of course, the Standard C++ exceptions are a good example of
an exception hierarchy and one on which you can build. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0150"
title="Add Comment A0150">Comment</a></sup></p>

<h4>Multiple inheritance (MI)</h4>

<p class=MsoNormal>As you’ll read in Chapter 9, the only <i>essential </i>place
for MI is if you need to upcast an object pointer to two different base
classes—that is, if you need polymorphic behavior with both of those base
classes. It turns out that exception hierarchies are useful places for multiple
inheritance because a base-class handler from any of the roots of the multiply inherited exception class can handle the exception. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0151"
title="Add Comment A0151">Comment</a></sup></p>

<h4>Catch by reference, not by value</h4>

<p class=MsoNormal>We explained in the section “Exception matching” earlier
that you should catch exceptions by reference for two reasons:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>To avoid making a needless copy of the exception object when it
is passed to the handler,</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>To avoid object slicing when catching a derived exception as a
base class object</p>

<p class=MsoNormal>Although you can also throw and catch pointers, by doing so you introduce more coupling—the thrower and the catcher must agree on
how the exception object is allocated and cleaned up. This is a problem because
the exception itself might have occurred from heap exhaustion. If you throw
exception objects, the exception-handling system takes care of all storage. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0155"
title="Add Comment A0155">Comment</a></sup></p>

<h4>Throw exceptions in constructors</h4>

<p class=MsoNormal>Because a constructor has no return value, you’ve previously had two ways to report an error during construction: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0156"
title="Add Comment A0156">Comment</a></sup></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Set a nonlocal flag and hope the user checks it.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Return an incompletely created object and hope the user checks
it.</p>

<p class=MsoNormal>This problem is serious because C programmers have come to
rely on an implied guarantee that object creation is always successful, which
is not unreasonable in C in which types are so primitive. But continuing
execution after construction fails in a C++ program is a guaranteed disaster,
so constructors are one of the most important places to throw exceptions—now
you have a safe, effective way to handle constructor errors. However, you must
also pay attention to pointers inside objects and the way cleanup occurs when
an exception is thrown inside a constructor. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0157"
title="Add Comment A0157">Comment</a></sup></p>

<h4>Don’t cause exceptions in destructors</h4>

<p class=MsoNormal>Because destructors are called in the process of throwing other exceptions, you’ll never want to throw an exception in a destructor or
cause another exception to be thrown by some action you perform in the destructor.
If this happens, a new exception can be thrown <i>before</i> the catch-clause
for an existing exception is reached, which will cause a call to <b>terminate(&nbsp;)</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0158"
title="Add Comment A0158">Comment</a></sup></p>

<p class=MsoNormal>If you call any functions inside a destructor that can throw
exceptions, those calls should be within a <b>try</b> block in the destructor,
and the destructor must handle all exceptions itself. None must escape from the
destructor. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0159"
title="Add Comment A0159">Comment</a></sup></p>

<h4>Avoid naked pointers</h4>

<p class=MsoNormal>See <b>Wrapped.cpp</b> earlier in this chapter. A naked
pointer usually means vulnerability in the constructor if resources are
allocated for that pointer. A pointer doesn’t have a destructor, so those
resources aren’t released if an exception is thrown in the constructor. Use <b>auto_ptr</b>
for pointers that reference heap memory. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0160"
title="Add Comment A0160">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439976"></a><a name="_Toc312374129"></a><a
name="_Toc305628776"></a><a name="_Toc305593304">Overhead</a></h2>

<p class=MsoNormal>When an exception is thrown, there’s considerable runtime
overhead (but it’s <i>good overhead</i>, since objects are cleaned up
automatically!). For this reason, you never want to use exceptions as part of
your normal flow-of-control, no matter how tempting and clever it may seem.
Exceptions should occur only rarely, so the overhead is piled on the exception
and not on the normally executing code. One of the important design goals for
exception handling was that it could be implemented with no impact on execution
speed when it <i>wasn’t</i> used; that is, as long as you don’t throw an
exception, your code runs as fast as it would without exception handling.
Whether this is actually true depends on the particular compiler implementation
you’re using. (See the description of the “zero-cost model” later in this
section.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0161"
title="Add Comment A0161">Comment</a></sup></p>

<p class=MsoNormal>You can think of a <b>throw</b> expression as a call to a
special system function that takes the exception object as an argument and
backtracks up the chain of execution. For this to work, extra information needs
to be put on the stack by the compiler, to aid in stack unwinding. To
understand this, you need to know about the runtime stack. Whenever a function
is called, information about that function is pushed onto the runtime stack in
an <i>activation record instance</i> (ARI), also called a <i>stack frame</i>. A
typical stack frame contains the address of the calling function (so execution
can return to it), a pointer to the ARI of the function’s static parent (the
scope that lexically contains the called function, so variables global to the
function can be accessed), and a pointer to the function that called it (its <i>dynamic
parent</i>). The path that logically results from repetitively following the
dynamic parent links is the <i>dynamic chain</i>, or <i>call chain</i>, that
we’ve mentioned previously in this chapter.  This is how execution can
backtrack when an exception is thrown, and it is the mechanism that makes it
possible for components developed without knowledge of one another to
communicate errors at runtime. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0162"
title="Add Comment A0162">Comment</a></sup></p>

<p class=MsoNormal>To enable stack unwinding for exception handling, extra
exception-related information about each function needs to be available for
each stack frame. This information describes which destructors need to be
called (so that local objects can be cleaned up), indicates whether the current
function has a <b>try</b> block, and lists which exceptions the associated
catch clauses can handle. Naturally there is space penalty for this extra
information, so programs that support exception handling can be somewhat larger
than those that don’t<a href="#_ftn9" name="_ftnref9" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[9]</span></sup></span></span></sup></span></a>.
Even the compile-time size of programs using exception handling is greater,
since the logic of how to generate the expanded stack frames during runtime
must be generated by the compiler. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1515"
title="Add Comment A1515">Comment</a></sup></p>

<p class=MsoNormal>To illustrate this, we compiled the following program both
with and without exception-handling support in Borland C++ Builder and
Microsoft Visual C++.<a href="#_ftn10" name="_ftnref10" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[10]</span></sup></span></span></sup></span></a> </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>struct HasDestructor {</p>

<p class=CodeChar style='margin-left:0in'>  ~HasDestructor(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void g();      // for all we know, g
may throw</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f() {</p>

<p class=CodeChar style='margin-left:0in'>   HasDestructor h;</p>

<p class=CodeChar style='margin-left:0in'>   g();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If exception handling is enabled, the compiler must keep
information about <b>~HasDestructor( )</b> available at runtime in the ARI for <b>f(
)</b> (so it can destroy <b>h</b> properly should <b>g( )</b> throw an
exception). The following table summarizes the result of the compilations in
terms of the size of the compiled (.obj) files (in bytes). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1553"
title="Add Comment A1553">Comment</a></sup></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:23.4pt;border-collapse:collapse'>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>Compiler\Mode</span></p>
  </td>
  <td width=144 valign=top style='width:1.5in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>With Exception Support</span></p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>Without Exception
  Support</span></p>
  </td>
 </tr>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Borland</p>
  </td>
  <td width=144 valign=top style='width:1.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>616</p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>234</p>
  </td>
 </tr>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Microsoft</p>
  </td>
  <td width=144 valign=top style='width:1.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>1162</p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>680</p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Don’t take the percentage differences between the two modes
too seriously. Remember that exceptions (should) typically constitute a small
part of a program, so the space overhead tends to be much smaller (usually
between 5 and 15 percent).<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1517"
title="Add Comment A1517">Comment</a></sup></p>

<p class=MsoNormal>You might think that this extra housekeeping would slow down
execution, and you’d be correct. A clever compiler implementation can avoid
that cost, however. Since information about exception-handling code and the
offsets of local objects can be computed once at compile time, such information
can be kept in a single place associated with each function, but not in each
ARI. You essentially remove exception overhead from each ARI and, therefore,
avoid the extra time to push them onto the stack. This approach is called the <i>zero-cost</i>
model<a href="#_ftn11" name="_ftnref11" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[11]</span></sup></span></span></sup></span></a> of
exception handling, and the optimized storage mentioned earlier is known as the
<i>shadow stack</i>.<a href="#_ftn12" name="_ftnref12" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[12]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1516"
title="Add Comment A1516">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439977"></a><a name="_Toc312374130"></a><a
name="_Toc305628777"></a><a name="_Toc305593305">Summary</a></h2>

<p class=MsoNormal>Error recovery is a fundamental concern for every program
you write, and it’s especially important in C++, in which one of the goals is
to create program components for others to use. To create a robust system, each
component must be robust. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0164"
title="Add Comment A0164">Comment</a></sup></p>

<p class=MsoNormal>The goals for exception handling in C++ are to simplify the
creation of large, reliable programs using less code than currently possible,
with more confidence that your application doesn’t have an unhandled error.
This is accomplished with little or no performance penalty and with low impact
on existing code. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0165"
title="Add Comment A0165">Comment</a></sup></p>

<p class=MsoNormal>Basic exceptions are not terribly difficult to learn, and
you should begin using them in your programs as soon as you can. Exceptions are
one of those features that provide immediate and significant benefits to your
project. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0166"
title="Add Comment A0166">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439978"></a><a name="_Toc312374131">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a class with member functions that throw exceptions.
Within this class, make a nested class to use as an exception object. It takes
a single <b>char*</b> as its argument; this represents a description string.
Create a member function that throws this exception. (State this in the
function’s exception specification.) Write a <b>try</b> block that calls this
function and a <b>catch</b> clause that handles the exception by displaying its
description string.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Rewrite the Stash class from Chapter 13 of Volume 1 so that it
throws <b>out_of_range</b> exceptions for <b>operator[]</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a generic <b>main(&nbsp;)</b> that takes all exceptions and
reports them as errors.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a class with its own <b>operator new</b>. This operator
should allocate ten objects, and on the eleventh object “run out of memory” and
throw an exception. Also add a <b>static</b> member function that reclaims this
memory. Now create a <b>main(&nbsp;)</b> with a <b>try</b> block and a <b>catch</b>
clause that calls the memory-restoration routine. Put these inside a <b>while</b>
loop, to demonstrate recovering from an exception and continuing execution.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a destructor that throws an exception, and write code to
prove to yourself that this is a bad idea by showing that if a new exception is
thrown before the handler for the existing one is reached, <b>terminate(&nbsp;)</b>
is called.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Prove to yourself that all exception objects (the ones that are
thrown) are properly destroyed.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Prove to yourself that if you create an exception object on the
heap and throw the pointer to that object, it will not be cleaned up.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>8. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a function with an exception specification that can throw
four exception types: a <b>char</b>, an <b>int</b>, a <b>bool</b>, and your own
exception class. Catch each in <b>main(&nbsp;)</b> and verify the catch. Derive
your exception class from a standard exception. Write the function in such a
way that the system recovers and tries to execute it again.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>9. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify your solution to the exercise 8 to throw a double from the
function, violating the exception specification. Catch the violation with your
own unexpected handler that displays a message and exits the program gracefully
(meaning <b>abort( )</b> is not called).</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>10. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a <b>Garage</b> class that has a <b>Car</b> that is having
troubles with its <b>Motor</b>. Use a function-level <b>try</b> block in the <b>Garage</b>
class constructor to catch an exception (thrown from the <b>Motor</b> class)
when its <b>Car</b> object is initialized. Throw a different exception from the
body of the <b>Garage</b> constructor’s handler and catch it in <b>main(&nbsp;)</b>.</p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section8>

<h1 style='margin-left:-81.35pt'><a name="_Toc45439979">2: Defensive
programming</a></h1>

<p class=Intro>Writing “perfect software” may be an elusive Holy Grail for
developers, but a few defensive techniques, routinely applied, can go a long
way toward narrowing the gap between code and ideal.</p>

<p class=MsoNormal>Although the complexity of typical production software
guarantees that testers will always have a job, chances are you still yearn to
produce defect-free software. (At least we hope you do!) Object-oriented design
techniques do much to corral the difficulty of large projects, to be sure.
Eventually, however, you have to get down to writing loops and functions. These
details of “programming in the small” become the building blocks of the
implementation of larger components called for by your design efforts. If your
loops are off by one or your functions calculate the correct values only “most”
of the time, you’re in deep trouble no matter how fancy your overall
methodology. In this chapter, we’re interested in coding practices that keep
you on track toward a working solution regardless of the size of your project. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1525"
title="Add Comment A1525">Comment</a></sup></p>

<p class=MsoNormal>Your code is, among other things, an expression of your
attempt to solve a problem. It should be clear to the reader (including yourself)
exactly what you were thinking when you designed that loop. At certain points
in your program, you should be able to make bold statements that some condition
or other holds. (If you can’t, you really haven’t yet solved the problem.) Such
statements are called <i>invariants</i>, since they should invariably be true
at the point where they appear in the code; if not, either your design is
faulty, or your code does not accurately reflect your design. (In other words,
you’ve got bugs!) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1526"
title="Add Comment A1526">Comment</a></sup></p>

<p class=MsoNormal>To illustrate, consider how to write a program that plays
the guessing game of Hi-lo. You play this game by having one person think of a
number between 1 and 100, and having the other person guess the number. (We’ll
let the computer do the guessing.) The person who holds the number tells the
guesser whether their guess is high, low or correct. The best strategy for the
guesser is of course <i>binary search</i>, which chooses the midpoint of the
range of numbers where the sought-after number resides. The high-low response
tells the guesser which half of the list holds the number, and the process
repeats, halving the size of the active search range on each iteration. So how
do you write a loop to drive the repetition properly? It’s not sufficient to
just say <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0167"
title="Add Comment A0167">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>bool guessed = false;</p>

<p class=CodeChar style='margin-left:0in'>while (!guessed) {</p>

<p class=CodeChar style='margin-left:0in'>  …</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>because a malicious user might respond deceitfully, and you
could spend all day guessing. What assumption, however simple, are you making
each time you guess? In other words, what condition should hold <i>by design</i>
on each loop iteration? <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1519"
title="Add Comment A1519">Comment</a></sup></p>

<p class=MsoNormal>The simple assumption we’re after is, of course, that the
secret number is within the current active range of unguessed numbers,
beginning with the range [1, 100]. Suppose we label the endpoints of the range
with the variables <b><i>low</i></b> and <b><i>high</i></b>. Each time you pass
through the loop you need to make sure that if the number was in the range [<b>low</b>,
<b>high</b>] at the beginning of the loop, you calculate the new range so that
it still contains the number at the end of the current loop iteration. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1520"
title="Add Comment A1520">Comment</a></sup></p>

<p class=MsoNormal>The goal is to express the loop invariant in code so that a
violation can be detected at runtime. Unfortunately, since the computer doesn’t
know the secret number, you can’t express this condition directly in code, but
you can at least make a comment to that effect:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>while (!guessed) {</p>

<p class=CodeChar style='margin-left:0in'>  // INVARIANT: the number is in the
range [low, high]</p>

<p class=CodeChar style='margin-left:0in'>  …</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If we were to stop this thread of discussion right here, we
would have accomplished a great deal if it helps clarify how you design loops.
Fortunately, we can do better than that. What happens when the user says that a
guess is too high when it isn’t or that it’s too low when it in fact is not?
The deception will in effect exclude the secret number from the new subrange.
Because one lie always leads to another, eventually your range will diminish to
nothing (since you shrink it by half each time and the secret number isn’t in
there). We can easily express this condition concretely, as the following
program illustrates. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1522"
title="Add Comment A1522">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:HiLo.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Plays the game of Hi-lo to
illustrate a loop invariant</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Think of a
number between 1 and 100\n&quot;;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>cout &lt;&lt;
&quot;I will make a guess; &quot;;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>cout &lt;&lt;
&quot;tell me if I'm (H)igh or (L)ow\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  int low = 1, high = 100;</p>

<p class=CodeChar style='margin-left:0in'>  bool guessed = false;</p>

<p class=CodeChar style='margin-left:0in'>  while (!guessed) {</p>

<p class=CodeChar style='margin-left:0in'>    // Invariant: the number is in
the range [low, high]</p>

<p class=CodeChar style='margin-left:0in'>    if (low &gt; high) {  //
Invariant violation</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;You
cheated! I quit\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>      return EXIT_FAILURE;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    int guess = (low + high) / 2;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;My guess is
&quot; &lt;&lt; guess &lt;&lt; &quot;. &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;(H)igh,
(L)ow, or (E)qual? &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    string response;</p>

<p class=CodeChar style='margin-left:0in'>    cin &gt;&gt; response;</p>

<p class=CodeChar style='margin-left:0in'>    switch(toupper(response[0])) {</p>

<p class=CodeChar style='margin-left:0in'>      case 'H':</p>

<p class=CodeChar style='margin-left:0in'>        high = guess - 1;</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 'L':</p>

<p class=CodeChar style='margin-left:0in'>        low = guess + 1;</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 'E':</p>

<p class=CodeChar style='margin-left:0in'>        guessed = true;</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      default:</p>

<p class=CodeChar style='margin-left:0in'>        cout &lt;&lt; &quot;Invalid
response\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>        continue;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;I got
it!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  return EXIT_SUCCESS;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The violation of the invariant is easily detected with the
condition <b>if (low &gt; high)</b>, because if the user always tells the
truth, we will always find the secret number before we run out of numbers to
guess from. (See the last paragraph of the text that follows the program <b>extractCode.cpp</b>
at the end of Chapter 3 for an explanation of the macros <b>EXIT_FAILURE</b>
and <b>EXIT_SUCCESS</b>). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1521"
title="Add Comment A1521">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439980">Assertions</a></h2>

<p class=MsoNormal>The condition in the Hi-lo program depends on user input, so
you’re powerless to always prevent a violation of the invariant. Most often,
however, invariants depend only on the code you write, so they will always
hold, if you’ve implemented your design correctly. In this case, it is clearer
to make an <i>assertion</i>, which is a positive statement that reveals your
design decisions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1523"
title="Add Comment A1523">Comment</a></sup></p>

<p class=MsoNormal>For example, suppose you are implementing a vector of
integers, which, as you know, is an expandable array that grows on demand. The
function that adds an element to the vector must first verify that there is an
open slot in the underlying array that holds the elements; otherwise, it needs
to request more heap space and copy the existing elements to the new space
before adding the new element (and of course deleting the old array). Such a
function might look like the following: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1524"
title="Add Comment A1524">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>void MyVector::push_back(int x) {</p>

<p class=CodeChar style='margin-left:0in'>   if (nextSlot == capacity)</p>

<p class=CodeChar style='margin-left:0in'>      grow();</p>

<p class=CodeChar style='margin-left:0in'>   assert(nextSlot &lt; capacity);</p>

<p class=CodeChar style='margin-left:0in'>   data[nextSlot++] = x;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this example, <b>data</b> is a dynamic array of <b>int</b>s
with <b>capacity</b> slots and <b>nextSlot</b> slots in use. The purpose of <b>grow(&nbsp;)</b>
is to expand the size of <b>data</b> so that the new value of <b>capacity</b>
is strictly greater than <b>nextSlot</b>. Proper behavior of <b>MyVector</b>
depends on this design decision, and it will never fail if the rest of the supporting
code is correct, so we <i>assert</i> the condition with the <b>assert(&nbsp;)</b>
macro (defined in the header <b>&lt;cassert&gt;</b>). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1527"
title="Add Comment A1527">Comment</a></sup></p>

<p class=MsoNormal>The Standard C library <b>assert(&nbsp;)</b> macro is brief,
to the point, and portable. If the condition in its parameter evaluates to
non-zero, execution continues uninterrupted; if it doesn’t, a message
containing the text of the offending expression along with its source file name
and line number is printed to the standard error channel and the program
aborts. Is that too drastic? In practice, it is much more drastic to let
execution continue when a basic design assumption has failed. Your program
needs to be fixed. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1528"
title="Add Comment A1528">Comment</a></sup></p>

<p class=MsoNormal>If all goes well, you will have thoroughly tested your code
with all assertions intact by the time the final product is deployed. (We’ll
say more about testing later.) Depending on the nature of your application, the
machine cycles needed to test all assertions at runtime might be too much of a
performance hit in the field. If that’s the case, you can remove all the
assertion code automatically by defining the macro <b>NDEBUG</b> and rebuilding
the application. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0168"
title="Add Comment A0168">Comment</a></sup></p>

<p class=MsoNormal>To see how this works, note that a typical implementation of
<b>assert(&nbsp;)</b> looks something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>#ifdef NDEBUG</p>

<p class=CodeChar style='margin-left:0in'>  #define assert(cond) ((void)0)</p>

<p class=CodeChar style='margin-left:0in'>#else</p>

<p class=CodeChar style='margin-left:0in'>  void assertImpl(const char*, const
char*, long);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>#define
assert(cond) \</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>  ((cond) ?
(void)0 : assertImpl(???))</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When the macro <b>NDEBUG</b> is defined, the code decays to
the expression <b>(void) 0</b>, so all that’s left in the compilation stream is
an essentially empty statement as a result of the semicolon you appended to
each <b>assert(&nbsp;)</b> invocation. If <b>NDEBUG</b> is not defined, <b>assert(cond)</b>
expands to a conditional statement that, when <b>cond</b> is zero, calls a
compiler-dependent function (which we named <b>assertImpl(&nbsp;)</b>) with a
string argument representing the text of <b>cond</b>, along with the file name
and line number where the assertion appeared. (We used “???” as a place holder
in the example, but the string mentioned is actually computed there, along with
the file name and the line number where the macro occurs in that file. How
these values are obtained is immaterial to our discussion.) If you want to turn
assertions on and off at different points in your program, you not only have to
<b>#define</b> or <b>#undef</b>  <b>NDEBUG</b>, but you have to re-include <b>&lt;cassert&gt;</b>.
Macros are evaluated as the preprocessor encounters them and therefore use
whatever <b>NDEBUG</b> state applies at that point in time. The most common way
to define <b>NDEBUG</b> once for an entire program is as a compiler option,
whether through project settings in your visual environment or via the command
line, as in</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>mycc –DNDEBUG myfile.cpp</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Most compilers use the <b>–D</b> flag to define macro names.
(Substitute the name of your compiler’s executable for <b>mycc</b> above.) The
advantage of this approach is that you can leave your assertions in the source
code as an invaluable bit of documentation, and yet there is no runtime
penalty. Because the code in an assertion disappears when <b>NDEBUG</b> is
defined, it is important that you <i>never do work in an assertion</i>. Only
test conditions that do not change the state of your program. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1529"
title="Add Comment A1529">Comment</a></sup></p>

<p class=MsoNormal>Whether using <b>NDEBUG</b> for released code is a good idea
remains a subject of debate. Tony Hoare, one of the most influential computer
scientists of all time,<a href="#_ftn13" name="_ftnref13" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[13]</span></sup></span></span></sup></span></a> has
suggested that turning off runtime checks such as assertions is similar to a
sailing enthusiast who wears a life jacket while training on land and then
discards it when he actually goes to sea.<a href="#_ftn14" name="_ftnref14"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[14]</span></sup></span></span></sup></span></a> If
an assertion fails in production, you have a problem much worse than
degradation in performance, so choose wisely. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1530"
title="Add Comment A1530">Comment</a></sup></p>

<p class=MsoNormal>Not all conditions should be enforced by assertions, of
course. User errors and runtime resource failures should be signaled by
throwing exceptions, as we explained in detail in Chapter 1. It is tempting to
use assertions for most error conditions while roughing out code, with the
intent to replace many of them later with robust exception handling. Like any
other temptation, use caution, since you might forget to make all the necessary
changes later. Remember: assertions are intended to verify design decisions
that will only fail because of faulty programmer logic. The ideal is to solve
all assertion violations during development. You shouldn’t use assertions for
conditions that aren’t totally in your control (for example, conditions that
depend on user input). In particular, you wouldn’t want to use assertions to
validate function arguments; throw a <b>logic_error</b> instead. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0169"
title="Add Comment A0169">Comment</a></sup></p>

<p class=MsoNormal>The use of assertions as a tool to ensure program
correctness was formalized by Bertrand Meyer in his <i>Design by Contract</i>
methodology.<a href="#_ftn15" name="_ftnref15" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[15]</span></sup></span></span></sup></span></a> Every
function has an implicit contract with clients that, given certain <i>pre-conditions</i>,
guarantees certain <i>post-conditions</i>. In other words, the pre-conditions
are the requirements for using the function, such as supplying arguments within
certain ranges, and the post-conditions are the results delivered by the
function, either by return value or by side-effect. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0170"
title="Add Comment A0170">Comment</a></sup></p>

<p class=MsoNormal>What should you do when clients fail to give you valid
input? They have broken the contract, and you need to let them know. As we
mentioned earlier, this is not the best time to abort the program (although
you’re justified in doing so since the contract was violated), but an exception
is certainly in order. This is why the Standard C++ library throws exceptions
derived from <b>logic_error</b>, such as <b>out_of_range.</b><a href="#_ftn16"
name="_ftnref16" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[16]</span></sup></span></span></sup></span></a> If there are
functions that only you call, however, such as private functions in a class of
your own design, the <b>assert(&nbsp;)</b> macro is appropriate, since you have
total control over the situation and you certainly want to debug your code
before shipping. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1531"
title="Add Comment A1531">Comment</a></sup></p>

<p class=MsoNormal>Since post-conditions are totally your responsibility, you
might think assertions also apply, and you would be partially right. It is
appropriate to use an assertion for <i>any invariant at any time</i>, including
when a function has finished its work. This especially applies to class member
functions that maintain the state of an object. In the <b>MyVector</b> example
earlier, for instance, a reasonable invariant for all public member functions
would be </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>assert(0 &lt;= nextSlot &amp;&amp;
nextSlot &lt;= capacity);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>or, if <b>nextSlot</b> is an unsigned integer, simply</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>assert(nextSlot &lt;= capacity);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Such an invariant is called a <i>class invariant</i> and can
reasonably be enforced by an assertion. Subclasses play the role of <i>subcontractor</i>
to their base classes in that they must maintain the original contract the base
class has with its clients. For this reason, the pre-conditions in derived
classes must impose no extra requirements beyond those in the base contract,
and the post-conditions must deliver at least as much.<a href="#_ftn17"
name="_ftnref17" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[17]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1532"
title="Add Comment A1532">Comment</a></sup></p>

<p class=MsoNormal>Validating results returned to the client, however, is
nothing more or less than <i>testing</i>, so using post-condition assertions in
this case would be duplicating work. There’s nothing wrong with it; it’s just
an exercise in redundancy. Yes, it’s good documentation, but more than one
developer has been fooled into using post-condition assertions as a <i>substitute</i>
for unit testing. Bad idea! <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1533"
title="Add Comment A1533">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439981">A simple framework for unit
testing</a></h2>

<p class=MsoNormal>Writing software is all about meeting requirements<a
href="#_ftn18" name="_ftnref18" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[18]</span></sup></span></span></sup></span></a>. It doesn’t take much
experience, however, to figure out that coming up with requirements in the
first place is no easy task, and, more important, requirements are not static.
It’s not unheard of to discover at a weekly project meeting that what you just
spent the week doing is not exactly what the users really want. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1534"
title="Add Comment A1534">Comment</a></sup></p>

<p class=MsoNormal>Frustrating? Yes. Reasonable? Also, yes! It is unreasonable
to expect mere humans to be able to articulate software requirements in detail
without sampling an evolving, working system. It's much better to specify a
little, design a little, code a little, test a little. Then, after evaluating
the outcome, do it all over again. The ability to develop from soup to nuts in
such an iterative fashion is one of the great advances of this object-oriented
era in software history. It requires nimble programmers who can craft resilient
code. Change is hard. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0176"
title="Add Comment A0176">Comment</a></sup></p>

<p class=MsoNormal>Ironically, another impetus for change comes from you, the
programmer. The craftsperson in you likely has the habit of continually improving
the physical design of working code. What maintenance programmer hasn't had
occasion to curse the aging, flagship company product as a convoluted patchwork
of spaghetti, wholly resistant to modification? Management's knee-jerk
reluctance to let you tamper with a functioning system, while not totally
unfounded, robs code of the resilience it needs to endure. &quot;If it ain't
broke, don't fix it&quot; eventually gives way to, &quot;We can't fix
it—rewrite it.&quot; Change is necessary. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0177"
title="Add Comment A0177">Comment</a></sup></p>

<p class=MsoNormal>Fortunately, our industry has finally gotten used to the
discipline of <i>refactoring</i>, the art of internally restructuring code to
improve its design, without changing the functionality visible to the user.<a
href="#_ftn19" name="_ftnref19" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[19]</span></sup></span></span></sup></span></a> Such tweaks include
extracting a new function from another, or its inverse, combining member
functions; replacing a member function with an object; parameterizing a member
function or class; and replacing conditionals with polymorphism. Refactoring
helps code embrace evolution. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1535"
title="Add Comment A1535">Comment</a></sup></p>

<p class=MsoNormal>Whether the force for change comes from users or
programmers, however, there is still the risk that changes today will break
what worked yesterday. What is needed is a way to build code that withstands
the winds of change and actually improves over time. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0179"
title="Add Comment A0179">Comment</a></sup></p>

<p class=MsoNormal>Many practices purport to support such a quick-on-your-feet
motif, of which Extreme Programming is only one.<a href="#_ftn20"
name="_ftnref20" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[20]</span></sup></span></span></sup></span></a> In this section we
explore what we think is the key to making flexible, incremental development
succeed: a ridiculously easy-to-use automated unit test framework. (Please note
that we in no way mean to de-emphasize the role of <i>testers</i>, software
professionals who test others’ code for a living. They are indispensable. We
are merely describing a way to help developers write better code.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0180"
title="Add Comment A0180">Comment</a></sup></p>

<p class=MsoNormal>Developers write <i>unit tests</i> to gain the confidence to
say the two most important things that any developer can say: </p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>I understand the requirements.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>My code meets those requirements to the best of my knowledge.</p>

<p class=MsoNormal>There is no better way to ensure that you know what the code
you're about to write should do than to write the unit tests first. This simple
exercise helps focus the mind on the task ahead and will likely lead to working
code faster than just jumping into coding. Or, to express it in XP terms:
Testing + Programming is <i>faster</i> than just Programming. Writing tests
first also puts you on guard up front against boundary conditions that might
cause your code to break, so your code is more robust right out of the chute. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0182"
title="Add Comment A0182">Comment</a></sup></p>

<p class=MsoNormal>Once your code passes all your tests, you have the peace of
mind that if the system you contribute to isn't working, it's not your fault.
The statement &quot;All my tests pass&quot; is a powerful trump card in the
workplace that cuts through any amount of politics and hand waving. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0183"
title="Add Comment A0183">Comment</a></sup></p>

<h3><a name="_Toc45439982">Automated testing</a></h3>

<p class=MsoNormal>So what does a unit test look like? Too often developers
just use some well-behaved input to produce some expected output, which they
inspect visually. Two dangers exist in this approach. First, programs don't
always receive only well-behaved input. We all know that we should test the
boundaries of program input, but it's hard to think about this when you're
trying to just get things working. If you write the test for a function first
before you start coding, you can wear your “tester hat” and ask yourself,
&quot;What could possibly make this break?&quot; Code a test that will prove
the function you'll write isn't broken, and then put on your developer hat and
make it happen. You'll write better code than if you hadn't written the test
first. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0185"
title="Add Comment A0185">Comment</a></sup></p>

<p class=MsoNormal>The second danger is that inspecting output visually is
tedious and error prone. Most any such thing a human can do a computer can do,
but without human error. It's better to formulate tests as collections of <i>Boolean
expressions</i> and have a test program report any failures. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0186"
title="Add Comment A0186">Comment</a></sup></p>

<p class=MsoNormal>For example, suppose you need to build a <b>Date</b> class
that has the following properties: </p>

<p class=MsoList3><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A date can be initialized with a string (YYYYMMDD), three
integers (Y, M, D), or nothing (giving today's date). </p>

<p class=MsoList3><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A date object can yield its year, month, and day or a string of
the form &quot;YYYYMMDD&quot;.</p>

<p class=MsoList3><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All relational comparisons are available, as well as computing
the duration between two dates (in years, months, and days).</p>

<p class=MsoList3><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Dates to be compared need to be able to span an arbitrary number
of centuries (for example, 1600–2200).</p>

<p class=MsoNormal>Your class can store three integers representing the year,
month, and day. (Just be sure the year is at least 16 bits in size to satisfy
the last bulleted item.) The interface for your <b>Date</b> class might look
like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0188"
title="Add Comment A0188">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// A first pass at Date.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DATE_H</p>

<p class=CodeChar style='margin-left:0in'>#define DATE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Date {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // A struct to hold elapsed time:</p>

<p class=CodeChar style='margin-left:0in'>  struct Duration {</p>

<p class=CodeChar style='margin-left:0in'>    int years;</p>

<p class=CodeChar style='margin-left:0in'>    int months;</p>

<p class=CodeChar style='margin-left:0in'>    int days;</p>

<p class=CodeChar style='margin-left:0in'>    Duration(int y, int m, int d)</p>

<p class=CodeChar style='margin-left:0in'>      : years(y), months(m), days(d)
{}</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  Date();</p>

<p class=CodeChar style='margin-left:0in'>  Date(int year, int month, int day);</p>

<p class=CodeChar style='margin-left:0in'>  Date(const std::string&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  int getYear() const;</p>

<p class=CodeChar style='margin-left:0in'>  int getMonth() const;</p>

<p class=CodeChar style='margin-left:0in'>  int getDay() const;</p>

<p class=CodeChar style='margin-left:0in'>  std::string toString() const;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator&lt;(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator&gt;(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator&lt;=(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator&gt;=(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator==(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>friend bool
operator!=(const Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  friend Duration duration(const
Date&amp;, const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Before you even think about implementation, you can solidify
your grasp of the requirements for this class by writing the beginnings of a
test program. You might come up with something like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:SimpleDateTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} Date</p>

<p class=CodeChar style='margin-left:0in'>// You’ll need the full Date.h from
the Appendix:</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Date.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Test machinery</p>

<p class=CodeChar style='margin-left:0in'>int nPass = 0, nFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>void test(bool t) {</p>

<p class=CodeChar style='margin-left:0in'>  if(t) nPass++; else nFail++;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Date mybday(1951, 10, 1);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getYear() == 1951);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getMonth() == 10);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getDay() == 1);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Passed: &quot;
&lt;&lt; nPass &lt;&lt; &quot;, Failed: &quot;</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; nFail &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>/* Expected output:</p>

<p class=CodeChar style='margin-left:0in'>Passed: 3, Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>*/ ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this trivial case, the function <b>test(&nbsp;)</b>
maintains the global variables <b>nPass</b> and <b>nFail</b>. The only visual
inspection you do is to read the final score. If a test failed, a more
sophisticated <b>test(&nbsp;)</b> displays an appropriate message. The
framework described later in this chapter has such a test function, among other
things. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0191"
title="Add Comment A0191">Comment</a></sup></p>

<p class=MsoNormal>You can now implement enough of the <b>Date</b> class to get
these tests to pass, and then you can proceed iteratively in like fashion until
all the requirements are met. By writing tests first, you are more likely to
think of corner cases that might break your upcoming implementation, and you’re
more likely to write the code correctly the first time. Such an exercise might
produce the following “final” version of a test for the <b>Date</b> class: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1536"
title="Add Comment A1536">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:SimpleDateTest2.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} Date</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Date.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Test machinery</p>

<p class=CodeChar style='margin-left:0in'>int nPass = 0, nFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>void test(bool t) {</p>

<p class=CodeChar style='margin-left:0in'>  if(t) nPass++; else nFail++;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Date mybday(1951, 10, 1);</p>

<p class=CodeChar style='margin-left:0in'>  Date today;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>Date
myevebday(&quot;19510930&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  </p>

<p class=CodeChar style='margin-left:0in'>  // Test the operators</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &lt; today);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &lt;= today);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday != today);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday == mybday);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &gt;= mybday);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &lt;= mybday);</p>

<p class=CodeChar style='margin-left:0in'>  test(myevebday &lt; mybday);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &gt; myevebday);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday &gt;= myevebday);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday != myevebday);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // Test the functions</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getYear() == 1951);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getMonth() == 10);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.getDay() == 1);</p>

<p class=CodeChar style='margin-left:0in'>  test(myevebday.getYear() == 1951);</p>

<p class=CodeChar style='margin-left:0in'>  test(myevebday.getMonth() == 9);</p>

<p class=CodeChar style='margin-left:0in'>  test(myevebday.getDay() == 30);</p>

<p class=CodeChar style='margin-left:0in'>  test(mybday.toString() ==
&quot;19511001&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  test(myevebday.toString() ==
&quot;19510930&quot;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // Test duration</p>

<p class=CodeChar style='margin-left:0in'>  Date d2(2003, 7, 4);</p>

<p class=CodeChar style='margin-left:0in'>  Date::Duration dur =
duration(mybday, d2);</p>

<p class=CodeChar style='margin-left:0in'>  test(dur.years == 51);</p>

<p class=CodeChar style='margin-left:0in'>  test(dur.months == 9);</p>

<p class=CodeChar style='margin-left:0in'>  test(dur.days == 3);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // Report results:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Passed: &quot;
&lt;&lt; nPass &lt;&lt; &quot;, Failed: &quot;</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; nFail &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The word “final” above was quoted because this test can of
course be more fully developed. For example we haven’t tested that long
durations are handled correctly. To save space on the printed page we’ll stop
here, but you get the idea. The full implementation for the <b>Date</b> class
is available in the files <b>Date.h</b> and <b>Date.cpp</b> in the appendix and
on the Mindview website<a href="#_ftn21" name="_ftnref21" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[21]</span></sup></span></span></sup></span></a>.<sup>
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1539"
title="Add Comment A1539">Comment</a></sup></p>

<h3><a name="_Toc45439983">The TestSuite Framework</a></h3>

<p class=MsoNormal>Some automated C++ unit test tools are available on the
World Wide Web for download, such as <b>CppUnit.</b><a href="#_ftn22"
name="_ftnref22" title=""><span class=MsoFootnoteReference><b><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><b><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[22]</span></sup></b></span></span></sup></b></span></a> These are
well designed and implemented, but our purpose here is not only to present a
test mechanism that is easy to use, but also easy to understand internally and
even tweak if necessary. So, in the spirit of “TheSimplestThingThatCouldPossiblyWork,”
we have developed the <i>TestSuite Framework</i>, a namespace named <b>TestSuite</b>
that contains two key classes: <b>Test</b> and <b>Suite</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1542"
title="Add Comment A1542">Comment</a></sup></p>

<p class=MsoNormal>The <b>Test</b> class is an abstract class you derive from
to define a test object. It keeps track of the number of passes and failures
for you and displays the text of any test condition that fails. Your main task
in defining a test is simply to override the <b>run(&nbsp;)</b> member
function, which should in turn call the <b>test_(&nbsp;)</b> macro for each
Boolean test condition you define. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1541"
title="Add Comment A1541">Comment</a></sup></p>

<p class=MsoNormal>To define a test for the <b>Date</b> class using the
framework, you can inherit from <b>Test</b> as shown in the following program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:DateTest.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DATE_TEST_H</p>

<p class=CodeChar style='margin-left:0in'>#define DATE_TEST_H</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Date.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DateTest : public TestSuite::Test
{</p>

<p class=CodeChar style='margin-left:0in'>  Date mybday;</p>

<p class=CodeChar style='margin-left:0in'>  Date today;</p>

<p class=CodeChar style='margin-left:0in'>  Date myevebday;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  DateTest() : mybday(1951, 10, 1),
myevebday(&quot;19510930&quot;) {   </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    testOps();</p>

<p class=CodeChar style='margin-left:0in'>    testFunctions();</p>

<p class=CodeChar style='margin-left:0in'>    testDuration();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testOps() {</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &lt; today);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &lt;= today);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday != today);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday == mybday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &gt;= mybday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &lt;= mybday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(myevebday &lt; mybday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &gt; myevebday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday &gt;= myevebday);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday != myevebday);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testFunctions() {</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday.getYear() == 1951);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday.getMonth() == 10);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday.getDay() == 1);</p>

<p class=CodeChar style='margin-left:0in'>    test_(myevebday.getYear() ==
1951);</p>

<p class=CodeChar style='margin-left:0in'>    test_(myevebday.getMonth() == 9);</p>

<p class=CodeChar style='margin-left:0in'>    test_(myevebday.getDay() == 30);</p>

<p class=CodeChar style='margin-left:0in'>    test_(mybday.toString() ==
&quot;19511001&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(myevebday.toString() ==
&quot;19510930&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testDuration() {</p>

<p class=CodeChar style='margin-left:0in'>    Date d2(2003, 7, 4);</p>

<p class=CodeChar style='margin-left:0in'>    Date::Duration dur =
duration(mybday, d2);</p>

<p class=CodeChar style='margin-left:0in'>    test_(dur.years == 51);</p>

<p class=CodeChar style='margin-left:0in'>    test_(dur.months == 9);</p>

<p class=CodeChar style='margin-left:0in'>    test_(dur.days == 3);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>#endif ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Running the test is a simple matter of instantiating a <b>DateTest</b>
object and calling its <b>run(&nbsp;)</b> member function. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1550"
title="Add Comment A1550">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:DateTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Automated Testing (with a
Framework)</p>

<p class=CodeChar style='margin-left:0in'>//{L} Date ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DateTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  DateTest test;</p>

<p class=CodeChar style='margin-left:0in'>  test.run();</p>

<p class=CodeChar style='margin-left:0in'>  return test.report();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>/* Output:</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;DateTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>        Passed: 21,      Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>*/ ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Test::report(&nbsp;)</b> function displays the
previous output and returns the number of failures, so it is suitable to use as
a return value from <b>main(&nbsp;)</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1540"
title="Add Comment A1540">Comment</a></sup></p>

<p class=MsoNormal>The <b>Test</b> class uses RTTI<a href="#_ftn23"
name="_ftnref23" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[23]</span></sup></span></span></sup></span></a> to get the name of
your class (for example, <b>DateTest</b>) for the report. There is also a <b>setStream(&nbsp;)</b>
member function if you want the test results sent to a file instead of to the
standard output (the default). You’ll see the <b>Test</b> class implementation
later in this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0196"
title="Add Comment A0196">Comment</a></sup></p>

<p class=MsoNormal>The <b>test_ (&nbsp;)</b> macro can extract the text of the
Boolean condition that fails, along with its file name and line number.<a
href="#_ftn24" name="_ftnref24" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[24]</span></sup></span></span></sup></span></a> To see what happens
when a failure occurs, you can introduce an intentional error in the code, say
by reversing the condition in the first call to <b>test_(&nbsp;)</b> in <b>DateTest::testOps(&nbsp;)</b>
in the previous example code. The output indicates exactly what test was in
error and where it happened: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1549"
title="Add Comment A1549">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>DateTest failure: (mybday &gt; today)
, DateTest.h (line 31)</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;DateTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>        Passed: 20      Failed: 1</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In addition to <b>test_(&nbsp;)</b>, the framework includes
the functions <b>succeed_(&nbsp;)</b> and <b>fail_(&nbsp;)</b>, for cases in
which a Boolean test won't do. These functions apply when the class you’re
testing might throw exceptions. During testing, you want to arrange an input
set that will cause the exception to occur to make sure it’s doing its job. If
it doesn’t, it’s an error, in which case you call <b>fail_(&nbsp;)</b>
explicitly to display a message and update the failure count. If it does throw
the exception as expected, you call <b>succeed_ (&nbsp;)</b> to update the
success count. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1543"
title="Add Comment A1543">Comment</a></sup></p>

<p class=MsoNormal>To illustrate, suppose we update the specification of the
two non-default <b>Date</b> constructors to throw a <b>DateError</b> exception
(a type nested inside <b>Date</b> and derived from <b>std::logic_error</b>) if
the input parameters do not represent a valid date: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1548"
title="Add Comment A1548">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Date(const string&amp; s)
throw(DateError);</p>

<p class=CodeChar style='margin-left:0in'>Date(int year, int month, int day)
throw(DateError);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>DateTest::run(&nbsp;)</b> member function can now
call the following function to test the exception handling:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  void testExceptions() {</p>

<p class=CodeChar style='margin-left:0in'>    try {</p>

<p class=CodeChar style='margin-left:0in'>      Date d(0,0,0);  // Invalid</p>

<p class=CodeChar style='margin-left:0in'>      fail_(&quot;Invalid date
undetected in Date int ctor&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    catch (Date::DateError&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>      succeed_();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    try {</p>

<p class=CodeChar style='margin-left:0in'>      Date d(&quot;&quot;);  //
Invalid</p>

<p class=CodeChar style='margin-left:0in'>      fail_(&quot;Invalid date
undetected in Date string ctor&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    catch (Date::DateError&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>      succeed_();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In both cases, if an exception is not thrown, it is an
error. Notice that you have to manually pass a message to <b>fail_(&nbsp;)</b>,
since no Boolean expression is being evaluated. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0200"
title="Add Comment A0200">Comment</a></sup></p>

<h3><a name="_Toc45439984">Test suites</a></h3>

<p class=MsoNormal>Real projects usually contain many classes, so you need a
way to group tests so that you can just push a single button to test the entire
project<a href="#_ftn25" name="_ftnref25" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[25]</span></sup></span></span></sup></span></a>.
The <b>Suite</b> class allows you to collect tests into a functional unit. You
derive <b>Test</b> objects to a <b>Suite</b> with the <b>addTest(&nbsp;)</b>
member function, or you can swallow an entire existing suite with <b>addSuite(&nbsp;)</b>.
We have a number of date-related classes to illustrate how to use a test suite.
Here's an actual test run: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0201"
title="Add Comment A0201">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Illustrates a suite of related
tests</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;suite.h&quot;         //
includes test.h</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;JulianDateTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;JulianTimeTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;MonthInfoTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DateTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;TimeTest.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>    Suite s(&quot;Date and Time
Tests&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    s.addTest(new MonthInfoTest);</p>

<p class=CodeChar style='margin-left:0in'>    s.addTest(new JulianDateTest);</p>

<p class=CodeChar style='margin-left:0in'>    s.addTest(new JulianTimeTest);</p>

<p class=CodeChar style='margin-left:0in'>    s.addTest(new DateTest);</p>

<p class=CodeChar style='margin-left:0in'>    s.addTest(new TimeTest);</p>

<p class=CodeChar style='margin-left:0in'>    s.run();</p>

<p class=CodeChar style='margin-left:0in'>    long nFail = s.report();</p>

<p class=CodeChar style='margin-left:0in'>    s.free();</p>

<p class=CodeChar style='margin-left:0in'>    return nFail;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>/* Output:</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>Suite
&quot;Date and Time Tests&quot;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>===========================</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>Test
&quot;MonthInfoTest&quot;:</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>   Passed: 18  Failed:
0</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;JulianDateTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>   Passed: 36  Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;JulianTimeTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>   Passed: 29  Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;DateTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>   Passed: 57  Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>Test &quot;TimeTest&quot;:</p>

<p class=CodeChar style='margin-left:0in'>   Passed: 84  Failed: 0</p>

<p class=CodeChar style='margin-left:0in'>===========================</p>

<p class=CodeChar style='margin-left:0in'>*/</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each of the five test files included as headers tests a
unique date component. You must give the suite a name when you create it. The <b>Suite::run(&nbsp;)</b>
member function calls <b>Test::run(&nbsp;)</b> for each of its contained tests.
Much the same thing happens for <b>Suite::report(&nbsp;)</b>, except that it is
possible to send the individual test reports to a destination stream that is
different from that of the suite report. If the test passed to <b>addSuite(&nbsp;)</b>
has a stream pointer assigned already, it keeps it. Otherwise, it gets its
stream from the <b>Suite</b> object. (As with <b>Test</b>, there is a second
argument to the suite constructor that defaults to <b>std::cout</b>.) The
destructor for <b>Suite</b> does not automatically delete the contained <b>Test</b>
pointers because they don’t have to reside on the heap; that’s the job of <b>Suite::free(&nbsp;)</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1547"
title="Add Comment A1547">Comment</a></sup></p>

<h3><a name="_Toc45439985">The test framework code</a></h3>

<p class=MsoNormal>The test framework code library is in a subdirectory called <b>TestSuite</b>
in the code distribution available on the Mindview website. To use it,
therefore, the <b>TestSuite</b> subdirectory in your header must include the
search path, you must link the object files, and thus you must also include the
<b>TestSuite</b> subdirectory in the library search path. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0204"
title="Add Comment A0204">Comment</a></sup></p>

<p class=MsoNormal>Here is the header for <b>Test.h</b>: </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: TestSuite:Test.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef TEST_H</p>

<p class=CodeChar style='margin-left:0in'>#define TEST_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::string;</p>

<p class=CodeChar style='margin-left:0in'>using std::ostream;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The following have underscores
because</p>

<p class=CodeChar style='margin-left:0in'>// they are macros. For consistency, </p>

<p class=CodeChar style='margin-left:0in'>// succeed_() also has an underscore.</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#define test_(cond) \</p>

<p class=CodeChar style='margin-left:0in'>  do_test(cond, #cond, __FILE__,
__LINE__)</p>

<p class=CodeChar style='margin-left:0in'>#define fail_(str) \</p>

<p class=CodeChar style='margin-left:0in'>  do_fail(str, __FILE__, __LINE__)</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>namespace TestSuite {</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Test {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Test(ostream* osptr = &amp;cout);</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Test(){}</p>

<p class=CodeChar style='margin-left:0in'>  virtual void run() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  long getNumPassed() const;</p>

<p class=CodeChar style='margin-left:0in'>  long getNumFailed() const;</p>

<p class=CodeChar style='margin-left:0in'>  const ostream* getStream() const;</p>

<p class=CodeChar style='margin-left:0in'>  void setStream(ostream* osptr);</p>

<p class=CodeChar style='margin-left:0in'>  void succeed_();</p>

<p class=CodeChar style='margin-left:0in'>  long report() const;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void reset();</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  void do_test(bool cond, const
string&amp; lbl,</p>

<p class=CodeChar style='margin-left:0in'>    const char* fname, long lineno);</p>

<p class=CodeChar style='margin-left:0in'>  void do_fail(const string&amp; lbl,</p>

<p class=CodeChar style='margin-left:0in'>    const char* fname, long lineno);</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  ostream* osptr;</p>

<p class=CodeChar style='margin-left:0in'>  long nPass;</p>

<p class=CodeChar style='margin-left:0in'>  long nFail;</p>

<p class=CodeChar style='margin-left:0in'>  // Disallowed:</p>

<p class=CodeChar style='margin-left:0in'>  Test(const Test&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Test&amp; operator=(const
Test&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline Test::Test(ostream* osptr) {</p>

<p class=CodeChar style='margin-left:0in'>  this-&gt;osptr = osptr;</p>

<p class=CodeChar style='margin-left:0in'>  nPass = nFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline long Test::getNumPassed()
const {</p>

<p class=CodeChar style='margin-left:0in'>  return nPass;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline long Test::getNumFailed()
const {</p>

<p class=CodeChar style='margin-left:0in'>  return nFail;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline const ostream*
Test::getStream() const {</p>

<p class=CodeChar style='margin-left:0in'>  return osptr;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline void Test::setStream(ostream*
osptr) {</p>

<p class=CodeChar style='margin-left:0in'>  this-&gt;osptr = osptr;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline void Test::succeed_() {</p>

<p class=CodeChar style='margin-left:0in'>  ++nPass;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline void Test::reset() {</p>

<p class=CodeChar style='margin-left:0in'>  nPass = nFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>} // namespace TestSuite</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // TEST_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>There are three virtual functions in the <b>Test</b> class: </p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A virtual destructor</p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The function <b>reset(&nbsp;)</b> </p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The pure virtual function <b>run(&nbsp;)</b> </p>

<p class=MsoNormal>As explained in Volume 1, it is an error to delete a derived
heap object through a base pointer unless the base class has a virtual
destructor. Any class intended to be a base class (usually evidenced by the
presence of at least one other virtual function) should have a virtual
destructor. The default implementation of the <b>Test::reset(&nbsp;)</b> resets
the success and failure counters to zero. You might want to override this
function to reset the state of the data in your derived test object; just be
sure to call <b>Test::reset(&nbsp;)</b> explicitly in your override so that the
counters are reset. The <b>Test::run(&nbsp;)</b> member function is pure
virtual, of course, since you are required to override it in your derived
class. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0206"
title="Add Comment A0206">Comment</a></sup></p>

<p class=MsoNormal>The <b>test_(&nbsp;)</b> and <b>fail_(&nbsp;)</b> macros can
include file name and line number information available from the preprocessor.
We originally omitted the trailing underscores in the names, but the original <b>fail(&nbsp;)</b>
macro collided with <b>ios::fail(&nbsp;)</b>, causing all kinds of compiler
errors. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1546"
title="Add Comment A1546">Comment</a></sup></p>

<p class=MsoNormal>Here is the implementation of <b>Test</b>: </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: TestSuite:Test.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;  // Note:
Visual C++ requires /GR</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>using namespace TestSuite;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Test::do_test(bool cond, </p>

<p class=CodeChar style='margin-left:0in'>  const std::string&amp; lbl, const
char* fname, </p>

<p class=CodeChar style='margin-left:0in'>  long lineno) {</p>

<p class=CodeChar style='margin-left:0in'>  if (!cond)</p>

<p class=CodeChar style='margin-left:0in'>    do_fail(lbl, fname, lineno);</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>    succeed_();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Test::do_fail(const
std::string&amp; lbl,</p>

<p class=CodeChar style='margin-left:0in'>  const char* fname, long lineno) {</p>

<p class=CodeChar style='margin-left:0in'>  ++nFail;</p>

<p class=CodeChar style='margin-left:0in'>  if (osptr) {</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt;
typeid(*this).name()</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt; &quot;failure:
(&quot; &lt;&lt; lbl &lt;&lt; &quot;) , &quot;</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt; fname</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt; &quot; (line
&quot; &lt;&lt; lineno &lt;&lt; &quot;)\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>long Test::report() const {</p>

<p class=CodeChar style='margin-left:0in'>  if (osptr) {</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt; &quot;Test
\&quot;&quot; &lt;&lt; typeid(*this).name()</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt;
&quot;\&quot;:\n\tPassed: &quot; &lt;&lt; nPass</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt; &quot;\tFailed:
&quot; &lt;&lt; nFail</p>

<p class=CodeChar style='margin-left:0in'>           &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return nFail;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>No rocket science here. The <b>Test</b> class just keeps
track of the number of successes and failures as well as the stream where you
want <b>Test::report(&nbsp;)</b> to display the results. The <b>test_(&nbsp;)</b>
and <b>fail_(&nbsp;)</b> macros extract the current file name and line number
information from the preprocessor and pass the file name to <b>do_test(&nbsp;)</b>
and the line number to <b>do_fail(&nbsp;)</b>, which do the actual work of
displaying a message and updating the appropriate counter. We can’t think of a
good reason to allow copy and assignment of test objects, so we have disallowed
these operations by making their prototypes private and omitting their
respective function bodies. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1545"
title="Add Comment A1545">Comment</a></sup></p>

<p class=MsoNormal>Here is the header file for <b>Suite</b>:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0209"
title="Add Comment A0209">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: TestSuite:Suite.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef SUITE_H</p>

<p class=CodeChar style='margin-left:0in'>#define SUITE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::vector;</p>

<p class=CodeChar style='margin-left:0in'>using std::logic_error;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>namespace TestSuite {</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class TestSuiteError : public
logic_error {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  TestSuiteError(const string&amp; s
= &quot;&quot;)</p>

<p class=CodeChar style='margin-left:0in'>    : logic_error(s) {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Suite {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Suite(const string&amp; name,
ostream* osptr = &amp;cout);</p>

<p class=CodeChar style='margin-left:0in'>  string getName() const;</p>

<p class=CodeChar style='margin-left:0in'>  long getNumPassed() const;</p>

<p class=CodeChar style='margin-left:0in'>  long getNumFailed() const;</p>

<p class=CodeChar style='margin-left:0in'>  const ostream* getStream() const;</p>

<p class=CodeChar style='margin-left:0in'>  void setStream(ostream* osptr);</p>

<p class=CodeChar style='margin-left:0in'>  void addTest(Test* t) throw
(TestSuiteError);</p>

<p class=CodeChar style='margin-left:0in'>  void addSuite(const Suite&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  void run();  // Calls Test::run()
repeatedly</p>

<p class=CodeChar style='margin-left:0in'>  long report() const;</p>

<p class=CodeChar style='margin-left:0in'>  void free();  // Deletes tests</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  string name;</p>

<p class=CodeChar style='margin-left:0in'>  ostream* osptr;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Test*&gt; tests;</p>

<p class=CodeChar style='margin-left:0in'>  void reset();</p>

<p class=CodeChar style='margin-left:0in'>  // Disallowed ops:</p>

<p class=CodeChar style='margin-left:0in'>  Suite(const Suite&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Suite&amp; operator=(const
Suite&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline</p>

<p class=CodeChar style='margin-left:0in'>Suite::Suite(const string&amp; name,
ostream* osptr)</p>

<p class=CodeChar style='margin-left:0in'>   : name(name) {</p>

<p class=CodeChar style='margin-left:0in'>  this-&gt;osptr = osptr;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline string Suite::getName() const
{</p>

<p class=CodeChar style='margin-left:0in'>  return name;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline const ostream*
Suite::getStream() const {</p>

<p class=CodeChar style='margin-left:0in'>  return osptr;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline void Suite::setStream(ostream*
osptr) {</p>

<p class=CodeChar style='margin-left:0in'>  this-&gt;osptr = osptr;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>} // namespace TestSuite</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // SUITE_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Suite</b> class holds pointers to its <b>Test</b>
objects in a vector. Notice the exception specification on the <b>addTest(&nbsp;)</b>
member function. When you add a test to a suite, <b>Suite::addTest(&nbsp;)</b>
verifies that the pointer you pass is not null; if it is null, it throws a <b>TestSuiteError</b>
exception. Since this makes it impossible to add a null pointer to a suite, <b>addSuite(&nbsp;)</b>
asserts this condition on each of its tests, as do the other functions that
traverse the vector of tests (see the following implementation). Copy and
assignment are disallowed as they are in the <b>Test</b> class. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0210"
title="Add Comment A0210">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: TestSuite:Suite.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Suite.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>using namespace TestSuite;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Suite::addTest(Test* t)
throw(TestSuiteError) {</p>

<p class=CodeChar style='margin-left:0in'>  // Verify test is valid and has a
stream:</p>

<p class=CodeChar style='margin-left:0in'>  if (t == 0)</p>

<p class=CodeChar style='margin-left:0in'>    throw TestSuiteError(</p>

<p class=CodeChar style='margin-left:0in'>      &quot;Null test in
Suite::addTest&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  else if (osptr &amp;&amp;
!t-&gt;getStream())</p>

<p class=CodeChar style='margin-left:0in'>    t-&gt;setStream(osptr);</p>

<p class=CodeChar style='margin-left:0in'>  tests.push_back(t);</p>

<p class=CodeChar style='margin-left:0in'>  t-&gt;reset();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Suite::addSuite(const Suite&amp;
s) {</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>for (size_t i = 0;
i &lt; s.tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'> 
assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in;text-indent:24.0pt'>addTest(s.tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Suite::free() {</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in'>    delete tests[i];</p>

<p class=CodeChar style='margin-left:0in'>    tests[i] = 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Suite::run() {</p>

<p class=CodeChar style='margin-left:0in'>  reset();</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in'>    assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>    tests[i]-&gt;run();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>long Suite::report() const {</p>

<p class=CodeChar style='margin-left:0in'>  if (osptr) {</p>

<p class=CodeChar style='margin-left:0in'>    long totFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt; &quot;Suite
\&quot;&quot; &lt;&lt; name </p>

<p class=CodeChar style='margin-left:0in'>             &lt;&lt;
&quot;\&quot;\n=======&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    size_t i;</p>

<p class=CodeChar style='margin-left:0in'>    for (i = 0; i &lt; name.size();
++i)</p>

<p class=CodeChar style='margin-left:0in'>      *osptr &lt;&lt; '=';</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt; &quot;=\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    for (i = 0; i &lt; tests.size();
++i) {</p>

<p class=CodeChar style='margin-left:0in'>      assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>      totFail +=
tests[i]-&gt;report();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt;
&quot;=======&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    for (i = 0; i &lt; name.size();
++i)</p>

<p class=CodeChar style='margin-left:0in'>      *osptr &lt;&lt; '=';</p>

<p class=CodeChar style='margin-left:0in'>    *osptr &lt;&lt; &quot;=\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    return totFail;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>    return getNumFailed();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>long Suite::getNumPassed() const {</p>

<p class=CodeChar style='margin-left:0in'>  long totPass = 0;</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in'>    assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>    totPass +=
tests[i]-&gt;getNumPassed();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return totPass;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>long Suite::getNumFailed() const {</p>

<p class=CodeChar style='margin-left:0in'>  long totFail = 0;</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in'>    assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>    totFail +=
tests[i]-&gt;getNumFailed();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return totFail;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Suite::reset() {</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
tests.size(); ++i) {</p>

<p class=CodeChar style='margin-left:0in'>    assert(tests[i]);</p>

<p class=CodeChar style='margin-left:0in'>    tests[i]-&gt;reset();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We will be using the <b>TestSuite</b> framework wherever it
applies throughout the rest of this book. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1544"
title="Add Comment A1544">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439986">Debugging techniques</a></h2>

<p class=MsoNormal>The best debugging habit to get into is to use assertions as
explained in the beginning of this chapter; by doing so you’ll be more likely
to find logic errors before they cause real trouble. This section contains some
other tips and techniques that might help during debugging. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0213"
title="Add Comment A0213">Comment</a></sup></p>

<h3><a name="_Toc45439987">Trace macros</a></h3>

<p class=MsoNormal>Sometimes it’s helpful to print the code of each statement
as it is executed, either to <b>cout</b> or to a trace file. Here’s a
preprocessor macro to accomplish this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0214"
title="Add Comment A0214">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>#define TRACE(ARG) cout
&lt;&lt; #ARG &lt;&lt; endl; ARG</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now you can go through and surround the statements you trace
with this macro. Of course, it can introduce problems. For example, if you take
the statement: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0215"
title="Add Comment A0215">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  cout &lt;&lt; i &lt;&lt;
endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>and put both lines inside <b>TRACE(&nbsp;)</b> macros, you
get this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>TRACE(for(int i = 0; i &lt; 100;
i++))</p>

<p class=CodeInlineCharChar style='margin-left:0in'>TRACE(  cout &lt;&lt; i
&lt;&lt; endl;)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which expands to this: </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>cout &lt;&lt; &quot;for(int i = 0; i
&lt; 100; i++)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;cout &lt;&lt; i
&lt;&lt; endl;&quot; &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt; i &lt;&lt;
endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which isn’t exactly what you want. Thus, you must use this
technique carefully. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0218"
title="Add Comment A0218">Comment</a></sup></p>

<p class=MsoNormal>The following is a variation on the <b>TRACE(&nbsp;)</b>
macro:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>#define D(a) cout &lt;&lt;
#a &quot;=[&quot; &lt;&lt; a &lt;&lt; &quot;]&quot; &lt;&lt; '\n';</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If you want to display an expression, you simply put it
inside a call to <b>D(&nbsp;).</b> The expression is displayed, followed by its
value (assuming there’s an overloaded operator <b>&lt;&lt;</b> for the result
type). For example, you can say <b>D(a + b)</b>. Thus, you can use this macro
any time you want to test an intermediate value to make sure things are okay. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0220"
title="Add Comment A0220">Comment</a></sup></p>

<p class=MsoNormal>Of course, these two macros are actually just the two most
fundamental things you do with a debugger: trace through the code execution and
display values. A good debugger is an excellent productivity tool, but sometimes
debuggers are not available, or it’s not convenient to use them. These
techniques always work, regardless of the situation. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0221"
title="Add Comment A0221">Comment</a></sup></p>

<h3><a name="_Toc45439988">Trace file</a></h3>

<p class=MsoNormal>DISCLAIMER: This section and the next contain code which is
officially unsanctioned by the C++ standard. In particular, we redefine <b>cout</b>
and <b>new</b> via macros, which can cause surprising results if you’re not
careful. Our examples work on all of the compilers we use, however, and provide
useful information. This is the only place in this book where we will depart
from the sanctity of standard-compliant coding practice. Use at your own risk!</p>

<p class=MsoNormal>The following code allows you to easily create a trace file
and send all the output that would normally go to <b>cout</b> into the file.
All you have to do is <b>#define</b> TRACEON and include the header file (of
course, it’s fairly easy just to write the two key lines right into your file):
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0222"
title="Add Comment A0222">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Trace.h</p>

<p class=CodeChar style='margin-left:0in'>// Creating a trace file</p>

<p class=CodeChar style='margin-left:0in'>#ifndef TRACE_H</p>

<p class=CodeChar style='margin-left:0in'>#define TRACE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#ifdef TRACEON</p>

<p class=CodeChar style='margin-left:0in'>ofstream
TRACEFILE__(&quot;TRACE.OUT&quot;);</p>

<p class=CodeChar style='margin-left:0in'>#define cout TRACEFILE__</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // TRACE_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here’s a simple test of the previous file: </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Tracetst.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test of trace.h</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#define TRACEON</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Trace.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>int main() {</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  ifstream
f(&quot;Tracetst.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(f,
&quot;Tracetst.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; f.rdbuf(); // Dumps
file contents to file</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<h3><a name="_Toc45439989">Finding memory leaks</a></h3>

<p class=MsoNormal>The following straightforward debugging techniques are
explained Volume 1.</p>

<p class=MsoNormal style='text-indent:-.25in'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>For array bounds checking, use the <b>Array</b> template in <b>C16:Array3.cpp</b>
of Volume 1 for all arrays. You can turn off the checking and increase
efficiency when you’re ready to ship. (This doesn’t deal with the case of
taking a pointer to an array, though—perhaps that could be made into a template
somehow as well). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0226"
title="Add Comment A0226">Comment</a></sup></p>

<p class=MsoNormal style='text-indent:-.25in'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Check for non-virtual destructors in base classes. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0228"
title="Add Comment A0228">Comment</a></sup></p>

<h4>Tracking new/delete and malloc/free</h4>

<p class=MsoNormal>Common problems with memory allocation include mistakenly
calling <b>delete</b> for memory not on the free store, deleting the free store
more than once, and, most often, forgetting to delete such a pointer at all.
This section discusses a system that can help you track down these kinds of
problems.</p>

<p class=MsoNormal>As an <i>additional disclaimer</i> beyond that of the
preceding section: because of the way we overload <b>new</b>, the following
technique may not work on all platforms, and will only work for programs that
do not call the <i>function</i> <b>operator new(&nbsp;)</b> explicitly. We have
been quite careful in this book to only present code that fully conforms to the
C++ standard, but in this one instance we’re making an exception for the
following reasons:</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Even though it’s technically illegal, it works on many compilers<a
href="#_ftn26" name="_ftnref26" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[26]</span></sup></span></span></sup></span></a>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>We illustrate some useful thinking along the way.</p>

<p class=Exercises style='margin-left:0in;text-indent:0in'>&nbsp;</p>

<p class=MsoNormal>To use the memory checking system, you simply include the
header file <b>MemCheck.h</b>, link the <b>MemCheck.obj</b> file into your
application, so that all the calls to <b>new</b> and <b>delete</b> are
intercepted, and call the macro <b>MEM_ON(&nbsp;)</b> (explained later in this
section) to initiate memory tracing. A trace of all allocations and
deallocations is printed to the standard output (via <b>stdout</b>). When you
use this system, all calls to <b>new</b> store information about the file and
line where they were called. This is accomplished by using the <i>placement
syntax</i> for <b>operator new.</b><a href="#_ftn27" name="_ftnref27" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[27]</span></sup></span></span></sup></span></a> Although
you typically use the placement syntax when you need to place objects at a
specific point in memory, it also allows you to create an <b>operator
new(&nbsp;)</b> with any number of arguments. This is used to advantage in the
following example to store the results of the <b>__FILE__</b> and <b>__LINE__</b>
macros whenever <b>new</b> is called: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0230"
title="Add Comment A0230">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>//:
C02:MemCheck.h</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>#ifndef
MEMCHECK_H</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>#define
MEMCHECK_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;  // for
size_t</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Hijack the new operator (both
scalar and array versions)</p>

<p class=CodeChar style='margin-left:0in'>void* operator new(std::size_t, const
char*, long);</p>

<p class=CodeChar style='margin-left:0in'>void* operator new[](std::size_t,
const char*, long);</p>

<p class=CodeChar style='margin-left:0in'>#define new new (__FILE__, __LINE__)</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>extern bool traceFlag;</p>

<p class=CodeChar style='margin-left:0in'>#define TRACE_ON() traceFlag = true</p>

<p class=CodeChar style='margin-left:0in'>#define TRACE_OFF() traceFlag = false</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>extern bool activeFlag;</p>

<p class=CodeChar style='margin-left:0in'>#define MEM_ON() activeFlag = true</p>

<p class=CodeChar style='margin-left:0in'>#define MEM_OFF() activeFlag = false</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It is important that you include this file in any source
file in which you want to track free store activity, but you must include it <i>last</i>
(after your other <b>#include</b> directives). Most headers in the standard
library are templates, and since most compilers use the <i>inclusion model</i>
of template compilation (meaning all source code is in the headers), the macro
that replaces <b>new</b> in <b>MemCheck.h</b> would usurp all instances of the <b>new</b>
operator in the library source code (and would likely result in compile
errors). Besides, you are only interested in tracking your own memory errors,
not the library’s. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1559"
title="Add Comment A1559">Comment</a></sup></p>

<p class=MsoNormal>In the following file, which contains the memory tracking
implementation, everything is done with C standard I/O rather than with C++
iostreams. It shouldn’t make a difference, really, since we’re not interfering
with iostreams’ use of the free store, but it’s safer to not take a chance.
(Besides, we tried it. Some compilers complained, but all compilers were happy
with the <b>&lt;stdio&gt;</b> version.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1551"
title="Add Comment A1551">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>//:
C02:MemCheck.cpp {O}</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>#include
&lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>#undef new</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Global flags set by macros in
MemCheck.h</p>

<p class=CodeChar style='margin-left:0in'>bool traceFlag = true;</p>

<p class=CodeChar style='margin-left:0in'>bool activeFlag = false;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>namespace {</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Memory map entry type</p>

<p class=CodeChar style='margin-left:0in'>struct Info {</p>

<p class=CodeChar style='margin-left:0in'>  void* ptr;</p>

<p class=CodeChar style='margin-left:0in'>  const char* file;</p>

<p class=CodeChar style='margin-left:0in'>  long line;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Memory map data</p>

<p class=CodeChar style='margin-left:0in'>const size_t MAXPTRS = 10000u;</p>

<p class=CodeChar style='margin-left:0in'>Info memMap[MAXPTRS];</p>

<p class=CodeChar style='margin-left:0in'>size_t nptrs = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Searches the map for an address</p>

<p class=CodeChar style='margin-left:0in'>int findPtr(void* p) {</p>

<p class=CodeChar style='margin-left:0in'>  for (int i = 0; i &lt; nptrs; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    if (memMap[i].ptr == p)</p>

<p class=CodeChar style='margin-left:0in'>      return i;</p>

<p class=CodeChar style='margin-left:0in'>  return -1;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void delPtr(void* p) {</p>

<p class=CodeChar style='margin-left:0in'>  int pos = findPtr(p);</p>

<p class=CodeChar style='margin-left:0in'>  assert(p &gt;= 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Remove pointer from map</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = pos; i &lt;
nptrs-1; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>memMap[i] =
memMap[i+1];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  --nptrs;</span></p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Dummy type for static destructor</p>

<p class=CodeChar style='margin-left:0in'>struct Sentinel {</p>

<p class=CodeChar style='margin-left:0in'>  ~Sentinel() {</p>

<p class=CodeChar style='margin-left:0in'>    if (nptrs &gt; 0) {</p>

<p class=CodeChar style='margin-left:0in'>      printf(&quot;Leaked memory
at:\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>      for (size_t i = 0; i &lt;
nptrs; ++i)</p>

<p class=CodeChar style='margin-left:0in'>        printf(&quot;\t%p (file: %s,
line %ld)\n&quot;,</p>

<p class=CodeChar style='margin-left:0in'>          <span lang=SV>memMap[i].ptr,
memMap[i].file, memMap[i].line);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>}</p>

<p class=CodeChar style='margin-left:0in'>    else</p>

<p class=CodeChar style='margin-left:0in'>      printf(&quot;No user memory
leaks!\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Static dummy object</p>

<p class=CodeChar style='margin-left:0in'>Sentinel s;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>} // End anonymous namespace</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Overload scalar new</p>

<p class=CodeChar style='margin-left:0in'>void* operator new(size_t siz, const
char* file,</p>

<p class=CodeChar style='margin-left:0in'>  long line) {</p>

<p class=CodeChar style='margin-left:0in'>  void* p = malloc(siz);</p>

<p class=CodeChar style='margin-left:0in'>  if (activeFlag) {</p>

<p class=CodeChar style='margin-left:0in'>    if (nptrs == MAXPTRS) {</p>

<p class=CodeChar style='margin-left:0in'>      printf(&quot;memory map too
small (increase MAXPTRS)\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>      exit(1);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    memMap[nptrs].ptr = p;</p>

<p class=CodeChar style='margin-left:0in'>    memMap[nptrs].file = file;</p>

<p class=CodeChar style='margin-left:0in'>    memMap[nptrs].line = line;</p>

<p class=CodeChar style='margin-left:0in'>    ++nptrs;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  if (traceFlag) {</p>

<p class=CodeChar style='margin-left:0in'>    printf(&quot;Allocated %u bytes
at address %p &quot;, siz, p);</p>

<p class=CodeChar style='margin-left:0in'>    printf(&quot;(file: %s, line:
%ld)\n&quot;, file, line);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return p;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Overload
array new</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>void* operator
new[](size_t siz, const char* file,</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  long line) {</p>

<p class=CodeChar style='margin-left:0in'>  return operator new(siz, file,
line);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Override
scalar delete</p>

<p class=CodeChar style='margin-left:0in'>void operator delete(void* p) {</p>

<p class=CodeChar style='margin-left:0in'>  if (findPtr(p) &gt;= 0) {</p>

<p class=CodeChar style='margin-left:0in'>    free(p);</p>

<p class=CodeChar style='margin-left:0in'>    assert(nptrs &gt; 0);</p>

<p class=CodeChar style='margin-left:0in'>    delPtr(p);</p>

<p class=CodeChar style='margin-left:0in'>    if (traceFlag)</p>

<p class=CodeChar style='margin-left:0in'>      printf(&quot;Deleted memory at
address %p\n&quot;, p);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  else if (!p &amp;&amp; activeFlag)</p>

<p class=CodeChar style='margin-left:0in'>    printf(&quot;Attempt to delete
unknown pointer: %p\n&quot;, p);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Override array delete</p>

<p class=CodeChar style='margin-left:0in'>void operator delete[](void* p) {</p>

<p class=CodeChar style='margin-left:0in'>  operator delete(p);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The Boolean flags <b>traceFlag</b> and <b>activeFlag</b> are
global, so they can be modified in your code by the macros <b>TRACE_ON(&nbsp;)</b>,
<b>TRACE_OFF(&nbsp;)</b>, <b>MEM_ON(&nbsp;)</b>, and <b>MEM_OFF(&nbsp;)</b>. In
general, enclose all the code in your <b>main(&nbsp;)</b> within a <b>MEM_ON(&nbsp;)</b>-<b>MEM_OFF(&nbsp;)</b>
pair so that memory is always tracked. Tracing, which echoes the activity of
the replacement functions for <b>operator new(&nbsp;)</b> and <b>operator
delete(&nbsp;)</b>, is on by default, but you can turn it off with <b>TRACE_OFF(&nbsp;)</b>.
In any case, the final results are always printed (see the test runs later in
this chapter).</p>

<p class=MsoNormal>The <b>MemCheck</b> facility tracks memory by keeping all
addresses allocated by <b>operator new(&nbsp;)</b> in an array of <b>Info</b>
structures, which also holds the file name and line number where the call to <b>new</b>
occurred. As much information as possible is kept inside the anonymous
namespace so as not to collide with any names you might have placed in the
global namespace. The <b>Sentinel</b> class exists solely to have a static
object’s destructor called as the program shuts down. This destructor inspects <b>memMap</b>
to see if any pointers are waiting to be deleted (in which case you have a
memory leak). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1558"
title="Add Comment A1558">Comment</a></sup></p>

<p class=MsoNormal>Our <b>operator new(&nbsp;)</b> uses <b>malloc(&nbsp;)</b>
to get memory, and then adds the pointer and its associated file information to
<b>memMap</b>. The <b>operator delete(&nbsp;)</b> function undoes all that work
by calling <b>free(&nbsp;)</b> and decrementing <b>nptrs</b>, but first it
checks to see if the pointer in question is in the map in the first place. If
it isn’t, either you’re trying to delete an address that isn’t on the free
store, or you’re trying to delete one that’s already been deleted and therefore
previously removed from the map. The <b>activeFlag</b> variable is important
here because we don’t want to process any deallocations from any system
shutdown activity. By calling <b>MEM_OFF(&nbsp;)</b> at the end of your code, <b>activeFlag</b>
will be set to <b>false</b>, and such subsequent calls to <b>delete</b> will be
ignored. (Of course, that’s bad in a real program, but as we said earlier, our
purpose here is to find <i>your</i> leaks; we’re not debugging the library.)
For simplicity, we forward all work for array <b>new</b> and <b>delete</b> to
their scalar counterparts. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1554"
title="Add Comment A1554">Comment</a></sup></p>

<p class=MsoNormal>The following is a simple test using the <b>MemCheck</b>
facility.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C02:MemTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} MemCheck</p>

<p class=CodeChar style='margin-left:0in'>// Test of MemCheck system</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;MemCheck.h&quot;   //
Must appear last!</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Foo {</p>

<p class=CodeChar style='margin-left:0in'>  char* s;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Foo(const char*s ) {</p>

<p class=CodeChar style='margin-left:0in'>    this-&gt;s = new char[strlen(s) +
1];</p>

<p class=CodeChar style='margin-left:0in'>    strcpy(this-&gt;s, s);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Foo() {</p>

<p class=CodeChar style='margin-left:0in'>    delete [] s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  MEM_ON();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;hello\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  int* p = new int;</p>

<p class=CodeChar style='margin-left:0in'>  delete p;</p>

<p class=CodeChar style='margin-left:0in'>  int* q = new int[3];</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>delete [] q;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  int* r;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  delete r;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>vector&lt;int&gt;
v;</p>

<p class=CodeChar style='margin-left:0in'>  v.push_back(1);</p>

<p class=CodeChar style='margin-left:0in'>  Foo s(&quot;goodbye&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  MEM_OFF();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example verifies that you can use <b>MemCheck</b> in
the presence of streams, standard containers, and classes that allocate memory
in constructors. The pointers <b>p</b> and <b>q</b> are allocated and
deallocated without any problem, but <b>r</b> is not a valid heap pointer, so
the output indicates the error as an attempt to delete an unknown pointer. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1557"
title="Add Comment A1557">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>hello</p>

<p class=CodeChar style='margin-left:0in'>Allocated 4 bytes at address
0xa010778 (file: memtest.cpp, line: 25)</p>

<p class=CodeChar style='margin-left:0in'>Deleted memory at address 0xa010778</p>

<p class=CodeChar style='margin-left:0in'>Allocated 12 bytes at address
0xa010778 (file: memtest.cpp, line: 27)</p>

<p class=CodeChar style='margin-left:0in'>Deleted memory at address 0xa010778</p>

<p class=CodeChar style='margin-left:0in'>Attempt to delete unknown pointer:
0x1</p>

<p class=CodeChar style='margin-left:0in'>Allocated 8 bytes at address
0xa0108c0 (file: memtest.cpp, line: 14)</p>

<p class=CodeChar style='margin-left:0in'>Deleted memory at address 0xa0108c0</p>

<p class=CodeChar style='margin-left:0in'>No user memory leaks!</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Because of the call to <b>MEM_OFF(&nbsp;)</b>, no subsequent
calls to <b>operator delete(&nbsp;)</b> by <b>vector</b> or <b>ostream</b> are
processed. You still might get some calls to <b>delete</b> from reallocations
performed by the containers. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1555"
title="Add Comment A1555">Comment</a></sup></p>

<p class=MsoNormal>If you call <b>TRACE_OFF(&nbsp;)</b> at the beginning of the
program, the output is as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>hello</p>

<p class=CodeChar style='margin-left:0in'>Attempt to delete unknown pointer:
0x1</p>

<p class=CodeChar style='margin-left:0in'>No user memory leaks! <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1556"
title="Add Comment A1556"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45439990">Summary</a></h2>

<p class=MsoNormal>Much of the headache of software engineering can be avoided
by being very deliberate about what you’re doing. You’ve probably been using
mental assertions as you’ve crafted your loops and functions anyway, even if
you haven’t routinely used the <b>assert(&nbsp;)</b> macro. If you’ll use <b>assert(&nbsp;)</b>,
you’ll find logic errors sooner and end up with more readable code as well.
Remember to only use assertions for invariants, though, and not for runtime
error handling.</p>

<p class=MsoNormal>Nothing will give you more peace of mind than thoroughly
tested code. If it’s been a hassle for you in the past, use an automated
framework, such as the one we’ve presented here, to integrate routine testing
into your daily work. You (and your users!) will be glad you did.</p>

<h2 style='margin-left:0in'><a name="_Toc45439991">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a test program using the <b>TestSuite</b> Framework for the
standard vector class that thoroughly tests the following member functions with
a vector of integers: <b>push_back(&nbsp;)</b> (appends an element to the end
of the vector), <b>front(&nbsp;)</b> (returns the first element in the vector),
<b>back(&nbsp;)</b> (returns the last element in the vector), <b>pop_back(&nbsp;)</b>
(removes the last element without returning it), <b>at(&nbsp;)</b> (returns the
element in a specified index position), and <b>size(&nbsp;)</b> (returns the
number of elements). Be sure to verify that <b>vector::at(&nbsp;)</b> throws a <b>std::out_of_range</b>
exception if the supplied index is out of range.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Suppose you are asked to develop a class named <b>Rational</b>
that supports rational numbers (fractions). The fraction in a <b>Rational</b>
object should always be stored in lowest terms, and a denominator of zero is an
error. Here is a sample interface for such a <b>Rational</b> class:<br>
<br>
</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>class Rational {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   Rational(int numerator = 0, int
denominator = 1);</p>

<p class=CodeChar style='margin-left:0in'>   Rational operator-() const;</p>

<p class=CodeChar style='margin-left:0in'>   friend Rational operator+(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                             const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend Rational operator-(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                             const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend Rational operator*(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                             const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend Rational operator/(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                             const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend ostream&amp;
operator&lt;&lt;(ostream&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                              const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend istream&amp;
operator&gt;&gt;(istream&amp;, Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   Rational&amp; operator+=(const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   Rational&amp; operator-=(const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   Rational&amp; operator*=(const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   Rational&amp; operator/=(const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator&lt;(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                         const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator&gt;(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                         const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator&lt;=(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                          const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator&gt;=(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                          const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator==(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                          const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>   friend bool operator!=(const
Rational&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                          const
Rational&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=Exercises style='text-indent:0in'>Write a complete specification for
this class, including pre-conditions, post-conditions, and exception
specifications.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a test using the <b>TestSuite</b> framework that thoroughly
tests all the specifications from the previous exercise, including testing
exceptions.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Implement the <b>Rational</b> class so that all the tests from
the previous exercise pass. Use assertions only for invariants.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The file <b>BuggedSearch.cpp</b> below contains a binary search
function that searches the range <b>[beg, end)</b> for <b>what</b>.   There are
some bugs in the algorithm.  Use the trace techniques from this chapter to
debug the search function.</p>

<p class=Exercises>&nbsp;</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// BuggedSearch.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// This function is only one with
bugs</p>

<p class=CodeChar style='margin-left:0in'>int* binarySearch(int* beg, int* end,
int what) {</p>

<p class=CodeChar style='margin-left:0in'>  while(end - beg != 1) {</p>

<p class=CodeChar style='margin-left:0in'>    if(*beg == what) return beg;</p>

<p class=CodeChar style='margin-left:0in'>    int mid = (end - beg) / 2;</p>

<p class=CodeChar style='margin-left:0in'>    if(what &lt;= beg[mid]) end = beg
+ mid;</p>

<p class=CodeChar style='margin-left:0in'>    else beg = beg + mid;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return 0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>class BinarySearchTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>  enum { SZ = 10 };</p>

<p class=CodeChar style='margin-left:0in'>  int* data;</p>

<p class=CodeChar style='margin-left:0in'>  int max; //Track largest number</p>

<p class=CodeChar style='margin-left:0in'>  int current; // Current
non-contained number</p>

<p class=CodeChar style='margin-left:0in'>               // Used in
notContained()</p>

<p class=CodeChar style='margin-left:0in'>  // Find the next number not
contained in the array</p>

<p class=CodeChar style='margin-left:0in'>  int notContained() {</p>

<p class=CodeChar style='margin-left:0in'>    while(data[current] + 1 ==
data[current + 1])</p>

<p class=CodeChar style='margin-left:0in'>     current++;</p>

<p class=CodeChar style='margin-left:0in'>    if(current &gt;= SZ) return max +
1;</p>

<p class=CodeChar style='margin-left:0in'>    int retValue = data[current++] +
1;</p>

<p class=CodeChar style='margin-left:0in'>    return retValue;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void setData() {</p>

<p class=CodeChar style='margin-left:0in'>    data = new int[SZ];</p>

<p class=CodeChar style='margin-left:0in'>    assert(!max);</p>

<p class=CodeChar style='margin-left:0in'>    // Input values with increments
of one.  Leave</p>

<p class=CodeChar style='margin-left:0in'>    // out some values on both odd
and even indexes.</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; SZ;</p>

<p class=CodeChar style='margin-left:0in'>        rand() % 2 == 0 ? max += 1 :
max += 2)</p>

<p class=CodeChar style='margin-left:0in'>      data[i++] = max;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testInBound() {</p>

<p class=CodeChar style='margin-left:0in'>    // Test locations both odd and
even</p>

<p class=CodeChar style='margin-left:0in'>    // not contained and contained</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = SZ; --i &gt;=0;)</p>

<p class=CodeChar style='margin-left:0in'>      test_(binarySearch(data, data +
SZ, data[i]));</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = notContained(); i
&lt; max;</p>

<p class=CodeChar style='margin-left:0in'>                                  i =
notContained())</p>

<p class=CodeChar style='margin-left:0in'>      test_(!binarySearch(data, data
+ SZ, i));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testOutBounds() {</p>

<p class=CodeChar style='margin-left:0in'>    // Test lower values</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = data[0]; --i &gt;
data[0] - 100;)</p>

<p class=CodeChar style='margin-left:0in'>      test_(!binarySearch(data, data
+ SZ, i));</p>

<p class=CodeChar style='margin-left:0in'>    // Test higher values</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = data[SZ - 1];</p>

<p class=CodeChar style='margin-left:0in'>        ++i &lt; data[SZ -1] + 100;)</p>

<p class=CodeChar style='margin-left:0in'>      test_(!binarySearch(data, data
+ SZ, i));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  BinarySearchTest() {</p>

<p class=CodeChar style='margin-left:0in'>    max = current = 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>    setData();</p>

<p class=CodeChar style='margin-left:0in'>    testInBound();</p>

<p class=CodeChar style='margin-left:0in'>    testOutBounds();</p>

<p class=CodeChar style='margin-left:0in'>    delete [] data;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  BinarySearchTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section9>

<h1 style='margin-left:0in'><span style='position:relative;z-index:3'><span
style='left:0px;position:absolute;left:-122px;top:-105px;width:734px;
height:118px'>

<table cellpadding=0 cellspacing=0>
 <tr>
  <td width=734 height=118 bgcolor=white style='vertical-align:top;background:
  white'><span style='position:absolute;left:0pt;z-index:3'>
  <table cellpadding=0 cellspacing=0 width="100%">
   <tr>
    <td>
    <div style='padding:3.6pt 7.2pt 3.6pt 7.2pt'>
    <p class=Partbleed>&nbsp;</p>
    <p class=Partbleed>          Part 2</p>
    </div>
    </td>
   </tr>
  </table>
  </span>&nbsp;</td>
 </tr>
</table>

</span></span><a name="_Toc45439992"></a><a name="_Toc15743849"></a><a
name=part2></a>The Standard C++ Library</h1>

<p class=Intro>Standard C++ not only incorporates all the Standard C libraries
(with small additions and changes to support type safety), it also adds
libraries of its own. These libraries are far more powerful than those in
Standard C; the leverage you get from them is analogous to the leverage you get
from changing from C to C++.</p>

<p class=MsoNormal>This part of the book gives you an in-depth introduction to
key portions of the Standard C++ library. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0241"
title="Add Comment A0241">Comment</a></sup></p>

<p class=MsoNormal>The most complete and also the most obscure reference to the
full libraries is the Standard itself. Bjarne Stroustrup’s <i>The C++
Programming Language, Third Edition </i>(Addison-Wesley, 2000) remains a
reliable reference for both the language and the library. The most celebrated
library-only reference is <i>The C++ Standard Library: A Tutorial and Reference</i>,
by Nicolai Josuttis (Addison-Wesley, 1999). The goal of the chapters in this
part of the book is to provide you with an encyclopedia of descriptions and
examples so that you’ll have a good starting point for solving any problem that
requires the use of the Standard libraries. However, some techniques and topics
are rarely used and are not covered here. If you can’t find it in these
chapters, reach for the other two books; this book is not intended to replace
those books but rather to complement them. In particular, we hope that after
going through the material in the following chapters you’ll have a much easier
time understanding those books. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0242"
title="Add Comment A0242">Comment</a></sup></p>

<p class=MsoNormal>You will notice that these chapters do not contain
exhaustive documentation describing every function and class in the Standard
C++ library. We’ve left the full descriptions to others; in particular to P.J.
Plauger’s <i>Dinkumware C/C++ Library Reference</i> at
http://www.dinkumware.com. This is an excellent online source of standard
library documentation in HTML format that you can keep resident on your
computer and view with a Web browser whenever you need to look up something. .
You can view this online and purchase it for local viewing. It contains
complete reference pages for the both the C and C++ libraries (so it’s good to
use for all your Standard C/C++ programming questions). Electronic
documentation is effective not only because you can always have it with you,
but also because you can do an electronic search for what you want. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0243"
title="Add Comment A0243">Comment</a></sup></p>

<p class=MsoNormal>When you’re actively programming, these resources should
adequately satisfy your reference needs (and you can use them to look up
anything in this chapter that isn’t clear to you). Appendix A lists additional
references. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0244"
title="Add Comment A0244">Comment</a></sup></p>

<p class=MsoNormal>The first chapter in this section introduces the Standard
C++ <b>string</b> class, which is a powerful tool that simplifies most of the
text-processing chores you might have. The <b>string</b> class might be the
most thorough string manipulation tool you’ve ever seen. Chances are, anything
you’ve done to character strings with lines of code in C can be done with a
member function call in the string class. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0246"
title="Add Comment A0246">Comment</a></sup></p>

<p class=MsoNormal>Chapter 4 covers the <b>iostreams</b> library, which
contains classes for processing input and output with files, string targets,
and the system console. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0247"
title="Add Comment A0247">Comment</a></sup></p>

<p class=MsoNormal>Although Chapter 5, “Templates in Depth,” is not explicitly
a library chapter, it is necessary preparation for the two that follow. In
Chapter 6 we examine the generic algorithms offered by the Standard C++
library. Because they are implemented with templates, these algorithms can be
applied to any <i>sequence</i> of objects. Chapter 7 covers the standard
containers and their associated iterators. We cover algorithms first because
they can be fully explored by using only arrays and the vector container (which
we have been using since early in Volume 1). It is also natural to use the standard
algorithms in connection with containers, so it’s a good idea to be familiar
with the algorithm before studying the containers.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><a name="_Toc15743850"><sup>&nbsp;</sup></a></p>

<h1 style='margin-left:-81.35pt'><a name="_Toc45439993">3: Strings in depth</a></h1>

<p class=Intro>One of the biggest time-wasters in C is using character arrays
for string processing: keeping track of the difference between static quoted
strings and arrays created on the stack and the heap, and the fact that
sometimes you’re passing around a <b>char*</b> and sometimes you must copy the
whole array.</p>

<p class=MsoNormal><a name=StringsChapter></a>Especially because string
manipulation is so common, character arrays are a great source of
misunderstandings and bugs. Despite this, creating string classes remained a
common exercise for beginning C++ programmers for many years. The Standard C++
library <b>string</b> class solves the problem of character array manipulation
once and for all, keeping track of memory even during assignments and
copy-constructions. You simply don’t need to think about it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0258"
title="Add Comment A0258">Comment</a></sup></p>

<p class=MsoNormal>This chapter examines the Standard C++ <b>string</b> class,
beginning with a look at what constitutes a C++ string and how the C++ version
differs from a traditional C character array.  You’ll learn about operations
and manipulations using <b>string</b> objects, and you’ll see how C++ <b>string</b>s
accommodate variation in character sets and string data conversion.<a
href="#_ftn28" name="_ftnref28" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[28]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0259"
title="Add Comment A0259">Comment</a></sup></p>

<p class=MsoNormal>Handling text is perhaps one of the oldest of all programming
applications, so it’s not surprising that the C++ <b>string</b> draws heavily
on the ideas and terminology that have long been used for this purpose in C and
other languages. As you begin to acquaint yourself with C++ <b>string</b>s,
this fact should be reassuring. No matter which programming idiom you choose,
there are really only about three things you want to do with a <b>string</b>: </p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create or modify the sequence of characters stored in the <b>string</b>.
</p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Detect the presence or absence of elements within the <b>string</b>.
</p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Translate between various schemes for representing <b>string</b>
characters. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0260"
title="Add Comment A0260">Comment</a></sup></p>

<p class=MsoNormal>You’ll see how each of these jobs is accomplished using C++ <b>string</b>
objects. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0261"
title="Add Comment A0261">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439994"></a><a name="_Toc15743851">What’s
in a string?</a></h2>

<p class=MsoNormal>In C, a string is simply an array of characters that always
includes a binary zero (often called the <i>null terminator</i>) as its final
array element. There are significant differences between C++ <b>string</b>s and
their C progenitors. First, and most important, C++ strings hide the physical
representation of the sequence of characters they contain. You don’t have to be
concerned at all about array dimensions or null terminators. A <b>string</b>
also contains certain “housekeeping” information about the size and storage
location of its data. Specifically, a C++ <b>string</b> object knows its
starting location in memory, its content, its length in characters, and the
length in characters to which it can grow before the <b>string</b> object must
resize its internal data buffer. C++ strings therefore greatly reduce the
likelihood of making three of the most common and destructive C programming
errors: overwriting array bounds, trying to access arrays through uninitialized
or incorrectly valued pointers, and leaving pointers “dangling” after an array
ceases to occupy the storage that was once allocated to it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0262"
title="Add Comment A0262">Comment</a></sup></p>

<p class=MsoNormal>The exact implementation of memory layout for the string
class is not defined by the C++ Standard. This architecture is intended to be
flexible enough to allow differing implementations by compiler vendors, yet
guarantee predictable behavior for users. In particular, the exact conditions
under which storage is allocated to hold data for a string object are not
defined. String allocation rules were formulated to allow but not require a
reference-counted implementation, but whether or not the implementation uses
reference counting, the semantics must be the same. To put this a bit
differently, in C, every <b>char</b> array occupies a unique physical region of
memory. In C++, individual <b>string</b> objects may or may not occupy unique
physical regions of memory, but if reference counting is used to avoid storing
duplicate copies of data, the individual objects must look and act as though
they do exclusively own unique regions of storage. For example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0263"
title="Add Comment A0263">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StringStorage.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class StringStorageTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    string s1(&quot;12345&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    // This may copy the first to the
second or </p>

<p class=CodeChar style='margin-left:0in'>    // use reference counting to
simulate a copy </p>

<p class=CodeChar style='margin-left:0in'>    string s2 = s1;</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 == s2);</p>

<p class=CodeChar style='margin-left:0in'>    // Either way, this statement must
ONLY modify s1</p>

<p class=CodeChar style='margin-left:0in'>    s1[0] = '6';</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;s1 = &quot;
&lt;&lt; s1 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;s2 = &quot;
&lt;&lt; s2 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 != s2);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  StringStorageTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>An implementation that only makes unique copies when a
string is modified is said to use a <i>copy-on-write</i> strategy. This
approach saves time and space when strings are used only as value parameters or
in other read-only situations.</p>

<p class=MsoNormal>Whether a library implementation uses reference counting or
not should be transparent to users of the <b>string</b> class. Unfortunately,
this is not always the case. In multithreaded programs, it is practically
impossible to use a reference-counting implementation safely.<a href="#_ftn29"
name="_ftnref29" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[29]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0264"
title="Add Comment A0264">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45439995"></a><a name="_Toc15743852"></a><a
name="_Toc424692472">Creating and initializing C++ strings</a></h2>

<p class=MsoNormal>Creating and initializing strings is a straightforward
proposition and fairly flexible. In the <b>SmallString.cpp</b> example in this
section, the first <b>string</b>, <b>imBlank</b>, is declared but contains no
initial value. Unlike a C <b>char</b> array, which would contain a random and
meaningless bit pattern until initialization, <b>imBlank</b> does contain
meaningful information. This <b>string</b> object has been initialized to hold
“no characters” and can properly report its zero length and absence of data
elements through the use of class member functions.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0265"
title="Add Comment A0265">Comment</a></sup></p>

<p class=MsoNormal>The next string, <b>heyMom</b>, is initialized by the
literal argument &quot;Where are my socks?&quot; This form of initialization
uses a quoted character array as a parameter to the <b>string</b> constructor.
By contrast, <b>standardReply</b> is simply initialized with an assignment. The
last string of the group, <b>useThisOneAgain</b>, is initialized using an
existing C++ <b>string</b> object. Put another way, this example illustrates
that <b>string</b> objects let you do the following: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0266"
title="Add Comment A0266">Comment</a></sup></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create an empty <b>string</b> and defer initializing it with
character data. </p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Initialize a <b>string</b> by passing a literal, quoted character
array as an argument to the constructor. </p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Initialize a <b>string</b> using the equal sign (<b>=</b>).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use one <b>string</b> to initialize another. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0270"
title="Add Comment A0270">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><a name="_Toc424692473">//:
C03:SmallString.cpp</a></p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string imBlank;</p>

<p class=CodeChar style='margin-left:0in'>  string heyMom(&quot;Where are my
socks?&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string standardReply = &quot;Beamed
into deep &quot;</p>

<p class=CodeChar style='margin-left:0in'>    &quot;space on wide angle
dispersion?&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  string
useThisOneAgain(standardReply);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>These are the simplest forms of <b>string</b>
initialization, but  variations offer more flexibility and control. You can do
the following: </p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='margin-left:.5in'>Use a portion of either a C <b>char</b>
     array or a C++ <b>string</b>. </li>
 <li class=MsoNormal style='margin-left:.5in'>Combine different sources of
     initialization data using <b>operator+</b>. </li>
 <li class=MsoNormal style='margin-left:.5in'>Use the <b>string</b> object’s <b>substr(&nbsp;)</b>
     member function to create a substring. <a
     href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0274"
     title="Add Comment A0274"><sup>Comment</sup></a></li>
</ul>

<p class=MsoNormal style='margin-left:0in'>Here’s a program that illustrates
these features.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:SmallString2.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s1</p>

<p class=CodeChar style='margin-left:0in'>    (&quot;What is the sound of one
clam napping?&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s2</p>

<p class=CodeChar style='margin-left:0in'>    (&quot;Anything worth doing is
worth overdoing.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s3(&quot;I saw Elvis in a
UFO&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Copy the first 8 chars</p>

<p class=CodeChar style='margin-left:0in'>  string s4(s1, 0, 8);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s4 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Copy 6 chars from the middle of
the source</p>

<p class=CodeChar style='margin-left:0in'>  string s5(s2, 15, 6);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s5 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Copy from middle to end</p>

<p class=CodeChar style='margin-left:0in'>  string s6(s3, 6, 15);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s6 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Copy all sorts of stuff</p>

<p class=CodeChar style='margin-left:0in'>  string quoteMe = s4 +
&quot;that&quot; +  </p>

<p class=CodeChar style='margin-left:0in'>  // substr() copies 10 chars at
element 20</p>

<p class=CodeChar style='margin-left:0in'>  s1.substr(20, 10) + s5 +</p>

<p class=CodeChar style='margin-left:0in'>  // substr() copies up to either 100
char</p>

<p class=CodeChar style='margin-left:0in'>  // or eos starting at element 5 </p>

<p class=CodeChar style='margin-left:0in'>  &quot;with&quot; + s3.substr(5,
100) +</p>

<p class=CodeChar style='margin-left:0in'>  // OK to copy a single char this
way </p>

<p class=CodeChar style='margin-left:0in'>  s1.substr(37, 1);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; quoteMe &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>string</b> member function <b>substr(&nbsp;)</b>
takes a starting position as its first argument and the number of characters to
select as the second argument. Both arguments have default values. If you say <b>substr(&nbsp;)</b>
with an empty argument list, you produce a copy of the entire <b>string</b>; so
this is a convenient way to duplicate a <b>string</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0275"
title="Add Comment A0275"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here’s the output from the program: </p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>What is </p>

<p class=CodeChar style='margin-left:0in'>doing </p>

<p class=CodeChar style='margin-left:0in'>Elvis in a UFO</p>

<p class=CodeChar style='margin-left:0in'>What is that one clam doing with
Elvis in a UFO?</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice the final line of the example. C++ allows <b>string</b>
initialization techniques to be mixed in a single statement, a flexible and
convenient feature. Also notice that the last initializer copies <i>just one
character</i> from the source <b>string</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0277"
title="Add Comment A0277"><sup>Comment</sup></a></p>

<p class=MsoNormal>Another slightly more subtle initialization technique
involves the use of the <b>string</b> iterators <b>string::begin(&nbsp;)</b>
and <b>string::end(&nbsp;).</b> This technique treats a <b>string</b> like a <i>container</i>
object (which you’ve seen primarily in the form of <b>vector</b> so far—you’ll
see many more containers in Chapter 7), which uses <i>iterators</i> to indicate
the start and end of a sequence of characters. In this way you can hand a <b>string</b>
constructor two iterators, and it copies from one to the other into the new <b>string</b>:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0278"
title="Add Comment A0278"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StringIterators.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string source(&quot;xxx&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s(source.begin(),
source.end());</p>

<p class=CodeChar style='margin-left:0in'>  assert(s == source);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The iterators are not restricted to <b>begin(&nbsp;)</b> and
<b>end(&nbsp;)</b>; you can increment, decrement, and add integer offsets to
them, allowing you to extract a subset of characters from the source <b>string</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0279"
title="Add Comment A0279"><sup>Comment</sup></a></p>

<p class=MsoNormal>C++ strings may <i>not</i> be initialized with single
characters or with ASCII or other integer values. You can initialize a string
with a number of copies of a single character, however. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0280"
title="Add Comment A0280">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:UhOh.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Error: no single char inits</p>

<p class=CodeChar style='margin-left:0in'>  //! string nothingDoing1('a');</p>

<p class=CodeChar style='margin-left:0in'>  // Error: no integer inits</p>

<p class=CodeChar style='margin-left:0in'>  //! string nothingDoing2(0x37);</p>

<p class=CodeChar style='margin-left:0in'>  // The following is legal:</p>

<p class=CodeChar style='margin-left:0in'>  string okay(5, 'a');</p>

<p class=CodeChar style='margin-left:0in'>  assert(okay == string(&quot;aaaaa&quot;));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45439996"></a><a name="_Toc15743853">Operating
on strings</a></h2>

<p class=MsoNormal>If you’ve programmed in C, you are accustomed to the
convenience of a large family of functions for writing, searching, modifying,
and copying <b>char</b> arrays. However, there are two unfortunate aspects of
the Standard C library functions for handling <b>char</b> arrays. First, there
are two loosely organized families of them: the “plain” group, and the ones
that require you to supply a count of the number of characters to be considered
in the operation at hand. The roster of functions in the C <b>char</b> array
handling library shocks the unsuspecting user with a long list of cryptic,
mostly unpronounceable names. Although the kinds and number of arguments to the
functions are somewhat consistent, to use them properly you must be attentive
to details of function naming and parameter passing. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0282"
title="Add Comment A0282">Comment</a></sup></p>

<p class=MsoNormal>The second inherent trap of the standard C <b>char</b> array
tools is that they all rely explicitly on the assumption that the character
array includes a null terminator. If by oversight or error the null is omitted
or overwritten, there’s little to keep the C <b>char</b> array handling
functions from manipulating the memory beyond the limits of the allocated
space, sometimes with disastrous results. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0283"
title="Add Comment A0283">Comment</a></sup></p>

<p class=MsoNormal>C++ provides a vast improvement in the convenience and
safety of <b>string</b> objects. For purposes of actual string handling
operations, there are about the same number of distinct member function names
in the <b>string</b> class as there are functions in the C library, but because
of overloading there is much more functionality. Coupled with sensible naming
practices and the judicious use of default arguments, these features combine to
make the <b>string</b> class much easier to use than the C library. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0284"
title="Add Comment A0284">Comment</a></sup></p>

<h3><a name="_Toc45439997"></a><a name="_Toc15743854">Appending, inserting, <br>
</a><a>and </a><span class=MsoCommentReference><span style='font-size:8.0pt;
font-family:Times;font-weight:normal'><a class=msocomanchor id="_anchor_5"
onmouseover="msoCommentShow('_anchor_5','_com_5')"
onmouseout="msoCommentHide('_com_5')" href="#_msocom_5" language=JavaScript
name="_msoanchor_5">[DwH5]</a><span style='display:none'>&nbsp;</span></span></span>concatenating
strings</h3>

<p class=MsoNormal>One of the most valuable and convenient aspects of C++
strings is that they grow as needed, without intervention on the part of the
programmer. Not only does this make string-handling code inherently more
trustworthy, it also almost entirely eliminates a tedious “housekeeping”
chore—keeping track of the bounds of the storage in which your strings live.
For example, if you create a string object and initialize it with a string of
50 copies of ‘X’, and later store in it 50 copies of “Zowie”, the object itself
will reallocate sufficient storage to accommodate the growth of the data.
Perhaps nowhere is this property more appreciated than when the strings
manipulated in your code change size and you don’t know how big the change is.
Appending, concatenating, and inserting strings often give rise to this
circumstance, but the string member functions <b>append(&nbsp;)</b> and <b>insert(&nbsp;)</b>
transparently reallocate storage when a string grows. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0285"
title="Add Comment A0285">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StrSize.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string bigNews(&quot;I saw Elvis in
a UFO. &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; bigNews &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  // How much data have we actually
got?</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Size = &quot;
&lt;&lt; bigNews.size() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // How much can we store without
reallocating</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Capacity =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; bigNews.capacity()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Insert this string in bigNews
immediately</p>

<p class=CodeChar style='margin-left:0in'>  // before bigNews[1]</p>

<p class=CodeChar style='margin-left:0in'>  bigNews.insert(1, &quot; thought
I&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; bigNews &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Size = &quot;
&lt;&lt; bigNews.size() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Capacity =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; bigNews.capacity()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Make sure that there will be
this much space</p>

<p class=CodeChar style='margin-left:0in'>  bigNews.reserve(500);</p>

<p class=CodeChar style='margin-left:0in'>  // Add this to the end of the
string</p>

<p class=CodeChar style='margin-left:0in'>  bigNews.append(&quot;I've been
working too hard.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; bigNews &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Size = &quot;
&lt;&lt; bigNews.size() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Capacity =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; bigNews.capacity()
&lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here is the output from one particular compiler: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0286"
title="Add Comment A0286">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>I saw Elvis in a UFO.</p>

<p class=CodeChar style='margin-left:0in'>Size = 22</p>

<p class=CodeChar style='margin-left:0in'>Capacity = 31</p>

<p class=CodeChar style='margin-left:0in'>I thought I saw Elvis in a UFO.</p>

<p class=CodeChar style='margin-left:0in'>Size = 32</p>

<p class=CodeChar style='margin-left:0in'>Capacity = 47</p>

<p class=CodeChar style='margin-left:0in'>I thought I saw Elvis in a UFO. I've
been </p>

<p class=CodeChar style='margin-left:0in'>working too hard.</p>

<p class=CodeChar style='margin-left:0in'>Size = 59</p>

<p class=CodeInlineCharChar style='margin-left:0in'>Capacity = 511</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example demonstrates that even though you can safely
relinquish much of the responsibility for allocating and managing the memory
your <b>string</b>s occupy, C++ <b>string</b>s provide you with several tools to
monitor and manage their size. Notice the ease with which we changed the size
of the storage allocated to the string. The <b>size(&nbsp;) </b>function, of
course, returns the number of characters currently stored in the string and is
identical to the <b>length(&nbsp;)</b> member function. The <b>capacity(&nbsp;)
</b>function<b> </b>returns the size of the current underlying allocation,
meaning the number of characters the string can hold without requesting more
storage. The <b>reserve(&nbsp;)</b> function is an optimization mechanism that
allows you to indicate your intention to specify a certain amount of storage
for future use; <b>capacity(&nbsp;)</b> always returns a value at least as
large as the most recent call to <b>reserve(&nbsp;)</b>. A <b>resize(&nbsp;)</b>
function appends spaces if the new size is greater than the current string size
or truncates the string otherwise. (An overload of <b>resize(&nbsp;)</b> allows
you to specify a different character to append.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0287"
title="Add Comment A0287">Comment</a></sup></p>

<p class=MsoNormal>The exact fashion in which the <b>string</b> member
functions allocate space for your data depends on the implementation of the
library. When we tested one implementation with the previous example, it
appeared that reallocations occurred on even word (that is, full-integer)
boundaries, with one byte held back. The architects of the <b>string</b> class
have endeavored to make it possible to mix the use of C <b>char</b> arrays and
C++ string objects, so it is likely that figures reported by <b>StrSize.cpp</b>
for capacity reflect that, in this particular implementation, a byte is set
aside to easily accommodate the insertion of a null terminator. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0288"
title="Add Comment A0288">Comment</a></sup></p>

<h3><a name="_Toc45439998"></a><a name="_Toc15743855">Replacing string
characters</a></h3>

<p class=MsoNormal>The<b> insert(&nbsp;) </b>function<b> </b>is particularly
nice because it absolves you of making sure the insertion of characters in a
string won’t overrun the storage space or overwrite the characters immediately
following the insertion point. Space grows, and existing characters politely
move over to accommodate the new elements. Sometimes, however, this might not
be what you want to happen. If you want the size of the string to remain
unchanged, use the <b>replace(&nbsp;)</b> function to overwrite characters.
There are quite a number of overloaded versions of <b>replace(&nbsp;)</b>, but
the simplest one takes three arguments: an integer indicating where to start in
the string, an integer indicating how many characters to eliminate from the
original string, and the replacement string (which can be a different number of
characters than the eliminated quantity). Here’s a simple example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0289"
title="Add Comment A0289">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StringReplace.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Simple find-and-replace in strings</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;A piece of
text&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>string
tag(&quot;$tag$&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  s.insert(8, tag + '
');</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>assert(s ==
&quot;A piece $tag$ of text&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int start = s.find(tag);</p>

<p class=CodeChar style='margin-left:0in'>  assert(start == 8);</p>

<p class=CodeChar style='margin-left:0in'>  assert(tag.size() == 5);</p>

<p class=CodeChar style='margin-left:0in'>  s.replace(start, tag.size(),
&quot;hello there&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(s == &quot;A piece hello
there of text&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>tag</b> is first inserted into <b>s</b> (notice that
the insert happens <i>before</i> the value indicating the insert point and that
an extra space was added after <b>tag</b>), and then it is found and replaced. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0290"
title="Add Comment A0290">Comment</a></sup></p>

<p class=MsoNormal>You should actually check to see if you’ve found anything
before you perform a <b>replace(&nbsp;)</b>.<b> </b>The previous example
replaces with a <b>char*</b>, but there’s an overloaded version that replaces
with a <b>string</b>.<b> </b>Here’s a more complete demonstration <b>replace(&nbsp;):<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0291"
title="Add Comment A0291"><span style='font-weight:normal'>Comment</span></a></sup></b></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Replace.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;  // for
size_t</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void replaceChars(string&amp;
modifyMe,</p>

<p class=CodeChar style='margin-left:0in'>  const string&amp; findMe, const
string&amp; newChars) {</p>

<p class=CodeChar style='margin-left:0in'>  // Look in modifyMe for the
&quot;find string&quot;</p>

<p class=CodeChar style='margin-left:0in'>  // starting at position 0</p>

<p class=CodeChar style='margin-left:0in'>  size_t i = modifyMe.find(findMe,
0);</p>

<p class=CodeChar style='margin-left:0in'>  // Did we find the string to
replace?</p>

<p class=CodeChar style='margin-left:0in'>  if (i != string::npos)</p>

<p class=CodeChar style='margin-left:0in'>    // Replace the find string with
newChars</p>

<p class=CodeChar style='margin-left:0in'>    modifyMe.replace(i,
findMe.size(), newChars);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string bigNews =</p>

<p class=CodeChar style='margin-left:0in'>   &quot;I thought I saw Elvis in a
UFO. &quot;</p>

<p class=CodeChar style='margin-left:0in'>   &quot;I have been working too
hard.&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  string
replacement(&quot;wig&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string findMe(&quot;UFO&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Find &quot;UFO&quot; in bigNews
and overwrite it:</p>

<p class=CodeChar style='margin-left:0in'>  replaceChars(bigNews, findMe,
replacement);</p>

<p class=CodeChar style='margin-left:0in'>  assert(bigNews == &quot;I thought I
saw Elvis in a &quot;</p>

<p class=CodeChar style='margin-left:0in'>         &quot;wig. I have been
working too hard.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If <b>replace</b> doesn’t find the search string, it returns
<b>string::npos</b>. The <b>npos</b> data member is a static constant member of
the <b>string</b> class that represents a nonexistent character position.<a
href="#_ftn30" name="_ftnref30" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[30]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0293"
title="Add Comment A0293">Comment</a></sup></p>

<p class=MsoNormal>Unlike <b>insert(&nbsp;)</b>, <b>replace(&nbsp;)</b> won’t
grow the <b>string</b>’s storage space if you copy new characters into the
middle of an existing series of array elements. However, it <i>will</i> grow
the storage space if needed, for example, when you make a “replacement” that
would expand the original string beyond the end of the current allocation.
Here’s an example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0294"
title="Add Comment A0294">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ReplaceAndGrow.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string bigNews(&quot;I have been
working the grave.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string replacement(&quot;yard
shift.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // The first arg says &quot;replace
chars</p>

<p class=CodeChar style='margin-left:0in'>  // beyond the end of the existing
string&quot;:</p>

<p class=CodeChar style='margin-left:0in'>  bigNews.replace(bigNews.size() - 1,</p>

<p class=CodeChar style='margin-left:0in'>    replacement.size(), replacement);</p>

<p class=CodeChar style='margin-left:0in'>  assert(bigNews == &quot;I have been
working the &quot;</p>

<p class=CodeChar style='margin-left:0in'>         &quot;graveyard
shift.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The call to <b>replace(&nbsp;) </b>begins “replacing” beyond
the end of the existing array, which is equivalent to an append operation.
Notice that in this example <b>replace(&nbsp;)</b> expands the array
accordingly. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0296"
title="Add Comment A0296">Comment</a></sup></p>

<p class=MsoNormal>You may have been hunting through this chapter trying to do
something relatively simple such as replace all the instances of one character
with a different character. Upon finding the previous material on replacing,
you thought you found the answer, but then you started seeing groups of
characters and counts and other things that looked a bit too complex. Doesn’t <b>string</b>
have a way to just replace one character with another everywhere? <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0297"
title="Add Comment A0297">Comment</a></sup></p>

<p class=MsoNormal>You can easily write such a function using the <b>find(&nbsp;)</b>
and <b>replace(&nbsp;)</b> member functions as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ReplaceAll.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; replaceAll(string&amp;
context, const string&amp; from,</p>

<p class=CodeChar style='margin-left:0in'>  const string&amp; to) {</p>

<p class=CodeChar style='margin-left:0in'>  size_t lookHere = 0;</p>

<p class=CodeChar style='margin-left:0in'>  size_t foundHere;</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>while ((foundHere
= context.find(from, lookHere))</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>  != string::npos)
{</p>

<p class=CodeChar style='margin-left:0in'>    context.replace(foundHere,
from.size(), to);</p>

<p class=CodeChar style='margin-left:0in;text-indent:24.0pt'>lookHere =
foundHere + to.size();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return context;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The version of <b>find(&nbsp;)</b> used here takes as a
second argument the position to start looking in and returns <b>string::npos</b>
if it doesn’t find it. It is important to advance the position held in the
variable <b>lookHere</b> past the replacement string, of course, in case <b>from</b>
is a substring of <b>to</b>. The following program tests the <b>replaceAll</b>
function: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1560"
title="Add Comment A1560">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ReplaceAllTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>//{L} ReplaceAll</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; replaceAll(string&amp;
context, const string&amp; from,</p>

<p class=CodeChar style='margin-left:0in'>  const string&amp; to);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string text = &quot;a man, a plan,
a canal, panama&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(text, &quot;an&quot;,
&quot;XXX&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(text == &quot;a mXXX, a
plXXX, a cXXXal, pXXXama&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As you can see, the <b>string</b> class by itself doesn’t
solve all possible problems. Many solutions have been left to the algorithms in
the Standard library,<a href="#_ftn31" name="_ftnref31" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[31]</span></sup></span></span></sup></span></a> because
the <b>string</b> class can look just like an STL sequence (by virtue of the
iterators discussed earlier). All the generic algorithms work on a “range” of
elements within a container. Usually that range is just “from the beginning of
the container to the end.” A <b>string</b> object looks like a container of
characters: to get the beginning of the range you use <b>string::begin(&nbsp;),</b>
and to get the end of the range you use <b>string::end(&nbsp;)</b>. The
following example shows the use of the <b>replace(&nbsp;)</b> algorithm to
replace all the instances of the single character ‘X’ with ‘Y’: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0298"
title="Add Comment A0298">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StringCharReplace.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string
s(&quot;aaaXaaaXXaaXXXaXXXXaaa&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replace(s.begin(), s.end(), 'X',
'Y');</p>

<p class=CodeChar style='margin-left:0in'>  assert(s ==
&quot;aaaYaaaYYaaYYYaYYYYaaa&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that this <b>replace(&nbsp;)</b> is <i>not</i> called
as a member function of <b>string</b>. Also, unlike the <b>string::replace(&nbsp;)</b>
functions that only perform one replacement, the <b>replace(&nbsp;)</b>
algorithm replaces <i>all instances</i> of one character with another. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0299"
title="Add Comment A0299">Comment</a></sup></p>

<p class=MsoNormal>The <b>replace(&nbsp;)</b> algorithm only works with single
objects (in this case, <b>char</b> objects) and will not replace quoted <b>char</b>
arrays or <b>string</b> objects. Since a <b>string</b> behaves like an STL
sequence, a number of other algorithms can be applied to it, which might solve
other problems that are not directly addressed by the <b>string</b> member
functions.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0301"
title="Add Comment A0301">Comment</a></sup></p>

<h3><a name="_Toc45439999"></a><a name="_Toc15743856">Concatenation using <br>
nonmember overloaded operators</a></h3>

<p class=MsoNormal>One of the most delightful discoveries awaiting a C
programmer learning about C++ <b>string</b> handling is how simply <b>string</b>s
can be combined and appended using <b>operator+</b> and <b>operator+=</b>.<b> </b>These
operators make combining <b>string</b>s syntactically similar to adding numeric
data. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0302"
title="Add Comment A0302">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:AddStrings.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s1(&quot;This &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s2(&quot;That &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s3(&quot;The other &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // operator+ concatenates strings</p>

<p class=CodeChar style='margin-left:0in'>  s1 = s1 + s2;</p>

<p class=CodeChar style='margin-left:0in'>  assert(s1 == &quot;This That
&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Another way to concatenates
strings</p>

<p class=CodeChar style='margin-left:0in'>  s1 += s3;</p>

<p class=CodeChar style='margin-left:0in'>  assert(s1 == &quot;This That The
other &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // You can index the string on the
right</p>

<p class=CodeChar style='margin-left:0in'>  s1 += s3 + s3[4] + &quot;ooh
lala&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  assert(s1 == &quot;This That The
other The other &quot;</p>

<p class=CodeChar style='margin-left:0in'>        &quot;oooh lala&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

<p class=CodeInlineCharChar style='margin-left:0in'>&nbsp;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Using the<b> operator+</b> and <b>operator+= </b>operators<b>
</b>is a flexible and<b> </b>convenient way to combine <b>string</b> data. On
the right side of the statement, you can use almost any type that evaluates to
a group of one or more characters. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0304"
title="Add Comment A0304">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440000"></a><a name="_Toc15743857">Searching
in strings</a></h2>

<p class=MsoNormal>The <b>find</b> family of <b>string</b> member functions
allows you to locate a character or group of characters within a given string.
Here are the members of the <b>find</b> family and their general usage :<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0305"
title="Add Comment A0305">Comment</a></sup></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse'>
 <tr>
  <td width=259 valign=top style='width:2.7in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>string find member function</p>
  </td>
  <td width=259 valign=top style='width:2.7in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>What/how it finds </p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> find(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a string for a specified character or group of
  characters and returns the starting position of the first occurrence found or
  npos if no match is found. (npos is a const of –1 [cast as a std::size_t] and
  indicates that a search failed.) </p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> find_first_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a target string and returns the position of the
  first match of <i>any</i> character in a specified group. If no match is
  found, it returns npos.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> find_last_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a target string and returns the position of the
  last match of <i>any</i> character in a specified group. If no match is
  found, it returns npos.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> find_first_not_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a target string and returns the position of the
  first element that <i>doesn’t</i> match <i>any</i> character in a specified
  group. If no such element is found, it returns npos.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> find_last_not_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a target string and returns the position of the
  element with the largest subscript that <i>doesn’t</i> match <i>any</i>
  character in a specified group. If no such element is found, it returns npos.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b> rfind(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Searches a string from end to beginning for a specified
  character or group of characters and returns the starting position of the
  match if one is found. If no match is found, it returns <b>npos</b>.</p>
  </td>
 </tr>
</table>

<h2 style='margin-left:0in'><a name="_Toc45440001">String searching member
functions and their general uses</a></h2>

<p class=MsoNormal>The simplest use of <b>find(&nbsp;) </b>searches for one or
more characters in a <b>string</b>. This overloaded version of <b>find(&nbsp;) </b>takes
a parameter that specifies the character(s) for which to search and optionally
a parameter that tells it where in the string to begin searching for the
occurrence of a substring. (The default position at which to begin searching is
0.) By setting the call to <b>find </b>inside a loop, you can easily move
through a string, repeating a search in order to find all the occurrences of a
given character or group of characters within the string. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0306"
title="Add Comment A0306">Comment</a></sup></p>

<p class=MsoNormal>The following program uses the method of <i>The Sieve of
Eratosthenes</i> to find prime numbers less than 50. This method starts with
the number 2, marks all subsequent multiples of 2 as not prime, and repeats the
process for the next prime candidate. Notice that we define the string object <b>sieveChars</b>
using a constructor idiom that sets the initial size of the character array and
writes the value ‘P’ to each of its member. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0307"
title="Add Comment A0307">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Sieve.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class SieveTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>  string sieveChars;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // Create a 50 char string and set
each</p>

<p class=CodeChar style='margin-left:0in'>  // element to 'P' for Prime</p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'>SieveTest() :
sieveChars(50, 'P') {}</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    findPrimes();</p>

<p class=CodeChar style='margin-left:0in'>    testPrimes();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  bool isPrime(int p) {</p>

<p class=CodeChar style='margin-left:0in'>    if (p == 0 || p == 1) return
false;</p>

<p class=CodeChar style='margin-left:0in'>    int root = int(sqrt(double(p)));</p>

<p class=CodeChar style='margin-left:0in'>    for (int i = 2; i &lt;= root;
++i)</p>

<p class=CodeChar style='margin-left:0in'>      if (p % i == 0) return false;</p>

<p class=CodeChar style='margin-left:0in'>    return true;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void findPrimes() {</p>

<p class=CodeChar style='margin-left:0in'>    // By definition neither 0 nor 1
is prime.</p>

<p class=CodeChar style='margin-left:0in'>    // Change these elements to
&quot;N&quot; for Not Prime</p>

<p class=CodeChar style='margin-left:0in'>    sieveChars.replace(0, 2,
&quot;NN&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    // Walk through the array:</p>

<p class=CodeChar style='margin-left:0in'>    size_t sieveSize =
sieveChars.size();</p>

<p class=CodeChar style='margin-left:0in'>    int root =
int(sqrt(double(sieveSize)));</p>

<p class=CodeChar style='margin-left:0in'>    for (int i = 2; i &lt;= root;
++i)</p>

<p class=CodeChar style='margin-left:0in'>      // Find all the multiples:</p>

<p class=CodeChar style='margin-left:0in'>      for (size_t factor = 2; factor
* i &lt; sieveSize;</p>

<p class=CodeChar style='margin-left:0in'>           ++factor)</p>

<p class=CodeChar style='margin-left:0in'>        sieveChars[factor * i] = 'N';</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testPrimes() {</p>

<p class=CodeChar style='margin-left:0in'>    size_t i = sieveChars.find('P');</p>

<p class=CodeChar style='margin-left:0in'>    while (i != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>      test_(isPrime(i++));</p>

<p class=CodeChar style='margin-left:0in'>      i = sieveChars.find('P', i);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    i =
sieveChars.find_first_not_of('P');</p>

<p class=CodeChar style='margin-left:0in'>    while (i != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>      test_(!isPrime(i++));</p>

<p class=CodeChar style='margin-left:0in'>      i =
sieveChars.find_first_not_of('P', i);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  SieveTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The<b> find(&nbsp;)</b> function allows you to walk forward
through a <b>string</b>, detecting multiple occurrences of a character or a
group of characters, and <b>find_first_not_of(&nbsp;)</b> allows you to find
other characters or substrings. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0309"
title="Add Comment A0309">Comment</a></sup></p>

<p class=MsoNormal>There are no functions in the <b>string </b>class to change
the case of a string, but you can easily create these functions using the
Standard C library functions <b>toupper(&nbsp;)</b> and <b>tolower(&nbsp;)</b>,
which change the case of one character at a time. The following example
illustrates a case-insensitive search: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0313"
title="Add Comment A0313">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Find.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Make an uppercase copy of s</p>

<p class=CodeChar style='margin-left:0in'>string upperCase(const string&amp; s)
{</p>

<p class=CodeChar style='margin-left:0in'>  string upper(s);</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
s.length(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>upper[i] =
toupper(upper[i]);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>return upper;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Make a lowercase copy of s</p>

<p class=CodeChar style='margin-left:0in'>string lowerCase(const string&amp; s)
{</p>

<p class=CodeChar style='margin-left:0in'>  string lower(s);</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
s.length(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>    lower[i] = tolower(lower[i]);</p>

<p class=CodeChar style='margin-left:0in'>  return lower;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class FindTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>  string chooseOne;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  FindTest() : chooseOne(&quot;Eenie,
Meenie, Miney, Mo&quot;) {}</p>

<p class=CodeChar style='margin-left:0in'>  void testUpper() {</p>

<p class=CodeChar style='margin-left:0in'>    string upper =
upperCase(chooseOne);</p>

<p class=CodeChar style='margin-left:0in'>    const string LOWER =
&quot;abcdefghijklmnopqrstuvwxyz&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    test_(upper.find_first_of(LOWER)
== string::npos);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testLower() {</p>

<p class=CodeChar style='margin-left:0in'>    string lower =
lowerCase(chooseOne);</p>

<p class=CodeChar style='margin-left:0in'>    const string UPPER =
&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    test_(lower.find_first_of(UPPER)
== string::npos);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testSearch() {</p>

<p class=CodeChar style='margin-left:0in'>    // Case sensitive search</p>

<p class=CodeChar style='margin-left:0in'>    size_t i =
chooseOne.find(&quot;een&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == 8);</p>

<p class=CodeChar style='margin-left:0in'>    // Search lowercase:</p>

<p class=CodeChar style='margin-left:0in'>    string test =
lowerCase(chooseOne);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;een&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == 0);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;een&quot;,
++i);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == 8);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;een&quot;,
++i);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == string::npos);</p>

<p class=CodeChar style='margin-left:0in'>    // Search uppercase:</p>

<p class=CodeChar style='margin-left:0in'>    test = upperCase(chooseOne);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;EEN&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == 0);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;EEN&quot;,
++i);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == 8);</p>

<p class=CodeChar style='margin-left:0in'>    i = test.find(&quot;EEN&quot;,
++i);</p>

<p class=CodeChar style='margin-left:0in'>    test_(i == string::npos);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    testUpper();</p>

<p class=CodeChar style='margin-left:0in'>    testLower();</p>

<p class=CodeChar style='margin-left:0in'>    testSearch();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  FindTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Both the <b>upperCase(&nbsp;)</b> and <b>lowerCase(&nbsp;)</b>
functions follow the same form: they make a copy of the argument <b>string</b>
and change the case. The <b>NewFind.cpp</b> program isn’t the best solution to
the case-sensitivity problem, so we’ll revisit it when we examine <b>string</b>
comparisons. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0317"
title="Add Comment A0317">Comment</a></sup></p>

<h3><a name="_Toc45440002"></a><a name="_Toc15743858">Finding in reverse</a></h3>

<p class=MsoNormal>Sometimes it’s necessary to search through a <b>string</b>
from end to beginning, if you need to find the data in “last in / first out”
order. The string member function <b>rfind(&nbsp;)</b> handles this job. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0318"
title="Add Comment A0318">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Rparse.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class RparseTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>  // To store the words:</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; strings;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void parseForData() {</p>

<p class=CodeChar style='margin-left:0in'>    // The ';' characters will be
delimiters</p>

<p class=CodeChar style='margin-left:0in'>    string
s(&quot;now.;sense;make;to;going;is;This&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    // The last element of the
string:</p>

<p class=CodeChar style='margin-left:0in'>    int last = s.size();</p>

<p class=CodeChar style='margin-left:0in'>    // The beginning of the current
word:</p>

<p class=CodeChar style='margin-left:0in'>    int current = s.rfind(';');</p>

<p class=CodeChar style='margin-left:0in'>    // Walk backward through the
string:</p>

<p class=CodeChar style='margin-left:0in'>    while(current != string::npos){</p>

<p class=CodeChar style='margin-left:0in'>      // Push each word into the
vector.</p>

<p class=CodeChar style='margin-left:0in'>      // Current is incremented
before copying to</p>

<p class=CodeChar style='margin-left:0in'>      // avoid copying the delimiter:</p>

<p class=CodeChar style='margin-left:0in'>      ++current;</p>

<p class=CodeChar style='margin-left:0in'>      strings.push_back(</p>

<p class=CodeChar style='margin-left:0in'>        s.substr(current, last -
current));</p>

<p class=CodeChar style='margin-left:0in'>      // Back over the delimiter we
just found,</p>

<p class=CodeChar style='margin-left:0in'>      // and set last to the end of
the next word:</p>

<p class=CodeChar style='margin-left:0in'>      current -= 2;</p>

<p class=CodeChar style='margin-left:0in'>      last = current + 1;</p>

<p class=CodeChar style='margin-left:0in'>      // Find the next delimiter</p>

<p class=CodeChar style='margin-left:0in'>      current = s.rfind(';',
current);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    // Pick up the first word - it's
not</p>

<p class=CodeChar style='margin-left:0in'>    // preceded by a delimiter</p>

<p class=CodeChar style='margin-left:0in'>    strings.push_back(s.substr(0,
last));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void testData() {</p>

<p class=CodeChar style='margin-left:0in'>    // Test order them in the new
order:</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[0] ==
&quot;This&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[1] ==
&quot;is&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[2] ==
&quot;going&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[3] ==
&quot;to&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[4] ==
&quot;make&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[5] ==
&quot;sense&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(strings[6] ==
&quot;now.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    string sentence;</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt;
strings.size() - 1; i++)</p>

<p class=CodeChar style='margin-left:0in'>      sentence += strings[i] +=
&quot; &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    // Manually put last word in to
avoid an extra space</p>

<p class=CodeChar style='margin-left:0in'>    sentence +=
strings[strings.size() - 1];</p>

<p class=CodeChar style='margin-left:0in'>    test_(sentence == &quot;This is
going to make sense now.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    parseForData();</p>

<p class=CodeChar style='margin-left:0in'>    testData();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  RparseTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The string member function<b> rfind(&nbsp;)</b> backs
through the string looking for tokens and reporting the array index of matching
characters or <b>string::npos</b> if it is unsuccessful. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0320"
title="Add Comment A0320">Comment</a></sup></p>

<h3><a name="_Toc45440003"></a><a name="_Toc15743859">Finding first/last of a
set of characters</a></h3>

<p class=MsoNormal>The <b>find_first_of(&nbsp;)</b> and <b>find_last_of(&nbsp;)</b>
member functions can be conveniently put to work to create a little utility
that will strip whitespace characters from both ends of a string. Notice that
it doesn’t touch the original string, but instead returns a new string: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0321"
title="Add Comment A0321">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Trim.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef TRIM_H</p>

<p class=CodeChar style='margin-left:0in'>#define TRIM_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>// General tool to strip spaces from
both ends:</p>

<p class=CodeChar style='margin-left:0in'>inline std::string trim(const
std::string&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  if(s.length() == 0)</p>

<p class=CodeChar style='margin-left:0in'>    return s;</p>

<p class=CodeChar style='margin-left:0in'>  int beg =
s.find_first_not_of(&quot; \a\b\f\n\r\t\v&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int end = s.find_last_not_of(&quot;
\a\b\f\n\r\t\v&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  if(beg == std::string::npos) // No
non-spaces</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  return std::string(s, beg, end -
beg + 1);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>#endif // TRIM_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first test checks for an empty <b>string</b>; in that
case, no tests are made, and a copy is returned. Notice that once the end
points are found, the <b>string</b> constructor builds a new <b>string</b> from
the old one, giving the starting count and the length.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0322"
title="Add Comment A0322">Comment</a></sup></p>

<p class=MsoNormal>Testing such a general-purpose tool needs to be thorough: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0323"
title="Add Comment A0323">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:TrimTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;trim.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string s[] = {</p>

<p class=CodeChar style='margin-left:0in'>  &quot; \t abcdefghijklmnop \t
&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;abcdefghijklmnop \t &quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot; \t abcdefghijklmnop&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;a&quot;, &quot;ab&quot;,
&quot;abc&quot;, &quot;a b c&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot; \t a b c \t &quot;, &quot;
\t a \t b \t c \t &quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;\t \n \r \v \f&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;&quot; // Must also test the
empty string</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class TrimTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void testTrim() {</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[0]) ==
&quot;abcdefghijklmnop&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[1]) ==
&quot;abcdefghijklmnop&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[2]) ==
&quot;abcdefghijklmnop&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[3]) ==
&quot;a&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[4]) ==
&quot;ab&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[5]) ==
&quot;abc&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[6]) == &quot;a b
c&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[7]) == &quot;a b
c&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[8]) == &quot;a \t b
\t c&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[9]) ==
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(trim(s[10]) ==
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    testTrim();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  TrimTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In the array of <b>strings</b>, you can see that the
character arrays are automatically converted to <b>string</b> objects. This
array provides cases to check the removal of spaces and tabs from both ends, as
well as ensuring that spaces and tabs are not removed from the middle of a <b>string</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0324"
title="Add Comment A0324">Comment</a></sup></p>

<h3><a name="_Toc45440004"></a><a name="_Toc15743860">Removing characters from
strings</a></h3>

<p class=MsoNormal>Removing characters is easy and efficient with the <b>erase(&nbsp;)</b> 
member function, which takes two arguments: where to start removing characters
(which defaults to <b>0</b>), and how many to remove (which defaults to <b>string::npos).</b>
If you specify more characters than remain in the string, the remaining
characters are all erased anyway (so calling <b>erase(&nbsp;)</b> without any
arguments removes all characters from a string). Sometimes it’s useful to take
an HTML file and strip its tags and special characters so that you have
something approximating the text that would be displayed in the Web browser,
only as a plain text file. The following uses <b>erase(&nbsp;)</b> to do the
job: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0329"
title="Add Comment A0329">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:HTMLStripper.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ReplaceAll</p>

<p class=CodeChar style='margin-left:0in'>// Filter to remove html tags and
markers</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; replaceAll(string&amp;
context, const string&amp; from,</p>

<p class=CodeChar style='margin-left:0in'>  const string&amp; to);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; stripHTMLTags(string&amp;
s) {</p>

<p class=CodeChar style='margin-left:0in'>  static bool inTag = false;</p>

<p class=CodeChar style='margin-left:0in'>  bool done = false;</p>

<p class=CodeChar style='margin-left:0in'>  while (!done) {</p>

<p class=CodeChar style='margin-left:0in'>    if (inTag) {</p>

<p class=CodeChar style='margin-left:0in'>      // The previous line started an
HTML tag</p>

<p class=CodeChar style='margin-left:0in'>      // but didn't finish. Must
search for '&gt;'.</p>

<p class=CodeChar style='margin-left:0in'>      size_t rightPos =
s.find('&gt;');</p>

<p class=CodeChar style='margin-left:0in'>      if (rightPos != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>        inTag = false;</p>

<p class=CodeChar style='margin-left:0in'>        s.erase(0, rightPos + 1);</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      else {</p>

<p class=CodeChar style='margin-left:0in'>        done = true;</p>

<p class=CodeChar style='margin-left:0in'>        s.erase();</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    else {</p>

<p class=CodeChar style='margin-left:0in'>      // Look for start of tag:</p>

<p class=CodeChar style='margin-left:0in'>      size_t leftPos =
s.find('&lt;');</p>

<p class=CodeChar style='margin-left:0in'>      if (leftPos != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>        // See if tag close is in
this line</p>

<p class=CodeChar style='margin-left:0in'>        size_t rightPos =
s.find('&gt;');</p>

<p class=CodeChar style='margin-left:0in'>        if (rightPos == string::npos)
{</p>

<p class=CodeChar style='margin-left:0in'>          inTag = done = true;</p>

<p class=CodeChar style='margin-left:0in'>          s.erase(leftPos);</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>        else</p>

<p class=CodeChar style='margin-left:0in'>          s.erase(leftPos, rightPos -
leftPos + 1);</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      else</p>

<p class=CodeChar style='margin-left:0in'>        done = true;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Remove all special HTML
characters</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s, &quot;&amp;lt;&quot;,
&quot;&lt;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s, &quot;&amp;gt;&quot;,
&quot;&gt;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s,
&quot;&amp;amp;&quot;, &quot;&amp;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s,
&quot;&amp;nbsp;&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Etc...</p>

<p class=CodeChar style='margin-left:0in'>  return s;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  requireArgs(argc, 1, </p>

<p class=CodeChar style='margin-left:0in'>    &quot;usage: HTMLStripper
InputFile&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  string s;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, s))</p>

<p class=CodeChar style='margin-left:0in'>    if (!stripHTMLTags(s).empty())</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example will even strip HTML tags that span multiple
lines<a href="#_ftn32" name="_ftnref32" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[32]</span></sup></span></span></sup></span></a>.
This is accomplished with the static flag, <b>inTag</b>, which is <b>true</b>
whenever the start of a tag is found, but the accompanying tag end is not found
in the same line. All forms of <b>erase(&nbsp;)</b> appear in the <b>stripHTMLFlags(&nbsp;)</b>
function.<a href="#_ftn33" name="_ftnref33" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[33]</span></sup></span></span></sup></span></a> The
version of <b>getline(&nbsp;)</b> we use here is a global function declared in
the <b>&lt;string&gt;</b> header and is handy because it stores an arbitrarily
long line in its <b>string</b> argument. You don’t have to worry about the
dimension of a character array as you do with <b>istream::getline(&nbsp;)</b>.
Notice that this program uses the <b>replaceAll(&nbsp;)</b> function from
earlier in this chapter. In the next chapter, we’ll use string streams to
create a more elegant solution. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0330"
title="Add Comment A0330">Comment</a></sup></p>

<h3><a name="_Toc45440005"></a><a name="_Toc15743861">Comparing strings</a> </h3>

<p class=MsoNormal>Comparing strings is inherently different from comparing
numbers. Numbers have constant, universally meaningful values. To evaluate the
relationship between the magnitudes of two strings, you must make a <i>lexical
comparison</i>. Lexical comparison means that when you test a character to see
if it is “greater than” or “less than” another character, you are actually
comparing the numeric representation of those characters as specified in the
collating sequence of the character set being used. Most often this will be the
ASCII collating sequence, which assigns the printable characters for the
English language numbers in the range 32 through 127 decimal. In the ASCII
collating sequence, the first “character” in the list is the space, followed by
several common punctuation marks, and then uppercase and lowercase letters.
With respect to the alphabet, this means that the letters nearer the front have
lower ASCII values than those nearer the end. With these details in mind, it
becomes easier to remember that when a lexical comparison that reports <b>s1</b>
is “greater than” <b>s2</b>, it simply means that when the two were compared,
the first differing character in <b>s1</b> came later in the alphabet than the
character in that same position in <b>s2</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0331"
title="Add Comment A0331">Comment</a></sup></p>

<p class=MsoNormal>C++ provides several ways to compare strings, and each has
advantages. The simplest to use are the nonmember, overloaded operator
functions: <b>operator ==, operator != operator &gt;, operator &lt;, operator
&gt;=, </b>and<b> operator &lt;=. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0332"
title="Add Comment A0332"><span style='font-weight:normal'>Comment</span></a></sup></b></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:CompStr.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;../TestSuite/Test.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class CompStrTest : public
TestSuite::Test {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void run() {</p>

<p class=CodeChar style='margin-left:0in'>    // Strings to compare</p>

<p class=CodeChar style='margin-left:0in'>    string s1(&quot;This&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    string s2(&quot;That&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 == s1);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 != s2);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 &gt; s2);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 &gt;= s2);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 &gt;= s1);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s2 &lt; s1);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s2 &lt;= s1);</p>

<p class=CodeChar style='margin-left:0in'>    test_(s1 &lt;= s1);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CompStrTest t;</p>

<p class=CodeChar style='margin-left:0in'>  t.run();</p>

<p class=CodeChar style='margin-left:0in'>  return t.report();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The overloaded comparison operators are useful for comparing
both full strings and individual string character elements. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0334"
title="Add Comment A0334">Comment</a></sup></p>

<p class=MsoNormal>Notice in the following code fragment the flexibility of
argument types on both the left and right side of the comparison operators. For
efficiency, the <b>string</b> class provides overloaded operators for the
direct comparison of string objects, quoted literals, and pointers to C-style
strings without having to create temporary <b>string</b> objects. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0335"
title="Add Comment A0335">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// The lvalue is a quoted literal and
</p>

<p class=CodeChar style='margin-left:0in'>// the rvalue is a string</p>

<p class=CodeChar style='margin-left:0in'>if(&quot;That&quot; == s2)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;A match&quot;
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>// The left operand below is a string
and the right is a</p>

<p class=CodeChar style='margin-left:0in'>// pointer to a C-style null
terminated string</p>

<p class=CodeChar style='margin-left:0in'>if(s1 != s2.c_str())</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  cout &lt;&lt; &quot;No
match&quot; &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>c_str(&nbsp;)</b> function returns a <b>const char*</b>
that points to a C-style, null-terminated string equivalent to the contents of
the <b>string</b> object. This comes in handy when you want to pass a string to
a standard C function, such as <b>atoi(&nbsp;)</b> or any of the functions
defined in the <b>&lt;cstring&gt;</b> header. It is an error to use the value
returned by <b>c_str(&nbsp;)</b> as non-<b>const</b> argument to any function. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1561"
title="Add Comment A1561">Comment</a></sup></p>

<p class=MsoNormal>You won’t find the logical not (<b>!</b>) or the logical
comparison operators (<b>&amp;&amp;</b> and <b>||</b>) among operators for a
string. (Neither will you find overloaded versions of the bitwise C operators <b>&amp;</b>,
<b>|</b>, <b>^</b>, or <b>~</b>.) The overloaded nonmember comparison operators
for the string class are limited to the subset that has clear, unambiguous
application to single characters or groups of characters. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0336"
title="Add Comment A0336">Comment</a></sup></p>

<p class=MsoNormal>The <b>compare(&nbsp;)</b> member function offers you a
great deal more sophisticated and precise comparison than the nonmember
operator set. It provides overloaded versions that allow you to compare two
complete strings, part of either string to a complete string, and subsets of
two strings. The following example compares complete strings: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0337"
title="Add Comment A0337">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Compare.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrates compare(), swap()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string first(&quot;This&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string second(&quot;That&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(first) == 0);</p>

<p class=CodeChar style='margin-left:0in'>  assert(second.compare(second) ==
0);</p>

<p class=CodeChar style='margin-left:0in'>  // Which is lexically greater?</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(second) &gt;
0);</p>

<p class=CodeChar style='margin-left:0in'>  assert(second.compare(first) &lt;
0);</p>

<p class=CodeChar style='margin-left:0in'>  first.swap(second);</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(second) &lt;
0);</p>

<p class=CodeChar style='margin-left:0in'>  assert(second.compare(first) &gt;
0);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>swap(&nbsp;)</b> function in this example does what
its name implies: it exchanges the contents of its object and argument. To
compare a subset of the characters in one or both strings, you add arguments
that define where to start the comparison and how many characters to consider.
For example, we can use the overloaded version of <b>compare(&nbsp;)</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0339"
title="Add Comment A0339">Comment</a></sup></p>

<p class=MsoNormal><b>s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos,
s2NumberChars); <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0340"
title="Add Comment A0340"><span style='font-weight:normal'>Comment</span></a></sup></b></p>

<p class=MsoNormal>Here’s an example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0341"
title="Add Comment A0341">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:Compare2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrate overloaded compare()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string first(&quot;This is a day
that will live in infamy&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string second(&quot;I don't believe
that this is what &quot;</p>

<p class=CodeChar style='margin-left:0in'>                &quot;I signed up
for&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Compare &quot;his is&quot; in
both strings:</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(1, 7, second,
22, 7) == 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Compare &quot;his is a&quot; to
&quot;his is w&quot;:</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(1, 9, second,
22, 9) &lt; 0);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In the examples so far, we have used C-style array indexing
syntax to refer to an individual character in a string. C++ strings provide an
alternative to the <b>s[n] </b>notation: the <b>at(&nbsp;)</b> member. These
two indexing mechanisms produce the same result in C++ if all goes well: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0344"
title="Add Comment A0344">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:StringIndexing.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>int main(){</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;1234&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(s[1] == '2');</p>

<p class=CodeChar style='margin-left:0in'>  assert(s.at(1) == '2');</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>There is one important difference, however, between <b>[ ]</b>
and <b>at(&nbsp;)</b>. When you try to reference an array element that is out
of bounds, <b>at(&nbsp;) </b>will do you the kindness of throwing an exception,
while ordinary <b>[ ] </b>subscripting syntax will leave you to your own
devices: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0346"
title="Add Comment A0346">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:BadStringIndexing.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;exception&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(){</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;1234&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // at() saves you by throwing an
exception:</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    s.at(5);</p>

<p class=CodeChar style='margin-left:0in'>  } catch(exception&amp; e) {</p>

<p class=CodeChar style='margin-left:0in'>    cerr &lt;&lt; e.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Responsible programmers will not use errant indexes, but
should you want to benefits of automatic index checking, using <b>at(&nbsp;) </b>in
place of <b>[ ] </b>will give you a chance to gracefully recover from
references to array elements that don’t exist. Execution of this program on one
of our test compilers gave the following output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>invalid string position</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The<b> at(&nbsp;)</b> member throws an object of class <b>out_of_range</b>,
which derives (ultimately) from <b>std::exception. </b>By catching this object
in an exception handler, you can take appropriate remedial actions such as
recalculating the offending subscript or growing the array. Using <b>string::operator[](&nbsp;)</b>
gives no such protection and is as dangerous as <b>char</b> array processing in
C.<a href="#_ftn34" name="_ftnref34" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[34]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0347"
title="Add Comment A0347">Comment</a></sup></p>

<h3><a name="_Toc45440006"></a><a name="_Toc15743862">Strings and character
traits</a></h3>

<p class=MsoNormal>The program <b>Find.cpp</b> earlier in this chapter leads us
to ask the obvious question: Why isn’t case-insensitive comparison part of the
standard <b>string</b> class? The answer provides interesting background on the
true nature of C++ string objects. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0356"
title="Add Comment A0356">Comment</a></sup></p>

<p class=MsoNormal>Consider what it means for a character to have “case.”
Written Hebrew, Farsi, and Kanji don’t use the concept of upper- and lowercase,
so for those languages this idea has no meaning. It would seem that if there
were a way to designate some languages as “all uppercase” or “all lowercase,”
we could design a generalized solution. However, some languages that employ the
concept of “case” <i>also</i> change the meaning of particular characters with
diacritical marks: for example, the cedilla in Spanish, the circumflex in
French, and the umlaut in German. For this reason, any case-sensitive collating
scheme that attempts to be comprehensive will be nightmarishly complex to use. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0358"
title="Add Comment A0358">Comment</a></sup></p>

<p class=MsoNormal>Although we usually treat the C++ <b>string</b> as a class,
this is really not the case. The <b>string</b> type is actually a
specialization of a more general constituent, the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b>
template. Observe how <b>string</b> is declared in the standard C++ header
file:<a href="#_ftn35" name="_ftnref35" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[35]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0359"
title="Add Comment A0359">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
basic_string&lt;char&gt; string;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>To really understand the nature of the string class, it’s
helpful to delve a bit deeper and look at the template on which it is based.
Here’s the declaration of the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b>
template: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0360"
title="Add Comment A0360">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT,</p>

<p class=CodeChar style='margin-left:0in'>  class traits =
char_traits&lt;charT&gt;,</p>

<p class=CodeChar style='margin-left:0in'>  class allocator =
allocator&lt;charT&gt; &gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  class basic_string;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In Chapter 5, we examine templates in great detail (much
more than in Chapter 16 of Volume 1). For now, the main thing to notice about
the two previous declarations is that the <b>string</b> type is created when
the <b>basic_string</b> template is instantiated with <b>char. </b>Inside the <b>basic_string&lt;</b>&nbsp;<b>&gt;
</b>template declaration, the line <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0361"
title="Add Comment A0361">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>class traits =
char_traits&lt;charT&gt;,</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>tells us that the behavior of the class made from the <b>basic_string&lt;</b>&nbsp;<b>&gt;
</b>template is specified by a class based on the template <b>char_traits&lt;</b>&nbsp;<b>&gt;</b>.
Thus, the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b> template provides for cases
in which you need string-oriented classes that manipulate types other than <b>char</b>
(wide characters, for example). To do this, the <b>char_traits&lt;</b>&nbsp;<b>&gt;
</b>template controls the content and collating behaviors of a variety of
character sets using the character comparison functions <b>eq(&nbsp;)</b>
(equal), <b>ne(&nbsp;)</b> (not equal), and <b>lt(&nbsp;)</b> (less than) upon
which the <b>basic_string&lt;</b>&nbsp;<b>&gt; </b>string comparison functions
rely. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0362"
title="Add Comment A0362">Comment</a></sup></p>

<p class=MsoNormal>This is why the string class doesn’t include
case-insensitive member functions: that’s not in its job description. To change
the way the string class treats character comparison, you must supply a
different <b>char_traits&lt;</b>&nbsp;<b>&gt;</b> template, because that
defines the behavior of the individual character comparison member functions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0363"
title="Add Comment A0363">Comment</a></sup></p>

<p class=MsoNormal>You can use this information to make a new type of <b>string
</b>class that ignores case. First, we’ll define a new case-insensitive <b>char_traits&lt;</b>&nbsp;<b>&gt;</b>
template that inherits from the existing template. Next, we’ll override only
the members we need to change in order to make character-by-character
comparison case insensitive. (In addition to the three lexical character
comparison members mentioned earlier, we’ll also have to supply a new
implementation for the <b>char_traits</b> functions <b>find(&nbsp;)</b> and <b>compare(&nbsp;)</b>.)
Finally, we’ll <b>typedef</b> a new class based on <b>basic_string</b>, but
using the case-insensitive <b>ichar_traits</b> template for its second
argument. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0364"
title="Add Comment A0364">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ichar_traits.h</p>

<p class=CodeChar style='margin-left:0in'>// Creating your own character traits</p>

<p class=CodeChar style='margin-left:0in'>#ifndef ICHAR_TRAITS_H</p>

<p class=CodeChar style='margin-left:0in'>#define ICHAR_TRAITS_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>using std::toupper;</p>

<p class=CodeChar style='margin-left:0in'>using std::tolower;</p>

<p class=CodeChar style='margin-left:0in'>using std::ostream;</p>

<p class=CodeChar style='margin-left:0in'>using std::string;</p>

<p class=CodeChar style='margin-left:0in'>using std::char_traits;</p>

<p class=CodeChar style='margin-left:0in'>using std::allocator;</p>

<p class=CodeChar style='margin-left:0in'>using std::basic_string;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct ichar_traits :
char_traits&lt;char&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  // We'll only change character-by-</p>

<p class=CodeChar style='margin-left:0in'>  // character comparison functions</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq(char c1st, char
c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return toupper(c1st) ==
toupper(c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static bool ne(char c1st, char
c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return !eq(c1st, c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static bool lt(char c1st, char
c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return toupper(c1st) &lt;
toupper(c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static int compare(const char*
str1, </p>

<p class=CodeChar style='margin-left:0in'>    const char* str2, size_t n) {</p>

<p class=CodeChar style='margin-left:0in'>    for(size_t i = 0; i &lt; n; i++)
{</p>

<p class=CodeChar style='margin-left:0in'>      if(str1 == 0)</p>

<p class=CodeChar style='margin-left:0in'>        return -1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(str2 == 0)</p>

<p class=CodeChar style='margin-left:0in'>        return 1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(tolower(*str1) &lt;
tolower(*str2))</p>

<p class=CodeChar style='margin-left:0in'>        return -1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(tolower(*str1) &gt;
tolower(*str2))</p>

<p class=CodeChar style='margin-left:0in'>        return 1;</p>

<p class=CodeChar style='margin-left:0in'>      assert(tolower(*str1) ==
tolower(*str2));</p>

<p class=CodeChar style='margin-left:0in'>      str1++; str2++; // Compare the
other chars</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static const char* find(const char*
s1, </p>

<p class=CodeChar style='margin-left:0in'>    size_t n, char c) {</p>

<p class=CodeChar style='margin-left:0in'>    while(n-- &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>      if(toupper(*s1) == toupper(c))</p>

<p class=CodeChar style='margin-left:0in'>        return s1;</p>

<p class=CodeChar style='margin-left:0in'>      else</p>

<p class=CodeChar style='margin-left:0in'>        ++s1;</p>

<p class=CodeChar style='margin-left:0in'>    return 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef basic_string&lt;char,
ichar_traits&gt; istring;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline ostream&amp;
operator&lt;&lt;(ostream&amp; os, const istring&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt;
string(s.c_str(), s.length());</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>#endif // ICHAR_TRAITS_H  ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We provide a <b>typedef</b> named <b>istring</b> so that our
class will act like an ordinary <b>string</b> in every way, except that it will
make all comparisons without respect to case. For convenience, we’ve also
provided an overloaded <b>operator&lt;&lt;(&nbsp;)</b> so that you can print <b>istring</b>s.
Here’s an example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0366"
title="Add Comment A0366">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ICompare.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;ichar_traits.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // The same letters except for
case:</p>

<p class=CodeChar style='margin-left:0in'>  istring first = &quot;tHis&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  istring second = &quot;ThIS&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; first &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; second &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.compare(second) == 0);</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.find('h') == 1);</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.find('I') == 2);</p>

<p class=CodeChar style='margin-left:0in'>  assert(first.find('x') ==
string::npos);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This is just a toy example, of course.  In order to make <b>istring</b>
fully equivalent to <b>string</b>, we’d have to create the other functions
necessary to support the new <b>istring</b> type. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0368"
title="Add Comment A0368">Comment</a></sup></p>

<p class=MsoNormal>The <b>&lt;string&gt;</b> header provides a wide string
class via the following <b>typedef</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
basic_string&lt;wchar_t&gt; wstring;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Wide string support also reveals itself in <i>wide streams</i>
(<b>wostream</b> in place of <b>ostream</b>, also defined in <b>&lt;iostream&gt;</b>)
and in the header <b>&lt;cwctype&gt;</b>, a wide-character version of <b>&lt;cctype&gt;</b>.
This along with the <b>wchar_t</b> specialization of <b>char_traits</b> in the
standard library allows us to do a wide-character version of <b>ichar_traits</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:iwchar_traits.h</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>// Creating your own wide-character
traits</p>

<p class=CodeChar style='margin-left:0in'>#ifndef IWCHAR_TRAITS_H</p>

<p class=CodeChar style='margin-left:0in'>#define IWCHAR_TRAITS_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cwctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>using std::towupper;</p>

<p class=CodeChar style='margin-left:0in'>using std::towlower;</p>

<p class=CodeChar style='margin-left:0in'>using std::wostream;</p>

<p class=CodeChar style='margin-left:0in'>using std::wstring;</p>

<p class=CodeChar style='margin-left:0in'>using std::char_traits;</p>

<p class=CodeChar style='margin-left:0in'>using std::allocator;</p>

<p class=CodeChar style='margin-left:0in'>using std::basic_string;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct iwchar_traits :
char_traits&lt;wchar_t&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  // We'll only change character-by-</p>

<p class=CodeChar style='margin-left:0in'>  // character comparison functions</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq(wchar_t c1st,
wchar_t c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return towupper(c1st) ==
towupper(c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static bool ne(wchar_t c1st,
wchar_t c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return towupper(c1st) !=
towupper(c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static bool lt(wchar_t c1st,
wchar_t c2nd) {</p>

<p class=CodeChar style='margin-left:0in'>    return towupper(c1st) &lt;
towupper(c2nd);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static int compare(const wchar_t*
str1, </p>

<p class=CodeChar style='margin-left:0in'>    const wchar_t* str2, size_t n) {</p>

<p class=CodeChar style='margin-left:0in'>    for(size_t i = 0; i &lt; n; i++)
{</p>

<p class=CodeChar style='margin-left:0in'>      if(str1 == 0)</p>

<p class=CodeChar style='margin-left:0in'>        return -1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(str2 == 0)</p>

<p class=CodeChar style='margin-left:0in'>        return 1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(towlower(*str1) &lt;
towlower(*str2))</p>

<p class=CodeChar style='margin-left:0in'>        return -1;</p>

<p class=CodeChar style='margin-left:0in'>      else if(towlower(*str1) &gt;
towlower(*str2))</p>

<p class=CodeChar style='margin-left:0in'>        return 1;</p>

<p class=CodeChar style='margin-left:0in'>      assert(towlower(*str1) ==
towlower(*str2));</p>

<p class=CodeChar style='margin-left:0in'>      str1++; str2++; // Compare the
other wchar_ts</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static const wchar_t* find(const
wchar_t* s1, </p>

<p class=CodeChar style='margin-left:0in'>    size_t n, wchar_t c) {</p>

<p class=CodeChar style='margin-left:0in'>    while(n-- &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>      if(towupper(*s1) ==
towupper(c))</p>

<p class=CodeChar style='margin-left:0in'>        return s1;</p>

<p class=CodeChar style='margin-left:0in'>      else</p>

<p class=CodeChar style='margin-left:0in'>        ++s1;</p>

<p class=CodeChar style='margin-left:0in'>    return 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef basic_string&lt;wchar_t,
iwchar_traits&gt; iwstring;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>inline wostream&amp;
operator&lt;&lt;(wostream&amp; os,</p>

<p class=CodeChar style='margin-left:0in'>  const iwstring&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt;
wstring(s.c_str(), s.length());</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>#endif // IWCHAR_TRAITS_H  ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As you can see, this is mostly an exercise in placing a ‘w’
in the appropriate place in the source code. The test program looks like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:IWCompare.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;iwchar_traits.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // The same letters except for
case:</p>

<p class=CodeChar style='margin-left:0in'>  iwstring wfirst =
L&quot;tHis&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  iwstring wsecond =
L&quot;ThIS&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  wcout &lt;&lt; wfirst &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  wcout &lt;&lt; wsecond &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  assert(wfirst.compare(wsecond) ==
0);</p>

<p class=CodeChar style='margin-left:0in'>  assert(wfirst.find('h') == 1);</p>

<p class=CodeChar style='margin-left:0in'>  assert(wfirst.find('I') == 2);</p>

<p class=CodeChar style='margin-left:0in'>  assert(wfirst.find('x') ==
wstring::npos);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Unfortunately, some compilers still do not provide robust
support for wide characters. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1562"
title="Add Comment A1562">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440007"></a><a name="_Toc15743863">A
string application</a></h2>

<p class=MsoNormal><a name="_Toc15743864">If you’ve looked at the sample code
in this book closely, you’ve noticed that certain tokens in the comments
surround the code. These are used by a Python program that Bruce wrote to
extract the code into files and set up makefiles for building the code. For
example, a double-slash followed by a colon at the beginning of a line denotes
the first line of a source file. The rest of the line contains information
describing the file’s name and location and whether it should be only compiled
rather than fully built into an executable file. For example, the first line in
the previous program above contains the string <b>C03:IWCompare.cpp</b>,
indicating that the file <b>IWCompare.cpp</b> should be extracted into the
directory <b>C03</b>. </a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1569"
title="Add Comment A1569"><sup>Comment</sup></a></p>

<p class=MsoNormal>The last line of a source file contains a triple-slash
followed by a colon and a tilde. If the first line has an exclamation point
immediately after the colon, the first and last lines of the source code are
not to be output to the file (this is for data-only files). (If you’re
wondering why we’re avoiding showing you these tokens, it’s because we don’t
want to break the code extractor when applied to the text of the book!) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1568"
title="Add Comment A1568"><sup>Comment</sup></a></p>

<p class=MsoNormal>Bruce’s Python program does a lot more than just extract
code. If the token <b>“{O}”</b> follows the file name, its makefile entry will
only be set up to compile the file and not to link it into an executable. (The
Test Framework in Chapter 2 is built this way.) To link such a file with
another source example, the target executable’s source file will contain an <b>“{L}”</b>
directive, as in <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1567"
title="Add Comment A1567"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This section will present a program to just extract all the
code so that you can compile and inspect it manually. You can use this program
to extract all the code in this book by saving the document file as a text file
(let’s call it TICV2.txt) and by executing something like the following on a
shell command line: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1566"
title="Add Comment A1566"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>C:&gt; extractCode
TICV2.txt /TheCode</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This command reads the text file <b>TICV2.txt</b> and writes
all the source code files in subdirectories under the top-level directory <b>/TheCode</b>.
The directory tree will look like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>TheCode/</p>

<p class=CodeChar style='margin-left:0in'>   C0B/</p>

<p class=CodeChar style='margin-left:0in'>   C01/</p>

<p class=CodeChar style='margin-left:0in'>   C02/</p>

<p class=CodeChar style='margin-left:0in'>   C03/</p>

<p class=CodeChar style='margin-left:0in'>   C04/</p>

<p class=CodeChar style='margin-left:0in'>   C05/</p>

<p class=CodeChar style='margin-left:0in'>   C06/</p>

<p class=CodeChar style='margin-left:0in'>   C07/</p>

<p class=CodeChar style='margin-left:0in'>   C08/</p>

<p class=CodeChar style='margin-left:0in'>   C09/</p>

<p class=CodeChar style='margin-left:0in'>   C10/</p>

<p class=CodeChar style='margin-left:0in'>   C11/</p>

<p class=CodeChar style='margin-left:0in'>   TestSuite/</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The source files containing the examples from each chapter
will be in the corresponding directory. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1565"
title="Add Comment A1565"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here’s the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C03:ExtractCode.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Extracts code from text</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// Legacy non-standard C header for
mkdir()</p>

<p class=CodeChar style='margin-left:0in'>#ifdef __GNUC__</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sys/stat.h&gt;</p>

<p class=CodeChar style='margin-left:0in'>#elif defined(__BORLANDC__) ||
defined(_MSC_VER)</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;direct.h&gt;</p>

<p class=CodeChar style='margin-left:0in'>#else</p>

<p class=CodeChar style='margin-left:0in'>#error Compiler not supported</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Check to see if directory exists</p>

<p class=CodeChar style='margin-left:0in'>// by attempting to open a new file</p>

<p class=CodeChar style='margin-left:0in'>// for output within it.</p>

<p class=CodeChar style='margin-left:0in'>bool exists(string fname) {</p>

<p class=CodeChar style='margin-left:0in'>  size_t len = fname.length();</p>

<p class=CodeChar style='margin-left:0in'>  if(fname[len-1] != '/' &amp;&amp;
fname[len-1] != '\\')</p>

<p class=CodeChar style='margin-left:0in'>    fname.append(&quot;/&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  fname.append(&quot;000.tmp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ofstream outf(fname.c_str());</p>

<p class=CodeChar style='margin-left:0in'>  bool existFlag = outf;</p>

<p class=CodeChar style='margin-left:0in'>  if (outf) {</p>

<p class=CodeChar style='margin-left:0in'>    outf.close();</p>

<p class=CodeChar style='margin-left:0in'>    remove(fname.c_str());</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return existFlag;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  // See if input file name provided</p>

<p class=CodeChar style='margin-left:0in'>  if(argc == 1) {</p>

<p class=CodeChar style='margin-left:0in'>    cerr &lt;&lt; &quot;usage: extractCode
file [dir]\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // See if input file exists</p>

<p class=CodeChar style='margin-left:0in'>  ifstream inf(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  if(!inf) {</p>

<p class=CodeChar style='margin-left:0in'>    cerr &lt;&lt; &quot;error opening
file: &quot; &lt;&lt; argv[1] &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Check for optional output
directory</p>

<p class=CodeChar style='margin-left:0in'>  string root(&quot;./&quot;);  //
current is default</p>

<p class=CodeChar style='margin-left:0in'>  if(argc == 3) {</p>

<p class=CodeChar style='margin-left:0in'>    // See if output directory exists</p>

<p class=CodeChar style='margin-left:0in'>    root = argv[2];</p>

<p class=CodeChar style='margin-left:0in'>    if(!exists(root)) {</p>

<p class=CodeChar style='margin-left:0in'>      cerr &lt;&lt; &quot;no such
directory: &quot; &lt;&lt; root &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>      exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    size_t rootLen = root.length();</p>

<p class=CodeChar style='margin-left:0in'>    if(root[rootLen-1] != '/'
&amp;&amp; root[rootLen-1] != '\\')</p>

<p class=CodeChar style='margin-left:0in'>      root.append(&quot;/&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Read input file line by line</p>

<p class=CodeChar style='margin-left:0in'>  // checking for code delimiters</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  bool inCode = false;</p>

<p class=CodeChar style='margin-left:0in'>  bool printDelims = true;</p>

<p class=CodeChar style='margin-left:0in'>  ofstream outf;</p>

<p class=CodeChar style='margin-left:0in'>  while (getline(inf, line)) {</p>

<p class=CodeChar style='margin-left:0in'>    size_t findDelim =
line.find(&quot;//&quot; &quot;/:~&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    if(findDelim != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>      // Output last line and close
file</p>

<p class=CodeChar style='margin-left:0in'>      if (!inCode) {</p>

<p class=CodeChar style='margin-left:0in'>        cerr &lt;&lt; &quot;Lines out
of order\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>        exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      assert(outf);</p>

<p class=CodeChar style='margin-left:0in'>      if (printDelims)</p>

<p class=CodeChar style='margin-left:0in'>        outf &lt;&lt; line &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>      outf.close();</p>

<p class=CodeChar style='margin-left:0in'>      inCode = false;</p>

<p class=CodeChar style='margin-left:0in'>      printDelims = true;</p>

<p class=CodeChar style='margin-left:0in'>    } else {</p>

<p class=CodeChar style='margin-left:0in'>      findDelim =
line.find(&quot;//&quot; &quot;:&quot;);</p>

<p class=CodeChar style='margin-left:0in'>      if(findDelim == 0) {</p>

<p class=CodeChar style='margin-left:0in'>        // Check for '!' directive</p>

<p class=CodeChar style='margin-left:0in'>        if(line[3] == '!') {</p>

<p class=CodeChar style='margin-left:0in'>          printDelims = false;</p>

<p class=CodeChar style='margin-left:0in'>          ++findDelim;  // To skip
'!' for next search</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>        // Extract subdirectory name,
if any</p>

<p class=CodeChar style='margin-left:0in'>        size_t startOfSubdir =</p>

<p class=CodeChar style='margin-left:0in'>         
line.find_first_not_of(&quot; \t&quot;, findDelim+3);</p>

<p class=CodeChar style='margin-left:0in'>        findDelim = line.find(':',
startOfSubdir);</p>

<p class=CodeChar style='margin-left:0in'>        if (findDelim ==
string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>          cerr &lt;&lt; &quot;missing
filename information\n&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>          exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>        string subdir;</p>

<p class=CodeChar style='margin-left:0in'>        if(findDelim &gt;
startOfSubdir)</p>

<p class=CodeChar style='margin-left:0in'>          subdir = line.substr(startOfSubdir,</p>

<p class=CodeChar style='margin-left:0in'>                              
findDelim - startOfSubdir);</p>

<p class=CodeChar style='margin-left:0in'>        // Extract file name (better
be one!)</p>

<p class=CodeChar style='margin-left:0in'>        size_t startOfFile =
findDelim + 1;</p>

<p class=CodeChar style='margin-left:0in'>        size_t endOfFile =</p>

<p class=CodeChar style='margin-left:0in'>          line.find_first_of(&quot;
\t&quot;, startOfFile);</p>

<p class=CodeChar style='margin-left:0in'>        if(endOfFile == startOfFile)
{</p>

<p class=CodeChar style='margin-left:0in'>          cerr &lt;&lt; &quot;missing
filename\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>          exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>        // We have all the pieces;
build fullPath name</p>

<p class=CodeChar style='margin-left:0in'>        string fullPath(root);</p>

<p class=CodeChar style='margin-left:0in'>        if(subdir.length() &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>         
fullPath.append(subdir).append(&quot;/&quot;);</p>

<p class=CodeChar style='margin-left:0in'>       
assert(fullPath[fullPath.length()-1] == '/');</p>

<p class=CodeChar style='margin-left:0in'>        if (!exists(fullPath))</p>

<p class=CodeChar style='margin-left:0in'>#ifdef __GNUC__</p>

<p class=CodeChar style='margin-left:0in'>          mkdir(fullPath.c_str(),
0);  // Create subdir</p>

<p class=CodeChar style='margin-left:0in'>#else</p>

<p class=CodeChar style='margin-left:0in'>          mkdir(fullPath.c_str()); 
// Create subdir</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>        fullPath.append(line.substr(startOfFile,</p>

<p class=CodeChar style='margin-left:0in'>                        endOfFile -
startOfFile));</p>

<p class=CodeChar style='margin-left:0in'>        outf.open(fullPath.c_str());</p>

<p class=CodeChar style='margin-left:0in'>        if(!outf) {</p>

<p class=CodeChar style='margin-left:0in'>          cerr &lt;&lt; &quot;error
opening &quot; &lt;&lt; fullPath</p>

<p class=CodeChar style='margin-left:0in'>               &lt;&lt; &quot; for
output\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>          exit(EXIT_FAILURE);</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>        inCode = true;</p>

<p class=CodeChar style='margin-left:0in'>        cout &lt;&lt;
&quot;Processing &quot; &lt;&lt; fullPath &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>        if(printDelims)</p>

<p class=CodeChar style='margin-left:0in'>          outf &lt;&lt; line &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      else if(inCode) {</p>

<p class=CodeChar style='margin-left:0in'>        assert(outf);</p>

<p class=CodeChar style='margin-left:0in'>        outf &lt;&lt; line &lt;&lt;
endl;  // output middle code line</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  exit(EXIT_SUCCESS);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>First, you’ll notice some conditional compilation
directives. The <b>mkdir(&nbsp;)</b> function, which creates a directory in the
file system, is defined by the POSIX<a href="#_ftn36" name="_ftnref36" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[36]</span></sup></span></span></sup></span></a> standard
in the header <b>&lt;sys/stat.h&gt;</b>. Unfortunately, many compilers still
use a different header (<b>&lt;direct.h&gt;</b>). The respective signatures for
<b>mkdir(&nbsp;)</b> also differ: POSIX specifies two arguments, the older
versions just one. For this reason, there is more conditional compilation later
in the program to choose the right call to <b>mkdir(&nbsp;)</b>. We normally
don’t use conditional compilation in the examples in this book, but this
particular program is too useful not to put a little extra work into, since you
can use it to extract all the code with it. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1570"
title="Add Comment A1570"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>exists(&nbsp;)</b> function in <b>ExtractCode.cpp</b>
tests whether a directory exists by opening a temporary file in it. If the open
fails, the directory doesn’t exist. You remove a file by sending its name as a <b>char*</b>
to <b>std::remove(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1564"
title="Add Comment A1564"><sup>Comment</sup></a></p>

<p class=MsoNormal>The main program validates the command-line arguments and
then reads the input file a line at a time, looking for the special source code
delimiters. The Boolean flag <b>inCode</b> indicates that the program is in the
middle of a source file, so lines should be output. The <b>printDelims</b> flag
will be true if the opening token is not followed by an exclamation point;
otherwise the first and last lines are not written. It is important to check
for the closing delimiter first, because the start token is a subset of it, and
searching for the start token first would return a successful find for both
cases. If we encounter the closing token, we verify that we are in the middle
of processing a source file; otherwise, something is wrong with the way the
delimiters are laid out in the text file. If <b>inCode</b> is true, all is
well, and we (optionally) write the last line and close the file. When the
opening token is found, we parse the directory and file name components and
open the file. The following <b>string</b>-related functions were used in this
example: <b>length(&nbsp;)</b>, <b>append(&nbsp;)</b>, <b>getline(&nbsp;)</b>, <b>find(&nbsp;)</b>
(two versions), <b>find_first_not_of(&nbsp;)</b>, <b>substr(&nbsp;)</b>, <b>find_first_of(&nbsp;)</b>,
<b>c_str(&nbsp;)</b>, and, of course, <b>operator&lt;&lt;(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1563"
title="Add Comment A1563"><sup>Comment</sup></a></p>

<p class=MsoNormal>We also use a standard C technique for reporting program
status to the calling context by returning different values from <b>main(&nbsp;)</b>.
It is portable to use the statement <b>return 0;</b> to indicate success, but
there is no portable value to indicate failure. For this reason we use the
macro declared for this very purpose in <b>&lt;cstdlib&gt;</b>: <b>EXIT_FAILURE</b>.
As a matter of consistency, whenever we use <b>EXIT_FAILURE</b> we also use <b>EXIT_SUCCESS</b>,
even though the latter is always defined as zero. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1607"
title="Add Comment A1607"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440008">Summary</a></h2>

<p class=MsoNormal>C++ string objects provide developers with a number of great
advantages over their C counterparts. For the most part, the <b>string</b>
class makes referring to strings through the use of character pointers
unnecessary. This eliminates an entire class of software defects that arise
from the use of uninitialized and incorrectly valued pointers. C++ strings
dynamically and transparently grow their internal data storage space to
accommodate increases in the size of the string data. This means that when the
data in a string grows beyond the limits of the memory initially allocated to
it, the string object will make the memory management calls that take space
from and return space to the heap. Consistent allocation schemes prevent memory
leaks and have the potential to be much more efficient than “roll your own”
memory management. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0379"
title="Add Comment A0379">Comment</a></sup></p>

<p class=MsoNormal>The <b>string</b> class member functions provide a fairly
comprehensive set of tools for creating, modifying, and searching in strings.
String comparisons are always case sensitive, but you can work around this by
copying string data to C-style null-terminated strings and using
case-insensitive string comparison functions, temporarily converting the data
held in string objects to a single case, or by creating a case-insensitive
string class that overrides the character traits used to create the <b>basic_string</b>
object. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0380"
title="Add Comment A0380">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440009"></a><a name="_Toc15743865">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that reverses the order of the characters in a
string.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A palindrome is a word or group of words that read the same
forward and backward. For example “madam” or “wow.” Write a program that takes
a string argument from the command line and prints whether the string was a
palindrome or not.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make your program from exercise 2 return <b>true</b> even if
symmetric letters differ in case. For example, &quot;Civic&quot; would still
return <b>true</b> although the first letter is capitalized.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make your program from exercise 3 report true even if the string
contains punctuation and spaces. For example &quot;Able was I, ere I saw
Elba.&quot; would report <b>true</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using the following strings and only <b>char</b>s (no string
literals or magic numbers):<br>
<br>
</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>string one(&quot;I walked down the
canyon with the moving mountain bikers.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>string two(&quot;The bikers passed by
me too close for comfort.&quot;);<br>
string three(&quot;I went hiking instead.&quot;)</p>

</div>

<p class=MsoNormal><br>
                        produce the following sentence:</p>

<p class=Exercises style='text-indent:0in'>&quot;I moved down the canyon with
the mountain bikers. The mountain bikers passed by me too close for comfort. So
I went hiking instead.&quot;</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program named <b>replace</b> that takes three
command-line arguments representing an input text file, a string to replace
(call it <b>from</b>), and a replacement string (call it <b>to</b>). The
program should write a new file to standard output with all occurrences of <b>from</b>
replaced by <b>to</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Repeat the previous exercise but replace all instances of <b>from</b>
regardless of case.</p>

<p class=Exercises>&nbsp;</p>

</div>

<b><span style='font-size:24.0pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span></b>

<div class=Section10>

<h1 style='margin-left:-81.35pt'><a name="_Toc312373873"></a><a
name="_Toc305628662"></a><a name="_Toc45440010">4: Iostreams</a></h1>

<p class=Intro style='margin-left:.25in'>You can do much more with the general
I/O problem than just take standard I/O and turn it into a class. </p>

<p class=MsoNormal>Wouldn’t it be nice if you could make all the usual
“receptacles”—standard I/O, files, and even blocks of memory—look the same so
that you need to remember only one interface? That’s the idea behind iostreams.
They’re much easier, safer, and sometimes even more efficient than the assorted
functions from the Standard C <b>stdio</b> library. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0382"
title="Add Comment A0382">Comment</a></sup></p>

<p class=MsoNormal>The iostreams classes are usually the first part of the C++
library that new C++ programmers learn to use. This chapter discusses how
iostreams are an improvement over C’s <b>stdio</b> facilities and explores the
behavior of file and string streams in addition to the standard console
streams. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0383"
title="Add Comment A0383">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440011"></a><a name="_Toc312373874"></a><a
name="_Toc305628663">Why iostreams?</a></h2>

<p class=MsoNormal>You might wonder what’s wrong with the good old C library.
Why not “wrap” the C library in a class and be done with it? Indeed, this is
the perfect thing to do in some situations. For example, suppose you want to
make sure the file represented by a <b>stdio</b> <b>FILE</b> pointer is always
safely opened and properly closed, without having to rely on the user to
remember to call the <b>close(&nbsp;)</b> function. The following program is
such an attempt. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0384"
title="Add Comment A0384">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:FileClass.h</p>

<p class=CodeChar style='margin-left:0in'>// stdio files wrapped</p>

<p class=CodeChar style='margin-left:0in'>#ifndef FILECLASS_H</p>

<p class=CodeChar style='margin-left:0in'>#define FILECLASS_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class FileClass {</p>

<p class=CodeChar style='margin-left:0in'>  std::FILE* f;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  struct FileClassError :
std::runtime_error {</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    FileClassError(const char* msg)  </p>

<p class=CodeChar style='margin-left:0in'>      : std::runtime_error(msg) {}</p>

<p class=CodeChar style='margin-left:0in'>  }; </p>

<p class=CodeChar style='margin-left:0in'>  FileClass(const char* fname, const
char* mode = &quot;r&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ~FileClass();</p>

<p class=CodeChar style='margin-left:0in'>  std::FILE* fp();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>#endif // FILECLASS_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When you perform file I/O in C, you work with a naked
pointer to a FILE <b>struct</b>, but this class wraps around the pointer and
guarantees it is properly initialized and cleaned up using the constructor and
destructor. The second constructor argument is the file mode, which defaults to
“r” for “read.” <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0385"
title="Add Comment A0385">Comment</a></sup></p>

<p class=MsoNormal>To fetch the value of the pointer to use in the file I/O
functions, you use the <b>fp(&nbsp;)</b> access function. Here are the member
function definitions: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0386"
title="Add Comment A0386">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:FileClass.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>// FileClassImplementation</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;FileClass.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>FileClass::FileClass(const char*
fname, const char* mode) {</p>

<p class=CodeChar style='margin-left:0in'>  if((f = fopen(fname, mode)) == 0)</p>

<p class=CodeChar style='margin-left:0in'>    throw FileClassError(&quot;Error
opening file&quot;);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>FileClass::~FileClass() { fclose(f);
}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>FILE* FileClass::fp() { return f; }
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The constructor calls <b>fopen(&nbsp;)</b>, as you would normally
do, but it also ensures that the result isn’t zero, which indicates a failure
upon opening the file. If the file does not open as expected, an exception is
thrown. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0387"
title="Add Comment A0387">Comment</a></sup></p>

<p class=MsoNormal>The destructor closes the file, and the access function <b>fp(&nbsp;)
</b>returns <b>f</b>. Here’s a simple example using <b>class FileClass</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0388"
title="Add Comment A0388">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:FileClassTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Tests FileClass</p>

<p class=CodeChar style='margin-left:0in'>//{L} FileClass</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;FileClass.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    FileClass
f(&quot;FileClassTest.cpp&quot;);  </p>

<p class=CodeChar style='margin-left:0in'>    const int BSIZE = 100;</p>

<p class=CodeChar style='margin-left:0in'>    char buf[BSIZE];</p>

<p class=CodeChar style='margin-left:0in'>    while(fgets(buf, BSIZE, f.fp()))</p>

<p class=CodeChar style='margin-left:0in'>      fputs(buf, stdout);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'> 
catch(FileClass::FileClassError&amp; e) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; e.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    return EXIT_FAILURE;    </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return EXIT_SUCCESS;</p>

<p class=CodeChar style='margin-left:0in'>} // File automatically closed by
destructor</p>

<p class=CodeChar style='margin-left:0in'>///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You create the <b>FileClass</b> object and use it in normal
C file I/O function calls by calling <b>fp(&nbsp;)</b>. When you’re done with
it, just forget about it; the file is closed by the destructor at the end of
its scope. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0389"
title="Add Comment A0389">Comment</a></sup></p>

<p class=MsoNormal>Even though the <b>FILE</b> pointer is private, it isn’t
particularly safe because <b>fp(&nbsp;)</b> retrieves it. Since the only effect
seems to be guaranteed initialization and cleanup, why not make it public or use
a <b>struct</b> instead? Notice that while you can get a copy of <b>f</b> using
<b>fp(&nbsp;)</b>, you cannot assign to <b>f</b>— that’s completely under the
control of the class. Of course, after capturing the pointer returned by <b>fp(&nbsp;)</b>,
the client programmer can still assign to the structure elements or even close
it, so the safety is in guaranteeing a valid <b>FILE</b> pointer rather than
proper contents of the structure. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0390"
title="Add Comment A0390">Comment</a></sup></p>

<p class=MsoNormal>If you want complete safety, you must prevent the user from
directly accessing the <b>FILE</b> pointer. Some version of all the normal file
I/O functions must show up as class members so that everything you can do with
the C approach is available in the C++ class: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0391"
title="Add Comment A0391">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Fullwrap.h</p>

<p class=CodeChar style='margin-left:0in'>// Completely hidden file IO</p>

<p class=CodeChar style='margin-left:0in'>#ifndef FULLWRAP_H</p>

<p class=CodeChar style='margin-left:0in'>#define FULLWRAP_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class File {</p>

<p class=CodeChar style='margin-left:0in'>  std::FILE* f;</p>

<p class=CodeChar style='margin-left:0in'>  std::FILE* F(); // Produces checked
pointer to f</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  File(); // Create object but don't
open file</p>

<p class=CodeChar style='margin-left:0in'>  File(const char* path,</p>

<p class=CodeChar style='margin-left:0in'>       const char* mode =
&quot;r&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ~File();</p>

<p class=CodeChar style='margin-left:0in'>  int open(const char* path,</p>

<p class=CodeChar style='margin-left:0in'>           const char* mode =
&quot;r&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int reopen(const char* path,</p>

<p class=CodeChar style='margin-left:0in'>             const char* mode);</p>

<p class=CodeChar style='margin-left:0in'>  int getc();</p>

<p class=CodeChar style='margin-left:0in'>  int ungetc(int c);</p>

<p class=CodeChar style='margin-left:0in'>  int putc(int c);</p>

<p class=CodeChar style='margin-left:0in'>  int puts(const char* s);</p>

<p class=CodeChar style='margin-left:0in'>  char* gets(char* s, int n);</p>

<p class=CodeChar style='margin-left:0in'>  int printf(const char* format,
...);</p>

<p class=CodeChar style='margin-left:0in'>  size_t read(void* ptr, size_t size,</p>

<p class=CodeChar style='margin-left:0in'>              size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  size_t write(const void* ptr,</p>

<p class=CodeChar style='margin-left:0in'>               size_t size, size_t
n);</p>

<p class=CodeChar style='margin-left:0in'>  int eof();</p>

<p class=CodeChar style='margin-left:0in'>  int close();</p>

<p class=CodeChar style='margin-left:0in'>  int flush();</p>

<p class=CodeChar style='margin-left:0in'>  int seek(long offset, int whence);</p>

<p class=CodeChar style='margin-left:0in'>  int getpos(fpos_t* pos);</p>

<p class=CodeChar style='margin-left:0in'>  int setpos(const fpos_t* pos);</p>

<p class=CodeChar style='margin-left:0in'>  long tell();</p>

<p class=CodeChar style='margin-left:0in'>  void rewind();</p>

<p class=CodeChar style='margin-left:0in'>  void setbuf(char* buf);</p>

<p class=CodeChar style='margin-left:0in'>  int setvbuf(char* buf, int type,
size_t sz);</p>

<p class=CodeChar style='margin-left:0in'>  int error();</p>

<p class=CodeChar style='margin-left:0in'>  void clearErr();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // FULLWRAP_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This class contains almost all the file I/O functions from <b>&lt;cstdio&gt;</b>.
(<b>vfprintf(&nbsp;)</b> is missing; it is used to implement the <b>printf(&nbsp;)</b>
member function.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0392"
title="Add Comment A0392">Comment</a></sup></p>

<p class=MsoNormal><b>File</b> has the same constructor as in the previous
example, and it also has a default constructor. The default constructor is
important if you want to create an array of <b>File</b> objects or use a <b>File</b>
object as a member of another class in which the initialization doesn’t happen
in the constructor, but some time after the enclosing object is created. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0393"
title="Add Comment A0393">Comment</a></sup></p>

<p class=MsoNormal>The default constructor sets the private <b>FILE</b> pointer
<b>f</b> to zero. But now, before any reference to <b>f</b>, its value must be
checked to ensure it isn’t zero. This is accomplished with <b>F(&nbsp;)</b>, which
is <b>private</b> because it is intended to be used only by other member
functions. (We don’t want to give the user direct access to the underlying <b>FILE</b>
structure in this class.)<a href="#_ftn37" name="_ftnref37" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[37]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0394"
title="Add Comment A0394">Comment</a></sup></p>

<p class=MsoNormal>This approach is not a terrible solution by any means. It’s
quite functional, and you could imagine making similar classes for standard
(console) I/O and for in-core formatting (reading/writing a piece of memory
rather than a file or the console). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0395"
title="Add Comment A0395">Comment</a></sup></p>

<p class=MsoNormal>The big stumbling block is the runtime interpreter used for the variable argument list functions. This is the code that parses your
format string at runtime and grabs and interprets arguments from the variable
argument list. It’s a problem for four reasons. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0396"
title="Add Comment A0396">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Even if you use only a fraction of the functionality of the
interpreter, the whole thing gets loaded into your executable. So if you say <span
style='font-family:"Courier New"'>printf(&quot;%c&quot;, 'x');, </span>you’ll
get the whole package, including the parts that print floating-point numbers
and strings. There’s no standard option for reducing the amount of space used
by the program. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1577"
title="Add Comment A1577">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Because the interpretation happens at runtime, you can’t get rid
of a performance overhead. It’s frustrating because all the information is <i>there</i>
in the format string at compile time, but it’s not evaluated until runtime.
However, if you could parse the arguments in the format string at compile time,
you could make direct function calls that have the potential to be much faster
than a runtime interpreter (although the <b>printf(&nbsp;)</b> family of
functions is usually quite well optimized). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1576"
title="Add Comment A1576">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A worse problem is that the format string is not evaluated until
runtime: there can be no compile-time error checking. You’re probably familiar with this problem if you’ve tried to find bugs that came from using the
wrong number or type of arguments in a <b>printf(&nbsp;)</b> statement. C++
makes a big deal out of compile-time error checking to find errors early and
make your life easier. It seems a shame to throw type safety away for an I/O
library, especially because I/O is used a lot. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1575"
title="Add Comment A1575">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>For C++, the most crucial problem is that the <b>printf(&nbsp;)</b>
family of functions is not particularly extensible. They’re really designed to handle only the four basic data types in C (<b>char</b>, <b>int</b>, <b>float</b>, <b>double</b>, <b>wchar_t</b>, <b>char*</b>, <b>wchar_t*</b>,
and <b>void*)</b> and their variations. You might think that every time you add
a new class, you could add overloaded <b>printf(&nbsp;)</b> and <b>scanf(&nbsp;)</b>
functions (and their variants for files and strings), but remember, overloaded
functions must have different types in their argument lists, and the <b>printf(&nbsp;)</b>
family hides its type information in the format string and in the variable
argument list. For a language such as C++, whose goal is to be able to easily
add new data types, this is an ungainly restriction. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1574"
title="Add Comment A1574">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440012"></a><a name="_Toc312373876"></a><a
name="_Toc305628664">Iostreams to the rescue</a></h2>

<p class=MsoNormal>All these issues make it clear that one of the first
priorities for the standard class libraries for C++ should handle I/O. Because
“hello, world” is the first program just about everyone writes in a new
language, and because I/O is part of virtually every program, the I/O library
in C++ must be particularly easy to use. It also has the much greater challenge
that it must accommodate any new class. Thus, its constraints require that this
foundation class library be a truly inspired design. In addition to gaining a
great deal of leverage and clarity in your dealings with I/O and formatting,
you’ll also see in this chapter how a really powerful C++ library can work. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0398"
title="Add Comment A0398">Comment</a></sup></p>

<h3><a name="_Toc45440013"></a><a name="_Toc312373878">Inserters and extractors</a></h3>

<p class=MsoNormal>A <i>stream</i> is an object that transports and formats
characters of a fixed width. You can have an input stream (via descendants of
the <b>istream</b> class), an output stream (with <b>ostream</b> objects), or a stream that does both simultaneously (with objects derived from <b>iostream</b>).
The iostreams library provides different types of such classes: <b>ifstream</b>,<i>
</i><b>ofstream</b>, and <b>fstream</b> for files, and <b>istringstream</b>, <b>ostringstream</b>, and <b>stringstream</b> for interfacing with the Standard C++ <b>string</b>
class. All these stream classes have nearly identical interfaces, so you can
use streams in a uniform manner, whether you’re working with a file, standard
I/O, a region of memory, or a <b>string</b> object. The single interface you
learn also works for extensions added to support new classes. Some functions
implement your formatting commands, and some functions read and write
characters without formatting. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0407"
title="Add Comment A0407">Comment</a></sup></p>

<p class=MsoNormal>The stream classes mentioned earlier are actually template
specializations,<a href="#_ftn38" name="_ftnref38" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[38]</span></sup></span></span></sup></span></a> much
like the standard <b>string</b> class is a specialization of the <b>basic_string</b>
template. The basic classes in the iostreams inheritance hierarchy are shown in
the following figure. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1573"
title="Add Comment A1573">Comment</a></sup></p>

<p class=MsoNormal style='page-break-after:avoid'><img border=0 width=472
height=360 src="TicV2_files/image004.gif"></p>

<p class=MsoNormal>The <b>ios_base</b> class declares everything that is common
to all streams, independent of the type of character the stream handles. These
declarations are mostly constants and functions to manage them, some of which
you’ll see throughout this chapter. The rest of the classes are templates that
have the underlying character type as a parameter. The <b>istream</b> class,
for example, is defined as follows: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1572"
title="Add Comment A1572">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
basic_istream&lt;char&gt; istream;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All the classes mentioned earlier are defined via similar
type definitions. There are also type definitions for all stream classes using <b>wchar_t</b>
(the wide character type discussed in Chapter 3) instead of <b>char</b>. We’ll
look at these at the end of this chapter. The <b>basic_ios</b> template defines
functions common to both input and output, but that depends on the underlying
character type (we won’t use these much). The template <b>basic_istream</b>
defines generic functions for input, and <b>basic_ostream</b> does the same for
output. The classes for file and string streams introduced later add
functionality for their specific stream types. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1571"
title="Add Comment A1571">Comment</a></sup></p>

<p class=MsoNormal>In the iostreams library, two operators are overloaded to
simplify the use of iostreams. The operator <b>&lt;&lt;</b> is often referred to as an <i>inserter</i> for iostreams, and the operator <b>&gt;&gt;</b> is often referred to as an <i>extractor</i>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0406"
title="Add Comment A0406">Comment</a></sup></p>

<p class=MsoNormal>Extractors parse the information that’s expected by the
destination object according to its type. To see an example of this, you can
use the <b>cin</b> object, which is the iostream equivalent of <b>stdin</b> in
C, that is, redirectable standard input. This object is predefined whenever you
include the <b>&lt;iostream&gt; </b>header. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0408"
title="Add Comment A0408"><span lang=SV>Comment</span></a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  int i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  float f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char c;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; c;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char buf[100];</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span lang=SV>  cin
&gt;&gt; buf;</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span lang=SV>&nbsp;</span></p>

<p class=MsoNormal>There’s an overloaded <b>operator &gt;&gt;</b> for every
built-in data type. You can also overload your own, as you’ll see later. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0409"
title="Add Comment A0409">Comment</a></sup></p>

<p class=MsoNormal>To find out what you have in the various variables, you can
use the <b>cout</b> object (corresponding to standard output; there’s also a <b>cerr</b>
object corresponding to standard error) with the inserter <b>&lt;&lt;</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0410"
title="Add Comment A0410">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;i = &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; i;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;f = &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; f;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c = &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;buf = &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; buf;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n&quot;;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This is notably tedious and doesn’t seem like much of an
improvement over <b>printf(&nbsp;)</b>, despite improved type checking.
Fortunately, the overloaded inserters and extractors are designed to be chained
together into a more complicated expression that is much easier to write (and
read): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0411"
title="Add Comment A0411">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;i = &quot;
&lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;f = &quot;
&lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c = &quot;
&lt;&lt; c &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  cout &lt;&lt; &quot;buf =
&quot; &lt;&lt; buf &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Defining inserters and extractors for your own classes is
just a matter of overloading the associated operators to do the right things,
namely:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make the first parameter a non-<b>const</b> reference to the
stream (<b>istream</b> for input, <b>ostream</b> for output)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Perform the operation by insert/extracting data to/from the
stream (by processing the components of the object, of course)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Return a reference to the stream</p>

<p class=MsoNormal>The stream should be non-<b>const</b> because processing
stream data changes the state of the stream. By returning the stream, you allow
for chaining stream operations in a single statement, as shown earlier. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1578"
title="Add Comment A1578">Comment</a></sup></p>

<p class=MsoNormal>As an example, consider how to output the representation of
a <b>Date</b> object in MM-DD-YYYY format. The following inserter does the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Date&amp; d) {</p>

<p class=CodeChar style='margin-left:0in'>  char fillc = os.fill('0');</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; setw(2) &lt;&lt;
d.getMonth() &lt;&lt; '-'</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; setw(2) &lt;&lt;
d.getDay() &lt;&lt; '-'</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; setw(4) &lt;&lt;
setfill(fillc) &lt;&lt; d.getYear();</p>

<p class=CodeChar style='margin-left:0in'>  return os;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This function cannot be a member of the <b>Date</b> class,
of course, because the left operand of the <b>&lt;&lt;</b> operator must be the
output stream. The <b>fill(&nbsp;)</b> member function of <b>ostream</b>
changes the padding character used when the width of an output field,
determined by the <i>manipulator</i> <b>setw(&nbsp;)</b>, is greater than
needed for the data. We use a ‘0’ character so that months before October will
display with a leading zero, such as “09” for September. The <b>fill(&nbsp;)</b>
function also returns the previous fill character (which defaults to a single
space) so that we can restore it later with the manipulator <b>setfill(&nbsp;)</b>.
We discuss manipulators in depth later in this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1579"
title="Add Comment A1579">Comment</a></sup></p>

<p class=MsoNormal>Extractors require a little more care because things
sometimes go wrong with input data. The way to signal a stream error is to set
the stream’s <i>fail bit</i>, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>istream&amp;
operator&gt;&gt;(istream&amp; is, Date&amp; d) {</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; d.month;</p>

<p class=CodeChar style='margin-left:0in'>  char dash;</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; dash;</p>

<p class=CodeChar style='margin-left:0in'>  if (dash != '-') </p>

<p class=CodeChar style='margin-left:0in'>    is.setstate(ios::failbit);</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; d.day;</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; dash;</p>

<p class=CodeChar style='margin-left:0in'>  if (dash != '-') </p>

<p class=CodeChar style='margin-left:0in'>    is.setstate(ios::failbit);</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; d.year;</p>

<p class=CodeChar style='margin-left:0in'>  return is;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When an error bit is set in a stream, all further streams
operations are ignored until the stream is restored to a good state (explained
shortly).  That’s why the code above continues extracting even if <b>ios::failbit</b>
gets set. This implementation is somewhat forgiving in that it allows white
space between the numbers and dashes in a date string (because the <b>&gt;&gt;</b>
operator skips white space by default when reading built-in types). The
following are valid date strings for this extractor: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1580"
title="Add Comment A1580">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>&quot;08-10-2003&quot;</p>

<p class=CodeChar style='margin-left:0in'>&quot;8-10-2003&quot;</p>

<p class=CodeChar style='margin-left:0in'>&quot;08 - 10 - 2003&quot;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>but these are not:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>&quot;A-10-2003&quot;    // No alpha
characters allowed</p>

<p class=CodeChar style='margin-left:0in'>&quot;08%10/2003&quot;   // Only
dashes allowed as a delimiter</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We’ll discuss stream state in more depth in the section
“Handling stream errors” later in this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1581"
title="Add Comment A1581">Comment</a></sup></p>

<h3><a name="_Toc45440014"></a><a name="_Toc312373879">Common usage</a></h3>

<p class=MsoNormal>As the <b>Date</b> extractor illustrated, you must be on
guard for erroneous input. If the input produces an unexpected value, the
process is skewed, and it’s difficult to recover. In addition, formatted input
defaults to white space delimiters. Consider what happens when we collect the
code fragments from earlier in this chapter into a single program: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0417"
title="Add Comment A0417">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Iosexamp.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Iostream examples</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>int i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  float f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char c;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; c;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char buf[100];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; buf;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cout &lt;&lt; &quot;i
= &quot; &lt;&lt; i &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>cout &lt;&lt;
&quot;f = &quot; &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c = &quot; &lt;&lt;
c &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;buf = &quot;
&lt;&lt; buf &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; flush;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; hex &lt;&lt;
&quot;0x&quot; &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>and give it the following input: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0418"
title="Add Comment A0418">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>12 1.4 c this is a test</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We expect the same output as if we gave it:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>12</p>

<p class=CodeChar style='margin-left:0in'>1.4</p>

<p class=CodeChar style='margin-left:0in'>c</p>

<p class=CodeInlineCharChar style='margin-left:0in'>this is a test</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>but the output is, somewhat unexpectedly</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>i = 12</p>

<p class=CodeChar style='margin-left:0in'>f = 1.4</p>

<p class=CodeChar style='margin-left:0in'>c = c</p>

<p class=CodeChar style='margin-left:0in'>buf = this</p>

<p class=CodeInlineCharChar style='margin-left:0in'>0xc</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that <b>buf</b> got only the first word because the
input routine looked for a space to delimit the input, which it saw after
“this.” In addition, if the continuous input string is longer than the storage
allocated for <b>buf</b>, we overrun the buffer. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0421"
title="Add Comment A0421">Comment</a></sup></p>

<p class=MsoNormal>In practice, you’ll usually want to get input from
interactive programs a line at a time as a sequence of characters, scan them,
and then perform conversions once they’re safely in a buffer. This way you
don’t have to worry about the input routine choking on unexpected data. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0422"
title="Add Comment A0422">Comment</a></sup></p>

<p class=MsoNormal>Another thing to consider is the whole concept of a command-line
interface. This made sense in the past when the console was little more than a
glass typewriter, but the world is rapidly changing to one in which the
graphical user interface (GUI) dominates. What is the meaning of console I/O in such a world? It makes much more sense to ignore <b>cin</b> altogether, other
than for simple examples or tests, and take the following approaches: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0423"
title="Add Comment A0423">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>If your program requires input, read that input from a file—you’ll
soon see that it’s remarkably easy to use files with iostreams. Iostreams for files still works fine with a GUI. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1582"
title="Add Comment A1582">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Read the input without attempting to convert it, as we just
suggested. When the input is some place where it can’t foul things up during
conversion, you can safely scan it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1583"
title="Add Comment A1583">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Output is different. If you’re using a GUI, <b>cout</b> doesn’t
necessarily work, and you must send it to a file (which is identical to sending
it to <b>cout</b>) or use the GUI facilities for data display. Otherwise it
often makes sense to send it to <b>cout</b>. In both cases, the output
formatting functions of iostreams are highly useful. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1584"
title="Add Comment A1584">Comment</a></sup></p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>Another common
practice saves compile time on large projects.  Consider, for example, how you
would declare the Date stream operators introduced earlier in the chapter in a
header file. You only need to include the prototypes for the functions, so it’s
not really necessary to include the entire <b>&lt;iostream&gt;</b> header in <b>Date.h</b>.
The standard practice is to only declare classes, something like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1585"
title="Add Comment A1585">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>class ostream;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>This is an age-old
technique for separating interface from implementation and is often called a <b>forward
declaration</b> (and <b>ostream</b> at this point would be considered an <i>incomplete
type</i>, since the class definition has not yet been seen by the compiler). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1586"
title="Add Comment A1586">Comment</a></sup></p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>This will not work
as is, however, for two reasons: </p>

<p class=Numbered style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
stream classes are defined in the <b>std</b> namespace. </p>

<p class=Numbered style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>They
are templates.</p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>The proper
declaration would be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>namespace std {</p>

<p class=CodeChar style='margin-left:0in'>  template&lt;class charT, class
traits = char_traits&lt;charT&gt; &gt; </p>

<p class=CodeChar style='margin-left:0in'>    class basic_ostream;</p>

<p class=CodeChar style='margin-left:0in'>  typedef basic_ostream&lt;char&gt;
ostream;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><a name="_Toc312373880">(As you can see, like the <b>string</b>
class, the streams classes use the character traits classes mentioned in Chapter
3). Since it would be terribly tedious to type all that for every stream class
you want to reference, the standard provides a header that does it for you: <b>&lt;iosfwd&gt;</b>.
The <b>Date</b> header would then look something like this: </a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1588"
title="Add Comment A1588"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Date.h</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iosfwd&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Date {</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp;
operator&lt;&lt;(std::ostream&amp;,</p>

<p class=CodeChar style='margin-left:0in'>                                 
const Date&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  friend std::istream&amp;
operator&gt;&gt;(std::istream&amp;, Date&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  // etc. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1587"
title="Add Comment A1587"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440015">Line-oriented input</a></h3>

<p class=MsoNormal>To grab input a line at a time, you have three choices: </p>

<p class=MsoListNumber style='margin-left:.5in'>The member function <b>get(&nbsp;)</b>
</p>

<p class=MsoListNumber style='margin-left:.5in'>The member function <b>getline(&nbsp;)</b>
</p>

<p class=MsoListNumber style='margin-left:.5in'>The global function <b>getline(&nbsp;)</b>
defined in the <b>&lt;string&gt;</b> header</p>

<p class=MsoNormal>The first two functions take three arguments:</p>

<p class=MsoListNumber style='margin-left:.5in'>A pointer to a character buffer
in which to store the result</p>

<p class=MsoListNumber style='margin-left:.5in'>The size of that buffer (so it’s
not overrun) </p>

<p class=MsoListNumber style='margin-left:.5in'>The terminating character, to
know when to stop reading input </p>

<p class=MsoNormal>The terminating character has a default value of <b>'\n'</b>,
which is what you’ll usually use. Both functions store a zero in the result
buffer when they encounter the terminating character in the input. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0424"
title="Add Comment A0424">Comment</a></sup></p>

<p class=MsoNormal>So what’s the difference? Subtle, but important: <b>get(&nbsp;)</b>
stops when it <i>sees</i> the delimiter in the input stream, but it doesn’t
extract it from the input stream. Thus, if you did another <b>get(&nbsp;)</b>
using the same delimiter, it would immediately return with no fetched input.
(Presumably, you either use a different delimiter in the next <b>get(&nbsp;)</b>
statement or a different input function.) The <b>getline(&nbsp;) </b>function,
on the other hand, extracts the delimiter from the input stream, but still
doesn’t store it in the result buffer. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0425"
title="Add Comment A0425">Comment</a></sup></p>

<p class=MsoNormal>The <b>getline(&nbsp;)</b> function defined in <b>&lt;string&gt;</b>
is convenient. It is not a member function, but rather a stand-alone function
declared in the namespace <b>std</b>. It takes only two non-default arguments,
the input stream and the <b>string</b> object to populate. Like its namesake,
it reads characters until it encounters the first occurrence of the delimiter (<b>'\n'</b>
by default) and consumes and discards the delimiter. The advantage of this
function is that it reads into a <b>string</b> object, so you don’t have to
worry about buffer size. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1589"
title="Add Comment A1589">Comment</a></sup></p>

<p class=MsoNormal>Generally, when you’re processing a text file that you read
a line at a time, you’ll want to use one of the <b>getline(&nbsp;)</b>
functions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0426"
title="Add Comment A0426">Comment</a></sup></p>

<h4>Overloaded versions of <span style='font-weight:normal'>get(&nbsp;)</span></h4>

<p class=MsoNormal>The<b> get(&nbsp;)</b> function also comes in three other
overloaded versions: one with no arguments that returns the next character,
using an <b>int</b> return value; one that stuffs a character into its <b>char</b>
argument, using a <i>reference</i>; and one that stores directly into the
underlying buffer structure of another iostream object. The latter is explored
later in the chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0427"
title="Add Comment A0427">Comment</a></sup></p>

<h4>Reading raw bytes</h4>

<p class=MsoNormal>If you know exactly what you’re dealing with and want to
move the bytes directly into a variable, an array, or a structure in memory,
you can use the unformatted I/O function <b>read(&nbsp;)</b>. The first argument is a pointer to the destination memory, and the second is the
number of bytes to read. This is especially useful if you’ve previously stored
the information to a file, for example, in binary form using the complementary <b>write(&nbsp;)</b> member function for an output stream (using the same compiler, of course). You’ll
see examples of all these functions later. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0428"
title="Add Comment A0428">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440016">Handling stream errors</a></h2>

<p class=MsoNormal>The <b>Date</b> extractor shown earlier sets a stream’s fail
bit under certain conditions. How does the user know when such a failure
occurs? You can detect stream errors by either calling certain stream member
functions to see if an error state has occurred, or if you don’t care what the
particular error was, you can just evaluate the stream in a Boolean context.
Both techniques derive from the state of a stream’s error bits.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1590"
title="Add Comment A1590">Comment</a></sup></p>

<h4>Stream state</h4>

<p class=MsoNormal>The <b>ios_base</b> class, from which <b>ios</b> derives,<a
href="#_ftn39" name="_ftnref39" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[39]</span></sup></span></span></sup></span></a> defines four flags
that you can use to test the state of a stream:</p>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse'>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Flag</p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Meaning</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>badbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><a>Some </a><span class=MsoCommentReference><span
  style='font-size:8.0pt;font-family:Times'><a class=msocomanchor id="_anchor_6"
  onmouseover="msoCommentShow('_anchor_6','_com_6')"
  onmouseout="msoCommentHide('_com_6')" href="#_msocom_6" language=JavaScript
  name="_msoanchor_6">[DwH6]</a><span style='display:none'>&nbsp;</span></span></span>fatal
  (perhaps physical) error occurred. The stream should be considered unusable.</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>eofbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>End-of-input has occurred (either by encountering the
  physical end of a file stream or by the user terminating a console stream,
  such as with Ctrl-Z or Ctrl&#8209;D).</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>failbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>An I/O operation failed, most likely because of invalid
  data (e.g., letters were found when trying to read a number). The stream is
  still usable. The failbit flag is also set when end-of-input occurs.</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>goodbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>All is well; no errors. End-of-input has not yet occurred.</p>
  </td>
 </tr>
</table>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can test whether any of these conditions have occurred
by calling corresponding member functions that return a Boolean value indicating
whether any of these have been set. The <b>good(&nbsp;)</b> stream member
function returns true if none of the other three bits are set. The <b>eof(&nbsp;)</b>
function returns true if <b>eofbit</b> is set, which happens with an attempt to
read from a stream that has no more data (usually a file). Because end-of-input
happens in C++ when trying to read past the end of the physical medium, <b>failbit</b>
is also set to indicate that the “expected” data was not successfully read. The
<b>fail(&nbsp;)</b> function returns true if <i>either</i> <b>failbit</b> or <b>badbit</b>
is set, and <b>bad(&nbsp;)</b> returns true only if the <b>badbit</b> is set. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1591"
title="Add Comment A1591">Comment</a></sup></p>

<p class=MsoNormal>Once any of the error bits in a stream’s state are set, they
remain set, which is not always what you want. When reading a file for example,
you might want to reposition to an earlier place in the file before end-of-file
occurred. Just moving the file pointer doesn’t automatically reset <b>eofbit</b>
or <b>failbit</b>; you have to do it yourself with the <b>clear(&nbsp;)</b>
function, like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1592"
title="Add Comment A1592">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>myStream.clear();    //
Clears all error bits</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>After calling <b>clear(&nbsp;)</b>, <b>good(&nbsp;)</b> will
return <b>true</b> if called immediately. As you saw in the <b>Date</b>
extractor earlier, the <b>setstate(&nbsp;)</b> function sets the bits you pass
it. It turns out that <b>setstate(&nbsp;)</b> doesn’t affect any other bits—if
they’re already set, they stay set. If you want to set certain bits but at the
same time reset all the rest, you can call an overloaded version of <b>clear(&nbsp;)</b>,
passing it a bitwise expression representing the bits you want to set, as in: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1593"
title="Add Comment A1593">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>myStream.clear(ios::failbit
| ios::eofbit);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Most of the time you won’t be interested in checking the
stream state bits individually. Usually you just want to know if everything is
okay. This is the case when you read a file from beginning to end; you just
want to know when the input data has been exhausted. In cases such as these, a
conversion operator is defined for <b>void*</b> that is automatically called
when a stream occurs in a Boolean expression. To read a stream until
end-of-input using this idiom looks like the following: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1594"
title="Add Comment A1594">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>int i;</p>

<p class=CodeChar style='margin-left:0in'>while (myStream &gt;&gt; i)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; i &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Remember that <b>operator&gt;&gt;(&nbsp;)</b> returns its
stream argument, so the <b>while</b> statement above tests the stream as a
Boolean expression. This particular example assumes that the input stream <b>myStream</b>
contains integers separated by white space. The function <b>ios_base::operator
void*(&nbsp;)</b> simply calls <b>good(&nbsp;)</b> on its stream and returns the
result.<a href="#_ftn40" name="_ftnref40" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[40]</span></sup></span></span></sup></span></a> Because
most stream operations return their stream, using this idiom is convenient. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1595"
title="Add Comment A1595">Comment</a></sup></p>

<h4>Streams and exceptions</h4>

<p class=MsoNormal>Iostreams existed as part of C++ long before there were
exceptions, so checking stream state manually was just the way things were
done. For backward compatibility, this is still the status quo, but iostreams
can throw exceptions instead. The <b>exceptions(&nbsp;)</b> stream member
function takes a parameter representing the state bits for which you want
exceptions to be thrown. Whenever the stream encounters such a state, it throws
an exception of type <b>std::ios_base::failure</b>, which inherits from <b>std::exception</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1596"
title="Add Comment A1596">Comment</a></sup></p>

<p class=MsoNormal>Although you can trigger a failure exception for any of the
four stream states, it’s not necessarily a good idea to enable exceptions for
all of them. As Chapter 1 explains, use exceptions for truly exceptional
conditions, but end-of-file is not only <i>not</i> exceptional—it’s <i>expected</i>!
For that reason, you might want to enable exceptions only for the errors
represented by <b>badbit</b>, which you would do like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1597"
title="Add Comment A1597">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>myStream.exceptions(ios::badbit);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You enable exceptions on a stream-by-stream basis, since <b>exceptions(
)</b> is a member function for streams. The <b>exceptions(&nbsp;)</b> function
returns a bitmask<a href="#_ftn41" name="_ftnref41" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[41]</span></sup></span></span></sup></span></a> (of
type <b>iostate</b>, which is some compiler-dependent type convertible to <b>int</b>)
indicating which stream states will cause exceptions. If those states have
already been set, an exception is thrown immediately. Of course, if you use
exceptions in connection with streams, you had better be ready to catch them,
which means that you need to wrap all stream processing with a <b>try</b> block
that has an <b>ios::failure</b> handler. Many programmers find this tedious and
just check states manually where they expect errors to occur (since, for
example, they don’t expect <b>bad(&nbsp;)</b> to return <b>true</b> most of the
time anyway). This is another reason that having streams throw exceptions is
optional and not the default. In any case, you can choose how you want to
handle stream errors. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1598"
title="Add Comment A1598">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440017"></a><a name="_Toc312373881"></a><a
name="_Toc305628665">File iostreams</a></h2>

<p class=MsoNormal>Manipulating files with iostreams is much easier and safer
than using <b>stdio </b>in C. All you do to open a file is create an object;
the constructor does the work. You don’t have to explicitly close a file
(although you can, using the <b>close(&nbsp;)</b> member function) because the
destructor will close it when the object goes out of scope. To create a file
that defaults to input, make an <b>ifstream</b> object. To create one that
defaults to output, make an <b>ofstream</b> object. An <b>fstream</b> object
can do both input and output. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0433"
title="Add Comment A0433">Comment</a></sup></p>

<p class=MsoNormal>The file stream classes fit into the iostreams classes as
shown in the following figure.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><img border=0 width=475 height=336
src="TicV2_files/image005.gif"></p>

<p class=MsoNormal>As before, the classes you actually use are template
specializations defined by type definitions. For example, <b>ifstream</b>, which
processes files of <b>char</b>, is defined as <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1599"
title="Add Comment A1599">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
basic_ifstream&lt;char&gt; ifstream;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440018">A File-Processing Example</a></h3>

<p class=MsoNormal>Here’s an example that shows many of the features discussed
so far. Notice the inclusion of <b>&lt;fstream&gt; </b>to declare the file I/O
classes. Although on many platforms this will also include <b>&lt;iostream&gt;</b>
automatically, compilers are not required to do so. If you want portable code,
always include both headers. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0434"
title="Add Comment A0434">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Strfile.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Stream I/O with files</p>

<p class=CodeChar style='margin-left:0in'>// The difference between get() &amp;
getline()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;  </p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int SZ = 100; // Buffer size;</p>

<p class=CodeChar style='margin-left:0in'>  char buf[SZ];</p>

<p class=CodeChar style='margin-left:0in'>  {</p>

<p class=CodeChar style='margin-left:0in'>    ifstream
in(&quot;Strfile.cpp&quot;); // Read</p>

<p class=CodeChar style='margin-left:0in'>    assure(in,
&quot;Strfile.cpp&quot;); // Verify open</p>

<p class=CodeChar style='margin-left:0in'>    ofstream out(&quot;Strfile.out&quot;);
// Write</p>

<p class=CodeChar style='margin-left:0in'>    assure(out,
&quot;Strfile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    int i = 1; // Line counter</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>    // A less-convenient approach for
line input:</p>

<p class=CodeChar style='margin-left:0in'>    while(in.get(buf, SZ)) { //
Leaves \n in input</p>

<p class=CodeChar style='margin-left:0in'>      in.get(); // Throw away next
character (\n)</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; buf &lt;&lt;
endl; // Must add \n</p>

<p class=CodeChar style='margin-left:0in'>      // File output just like
standard I/O:</p>

<p class=CodeChar style='margin-left:0in'>      out &lt;&lt; i++ &lt;&lt;
&quot;: &quot; &lt;&lt; buf &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } // Destructors close in &amp; out</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Strfile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in,
&quot;Strfile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // More convenient line input:</p>

<p class=CodeChar style='margin-left:0in'>  while(in.getline(buf, SZ)) { //
Removes \n</p>

<p class=CodeChar style='margin-left:0in'>    char* cp = buf;</p>

<p class=CodeChar style='margin-left:0in'>    while(*cp != ':')</p>

<p class=CodeChar style='margin-left:0in'>      cp++;</p>

<p class=CodeChar style='margin-left:0in'>    cp += 2; // Past &quot;: &quot;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; cp &lt;&lt; endl;
// Must still add \n</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The creation of both the <b>ifstream</b> and <b>ofstream</b>
are followed by an <b>assure(&nbsp;)</b> to guarantee the file has been
successfully opened. Here again the object, used in a situation in which the
compiler expects a Boolean result, produces a value that indicates success or
failure. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0435"
title="Add Comment A0435">Comment</a></sup></p>

<p class=MsoNormal>The first <b>while</b> loop demonstrates the use of two
forms of the <b>get(&nbsp;)</b> function. The first gets characters into a
buffer and puts a zero terminator in the buffer when either <b>SZ – 1</b>
characters have been read or the third argument (defaulted to <b>'\n'</b>) is
encountered. The <b>get(&nbsp;)</b> function leaves the terminator character in
the input stream, so this terminator must be thrown away via <b>in.get(&nbsp;)</b>
using the form of <b>get(&nbsp;)</b> with no argument, which fetches a single
byte and returns it as an <b>int</b>. You can also use the <b>ignore(&nbsp;)</b>
member function, which has two default arguments. The first argument is the
number of characters to throw away and defaults to one. The second argument is
the character at which the <b>ignore(&nbsp;)</b> function quits (after
extracting it) and defaults to <b>EOF</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0436"
title="Add Comment A0436">Comment</a></sup></p>

<p class=MsoNormal>Next, you see two output statements that look similar: one
to <b>cout </b>and one to the file <b>out</b>. Notice the convenience here; you
don’t need to worry about what kind of object you’re dealing with because the
formatting statements work the same with all <b>ostream</b> objects. The first one echoes the line to standard output, and the second writes
the line out to the new file and includes a line number. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0437"
title="Add Comment A0437">Comment</a></sup></p>

<p class=MsoNormal>To demonstrate <b>getline(&nbsp;)</b>, open the file we just created and strip off the line numbers. To ensure the file
is properly closed before opening it to read, you have two choices. You can
surround the first part of the program with braces to force the <b>out</b>
object out of scope, thus calling the destructor and closing the file, which is
done here. You can also call <b>close(&nbsp;)</b> for both files; if you do
this, you can even reuse the <b>in</b> object by calling the <b>open(&nbsp;)</b>
member function. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0438"
title="Add Comment A0438">Comment</a></sup></p>

<p class=MsoNormal>The second <b>while</b> loop shows how <b>getline(&nbsp;)</b>
removes the terminator character (its third argument, which defaults to <b>'\n'</b>)
from the input stream when it’s encountered. Although <b>getline(&nbsp;)</b>,
like <b>get(&nbsp;)</b>, puts a zero in the buffer, it still doesn’t insert the
terminating character. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0439"
title="Add Comment A0439">Comment</a></sup></p>

<p class=MsoNormal>This example, as well as most of the examples in this
chapter, assumes that each call to any overload of <b>getline(&nbsp;)</b> will
actually encounter a newline character. If this is not the case, the eofbit
state of the stream will be set and the call to <b>getline(&nbsp;)</b> will
return <b>false</b>, causing the program to lose the last line of input.</p>

<h3><a name="_Toc45440019"></a><a name="_Toc312373882">Open modes</a></h3>

<p class=MsoNormal>You can control the way a file is opened by overriding the
constructor’s default arguments. The following table shows the flags that
control the mode of the file: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0440"
title="Add Comment A0440">Comment</a></sup></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=108 valign=top style='width:81.0pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>Flag</p>
   </td>
   <td width=321 valign=top style='width:240.55pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>Function</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::in</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Opens an input file. Use this as an open mode for an <b>ofstream</b>
  to prevent truncating an existing file.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::out</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Opens an output file. When used for an <b>ofstream</b>
  without <b>ios::app</b>, <b>ios::ate</b> or <b>ios::in</b>, <b>ios::trunc</b>
  is implied.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::app</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Opens an output file for appending only.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::ate</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Opens an existing file (either input or output) and seeks
  to the end.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::trunc</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Truncates the old file, if it already exists.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::binary</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Opens a file in <i>binary mode</i>. The default is <i>text
  mode</i>.</p>
  </td>
 </tr>
</table>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can combine these flags using a bitwise <i>or</i>
operation. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0441"
title="Add Comment A0441">Comment</a></sup></p>

<p class=MsoNormal>The binary flag, while portable, only has an effect on some
non-UNIX systems, such as operating systems derived from MS-DOS, that have
special conventions for storing end-of-line delimiters. For example, on MS-DOS
systems in text mode (which is the default), every time you output a newline
character (<b>'\n'</b>), the file system actually outputs two characters, a
carriage-return/linefeed pair (CRLF), which is the pair of ASCII characters <b>0x0D</b>
and <b>0x0A</b>. Conversely, when you read such a file back into memory in text
mode, each occurrence of this pair of bytes causes a <b>'\n'</b> to be sent to
the program in its place. If you want to bypass this special processing, you
open files in binary mode. Binary mode has nothing whatsoever to do with
whether you <i>can</i> write raw bytes to a file—you <i>always</i> can (by
calling <b>write(&nbsp;)</b>) . You should, however, open a file in binary mode
when you’ll be using <b>read(&nbsp;)</b> or <b>write(&nbsp;)</b>, because these
functions take a byte count parameter. Having the extra <b>'\r'</b> characters
will throw your byte count off in those instances. You should also open a file
in binary mode if you’re going to use the stream-positioning commands discussed
later in this chapter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1600"
title="Add Comment A1600">Comment</a></sup></p>

<p class=MsoNormal>You can open a file for both input and output by declaring
an <b>fstream</b> object. When declaring an <b>fstream</b> object, you must use
enough of the open mode flags mentioned earlier to let the file system know
whether you want to input, output, or both. To switch from output to input, you
need to either flush the stream or change the file position. To change from
input to output, you must change the file position. To create a file via an <b>fstream</b>
object, you need to use the <b>ios::trunc</b> open mode flag in the constructor
call if you will actually do both input and output. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1601"
title="Add Comment A1601">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440020"></a><a name="_Toc312373883"></a><a
name="_Toc305628666">Iostream buffering</a></h2>

<p class=MsoNormal>Good design practice dictates that whenever you create a new class, you should endeavor to hide the details of the underlying
implementation as much possible from the user of the class. You show them only
what they need to know and make the rest <b>private </b>to avoid confusion.
When using inserters and extractors, you normally don’t know or care where the
bytes are being produced or consumed, whether you’re dealing with standard I/O,
files, memory, or some newly created class or device. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0442"
title="Add Comment A0442">Comment</a></sup></p>

<p class=MsoNormal>A time comes, however, when it is important to communicate
with the part of the iostream that produces and consumes bytes. To provide this
part with a common interface and still hide its underlying implementation, the
standard library abstracts it into its own class, called <b>streambuf</b>. Each iostream object contains a pointer to some kind of <b>streambuf</b>. (The
kind depends on whether it deals with standard I/O, files, memory, and so on.)
You can access the <b>streambuf </b>directly; for example, you can move raw
bytes into and out of the <b>streambuf</b>, without formatting them through the
enclosing iostream. This is accomplished by calling member functions for the <b>streambuf</b>
object. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0443"
title="Add Comment A0443">Comment</a></sup></p>

<p class=MsoNormal>Currently, the most important thing for you to know is that
every iostream object contains a pointer to a <b>streambuf</b> object, and the <b>streambuf</b>
object has some member functions you can call if necessary. For file and string
streams, there are specialized types of stream buffers, as the following figure
illustrates. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0444"
title="Add Comment A0444">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=412 height=190
src="TicV2_files/image006.gif"></p>

<p class=MsoNormal>To allow you to access the <b>streambuf</b>, every iostream
object has a member function called <b>rdbuf(&nbsp;)</b> that returns the pointer to the object’s <b>streambuf</b>. This way you can call
any member function for the underlying <b>streambuf</b>. However, one of the
most interesting things you can do with the <b>streambuf</b> pointer is to
connect it to another iostream object using the <b>&lt;&lt;</b> operator. This
drains all the characters from your object into the one on the left side of the
<b>&lt;&lt;</b>. If you want to move all the characters from one iostream to
another, you don’t have to go through the tedium (and potential coding errors)
of reading them one character or one line at a time. It’s a much more elegant
approach. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0445"
title="Add Comment A0445">Comment</a></sup></p>

<p class=MsoNormal>For example, here’s a simple program that opens a file and
sends the contents to standard output (similar to the previous example): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0446"
title="Add Comment A0446">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Stype.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Type a file to standard output</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(&quot;Stype.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, &quot;Stype.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; in.rdbuf(); //
Outputs entire file</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>An <b>ifstream</b> is created using the source code file for
this program as an argument. The <b>assure( ) </b>function reports a failure if
the file cannot be opened. All the work really happens in the statement: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0447"
title="Add Comment A0447">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt; in.rdbuf();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which sends the entire contents of the file to <b>cout</b>.
This is not only more succinct to code, it is often more efficient than moving
the bytes one at a time. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0448"
title="Add Comment A0448">Comment</a></sup></p>

<p class=MsoNormal>A form of <b>get(&nbsp;)</b> allows you to write directly into the <b>streambuf</b> of another object. The first argument is a
reference to the destination <b>streambuf,</b>  and the second is the
terminating character (<b>‘\n’</b> by default), which stops the <b>get(&nbsp;)</b>
function. So there is yet another way to print a file to standard output: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0449"
title="Add Comment A0449">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Sbufget.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Copies a file to standard output</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Sbufget.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in);</p>

<p class=CodeChar style='margin-left:0in'>  streambuf&amp; sb = *cout.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>  while (!in.get(sb).eof()) {</p>

<p class=CodeChar style='margin-left:0in'>    if (in.fail())          // Found
blank line</p>

<p class=CodeChar style='margin-left:0in'>      in.clear();</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; char(in.get()); //
Process '\n'</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The<b> rdbuf(&nbsp;)</b> function returns a pointer, so it
must be dereferenced to satisfy the function’s need to see an object. Stream
buffers are not meant to be copied (they have no copy constructor), so we
define <b>sb</b> as a <i>reference</i> to <b>cout</b>’s stream buffer. We need
the calls to <b>fail(&nbsp;)</b> and <b>clear(&nbsp;)</b> in case the input
file has a blank line (this one does). When this particular overloaded version
of <b>get(&nbsp;)</b> sees two newlines in a row (evidence of a blank line), it
sets the input stream’s fail bit, so we must call <b>clear(&nbsp;)</b> to reset
it so that the stream can continue to be read. The second call to <b>get(&nbsp;)</b>
extracts and echoes each newline delimiter. (Remember, the <b>get(&nbsp;)</b>
function doesn’t extract its delimiter like <b>getline(&nbsp;)</b> does.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0450"
title="Add Comment A0450">Comment</a></sup></p>

<p class=MsoNormal>You probably won’t need to use a technique like this often,
but it’s nice to know it exists.<a href="#_ftn42" name="_ftnref42" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[42]</span></sup></span></span></sup></span></a><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0451"
title="Add Comment A0451">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440021"></a><a name="_Toc312373885"></a><a
name="_Toc305628667">Seeking in iostreams</a></h2>

<p class=MsoNormal>Each type of iostream has a concept of where its “next”
character will come from (if it’s an <b>istream</b>) or go (if it’s an <b>ostream</b>).
In some situations, you might want to move this stream position. You can do so
using two models: one uses an absolute location in the stream called the <b>streampos</b>; the second works like the Standard C library functions <b>fseek(&nbsp;)</b> for a file and moves a given number of bytes from the beginning, end, or current
position in the file. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0452"
title="Add Comment A0452">Comment</a></sup></p>

<p class=MsoNormal>The <b>streampos</b> approach requires that you first call a
“tell” function: <b>tellp(&nbsp;)</b> for an <b>ostream</b> or <b>tellg(&nbsp;)</b> for an <b>istream</b>. (The “p” refers to the “put pointer,” and the “g” refers to the “get pointer.”) This function returns a <b>streampos</b> you can
later use in calls to <b>seekp(&nbsp;)</b> for an <b>ostream</b> or <b>seekg(&nbsp;)</b> for an <b>istream</b>, when you want to return to
that position in the stream. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0453"
title="Add Comment A0453">Comment</a></sup></p>

<p class=MsoNormal>The second approach is a relative seek and uses overloaded
versions of <b>seekp(&nbsp;)</b> and <b>seekg(&nbsp;)</b>. The first argument
is the number of characters to move: it can be positive or negative. The second
argument is the seek direction: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0454"
title="Add Comment A0454">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::beg</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>From beginning of stream</p>
  </td>
 </tr>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::cur</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Current position in stream</p>
  </td>
 </tr>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::end</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>From end of stream</p>
  </td>
 </tr>
</table>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here’s an example that shows the movement through a file,
but remember, you’re not limited to seeking within files, as you are with C and
<b>cstdio</b>. With C++, you can seek in any type of iostream (although the
standard stream objects, such as <b>cin</b> and <b>cout</b>,<b> </b>explicitly
disallow it): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0455"
title="Add Comment A0455">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Seeking.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Seeking in iostreams</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>const int STR_NUM =
5, STR_LEN = 30;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char
origData[STR_NUM][STR_LEN] = {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>&quot;Hickory
dickory dus. . .&quot;,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;Are you tired of
C++?&quot;,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;Well, if you are,&quot;,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;That's just too bad,&quot;,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;There's plenty more for
us!&quot;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>};</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  char
readData[STR_NUM][STR_LEN] = { 0 };</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>ofstream
out(&quot;Poem.bin&quot;, ios::out | ios::binary);</p>

<p class=CodeChar style='margin-left:0in'>  assure(out, &quot;Poem.bin&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; STR_NUM;
i++)</p>

<p class=CodeChar style='margin-left:0in'>    out.write(origData[i], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  out.close();</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(&quot;Poem.bin&quot;,
ios::in | ios::binary);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, &quot;Poem.bin&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  in.read(readData[0], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  assert(strcmp(readData[0], &quot;Hickory
dickory dus. . .&quot;)</p>

<p class=CodeChar style='margin-left:0in'>    == 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Seek -STR_LEN bytes from the end
of file</p>

<p class=CodeChar style='margin-left:0in'>  in.seekg(-STR_LEN, ios::end);</p>

<p class=CodeChar style='margin-left:0in'>  in.read(readData[1], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  assert(strcmp(readData[1],
&quot;There's plenty more for us!&quot;) </p>

<p class=CodeChar style='margin-left:0in'>    == 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Absolute seek (like using
operator[] with a file)</p>

<p class=CodeChar style='margin-left:0in'>  in.seekg(3 * STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  in.read(readData[2], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  assert(strcmp(readData[2],
&quot;That's just too bad,&quot;) == 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Seek backwards from current
position</p>

<p class=CodeChar style='margin-left:0in'>  in.seekg(-STR_LEN * 2, ios::cur);</p>

<p class=CodeChar style='margin-left:0in'>  in.read(readData[3], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  assert(strcmp(readData[3],
&quot;Well, if you have,&quot;) == 0);</p>

<p class=CodeChar style='margin-left:0in'>  // Seek from the begining of the
file</p>

<p class=CodeChar style='margin-left:0in'>  in.seekg(1 * STR_LEN, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  in.read(readData[4], STR_LEN);</p>

<p class=CodeChar style='margin-left:0in'>  assert(strcmp(readData[4],
&quot;Have you had plenty of C++?&quot;) </p>

<p class=CodeChar style='margin-left:0in'>    == 0);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This program writes a (very clever) poem to a file using a
binary output stream. Since we reopen it as an <b>ifstream</b>, we use <b>seekg(&nbsp;)</b>
to position the “get pointer.” As you can see, you can seek from the beginning
or end of the file or from the current file position. Obviously, you must
provide a positive number to move from the beginning of the file and a negative
number to move back from the end. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0456"
title="Add Comment A0456">Comment</a></sup></p>

<p class=MsoNormal>Now that you know about the <b>streambuf</b> and how to
seek, you can understand an alternative method (besides using an <b>fstream</b>
object) for creating a stream object that will both read and write a file. The
following code first creates an <b>ifstream</b> with flags that say it’s both
an input and an output file. You can’t write to an <b>ifstream</b>, of course,
so you need to create an <b>ostream</b> with the underlying stream buffer: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0457"
title="Add Comment A0457">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>ifstream in(&quot;filename&quot;,
ios::in | ios::out);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>ostream out(in.rdbuf());</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You might wonder what happens when you write to one of these
objects. Here’s an example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0458"
title="Add Comment A0458">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Iofile.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Reading &amp; writing one file</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Iofile.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, &quot;Iofile.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
out(&quot;Iofile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(out,
&quot;Iofile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  out &lt;&lt; in.rdbuf(); // Copy
file</p>

<p class=CodeChar style='margin-left:0in'>  in.close();</p>

<p class=CodeChar style='margin-left:0in'>  out.close();</p>

<p class=CodeChar style='margin-left:0in'>  // Open for reading and writing:</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in2(&quot;Iofile.out&quot;, ios::in);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in2,
&quot;Iofile.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ostream out2(in2.rdbuf());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; in2.rdbuf();  //
Print whole file</p>

<p class=CodeChar style='margin-left:0in'>  out2 &lt;&lt; &quot;Where does this
end up?&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  out2.seekp(0, ios::end);</p>

<p class=CodeChar style='margin-left:0in'>  out2 &lt;&lt; &quot;And what about
this?&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  in2.seekg(0, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; in2.rdbuf();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first five lines copy the source code for this program
into a file called <b>iofile.out</b> and then close the files. This gives us a
safe text file to play with. Then the aforementioned technique is used to
create two objects that read and write to the same file. In <b>cout &lt;&lt;
in2.rdbuf(&nbsp;)</b>, you can see the “get” pointer is initialized to the
beginning of the file. The “put” pointer, however, is set to the end of the
file because “Where does this end up?” appears appended to the file. However,
if the put pointer is moved to the beginning with a <b>seekp(&nbsp;)</b>, all
the inserted text <i>overwrites </i>the existing text. Both writes are seen
when the get pointer is moved back to the beginning with a <b>seekg(&nbsp;)</b>,
and the file is displayed. Of course, the file is automatically saved and
closed when <b>out2</b> goes out of scope and its destructor is called. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0459"
title="Add Comment A0459">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc312373887"></a><a name="_Toc305628668"></a><a
name="_Toc45440022">String iostreams</a></h2>

<p class=MsoNormal>A string stream works directly with memory instead of a file
or standard output. It allows you to use the same reading and formatting
functions that you use with <b>cin</b> and <b>cout</b> to manipulate bytes in
memory. On old computers, the memory was referred to as <i>core,</i> so this
type of functionality is often called <i>in-core formatting</i>. <sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0461"
title="Add Comment A0461">Comment</a></sup></p>

<p class=MsoNormal>The class names for string streams echo those for file
streams. If you want to create a string stream to extract characters from, you
create an <b>istringstream</b>. If you want to put characters into a string
stream, you create an <b>ostringstream</b>. All declarations for string stream
are in the standard header <b>&lt;sstream&gt;</b>. As usual, there are class
templates that fit into the iostreams hierarchy, as shown in the following
figure: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0462"
title="Add Comment A0462">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=505 height=336
src="TicV2_files/image007.gif"></p>

<h3><a name="_Toc45440023">Input string streams</a></h3>

<p class=MsoNormal>To read from a string using stream operations, you create an
<b>istringstream</b> object initialized with the string. The following program
shows how to use an <b>istringstream</b> object.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Istring.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Input string streams</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;  // For fabs()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;limits&gt; // For
epsilon()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  istringstream s(&quot;47 1.414 This
is a test&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>  double f;</p>

<p class=CodeChar style='margin-left:0in'>  s &gt;&gt; i &gt;&gt; f; //
Whitespace-delimited input</p>

<p class=CodeChar style='margin-left:0in'>  assert(i == 47);</p>

<p class=CodeChar style='margin-left:0in'>  double relerr = (fabs(f) - 1.414) /
1.414;</p>

<p class=CodeChar style='margin-left:0in'>  assert(relerr &lt;=
numeric_limits&lt;double&gt;::epsilon());</p>

<p class=CodeChar style='margin-left:0in'>  string buf2;</p>

<p class=CodeChar style='margin-left:0in'>  s &gt;&gt; buf2;</p>

<p class=CodeChar style='margin-left:0in'>  assert(buf2 == &quot;This&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s.rdbuf(); // &quot;
is a test&quot;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that this is a more flexible and general
approach to transforming character strings to typed values than the standard C library functions such as <b>atof(&nbsp;)</b>, <b>atoi(&nbsp;)</b>, even though the latter may be more efficient for single conversions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0467"
title="Add Comment A0467">Comment</a></sup></p>

<p class=MsoNormal>In the expression <b>s &gt;&gt; i &gt;&gt; f</b>, the first
number is extracted into <b>i,</b> and the second into <b>f</b>. This isn’t
“the first whitespace-delimited set of characters” because it depends on the
data type it’s being extracted into. For example, if the string were instead, “<b>1.414
47 This is a test</b>,” then <b>i</b> would get the value 1 because the input
routine would stop at the decimal point. Then <b>f</b> would get <b>0.414</b>.
This could be useful if you want to break a floating-point number into a whole
number and a fraction part. Otherwise it would seem to be an error. The second <b>assert(&nbsp;)</b>
calculates the relative error between what we read and what we expected; it’s
always better to do this than to compare floating-point numbers for equality.
The constant returned by <b>epsilon(&nbsp;)</b>, defined in <b>&lt;limits&gt;</b>,
represents the <i>machine epsilon</i> for double-precision numbers, which is
the best tolerance you can expect comparisons of <b>double</b>s to satisfy.<a
href="#_ftn43" name="_ftnref43" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[43]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0470"
title="Add Comment A0470">Comment</a></sup></p>

<p class=MsoNormal>As you may already have guessed, <b>buf2</b> doesn’t get the
rest of the string, just the next white-space-delimited word. In general, it’s
best to use the extractor in iostreams when you know the exact sequence of data
in the input stream and you’re converting to some type other than a character
string. However, if you want to extract the rest of the string all at once and
send it to another iostream, you can use <b>rdbuf(&nbsp;)</b> as shown. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0471"
title="Add Comment A0471">Comment</a></sup></p>

<p class=MsoNormal>To test the <b>Date</b> extractor at the beginning of this chapter,
we used an input string stream with the following test program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:DateIOTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../C02/Date</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../C02/Date.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void testDate(const string&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  istringstream os(s);</p>

<p class=CodeChar style='margin-left:0in'>  Date d;</p>

<p class=CodeChar style='margin-left:0in'>  os &gt;&gt; d;</p>

<p class=CodeChar style='margin-left:0in'>  if (os)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; d &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;input error
with \&quot;&quot; &lt;&lt; s &lt;&lt; &quot;\&quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  testDate(&quot;08-10-2003&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testDate(&quot;8-10-2003&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testDate(&quot;08 - 10 -
2003&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testDate(&quot;A-10-2003&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testDate(&quot;08%10/2003&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each string literal in <b>main(&nbsp;)</b> is passed by
reference to <b>testDate(&nbsp;)</b>, which in turn wraps it in an <b>istringstream</b>
so we can test the<b> </b>stream extractor we wrote for <b>Date</b> objects.
The function <b>testDate(&nbsp;)</b> also begins to test the inserter, <b>operator&lt;&lt;(&nbsp;)</b>.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1602"
title="Add Comment A1602">Comment</a></sup></p>

<h3><a name="_Toc45440024">Output string streams</a></h3>

<p class=MsoNormal>To create an output string stream to put data into, you just
create an <b>ostringstream</b> object, which manages a dynamically sized
character buffer to hold whatever you insert. To get the formatted result as a <b>string</b>
object, you call the <b>str(&nbsp;)</b> member function. Here’s an example: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0476"
title="Add Comment A0476">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Ostring.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates ostringstream</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;type an int, a
float and a string: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>int i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  float f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cin &gt;&gt; i
&gt;&gt; f;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>cin &gt;&gt;
ws; // Throw away white space</p>

<p class=CodeChar style='margin-left:0in'>  string stuff;</p>

<p class=CodeChar style='margin-left:0in'>  getline(cin, stuff); // Get rest of
the line</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>ostringstream os;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  os &lt;&lt;
&quot;integer = &quot; &lt;&lt; i &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  os &lt;&lt;
&quot;float = &quot; &lt;&lt; f &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  os &lt;&lt;
&quot;string = &quot; &lt;&lt; stuff &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>string result
= os.str();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; result &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This is similar to the <b>Istring.cpp</b> example earlier
that fetched an <b>int</b> and a <b>float</b>. A sample execution follows (the
keyboard input is in bold type). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0477"
title="Add Comment A0477">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>type an int, a float and a string: <b>10
20.5 the end</b></p>

<p class=CodeChar style='margin-left:0in'>integer = 10</p>

<p class=CodeChar style='margin-left:0in'>float = 20.5</p>

<p class=CodeChar style='margin-left:0in'>string = the end</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that, like the other output streams, you can use
the ordinary formatting tools, such as the <b>&lt;&lt;</b> operator and <b>endl</b>,
to send bytes to the <b>ostringstream</b>. The <b>str(&nbsp;)</b> function
returns a new <b>string</b> object every time you call it so the underlying <b>stringbuf</b>
object owned by the string stream is left undisturbed.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0478"
title="Add Comment A0478">Comment</a></sup></p>

<p class=MsoNormal>In the previous chapter, we presented a program, <b>HTMLStripper.cpp</b>,
that removed all HTML tags and special codes from a text file. As promised,
here is a more elegant version using string streams.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:HTMLStripper2.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../c03/replaceAll</p>

<p class=CodeChar style='margin-left:0in'>// Filter to remove html tags and
markers</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; replaceAll(string&amp;
context, const string&amp; from,</p>

<p class=CodeChar style='margin-left:0in'>  const string&amp; to);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string&amp; stripHTMLTags(string&amp;
s) throw(runtime_error) {</p>

<p class=CodeChar style='margin-left:0in'>  size_t leftPos;</p>

<p class=CodeChar style='margin-left:0in'>  while ((leftPos = s.find('&lt;'))
!= string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>    size_t rightPos = s.find('&gt;',
leftPos+1);</p>

<p class=CodeChar style='margin-left:0in'>    if (rightPos == string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>      ostringstream msg;</p>

<p class=CodeChar style='margin-left:0in'>      msg &lt;&lt; &quot;Incomplete
HTML tag starting in position &quot;</p>

<p class=CodeChar style='margin-left:0in'>          &lt;&lt; leftPos;</p>

<p class=CodeChar style='margin-left:0in'>      throw runtime_error(msg.str());</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    s.erase(leftPos, rightPos -
leftPos + 1);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Remove all special HTML
characters</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s, &quot;&amp;lt;&quot;,
&quot;&lt;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s, &quot;&amp;gt;&quot;,
&quot;&gt;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s,
&quot;&amp;amp;&quot;, &quot;&amp;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replaceAll(s,
&quot;&amp;nbsp;&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Etc...</p>

<p class=CodeChar style='margin-left:0in'>  return s;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  requireArgs(argc, 1, </p>

<p class=CodeChar style='margin-left:0in'>    &quot;usage: HTMLStripper2 InputFile&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  // Read entire file into string;
then strip</p>

<p class=CodeChar style='margin-left:0in'>  ostringstream ss;</p>

<p class=CodeChar style='margin-left:0in'>  ss &lt;&lt; in.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    string s = ss.str();</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; stripHTMLTags(s)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    return EXIT_SUCCESS;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (runtime_error&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; x.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    return EXIT_FAILURE;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this program we read the entire file into a string by
inserting a <b>rdbuf(&nbsp;)</b> call to the file stream into an <b>ostringstream</b>.
Now it’s an easy matter to search for HTML delimiter pairs and erase them
without having to worry about crossing line boundaries like we had to with the
previous version in Chapter 3. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1604"
title="Add Comment A1604">Comment</a></sup></p>

<p class=MsoNormal>The following example shows how to use a bidirectional (that
is, read/write) string stream.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:StringSeeking.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Reads and writes a string stream</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string text = &quot;We will sell no
wine&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  stringstream ss(text);</p>

<p class=CodeChar style='margin-left:0in'>  ss.seekp(0, ios::end);</p>

<p class=CodeChar style='margin-left:0in'>  ss &lt;&lt; &quot; before its
time.&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  assert(ss.str() ==</p>

<p class=CodeChar style='margin-left:0in'>    &quot;We will sell no wine before
its time.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Change &quot;sell&quot; to
&quot;ship&quot;</p>

<p class=CodeChar style='margin-left:0in'>  ss.seekg(9, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  string word;</p>

<p class=CodeChar style='margin-left:0in'>  ss &gt;&gt; word;</p>

<p class=CodeChar style='margin-left:0in'>  assert(word == &quot;ell&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ss.seekp(9, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  ss &lt;&lt; &quot;hip&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Change &quot;wine&quot; to
&quot;code&quot;</p>

<p class=CodeChar style='margin-left:0in'>  ss.seekg(16, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  ss &gt;&gt; word;</p>

<p class=CodeChar style='margin-left:0in'>  assert(word == &quot;wine&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ss.seekp(16, ios::beg);</p>

<p class=CodeChar style='margin-left:0in'>  ss &lt;&lt; &quot;code&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  assert(ss.str() ==</p>

<p class=CodeChar style='margin-left:0in'>    &quot;We will ship no code before
its time.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ss.str(&quot;A horse of a different
color.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(ss.str() == &quot;A horse of
a different color.&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><a name="_Toc312373890"></a><a name="_Toc305628669">As
always, to move the put pointer, you call <b>seekp(&nbsp;)</b>, and to
reposition the get pointer, you call <b>seekg(&nbsp;)</b>. Even though we
didn’t show it with this example, string streams are a little more forgiving
than file streams in that you can switch from reading to writing or vice-versa
at any time. You don’t need to reposition the get or put pointers or flush the
stream. This program also illustrates the overload of <b>str(&nbsp;)</b> that
replaces the stream’s underlying <b>stringbuf</b> with a new string. </a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1608"
title="Add Comment A1608"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440025">Output stream formatting</a></h2>

<p class=MsoNormal>The goal of the iostreams design is to allow you to easily
move and/or format characters. It certainly wouldn’t be useful if you couldn’t
do most of the formatting provided by C’s <b>printf(&nbsp;)</b> family of functions. In this section, you’ll learn all the output formatting
functions that are available for iostreams, so you can format your bytes the
way you want them. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0498"
title="Add Comment A0498">Comment</a></sup></p>

<p class=MsoNormal>The formatting functions in iostreams can be somewhat
confusing at first because there’s often more than one way to control the
formatting: through both member functions and manipulators. To further confuse
things, a generic member function sets state flags to control formatting, such
as left or right justification, to use uppercase letters for hex notation, to
always use a decimal point for floating-point values, and so on. On the other
hand, separate member functions set and read values for the fill character, the
field width, and the precision. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0499"
title="Add Comment A0499">Comment</a></sup></p>

<p class=MsoNormal>In an attempt to clarify all this, we’ll first examine the
internal formatting data of an iostream , along with the member functions that
can modify that data. (Everything can be controlled through the member
functions, if desired.) We’ll cover the manipulators separately. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0500"
title="Add Comment A0500">Comment</a></sup></p>

<h3><a name="_Toc45440026">Format flags</a></h3>

<p class=MsoNormal>The class <b>ios</b> contains data members to store all the
formatting information pertaining to a stream. Some of this data has a range of
values and is stored in variables: the floating-point precision, the output
field width, and the character used to pad the output (normally a space). The
rest of the formatting is determined by flags, which are usually combined to
save space and are referred to collectively as the <i>format flags</i>. You can find out the value of the format flags with the <b>ios::flags(&nbsp;)</b> member function, which takes no arguments and returns an object of type <b>fmtflags</b>
(usually a synonym for <b>long</b>) that contains the current format flags. All
the rest of the functions make changes to the format flags and return the
previous value of the format flags. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0501"
title="Add Comment A0501"><span lang=SV>Comment</span></a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span lang=SV>fmtflags
ios::flags(fmtflags newflags);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>fmtflags
ios::setf(fmtflags ored_flag);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>fmtflags ios::unsetf(fmtflags
clear_flag);</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span lang=SV>fmtflags
ios::setf(fmtflags bits, fmtflags field);</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span lang=SV>&nbsp;</span></p>

<p class=MsoNormal>The first function forces <i>all</i> the flags to change,
which you do sometimes. More often, you change one flag at a time using the
remaining three functions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0502"
title="Add Comment A0502">Comment</a></sup></p>

<p class=MsoNormal>The use of <b>setf(&nbsp;)</b> can seem somewhat confusing. To know which overloaded version to use, you must know what type of
flag you’re changing. There are two types of flags: those that are simply on or
off, and those that work in a group with other flags. The on/off flags are the
simplest to understand because you turn them on with <b>setf(fmtflags)</b> and
off with <b>unsetf(fmtflags)</b>. These flags are shown in the following table.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0503"
title="Add Comment A0503">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=143 valign=top style='width:107.1pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>on/off flag</p>
   </td>
   <td width=258 valign=top style='width:193.5pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::skipws</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Skip white space. (For input; this is the default.)</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::showbase</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Indicate the numeric base (as set, for example, by <b>dec</b>,
  <b>oct</b>, or <b>hex</b>) when printing an integral value. Input streams
  also recognize the base prefix when <b>showbase</b> is on.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::showpoint</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Show decimal point and trailing zeros for floating-point
  values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::uppercase</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Display uppercase A-F for hexadecimal values and E for
  scientific values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::showpos</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Show plus sign (+) for positive values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::unitbuf</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>“Unit buffering.” The stream is flushed after each
  insertion.</p>
  </td>
 </tr>
</table>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>For example, to show the plus sign for <b>cout</b>, you say <b>cout.setf(ios::showpos)</b>.
To stop showing the plus sign, you say <b>cout.unsetf(ios::showpos)</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0505"
title="Add Comment A0505">Comment</a></sup></p>

<p class=MsoNormal>The <b>unitbuf</b> flag controls <i>unit buffering</i>,
which means that each insertion is flushed to its output stream immediately.
This is handy for error tracing, so that in case of a program crash, your data
is still written to the log file. The following program illustrates unit
buffering.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Unitbuf.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;  // For
abort()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ofstream out(&quot;log.txt&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  out.setf(ios::unitbuf);</p>

<p class=CodeChar style='margin-left:0in'>  out &lt;&lt; &quot;one\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  out &lt;&lt; &quot;two\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  abort();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It is necessary to turn on unit buffering before any
insertions are made to the stream. When we commented out the call to <b>setf(&nbsp;)</b>,
one particular compiler had written only the letter ‘o’ to the file <b>log.txt</b>.
With unit buffering, no data was lost. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1603"
title="Add Comment A1603">Comment</a></sup></p>

<p class=MsoNormal>The standard error output stream <b>cerr</b> has unit
buffering turned on by default. There is a cost for unit buffering, of course,
so if an output stream is heavily used, don’t enable unit buffering unless
efficiency is not a consideration. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0506"
title="Add Comment A0506">Comment</a></sup></p>

<h3><a name="_Toc45440027">Format fields</a></h3>

<p class=MsoNormal>The second type of formatting flags work in a group. Only
one of these flags can be, like the buttons on old car radios—you push one in,
the rest pop out. Unfortunately this doesn’t happen automatically, and you have
to pay attention to what flags you’re setting so that you don’t accidentally
call the wrong <b>setf(&nbsp;)</b> function. For example, there’s a flag for
each of the number bases: hexadecimal, decimal, and octal. Collectively, these flags are referred to as the <b>ios::basefield</b>. If the <b>ios::dec</b> flag is set and you call <b>setf(ios::hex)</b>, you’ll set
the <b>ios::hex</b> flag, but you <i>won’t</i> clear the <b>ios::dec</b> bit,
resulting in undefined behavior. The proper thing to do is call the second form
of <b>setf(&nbsp;)</b> like this: <b>setf(ios::hex, ios::basefield)</b>. This
function first clears all the bits in the <b>ios::basefield</b> and <i>then</i>
sets <b>ios::hex</b>. Thus, this form of <b>setf(&nbsp;)</b> ensures that the
other flags in the group “pop out” whenever you set one. Of course, the <b>ios::hex</b> manipulator does all this for you, automatically, so you don’t have to concern
yourself with the internal details of the implementation of this class or to
even <i>care</i> that it’s a set of binary flags. Later you’ll see that there
are manipulators to provide equivalent functionality in all the places you
would use <b>setf(&nbsp;)</b>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0508"
title="Add Comment A0508">Comment</a></sup></p>

<p class=MsoNormal>Here are the flag groups and their effects: </p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>ios::basefield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::dec</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Format integral values in base 10 (decimal) (the default
  radix—no prefix is visible).</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::hex</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Format integral values in base 16 (hexadecimal).</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::oct</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Format integral values in base 8 (octal).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0510"
title="Add Comment A0510">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>ios::floatfield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::scientific</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Display floating-point numbers in scientific format.
  Precision field indicates number of digits after the decimal point.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ios::fixed</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Display floating-point numbers in fixed format. Precision
  field indicates number of digits after the decimal point.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>“automatic” (Neither bit is set.)</p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Precision field indicates the total number of significant
  digits.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0511"
title="Add Comment A0511">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>ios::adjustfield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>ios::left</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Left-align values; pad on the right with the fill character.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>ios::right</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Right-align values. Pad on the left with the fill character.
  This is the default alignment.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>ios::internal</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Add fill characters after any leading sign or base indicator,
  but before the value. (In other words, the sign, if printed, is
  left-justified while the number is right-justified).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0512"
title="Add Comment A0512">Comment</a></sup></p>

<h3><a name="_Toc45440028">Width, fill, and precision</a></h3>

<p class=MsoNormal>The internal variables that control the width of the output
field, the fill character used to pad an output field, and the precision for
printing floating-point numbers are read and written by member functions of the
same name. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0513"
title="Add Comment A0513">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=215 valign=top style='width:161.1pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>Function</p>
   </td>
   <td width=240 valign=top style='width:2.5in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=tablehead0>effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::width(&nbsp;)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Returns the current width. (Default is 0.) Used for both
  insertion and extraction.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::width(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Sets the width, returns the previous width.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::fill(&nbsp;)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Returns the current fill character. (Default is space.)</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::fill(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Sets the fill character, returns the previous fill character.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::precision(&nbsp;)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Returns current floating-point precision. (Default is 6.) </p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>int ios::precision(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Sets floating-point precision, returns previous precision. See
  <b>ios::floatfield</b> table for the meaning of “precision.”</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0514"
title="Add Comment A0514">Comment</a></sup></p>

<p class=MsoNormal>The <b>fill</b> and <b>precision</b> values are fairly
straightforward, but <b>width</b> requires some explanation. When the width is
zero, inserting a value produces the minimum number of characters necessary to
represent that value. A positive width means that inserting a value will
produce at least as many characters as the width; if the value has fewer than
width characters, the fill character is used to pad the field. However, the
value will never be truncated, so if you try to print 123 with a width of two,
you’ll still get 123. The field width specifies a <i>minimum</i> number of
characters; there’s no way to specify a maximum number. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0515"
title="Add Comment A0515">Comment</a></sup></p>

<p class=MsoNormal>The width is also distinctly different because it’s reset to
zero by each inserter or extractor that could be influenced by its value. It’s
really not a state variable, but rather an implicit argument to the inserters
and extractors. If you want a constant width, you must call <b>width(&nbsp;)</b>
after each insertion or extraction. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0516"
title="Add Comment A0516">Comment</a></sup></p>

<h3><a name="_Toc45440029"></a><a name="_Toc312373892">An exhaustive example</a></h3>

<p class=MsoNormal>To make sure you know how to call all the functions
previously discussed, here’s an example that calls them all: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0517"
title="Add Comment A0517">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Format.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Formatting Functions</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>#define D(A) T &lt;&lt; #A &lt;&lt;
endl; A</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ofstream T(&quot;format.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(T);</p>

<p class=CodeChar style='margin-left:0in'>  D(int i = 47;)</p>

<p class=CodeChar style='margin-left:0in'>  D(float f = 2300114.414159;)</p>

<p class=CodeChar style='margin-left:0in'>  char* s = &quot;Is there any
more?&quot;;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::unitbuf);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::showbase);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::uppercase |
ios::showpos);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; i &lt;&lt; endl;) //
Default is dec</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::hex,
ios::basefield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; i &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::oct,
ios::basefield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; i &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.unsetf(ios::showbase);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::dec,
ios::basefield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::left,
ios::adjustfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.fill('0');)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; &quot;fill char:
&quot; &lt;&lt; T.fill() &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>D(T.width(10);)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  T &lt;&lt; i &lt;&lt;
endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>D(T.setf(ios::right,
ios::adjustfield);)</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>D(T.width(10);)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  T &lt;&lt; i &lt;&lt;
endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>D(T.setf(ios::internal,
ios::adjustfield);)</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>D(T.width(10);)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  T &lt;&lt; i &lt;&lt;
endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>D(T &lt;&lt; i
&lt;&lt; endl;) // Without width(10)</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  D(T.unsetf(ios::showpos);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::showpoint);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; &quot;prec = &quot;
&lt;&lt; T.precision() &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::scientific,
ios::floatfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; endl &lt;&lt; f
&lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.unsetf(ios::uppercase);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; endl &lt;&lt; f
&lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::fixed,
ios::floatfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; f &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.precision(20);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; &quot;prec = &quot;
&lt;&lt; T.precision() &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; endl &lt;&lt; f
&lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::scientific,
ios::floatfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; endl &lt;&lt; f
&lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::fixed,
ios::floatfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T &lt;&lt; f &lt;&lt; endl;)</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  D(T.width(10);)</p>

<p class=CodeChar style='margin-left:0in'>  T &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  D(T.width(40);)</p>

<p class=CodeChar style='margin-left:0in'>  T &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  D(T.setf(ios::left,
ios::adjustfield);)</p>

<p class=CodeChar style='margin-left:0in'>  D(T.width(40);)</p>

<p class=CodeChar style='margin-left:0in'>  T &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example uses a trick to create a trace file so that you
can monitor what’s happening. The macro <b>D(a)</b> uses the preprocessor
“stringizing” to turn <b>a</b> into a string to display. Then it reiterates <b>a</b>
so the statement is executed. The macro sends all the information to a file
called <b>T</b>, which is the trace file. The output is: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0518"
title="Add Comment A0518">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>int i = 47;</p>

<p class=CodeChar style='margin-left:0in'>float f = 2300114.414159;</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::unitbuf);</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::showbase);</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::uppercase |
ios::showpos);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>+47</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::hex, ios::basefield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>0X2F</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::oct, ios::basefield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>057</p>

<p class=CodeChar style='margin-left:0in'>T.unsetf(ios::showbase);</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::dec, ios::basefield);</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::left, ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>T.fill('0');</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; &quot;fill char: &quot;
&lt;&lt; T.fill() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>fill char: 0</p>

<p class=CodeChar style='margin-left:0in'>T.width(10);</p>

<p class=CodeChar style='margin-left:0in'>+470000000</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::right, ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>T.width(10);</p>

<p class=CodeChar style='margin-left:0in'>0000000+47</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::internal,
ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>T.width(10);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>+000000047</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>T &lt;&lt; i &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'>+47</p>

<p class=CodeChar style='margin-left:0in'>T.unsetf(ios::showpos);</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::showpoint);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; &quot;prec = &quot;
&lt;&lt; T.precision() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>prec = 6</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::scientific,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; endl &lt;&lt; f &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>2.300114E+06</p>

<p class=CodeChar style='margin-left:0in'>T.unsetf(ios::uppercase);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; endl &lt;&lt; f &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>2.300114e+06</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::fixed, ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>2300114.500000</p>

<p class=CodeChar style='margin-left:0in'>T.precision(20);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; &quot;prec = &quot;
&lt;&lt; T.precision() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>prec = 20</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; endl &lt;&lt; f &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>2300114.50000000000000000000</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::scientific,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; endl &lt;&lt; f &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>2.30011450000000000000e+06</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::fixed, ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>T &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>2300114.50000000000000000000</p>

<p class=CodeChar style='margin-left:0in'>T.width(10);</p>

<p class=CodeChar style='margin-left:0in'>Is there any more?</p>

<p class=CodeChar style='margin-left:0in'>T.width(40);</p>

<p class=CodeChar style='margin-left:0in'>0000000000000000000000Is there any
more?</p>

<p class=CodeChar style='margin-left:0in'>T.setf(ios::left, ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>T.width(40);</p>

<p class=CodeChar style='margin-left:0in'>Is there any more?0000000000000000000000</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Studying this output should clarify your understanding of
the iostream formatting member functions. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0519"
title="Add Comment A0519">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc312373893"></a><a name="_Toc305628670"></a><a
name="_Toc45440030">Manipulators</a></h2>

<p class=MsoNormal>As you can see from the previous program, calling the member functions for stream formatting operations can get a bit tedious.
To make things easier to read and write, a set of <i>manipulators</i> is
supplied to duplicate the actions provided by the member functions.
Manipulators are a convenience because you can insert them for their effect
within a containing expression; you don’t have to create a separate
function-call statement. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0520"
title="Add Comment A0520"><sup>Comment</sup></a></p>

<p class=MsoNormal>Manipulators change the state of the stream instead of (or
in addition to) processing data. When you insert <b>endl</b> in an output
expression, for example, it not only inserts a newline character, but it also <i>flushes</i>
the stream (that is, puts out all pending characters that have been stored in
the internal stream buffer but not yet output). You can also just flush a stream like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0413"
title="Add Comment A0413"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt; flush;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which causes a call to the <b>flush(&nbsp;)</b> member function,
as in</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout.flush();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>as a side effect (nothing is inserted into the stream).
Additional basic manipulators will change the number base to <b>oct</b> (octal), <b>dec</b> (decimal) or <b>hex</b> (hexadecimal): <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0414"
title="Add Comment A0414"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'> cout &lt;&lt; hex &lt;&lt;
&quot;0x&quot; &lt;&lt; i &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this case, numeric output will continue in hexadecimal
mode until you change it by inserting either <b>dec</b> or <b>oct</b> in the
output stream.</p>

<p class=MsoNormal>There’s also a manipulator for extraction that “eats” white
space: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0415"
title="Add Comment A0415"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cin &gt;&gt; ws;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Manipulators with no arguments are provided in <b>&lt;iostream&gt;</b>.
These include <b>dec</b>, <b>oct</b>,  and <b>hex</b> , which perform the same action as, respectively, <b>setf(ios::dec, ios::basefield)</b>, <b>setf(ios::oct,
ios::basefield)</b>, and <b>setf(ios::hex, ios::basefield)</b>, albeit more
succinctly. The <b>&lt;iostream&gt;</b> header also includes <b>ws</b>, <b>endl</b>, and <b>flush</b> and the additional set shown here: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0521"
title="Add Comment A0521">Comment</a></sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=461
 style='width:4.8in;margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=169 valign=top style='width:126.8pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>Manipulator</p>
   </td>
   <td width=292 valign=top style='width:218.8pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>showbase</b><b><br>
  noshowbase</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Indicate the numeric base (<b>dec</b>, <b>oct</b>, or <b>hex</b>)
  when printing an integral value. The format used can be read by the C++
  compiler.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>showpos</b><b><br>
  noshowpos</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Show plus sign (+) for positive values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>uppercase</b><b><br>
  nouppercase</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Display uppercase A-F for hexadecimal values, and display E
  for scientific values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>showpoint</b><b><br>
  noshowpoint</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Show decimal point and trailing zeros for floating-point
  values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>skipws</b><b><br>
  noskipws</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Skip white space on input.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>left</b><b><br>
  right</b><b><br>
  internal</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Left-align, pad on right.<br>
  Right-align, pad on left.<br>
  Fill between leading sign or base indicator and value.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>scientific</b><b><br>
  fixed</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Indicates the display preference for floating-point output
  (scientific notation vs. fixed-point decimal).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0523"
title="Add Comment A0523">Comment</a></sup></p>

<h3><a name="_Toc45440031"></a><a name="_Toc312373894">Manipulators with
arguments</a></h3>

<p class=MsoNormal>There are six standard manipulators, such as <b>setw(&nbsp;)</b>,
that take arguments. These are defined in the header file &lt;<b>iomanip&gt;</b>,
and are summarized in the following table.</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=461
 style='width:4.8in;margin-left:.4in;border-collapse:collapse;border:none'>
 <thead>
  <tr style='page-break-inside:avoid'>
   <td width=221 valign=top style='width:2.3in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>Manipulator</p>
   </td>
   <td width=240 valign=top style='width:2.5in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt'>
   <p class=TableHead>effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>setiosflags</b><b> (fmtflags n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Equivalent to a call to <b>setf(n)</b>. The setting remains in
  effect until the next change, such as <b>ios::setf(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>resetiosflags</b><b>(fmtflags n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Clears only the format flags specified by <b>n</b>. The
  setting remains in effect until the next change, such as <b>ios::unsetf(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>setbase</b><b>(base n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Changes base to <b>n</b>, where <b>n</b> is 10, 8, or 16.
  (Anything else results in 0.) If <b>n</b> is zero, output is base 10, but
  input uses the C conventions: 10 is 10, 010 is 8, and 0xf is 15. You might as
  well use <b>dec</b>, <b>oct</b>, and <b>hex</b> for output.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>setfill</b><b>(char n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Changes the fill character to <b>n</b>, such as <b>ios::fill(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>setprecision</b><b>(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Changes the precision to <b>n</b>, such as <b>ios::precision(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table><b>setw(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=Table>Changes the field width to <b>n</b>, such as <b>ios::width(&nbsp;)</b>.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0525"
title="Add Comment A0525">Comment</a></sup></p>

<p class=MsoNormal>If you’re doing a lot of formatting, you can see how using
manipulators instead of calling stream member functions can clean up your code.
As an example, here’s the program from the previous section rewritten to use
the manipulators. (The <b>D(&nbsp;)</b> macro has been removed to make it
easier to read.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0526"
title="Add Comment A0526">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Manips.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Format.cpp using manipulators</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iomanip&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
trc(&quot;trace.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int i = 47;</p>

<p class=CodeChar style='margin-left:0in'>  float f = 2300114.414159;</p>

<p class=CodeChar style='margin-left:0in'>  char* s = &quot;Is there any
more?&quot;;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt;
setiosflags(ios::unitbuf</p>

<p class=CodeChar style='margin-left:0in'>           | ios::showbase |
ios::uppercase</p>

<p class=CodeChar style='margin-left:0in'>           | ios::showpos);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>trc &lt;&lt; hex
&lt;&lt; i &lt;&lt; endl</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>      &lt;&lt; oct
&lt;&lt; i &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>trc.setf(ios::left,
ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt;
resetiosflags(ios::showbase)</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; dec &lt;&lt;
setfill('0');</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; &quot;fill char:
&quot; &lt;&lt; trc.fill() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(10) &lt;&lt; i
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::right,
ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(10) &lt;&lt; i
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::internal, ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(10) &lt;&lt; i
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; i &lt;&lt; endl; //
Without setw(10)</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt;
resetiosflags(ios::showpos)</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt;
setiosflags(ios::showpoint)</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;prec = &quot;
&lt;&lt; trc.precision() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::scientific,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt;
resetiosflags(ios::uppercase) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::fixed,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setprecision(20);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; &quot;prec = &quot;
&lt;&lt; trc.precision() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::scientific,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::fixed,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; f &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(10) &lt;&lt; s
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(40) &lt;&lt; s
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  trc.setf(ios::left,
ios::adjustfield);</p>

<p class=CodeChar style='margin-left:0in'>  trc &lt;&lt; setw(40) &lt;&lt; s
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that a lot of the multiple statements have been
condensed into a single chained insertion. Notice the call to <b>setiosflags(&nbsp;)</b>
in which the bitwise-OR of the flags is passed. This could also have been done
with <b>setf(&nbsp;)</b> and <b>unsetf(&nbsp;)</b> as in the previous example. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0527"
title="Add Comment A0527">Comment</a></sup></p>

<p class=MsoNormal>When using <b>setw(&nbsp;)</b> with an output stream, the
output expression is formatted into a temporary string that is padded with the
current fill character if needed, as determined by comparing the length of the
formatted result to the argument of <b>setw(&nbsp;)</b>. In other words, <b>setw(&nbsp;)</b>
affects the <i>result string</i> of a formatted output operation. Likewise,
using <b>setw(&nbsp;)</b> with input streams only is meaningful when reading <i>strings</i>,
as the following example makes clear.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:InputWidth.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Shows limitations of setw with
input</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iomanip&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;limits&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  istringstream is(&quot;one 2.34
five&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string temp;</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; setw(2) &gt;&gt; temp;</p>

<p class=CodeChar style='margin-left:0in'>  assert(temp == &quot;on&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; setw(2) &gt;&gt; temp;</p>

<p class=CodeChar style='margin-left:0in'>  assert(temp == &quot;e&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  double x;</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; setw(2) &gt;&gt; x;</p>

<p class=CodeChar style='margin-left:0in'>  double relerr = fabs(x - 2.34) / x;</p>

<p class=CodeChar style='margin-left:0in'>  assert(relerr &lt;=
numeric_limits&lt;double&gt;::epsilon());</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><a name="_Toc312373895">If you attempt to read a string, <b>setw(&nbsp;)</b>
will control the number of characters extracted quite nicely… up to a point.
The first extraction gets two characters, but the second only gets one, even
though we asked for two. That is because <b>operator&gt;&gt;(&nbsp;)</b> uses
white space as a delimiter (unless you turn off the <b>skipws</b> flag). When
trying to read a number, however, such as <b>x</b>, you cannot use <b>setw(&nbsp;)
</b>to limit the characters read. With input streams, use only <b>setw(&nbsp;)</b>
for extracting strings. </a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1609"
title="Add Comment A1609"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440032">Creating manipulators</a></h3>

<p class=MsoNormal>Sometimes you’d like to create your own manipulators, and it
turns out to be remarkably simple. A zero-argument manipulator such as <b>endl </b>is
simply a function that takes as its argument an <b>ostream</b> reference and
returns an <b>ostream</b> reference. The declaration for <b>endl</b> is <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0528"
title="Add Comment A0528">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>ostream&amp;
endl(ostream&amp;);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now, when you say: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0529"
title="Add Comment A0529">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt;
&quot;howdy&quot; &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>the <b>endl</b> produces the <i>address</i> of that
function. So the compiler asks, “Is there a function I can call that takes the
address of a function as its argument?” Predefined functions in <b>&lt;iostream&gt;
</b>do this; they’re called <i>applicators</i> (because they <i>apply</i> a
function to a stream). The applicator calls its function argument, passing it
the <b>ostream</b> object as its argument. You don’t need to know how applicators
work to create your own manipulator; you only need to know that they exist.
Nonetheless, they’re simple. Here’s the (simplified) code for an <b>ostream</b>
applicator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
ostream::operator&lt;&lt;(ostream&amp; (*pf)(ostream&amp;)) {</p>

<p class=CodeChar style='margin-left:0in'>  return pf(*this);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The actual definition is a little more complicated since it
involves templates, but this code illustrates the technique. When a function
such as <b>*pf</b> (that takes a stream parameter and returns a stream
reference) is inserted into a stream, this applicator function is called, which
in turn executes the function to which <b>pf</b> points. Applicators for <b>ios_base</b>,
<b>basic_ios</b>, <b>basic_ostream</b>, and <b>basic_istream</b> are predefined
in the standard C++ library. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1605"
title="Add Comment A1605">Comment</a></sup></p>

<p class=MsoNormal>To illustrate the process, here’s a trivial example that
creates a manipulator called <b>nl</b> that is equivalent to just inserting a
newline into a stream (i.e., no flushing of the stream occurs, as with <b>endl</b>):
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0531"
title="Add Comment A0531">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:nl.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Creating a manipulator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp; nl(ostream&amp; os) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt; '\n';</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;newlines&quot;
&lt;&lt; nl &lt;&lt; &quot;between&quot; &lt;&lt; nl</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; &quot;each&quot;
&lt;&lt; nl &lt;&lt; &quot;word&quot; &lt;&lt; nl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When you insert <b>nl</b> into an output stream, such as <b>cout</b>,
the following sequence of calls ensues:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout.operator&lt;&lt;(nl) <span
style='font-family:Wingdings'>è</span> nl(cout)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The expression</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>os &lt;&lt; '\n';</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>inside <b>nl(&nbsp;)</b> calls <b>ostream::operator(char)</b>,
which of course returns the stream, which is what is ultimately returned from <b>nl(&nbsp;)</b>.<a
href="#_ftn44" name="_ftnref44" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[44]</span></sup></span></span></sup></span></a> <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0533"
title="Add Comment A0533">Comment</a></sup></p>

<h3><a name="_Toc45440033"></a><a name="_Toc312373896">Effectors</a></h3>

<p class=MsoNormal>As you’ve seen, zero-argument manipulators are easy to
create. But what if you want to create a manipulator that takes arguments? If
you inspect the <b>&lt;iomanip&gt;</b> header, you’ll see a type called <b>smanip</b>,
which is what the manipulators with arguments return. You might be tempted to
somehow use that type to define your own manipulators, but don’t give in to the
temptation. The <b>smanip</b> type is implementation-dependent, so using it
would not be portable. Fortunately, you can define such manipulators in a
straightforward way without any special machinery, based on a technique
introduced by Jerry Schwarz, called an <i>effector</i>.<a href="#_ftn45"
name="_ftnref45" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[45]</span></sup></span></span></sup></span></a> An effector is a
simple class whose constructor formats a string representing the desired
operation, along with an overloaded <b>operator&lt;&lt;</b> to insert that
string into a stream. Here’s an example with two effectors. The first outputs a
truncated character string, and the second prints a number in binary. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0535"
title="Add Comment A0535">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><a name="_Toc305628671">//:
C04:Effector.cpp</a></p>

<p class=CodeChar style='margin-left:0in'>// Jerry Schwarz's
&quot;effectors&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;limits&gt;  // For max()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Put out a prefix of a string:</p>

<p class=CodeChar style='margin-left:0in'>class Fixw {</p>

<p class=CodeChar style='margin-left:0in'>  string str;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Fixw(const string&amp; s, int
width)</p>

<p class=CodeChar style='margin-left:0in'>    : str(s, 0, width) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Fixw&amp; fw) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; fw.str;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Print a number in binary:</p>

<p class=CodeChar style='margin-left:0in'>typedef unsigned long ulong;</p>

<p class=CodeChar style='margin-left:0in'>class Bin {</p>

<p class=CodeChar style='margin-left:0in'>  ulong n;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bin(ulong nn) { n = nn; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Bin&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    const ulong ULMAX =
numeric_limits&lt;ulong&gt;::max();</p>

<p class=CodeChar style='margin-left:0in'>    ulong bit = ~(ULMAX &gt;&gt; 1);
// Top bit set</p>

<p class=CodeChar style='margin-left:0in'>    while(bit) {</p>

<p class=CodeChar style='margin-left:0in'>      os &lt;&lt; (b.n &amp; bit ?
'1' : '0');</p>

<p class=CodeChar style='margin-left:0in'>      bit &gt;&gt;= 1;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return os;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};            </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string words =</p>

<p class=CodeChar style='margin-left:0in'>    &quot;Things that make us happy,
make us wise&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = words.size(); --i &gt;=
0;) {</p>

<p class=CodeChar style='margin-left:0in'>    ostringstream s;</p>

<p class=CodeChar style='margin-left:0in'>    s &lt;&lt; Fixw(words, i);</p>

<p class=CodeChar style='margin-left:0in'>    assert(s.str() == words.substr(0,
i));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ostringstream xs, ys;</p>

<p class=CodeChar style='margin-left:0in'>  xs &lt;&lt; Bin(0xCAFEBABEUL);</p>

<p class=CodeChar style='margin-left:0in'>  assert(xs.str() ==  </p>

<p class=CodeChar style='margin-left:0in'>   
&quot;1100&quot;&quot;1010&quot;&quot;1111&quot;&quot;1110&quot;&quot;1011&quot;&quot;1010&quot;&quot;1011&quot;&quot;1110&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ys &lt;&lt; Bin(0x76543210UL);</p>

<p class=CodeChar style='margin-left:0in'>  assert(ys.str() == </p>

<p class=CodeChar style='margin-left:0in'>   
&quot;0111&quot;&quot;0110&quot;&quot;0101&quot;&quot;0100&quot;&quot;0011&quot;&quot;0010&quot;&quot;0001&quot;&quot;0000&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The constructor for <b>Fixw</b> creates a shortened copy of its
<b>char*</b> argument, and the destructor releases the memory created for this
copy. The overloaded <b>operator&lt;&lt;</b> takes the contents of its second
argument, the <b>Fixw</b> object, inserts it into the first argument, the <b>ostream</b>,
and then returns the <b>ostream</b> so that it can be used in a chained
expression. When you use <b>Fixw</b> in an expression like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0536"
title="Add Comment A0536"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt; Fixw(string,
i) &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>a <i>temporary object</i> is created by the call to the <b>Fixw</b>
constructor, and that temporary object is passed to <b>operator&lt;&lt;</b>.
The effect is that of a manipulator with arguments. The temporary <b>Fixw</b>
object persists until the end of the statement. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0537"
title="Add Comment A0537"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>Bin</b> effector relies on the fact that shifting an
unsigned number to the right shifts zeros into the high bits. We use <b>numeric_limits&lt;unsigned
long&gt;::max(&nbsp;)</b> (the largest <b>unsigned long</b> value, from the
standard header <b>&lt;limits&gt;</b> ) to produce a value with the high bit
set, and this value is moved across the number in question (by shifting it to
the right), masking each bit in turn. We’ve juxtaposed string literals in the
code for readability; the separate strings are of course concatenated into one
by the compiler. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0538"
title="Add Comment A0538"><sup>Comment</sup></a></p>

<p class=MsoNormal>Historically, the problem with this technique was that once
you created a class called <b>Fixw</b> for <b>char*</b> or <b>Bin </b>for <b>unsigned
long</b>,<b> </b>no one else could create a different <b>Fixw</b> or <b>Bin </b>class
for their type. However, with namespaces, this problem is eliminated. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0539"
title="Add Comment A0539"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440034"></a><a name="_Toc312373897">Iostream
examples</a></h2>

<p class=MsoNormal>In this section you’ll see some examples of what you can do
with all the information you’ve learned in this chapter. Although many tools
exist to manipulate bytes (stream editors such as <b>sed</b> and <b>awk</b> from UNIX are perhaps the most well known, but a text editor also fits this
category), they generally have some limitations. Both <b>sed</b> and <b>awk</b>
can be slow and can only handle lines in a forward sequence, and text editors
usually require human interaction, or at least learning a proprietary macro
language. The programs you write with iostreams have none of these limitations:
they’re fast, portable, and flexible. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0540"
title="Add Comment A0540">Comment</a></sup></p>

<h3><a name="_Toc45440035">Maintaining class library source code</a></h3>

<p class=MsoNormal>Generally, when you create a class, you think in library
terms: you make a header file <b>Name.h </b>for the class declaration, and you
create a file in which the member functions are implemented, called <b>Name.cpp</b><span
style='text-transform:uppercase'>. T</span>hese files have certain
requirements: a particular coding standard (the program shown here uses the
coding format for this book), and in the header file the declarations are
generally surrounded by some preprocessor statements to prevent multiple
declarations of classes. (Multiple declarations confuse the compiler—it doesn’t
know which one you want to use. They could be different, so it throws up its
hands and gives an error message.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0543"
title="Add Comment A0543">Comment</a></sup></p>

<p class=MsoNormal>This example allows you to create a new
header/implementation pair of files or to modify an existing pair. If the files
already exist, it checks and potentially modifies the files, but if they don’t
exist, it creates them using the proper format. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0544"
title="Add Comment A0544">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Cppcheck.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Configures .h &amp; .cpp files to
conform to style</p>

<p class=CodeChar style='margin-left:0in'>// standard. Tests existing files for
conformance.</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>bool startsWith(const string&amp;
base, const string&amp; key) {</p>

<p class=CodeChar style='margin-left:0in'>  return base.compare(0, key.size(),
key) == 0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void cppCheck(string fileName) {</p>

<p class=CodeChar style='margin-left:0in'>  enum bufs { BASE, HEADER,
IMPLEMENT,</p>

<p class=CodeChar style='margin-left:0in'>    HLINE1, GUARD1, GUARD2, GUARD3,</p>

<p class=CodeChar style='margin-left:0in'>    CPPLINE1, INCLUDE, BUFNUM };</p>

<p class=CodeChar style='margin-left:0in'>  string part[BUFNUM];</p>

<p class=CodeChar style='margin-left:0in'>  part[BASE] = fileName;</p>

<p class=CodeChar style='margin-left:0in'>  // Find any '.' in the string:</p>

<p class=CodeChar style='margin-left:0in'>  size_t loc = part[BASE].find('.');</p>

<p class=CodeChar style='margin-left:0in'>  if(loc != string::npos) </p>

<p class=CodeChar style='margin-left:0in'>    part[BASE].erase(loc); // Strip
extension</p>

<p class=CodeChar style='margin-left:0in'>  // Force to upper case:</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
part[BASE].size(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    part[BASE][i] =
toupper(part[BASE][i]);</p>

<p class=CodeChar style='margin-left:0in'>  // Create file names and internal
lines:</p>

<p class=CodeChar style='margin-left:0in'>  part[HEADER] = part[BASE] +
&quot;.h&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  part[IMPLEMENT] = part[BASE] +
&quot;.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  part[HLINE1] = &quot;//&quot;
&quot;: &quot; + part[HEADER];</p>

<p class=CodeChar style='margin-left:0in'>  part[GUARD1] = &quot;#ifndef &quot;
+ part[BASE] + &quot;_H&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  part[GUARD2] = &quot;#define &quot;
+ part[BASE] + &quot;_H&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  part[GUARD3] = &quot;#endif //
&quot; + part[BASE] +&quot;_H&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  part[CPPLINE1] =
string(&quot;//&quot;) + &quot;: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    + part[IMPLEMENT];</p>

<p class=CodeChar style='margin-left:0in'>  part[INCLUDE] = &quot;#include
\&quot;&quot; + part[HEADER] + &quot;\&quot;&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // First, try to open existing
files:</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
existh(part[HEADER].c_str()),</p>

<p class=CodeChar style='margin-left:0in'>          
existcpp(part[IMPLEMENT].c_str());</p>

<p class=CodeChar style='margin-left:0in'>  if(!existh) { // Doesn't exist;
create it</p>

<p class=CodeChar style='margin-left:0in'>    ofstream newheader(part[HEADER].c_str());</p>

<p class=CodeChar style='margin-left:0in'>    assure(newheader,
part[HEADER].c_str());</p>

<p class=CodeChar style='margin-left:0in'>    newheader &lt;&lt; part[HLINE1]
&lt;&lt; endl</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; part[GUARD1] &lt;&lt;
endl</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; part[GUARD2] &lt;&lt;
endl &lt;&lt; endl</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; part[GUARD3] &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  } else { // Already exists; verify
it</p>

<p class=CodeChar style='margin-left:0in'>    stringstream hfile; // Write
&amp; read</p>

<p class=CodeChar style='margin-left:0in'>    ostringstream newheader; // Write</p>

<p class=CodeChar style='margin-left:0in'>    hfile &lt;&lt; existh.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>    // Check that first three lines
conform:</p>

<p class=CodeChar style='margin-left:0in'>    bool changed = false;</p>

<p class=CodeChar style='margin-left:0in'>    string s;</p>

<p class=CodeChar style='margin-left:0in'>    hfile.seekg(0);</p>

<p class=CodeChar style='margin-left:0in'>    getline(hfile, s);</p>

<p class=CodeChar style='margin-left:0in'>    bool lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>    // The call to good() is for
Microsoft (later too)</p>

<p class=CodeChar style='margin-left:0in'>    for (int line = HLINE1;
hfile.good() &amp;&amp; line &lt;= GUARD2; </p>

<p class=CodeChar style='margin-left:0in'>         ++line) {</p>

<p class=CodeChar style='margin-left:0in'>      if(startsWith(s, part[line])) {</p>

<p class=CodeChar style='margin-left:0in'>        newheader &lt;&lt; s &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>        lineUsed = true;</p>

<p class=CodeChar style='margin-left:0in'>        if (getline(hfile, s))</p>

<p class=CodeChar style='margin-left:0in'>          lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>      } else {</p>

<p class=CodeChar style='margin-left:0in'>        newheader &lt;&lt; part[line]
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>        changed = true;</p>

<p class=CodeChar style='margin-left:0in'>        lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    // Copy rest of file</p>

<p class=CodeChar style='margin-left:0in'>    if (!lineUsed)</p>

<p class=CodeChar style='margin-left:0in'>      newheader &lt;&lt; s &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    newheader &lt;&lt; hfile.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>    // Check for GUARD3</p>

<p class=CodeChar style='margin-left:0in'>    string head = hfile.str();</p>

<p class=CodeChar style='margin-left:0in'>    if(head.find(part[GUARD3]) ==
string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>      newheader &lt;&lt; part[GUARD3]
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>      changed = true;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    // If there were changes,
overwrite file:</p>

<p class=CodeChar style='margin-left:0in'>    if(changed) {</p>

<p class=CodeChar style='margin-left:0in'>      existh.close();</p>

<p class=CodeChar style='margin-left:0in'>      ofstream
newH(part[HEADER].c_str());</p>

<p class=CodeChar style='margin-left:0in'>      assure(newH,
part[HEADER].c_str());</p>

<p class=CodeChar style='margin-left:0in'>      newH &lt;&lt;
&quot;//@//\n&quot;  // Change marker</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; newheader.str();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  if(!existcpp) { // Create cpp file</p>

<p class=CodeChar style='margin-left:0in'>    ofstream
newcpp(part[IMPLEMENT].c_str());</p>

<p class=CodeChar style='margin-left:0in'>    assure(newcpp,
part[IMPLEMENT].c_str());</p>

<p class=CodeChar style='margin-left:0in'>    newcpp &lt;&lt; part[CPPLINE1]
&lt;&lt; endl</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; part[INCLUDE] &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  } else { // Already exists; verify
it</p>

<p class=CodeChar style='margin-left:0in'>    stringstream cppfile;</p>

<p class=CodeChar style='margin-left:0in'>    ostringstream newcpp;</p>

<p class=CodeChar style='margin-left:0in'>    cppfile &lt;&lt;
existcpp.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>    // Check that first two lines
conform:</p>

<p class=CodeChar style='margin-left:0in'>    bool changed = false;</p>

<p class=CodeChar style='margin-left:0in'>    string s;</p>

<p class=CodeChar style='margin-left:0in'>    cppfile.seekg(0);</p>

<p class=CodeChar style='margin-left:0in'>    getline(cppfile, s);</p>

<p class=CodeChar style='margin-left:0in'>    bool lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>    for (int line = CPPLINE1;</p>

<p class=CodeChar style='margin-left:0in'>         cppfile.good() &amp;&amp;
line &lt;= INCLUDE;</p>

<p class=CodeChar style='margin-left:0in'>         ++line) {</p>

<p class=CodeChar style='margin-left:0in'>      if(startsWith(s, part[line])) {</p>

<p class=CodeChar style='margin-left:0in'>        newcpp &lt;&lt; s &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>        lineUsed = true;</p>

<p class=CodeChar style='margin-left:0in'>        if (getline(cppfile, s))</p>

<p class=CodeChar style='margin-left:0in'>          lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>      } else {</p>

<p class=CodeChar style='margin-left:0in'>        newcpp &lt;&lt; part[line]
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>        changed = true;</p>

<p class=CodeChar style='margin-left:0in'>        lineUsed = false;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    // Copy rest of file</p>

<p class=CodeChar style='margin-left:0in'>    if (!lineUsed)</p>

<p class=CodeChar style='margin-left:0in'>      newcpp &lt;&lt; s &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    newcpp &lt;&lt; cppfile.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>    // If there were changes,
overwrite file:</p>

<p class=CodeChar style='margin-left:0in'>    if(changed){</p>

<p class=CodeChar style='margin-left:0in'>      existcpp.close();</p>

<p class=CodeChar style='margin-left:0in'>      ofstream
newCPP(part[IMPLEMENT].c_str());</p>

<p class=CodeChar style='margin-left:0in'>      assure(newCPP, part[IMPLEMENT].c_str());</p>

<p class=CodeChar style='margin-left:0in'>      newCPP &lt;&lt;
&quot;//@//\n&quot;  // Change marker</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; newcpp.str();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1)</p>

<p class=CodeChar style='margin-left:0in'>    cppCheck(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>   
cppCheck(&quot;cppCheckTest.h&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>First notice the useful function <b>startsWith(&nbsp;)</b>,
which does just what its name says—it returns <b>true</b> if the first string
argument starts with the second argument. This is used when looking for the
expected comments and include-related statements. Having the array of strings, <b>part</b>,
allows for easy looping through the series of expected statements in source
code. If the source file doesn’t exist, we merely write the statements to a new
file of the given name. If the file does exist, we search a line at a time,
verifying that the expected lines occur. If they are not present, they are
inserted. Special care has to be taken to make sure we don’t drop existing
lines (see where we use the Boolean variable <b>lineUsed</b>). Notice that we
use a <b>stringstream</b> for an existing file, so we can first write the
contents of the file to it and then read from it and search it. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0546"
title="Add Comment A0546">Comment</a></sup></p>

<p class=MsoNormal>The names in the enumeration are <b>BASE</b>, the
capitalized base file name without extension; <b>HEADER</b>, the header file
name; <b>IMPLEMENT</b>, the implementation file (<b>cpp</b>) name; <b>HLINE1</b>,
the skeleton first line of the header file; <b>GUARD1</b>, <b>GUARD2</b>, and <b>GUARD3</b>,
the “guard” lines in the header file (to prevent multiple inclusion); <b>CPPLINE1</b>,
the skeleton first line of the <b>cpp</b> file; and <b>INCLUDE</b>, the line in
the <b>cpp</b> file that includes the header file. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0547"
title="Add Comment A0547">Comment</a></sup></p>

<p class=MsoNormal>If you run this program without any arguments, the following
two files are created:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// CPPCHECKTEST.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef CPPCHECKTEST_H</p>

<p class=CodeChar style='margin-left:0in'>#define CPPCHECKTEST_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#endif // CPPCHECKTEST_H</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// CPPCHECKTEST.cpp</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#include
&quot;CPPCHECKTEST.h&quot;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>(We removed the colon after the double-slash in the first
comment lines so as not to confuse the book’s code extractor. It will appear in
the actual output produced by <b>cppCheck.</b>)</p>

<p class=MsoNormal>You can experiment by removing selected lines from these
files and re-running the program. Each time you will see that the correct lines
are added back in. When a file is modified, the string “<span style='font-size:
10.0pt;font-family:"Courier New"'>//@//</span>” is placed as the first line of
the file to bring the change to your attention. You will need to remove this
line before you process the file again (otherwise <b>cppcheck</b> will assume
the initial comment line is missing). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1613"
title="Add Comment A1613">Comment</a></sup></p>

<h3><a name="_Toc45440036">Detecting compiler errors</a></h3>

<p class=MsoNormal>All the code in this book is designed to compile as shown
without errors. Any line of code that should generate a compile-time error is
commented out with the special comment sequence “//!”. The following program
will remove these special comments and append a numbered comment to the line.
When you run your compiler, it should generate error messages, and you should
see all the numbers appear when you compile all the files. This program also
appends the modified line to a special file so that you can easily locate any
lines that don’t generate errors. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0553"
title="Add Comment A0553">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Showerr.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Un-comment error generators</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdio&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>const string usage =</p>

<p class=CodeChar style='margin-left:0in'>  &quot;usage: showerr filename
chapnum\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;where filename is a C++
source file\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;and chapnum is the chapter
name it's in.\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Finds lines commented with
//! and removes\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;comment, appending //(#)
where # is unique\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;across all files, so you can
determine\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;if your compiler finds the
error.\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;showerr /r\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>  &quot;resets the unique
counter.&quot;;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Showerr {</p>

<p class=CodeChar style='margin-left:0in'>  const int CHAP;</p>

<p class=CodeChar style='margin-left:0in'>  const string MARKER, FNAME;</p>

<p class=CodeChar style='margin-left:0in'>  // File containing error number
counter:</p>

<p class=CodeChar style='margin-left:0in'>  const string ERRNUM;</p>

<p class=CodeChar style='margin-left:0in'>  // File containing error lines:</p>

<p class=CodeChar style='margin-left:0in'>  const string ERRFILE;</p>

<p class=CodeChar style='margin-left:0in'>  stringstream edited; // Edited file</p>

<p class=CodeChar style='margin-left:0in'>  int counter;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Showerr(const string&amp; f, const
string&amp; en,</p>

<p class=CodeChar style='margin-left:0in'>    const string&amp; ef, int c) :
FNAME(f), MARKER(&quot;//!&quot;),</p>

<p class=CodeChar style='margin-left:0in'>    ERRNUM(en), ERRFILE(ef), CHAP(c)
{ counter = 0; }</p>

<p class=CodeChar style='margin-left:0in'>  void replaceErrors() {</p>

<p class=CodeChar style='margin-left:0in'>    ifstream infile(FNAME.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    assure(infile, FNAME.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    ifstream count(ERRNUM.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    if(count) count &gt;&gt; counter;</p>

<p class=CodeChar style='margin-left:0in'>    int linecount = 1;</p>

<p class=CodeChar style='margin-left:0in'>    string buf;</p>

<p class=CodeChar style='margin-left:0in'>    ofstream
errlines(ERRFILE.c_str(), ios::app);</p>

<p class=CodeChar style='margin-left:0in'>    assure(errlines,
ERRFILE.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    while(getline(infile, buf)) {</p>

<p class=CodeChar style='margin-left:0in'>      // Find marker at start of
line:</p>

<p class=CodeChar style='margin-left:0in'>      size_t pos = buf.find(MARKER);</p>

<p class=CodeChar style='margin-left:0in'>      if(pos != string::npos) {</p>

<p class=CodeChar style='margin-left:0in'>        // Erase marker:</p>

<p class=CodeChar style='margin-left:0in'>        buf.erase(pos, MARKER.size()
+ 1);</p>

<p class=CodeChar style='margin-left:0in'>        // Append counter &amp; error
info:</p>

<p class=CodeChar style='margin-left:0in'>        ostringstream out;</p>

<p class=CodeChar style='margin-left:0in'>        out &lt;&lt; buf &lt;&lt;
&quot; // (&quot; &lt;&lt; ++counter &lt;&lt; &quot;) &quot;</p>

<p class=CodeChar style='margin-left:0in'>            &lt;&lt; &quot;Chapter
&quot; &lt;&lt; CHAP</p>

<p class=CodeChar style='margin-left:0in'>            &lt;&lt; &quot; File:
&quot; &lt;&lt; FNAME</p>

<p class=CodeChar style='margin-left:0in'>            &lt;&lt; &quot; Line
&quot; &lt;&lt; linecount &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>        edited &lt;&lt; out.str();</p>

<p class=CodeChar style='margin-left:0in'>        errlines &lt;&lt; out.str();
// Append error file</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      else</p>

<p class=CodeChar style='margin-left:0in'>        edited &lt;&lt; buf &lt;&lt;
&quot;\n&quot;; // Just copy</p>

<p class=CodeChar style='margin-left:0in'>      linecount++;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void saveFiles() {</p>

<p class=CodeChar style='margin-left:0in'>    ofstream outfile(FNAME.c_str());
// Overwrites</p>

<p class=CodeChar style='margin-left:0in'>    assure(outfile, FNAME.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    outfile &lt;&lt; edited.rdbuf();</p>

<p class=CodeChar style='margin-left:0in'>    ofstream count(ERRNUM.c_str());
// Overwrites</p>

<p class=CodeChar style='margin-left:0in'>    assure(count, ERRNUM.c_str());</p>

<p class=CodeChar style='margin-left:0in'>    count &lt;&lt; counter; // Save
new counter</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  const string
ERRCOUNT(&quot;../errnum.txt&quot;),</p>

<p class=CodeChar style='margin-left:0in'>   
ERRFILE(&quot;../errlines.txt&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  requireMinArgs(argc, 1,
usage.c_str());</p>

<p class=CodeChar style='margin-left:0in'>  if(argv[1][0] == '/' || argv[1][0]
== '-') {</p>

<p class=CodeChar style='margin-left:0in'>    // Allow for other switches:</p>

<p class=CodeChar style='margin-left:0in'>    switch(argv[1][1]) {</p>

<p class=CodeChar style='margin-left:0in'>      case 'r': case 'R':</p>

<p class=CodeChar style='margin-left:0in'>        cout &lt;&lt; &quot;reset
counter&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>        remove(ERRCOUNT.c_str()); //
Delete files</p>

<p class=CodeChar style='margin-left:0in'>        remove(ERRFILE.c_str());</p>

<p class=CodeChar style='margin-left:0in'>        return 0;</p>

<p class=CodeChar style='margin-left:0in'>      default:</p>

<p class=CodeChar style='margin-left:0in'>        cerr &lt;&lt; usage &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>        return 1;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  if (argc == 3) {</p>

<p class=CodeChar style='margin-left:0in'>    Showerr s(argv[1], ERRCOUNT,
ERRFILE, atoi(argv[2]));</p>

<p class=CodeChar style='margin-left:0in'>    s.replaceErrors();</p>

<p class=CodeChar style='margin-left:0in'>    s.saveFiles();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can replace the marker with one of your choice. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0554"
title="Add Comment A0554">Comment</a></sup></p>

<p class=MsoNormal>Each file is read a line at a time, and each line is
searched for the marker appearing at the head of the line; the line is modified
and put into the error line list and into the string stream, <b>edited</b>.
When the whole file is processed, it is closed (by reaching the end of a
scope), it is reopened as an output file, and <b>edited</b> is poured into the
file. Also notice the counter is saved in an external file. The next time this
program is invoked, it continues to sequence the counter. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0555"
title="Add Comment A0555">Comment</a></sup></p>

<h3><a name="_Toc45440037"></a><a name="_Toc312373899">A simple datalogger</a><a
name=x></a></h3>

<p class=MsoNormal>This example shows an approach you might take to log data to
disk and later retrieve it for processing. It is meant to produce a temperature-depth
profile of the ocean at various points. To hold the data, a class is used: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0556"
title="Add Comment A0556">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:DataLogger.h</p>

<p class=CodeChar style='margin-left:0in'>// Datalogger record layout</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DATALOG_H</p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>#define DATALOG_H</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>#include &lt;ctime&gt;</span></p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iosfwd&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::ostream;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct Coord {</p>

<p class=CodeChar style='margin-left:0in'>  int deg, min, sec;</p>

<p class=CodeChar style='margin-left:0in'>  Coord(int d=0, int m=0, int s=0)</p>

<p class=CodeChar style='margin-left:0in'>    : deg(d), min(m), sec(s) {}</p>

<p class=CodeChar style='margin-left:0in'>  std::string toString() const;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp; operator&lt;&lt;(ostream&amp;,
const Coord&amp;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DataPoint {</p>

<p class=CodeChar style='margin-left:0in'>  std::time_t timestamp; // Time
&amp; day</p>

<p class=CodeChar style='margin-left:0in'>  Coord latitude, longitude;</p>

<p class=CodeChar style='margin-left:0in'>  double depth, temperature;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  DataPoint(std::time_t ts, const
Coord&amp; lat,</p>

<p class=CodeChar style='margin-left:0in'>            const Coord&amp; lon,
double dep, double temp)</p>

<p class=CodeChar style='margin-left:0in'>    : timestamp(ts), latitude(lat),
longitude(lon),</p>

<p class=CodeChar style='margin-left:0in'>      depth(dep), temperature(temp)
{}</p>

<p class=CodeChar style='margin-left:0in'>  DataPoint() : timestamp(0),
depth(0), temperature(0) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp;, const DataPoint&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>#endif // DATALOG_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>DataPoint</b> consists of a time stamp, which is stored
as a <b>time</b>_t value as defined in <b>&lt;ctime&gt;</b>, longitude and
latitude coordinates, and values for depth and temperature. We use inserters
for easy formatting. Here’s the implementation file: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0557"
title="Add Comment A0557">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Datalogger.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>// Datapoint implementations</p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>#include
&quot;DataLogger.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>#include
&lt;iomanip&gt;</span></p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Coord&amp; c) {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>return os &lt;&lt;
c.deg &lt;&lt; '*' &lt;&lt; c.min &lt;&lt; '\''</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>            </span>&lt;&lt;
c.sec &lt;&lt; '&quot;';</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string Coord::toString() const {</p>

<p class=CodeChar style='margin-left:0in'>  ostringstream os;</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; *this;</p>

<p class=CodeChar style='margin-left:0in'>  return os.str();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp; os, const DataPoint&amp; d) {</p>

<p class=CodeChar style='margin-left:0in'>  os.setf(ios::fixed,
ios::floatfield);</p>

<p class=CodeChar style='margin-left:0in'>  char fillc = os.fill('0'); // Pad
on left with '0'</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>tm* tdata =
localtime(&amp;d.timestamp);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span><span lang=SV>os
&lt;&lt; setw(2) &lt;&lt; tdata-&gt;tm_mon + 1 &lt;&lt; '\\'</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>     &lt;&lt; setw(2)
&lt;&lt; tdata-&gt;tm_mday &lt;&lt; '\\'</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>     </span>&lt;&lt;
setw(2) &lt;&lt; tdata-&gt;tm_year+1900 &lt;&lt; ' '</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; setw(2) &lt;&lt;
tdata-&gt;tm_hour &lt;&lt; ':'</p>

<p class=CodeChar style='margin-left:0in'>     <span lang=SV>&lt;&lt; setw(2)
&lt;&lt; tdata-&gt;tm_min &lt;&lt; ':'</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>     </span>&lt;&lt;
setw(2) &lt;&lt; tdata-&gt;tm_sec;</p>

<p class=CodeChar style='margin-left:0in'>  os.fill(' '); // Pad on left with '
'</p>

<p class=CodeChar style='margin-left:0in'>  streamsize prec = os.precision(4);</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; &quot; Lat:&quot;
&lt;&lt; setw(9) &lt;&lt; d.latitude.toString()</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; &quot;, Long:&quot;
&lt;&lt; setw(9) &lt;&lt; d.longitude.toString()</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; &quot;, depth:&quot;
&lt;&lt; setw(9) &lt;&lt; d.depth</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; &quot;, temp:&quot;
&lt;&lt; setw(9) &lt;&lt; d.temperature;</p>

<p class=CodeChar style='margin-left:0in'>  os.fill(fillc);</p>

<p class=CodeChar style='margin-left:0in'>  os.precision(prec);</p>

<p class=CodeChar style='margin-left:0in'>  return os;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Coord::toString(&nbsp;) </b>function is necessary
because the <b>DataPoint</b> inserter calls <b>setw(&nbsp;)</b> before it
prints the latitude and longitude. If we used the stream inserter for <b>Coord</b>
instead, the width would only apply to the first insertion (that is, to <b>Coord::deg</b>),
since width changes are always reset immediately. The call to <b>setf(&nbsp;)</b> causes the floating-point output to be fixed-precision, and <b>precision(&nbsp;)</b> sets the number of decimal places to four. Notice how we restore the fill
character and precision to whatever they were before the inserter was called. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0558"
title="Add Comment A0558">Comment</a></sup></p>

<p class=MsoNormal>To get the values from the time encoding stored in <b>DataPoint::timestamp</b>,
we call the function <b>std::localtime(&nbsp;)</b>, which returns a static
pointer to a <b>tm</b> object. The <b>tm</b> <b>struct</b> has the following
layout:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>struct tm {</p>

<p class=CodeChar style='margin-left:0in'>  int tm_sec; // 0-59 seconds</p>

<p class=CodeChar style='margin-left:0in'>  int tm_min; // 0-59 minutes</p>

<p class=CodeChar style='margin-left:0in'>  int tm_hour; // 0-23 hours</p>

<p class=CodeChar style='margin-left:0in'>  int tm_mday; // Day of month</p>

<p class=CodeChar style='margin-left:0in'>  int tm_mon; // 0-11 months</p>

<p class=CodeChar style='margin-left:0in'>  int tm_year; // Years since 1900</p>

<p class=CodeChar style='margin-left:0in'>  int tm_wday; // Sunday == 0, etc.</p>

<p class=CodeChar style='margin-left:0in'>  int tm_yday; // 0-365 day of year</p>

<p class=CodeChar style='margin-left:0in'>  int tm_isdst; // Daylight savings?</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h4>Generating test data</h4>

<p class=MsoNormal>Here’s a program that creates a file of test data in binary
form (using <b>write(&nbsp;)</b>) and a second file in ASCII form using the <b>DataPoint</b>
inserter. You can also print it out to the screen, but it’s easier to inspect
in file form. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0561"
title="Add Comment A0561">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Datagen.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test data generator</p>

<p class=CodeChar style='margin-left:0in'>//{L} DataLogger</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DataLogger.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
data(&quot;data.txt&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(data, &quot;data.txt&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
bindata(&quot;data.bin&quot;, ios::binary);</p>

<p class=CodeChar style='margin-left:0in'>  assure(bindata,
&quot;data.bin&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  time_t timer;</p>

<p class=CodeChar style='margin-left:0in'>  Coord lat(45,20,31);</p>

<p class=CodeChar style='margin-left:0in'>  Coord lon(22,34,18);</p>

<p class=CodeChar style='margin-left:0in'>  // Seed random number generator:</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(&amp;timer)); </p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++,
timer += 55) {</p>

<p class=CodeChar style='margin-left:0in'>    // Zero to 199 meters:</p>

<p class=CodeChar style='margin-left:0in'>    double newdepth  = rand() % 200;</p>

<p class=CodeChar style='margin-left:0in'>    double fraction = rand() % 100 +
1;</p>

<p class=CodeChar style='margin-left:0in'>    newdepth += 1.0 / fraction;</p>

<p class=CodeChar style='margin-left:0in'>    double newtemp = 150 +
rand()%200; // Kelvin</p>

<p class=CodeChar style='margin-left:0in'>    fraction = rand() % 100 + 1;</p>

<p class=CodeChar style='margin-left:0in'>    newtemp += 1.0 / fraction;</p>

<p class=CodeChar style='margin-left:0in'>    const DataPoint d(timer,
Coord(45,20,31), </p>

<p class=CodeChar style='margin-left:0in'>                     
Coord(22,34,18), newdepth,</p>

<p class=CodeChar style='margin-left:0in'>                      newtemp);</p>

<p class=CodeChar style='margin-left:0in'>    data &lt;&lt; d &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>   
bindata.write(reinterpret_cast&lt;const char*&gt;(&amp;d),</p>

<p class=CodeChar style='margin-left:0in'>                  sizeof(d));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The file <b>data.txt </b>is created in the ordinary way as
an ASCII file, but <b>data.bin </b>has the flag <b>ios::binary</b> to tell the
constructor to set it up as a binary file. To illustrate the formatting used
for the text file, here is the first line of <b>data.txt</b> (the line wraps
because it’s longer than this page will allow): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0562"
title="Add Comment A0562">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>07\28\2003 12:54:40 Lat:45*20'31&quot;, Long:22*34'18&quot;, depth:  16.0164, temp: 242.0122</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The Standard C library function <b>time(&nbsp;)</b> updates
the <b>time_t</b> value its argument points to with an encoding of the current
time, which on most platforms is the number of seconds elapsed since 00:00:00
GMT, January 1 1970 (the dawning of the age of Aquarius?). The current time is
also a convenient way to seed the random number generator with the Standard C
library function <b>srand(&nbsp;)</b>, as is done here. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0563"
title="Add Comment A0563">Comment</a></sup></p>

<p class=MsoNormal>After this, the <b>timer</b> is incremented by 55 seconds to
give an interesting interval between readings in this simulation. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0566"
title="Add Comment A0566">Comment</a></sup></p>

<p class=MsoNormal>The latitude and longitude used are fixed values to indicate
a set of readings at a single location. Both the depth and the temperature are
generated with the Standard C library <b>rand(&nbsp;)</b> function, which returns a pseudorandom number between zero and a platform-dependent
constant, <b>RAND_MAX</b>, defined in <b>&lt;cstdlib&gt;</b> (usually the value
of the platform’s largest unsigned integer). To put this in a desired range,
use the remainder operator <b>%</b> and the upper end of the range. These
numbers are integral; to add a fractional part, a second call to <b>rand(&nbsp;)</b>
is made, and the value is inverted after adding one (to prevent divide-by-zero
errors). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0567"
title="Add Comment A0567">Comment</a></sup></p>

<p class=MsoNormal>In effect, the <b>data.bin </b>file is being used as a
container for the data in the program, even though the container exists on disk
and not in RAM. To send the data out to the disk in binary form, <b>write(&nbsp;)</b>
is used. The first argument is the starting address of the source block—notice
it must be cast to a<b> char*</b> because that’s what <b>write(&nbsp;)</b>
expects for narrow streams. The second argument is the number of characters to
write, which in this case is the size of the <b>DataPoint</b> object (again,
because we’re using <i>narrow streams</i>). Because no pointers are contained
in <b>DataPoint</b>, there is no problem in writing the object to disk. If the
object is more sophisticated, you must implement a scheme for <i>serialization</i>,
which writes the data referred to by pointers and defines new pointers when
read back in later. (We don’t talk about serialization in this volume—most
vendor class libraries have some sort of serialization structure built into
them.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0568"
title="Add Comment A0568">Comment</a></sup></p>

<h4>Verifying and viewing the data</h4>

<p class=MsoNormal>To check the validity of the data stored in binary format,
you can read it into memory with the <b>read(&nbsp;)</b> member function for
input streams, and compare it to the text file created earlier by <b>Datagen.cpp</b>.
The following example just writes the formatted results to <b>cout</b>, but you
can redirect this to a file and then use a file comparison utility to verify
that it is identical to the original.<sup> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0569"
title="Add Comment A0569">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Datascan.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test data generator</p>

<p class=CodeChar style='margin-left:0in'>//{L} DataLogger</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DataLogger.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
bindata(&quot;data.bin&quot;, ios::binary);</p>

<p class=CodeChar style='margin-left:0in'>  assure(bindata,
&quot;data.bin&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  DataPoint d;</p>

<p class=CodeChar style='margin-left:0in'>  while
(bindata.read(reinterpret_cast&lt;char*&gt;(&amp;d),</p>

<p class=CodeChar style='margin-left:0in'>         sizeof d))</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; d &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc312373900"></a><a name="_Toc305628672"></a><a
name="_Toc45440038">Internationalization</a></h2>

<p class=MsoNormal>The software industry is now a healthy, worldwide economic
market, and applications that can run in various languages and cultures are in
demand. As early as the late 1980s, the C Standards Committee added support for
non-U.S. formatting conventions with their <i>locale</i> mechanism. A locale is
a set of preferences for displaying certain entities such as dates and monetary
quantities. In the 1990s, the C Standards Committee approved an addendum to Standard
C that specified functions to handle <i>wide characters</i> (denoted by the
type <b>wchar_t</b>), which allow support for character sets other than ASCII
and its commonly used Western European extensions. Although the size of a wide
character is not specified, some platforms implement them as 32-bit quantities,
so they can hold the encodings specified by the Unicode Consortium, as well as
mappings to multi-byte characters sets defined by Asian standards bodies. C++
has integrated support for both wide characters and locales into the iostreams
library. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1606"
title="Add Comment A1606"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440039">Wide Streams</a></h3>

<p class=MsoNormal>A <i>wide stream</i> is a simply a stream class that handles
wide characters. All the examples so far (except for the last traits example in
Chapter 3) have used <i>narrow</i> streams, meaning streams that hold instances
of <b>char</b>. Since stream operations are essentially the same no matter the
underlying character type, they are encapsulated generically as templates. As
we mentioned earlier, all input streams, for example, are connected somehow to
the <b>basic_istream</b> class template, which is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT, class traits
= char_traits&lt;charT&gt; &gt;</p>

<p class=CodeChar style='margin-left:0in'>class basic_istream {…};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In fact, all input stream types are specializations of this
template, according to the following type definitions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>typedef basic_istream&lt;char&gt;
istream;</p>

<p class=CodeChar style='margin-left:0in'>typedef basic_istream&lt;wchar_t&gt;
wistream;</p>

<p class=CodeChar style='margin-left:0in'>typedef basic_ifstream&lt;char&gt;
ifstream;</p>

<p class=CodeChar style='margin-left:0in'>typedef basic_ifstream&lt;wchar_t&gt;
wifstream;</p>

<p class=CodeChar style='margin-left:0in'>typedef
basic_istringstream&lt;char&gt; istringstream;</p>

<p class=CodeChar style='margin-left:0in'>typedef
basic_istringstream&lt;wchar_t&gt; wistringstream;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All other stream types are defined in similar fashion.</p>

<p class=MsoNormal>In a “perfect” world, this is all you’d have to do to have
streams of different character types. In reality, things aren’t that simple.
The reason is that the character-processing functions provided for <b>char</b>
and <b>wchar_t</b> don’t have the same names. To compare two narrow strings,
for example, you use the <b>strcmp(&nbsp;)</b> function. For wide characters,
that function is named <b>wcscmp(&nbsp;)</b>. (Remember these originated in C,
which does not have function overloading, hence unique names are a must.) For
this reason, a generic stream can’t just call <b>strcmp(&nbsp;)</b> in response
to a comparison operator. There needs to be a way for the correct low-level
functions to be called automatically. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1610"
title="Add Comment A1610"><sup>Comment</sup></a></p>

<p class=MsoNormal>The principle that guides the solution is well known. You
simply “factor out” the differences into a new abstraction. The operations you
can perform on characters have been abstracted into the <b>char_traits</b>
template, which has predefined specializations for char and <b>wchar_t</b>, as
we discussed at the end of the previous chapter. To compare two strings, then, <b>basic_string</b>
just calls <b>traits::compare(&nbsp;)</b> (remember that <b>traits</b> is the
second template parameter), which in turn calls either <b>strcmp(&nbsp;)</b> or
<b>wcscmp(&nbsp;)</b>, depending on which specialization is being used
(transparent to <b>basic_string</b>, of course). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1611"
title="Add Comment A1611"><sup>Comment</sup></a></p>

<p class=MsoNormal>You only need to be concerned about <b>char_traits</b> if
you must access the low-level character processing functions; most of the time
you really don’t care. You should consider, however, making your inserters and
extractors more robust by defining them as templates, just in case someone
wants to use them on a wide stream.</p>

<p class=MsoNormal>To illustrate, recall again the <b>Date</b> class inserter
from the beginning of this chapter. We originally declared it as:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp;, const Date&amp;);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This accommodates only narrow streams. To make it generic,
we simply make it a template based on <b>basic_ostream</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT, class
traits&gt;</p>

<p class=CodeChar style='margin-left:0in'>std::basic_ostream&lt;charT,
traits&gt;&amp;</p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(std::basic_ostream&lt;charT,
traits&gt;&amp; os, </p>

<p class=CodeChar style='margin-left:0in'>           const Date&amp; d) {</p>

<p class=CodeChar style='margin-left:0in'>  charT fillc =
os.fill(os.widen('0'));</p>

<p class=CodeChar style='margin-left:0in'>  charT dash = os.widen('-');</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; setw(2) &lt;&lt;
d.month &lt;&lt; dash</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; setw(2) &lt;&lt; d.day
&lt;&lt; dash</p>

<p class=CodeChar style='margin-left:0in'>     &lt;&lt; setw(4) &lt;&lt; d.year;</p>

<p class=CodeChar style='margin-left:0in'>  os.fill(fillc);</p>

<p class=CodeChar style='margin-left:0in'>  return os;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that we also have to replace <b>char</b> with the
template parameter <b>charT</b> in the declaration of <b>fillc</b>, since it
could be either <b>char</b> or <b>wchar_t</b>, depending on the template
instantiation being used. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1682"
title="Add Comment A1682"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since you don’t know when you’re writing the template which
type of stream you have, you need a way to automatically convert character
literals to the correct size for the stream. This is the job of the <b>widen(&nbsp;)</b>
member function. The expression <b>widen('-')</b>, for example, converts its
argument to <b>L’-’</b> (the literal syntax equivalent to the conversion <b>wchar_t(‘-’)</b>)
if the stream is a wide stream and leaves it alone otherwise. There is also a <b>narrow(&nbsp;)</b>
function that converts to a <b>char</b> if needed. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1612"
title="Add Comment A1612"><sup>Comment</sup></a></p>

<p class=MsoNormal>We can use <b>widen(&nbsp;)</b> to write a generic version
of the <b>nl</b> manipulator we presented earlier in the chapter.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><a name="OLE_LINK1">template&lt;class
charT, class traits&gt;</a></p>

<p class=CodeChar style='margin-left:0in'>basic_ostream&lt;charT,traits&gt;&amp;</p>

<p class=CodeChar style='margin-left:0in'>nl(basic_ostream&lt;charT,traits&gt;&amp;
os) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt;
charT(os.widen('\n'));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440040">Locales</a></h3>

<p class=MsoNormal>Perhaps the most notable difference in typical numeric
computer output from country to country is the punctuator used to separate the
integer and fractional parts of a real number. In the United States, a period
is used to denote a decimal point, but in much of the world, a comma is
expected instead. It would be quite inconvenient to do all your own formatting
for locale-dependent displays. Once again, creating an abstraction that handles
these differences solves the problem.</p>

<p class=MsoNormal>That abstraction is the <i>locale</i>. All streams have an
associated locale object that they use for guidance on how to display certain
quantities for different cultural environments. A locale manages the categories
of culture-dependent display rules, which are defined as follows:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>Category</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>Effect</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>collate</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>allows comparing strings according to different, supported
  collating sequences</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>ctype</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>abstracts the character classification and conversion
  facilities found in &lt;cctype&gt;</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>monetary</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>supports different displays of monetary quantities</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>numeric</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>supports different display formats of real numbers,
  including radix (decimal point) and grouping (thousands) separators</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>time</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>supports various international formats for display of date
  and time</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>messages</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>scaffolding to implement context-dependent message
  catalogs (such as for error messages in different languages)</p>
  </td>
 </tr>
</table>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The following program illustrates basic locale behavior:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Locale.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-edg}</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates effects of locales</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;locale&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  locale def;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; def.name() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  locale current = cout.getloc();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; current.name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  float val = 1234.56;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Change to French/France</p>

<p class=CodeChar style='margin-left:0in'> 
cout.imbue(locale(&quot;french&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  current = cout.getloc();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; current.name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Enter the
literal 7890,12: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cin.imbue(cout.getloc());</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>cin &gt;&gt; val;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cout &lt;&lt; val
&lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>cout.imbue(def);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here’s the output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>C</p>

<p class=CodeChar style='margin-left:0in'>C</p>

<p class=CodeChar style='margin-left:0in'>1234.56</p>

<p class=CodeChar style='margin-left:0in'>French_France.1252</p>

<p class=CodeChar style='margin-left:0in'>1234,56</p>

<p class=CodeChar style='margin-left:0in'>Enter the literal 7890,12: <b>7890,12</b></p>

<p class=CodeChar style='margin-left:0in'>7890,12</p>

<p class=CodeChar style='margin-left:0in'>7890.12</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The default locale is the “C” locale, which is what C and
C++ programmers have been used to all these years (basically, English language
and American culture). All streams are initially “imbued” with the “C” locale.
The <b>imbue(&nbsp;)</b> member function changes the locale that a stream uses.
Notice that the full ISO name for the “french” locale is displayed (that is,
French used in France vs. French used in another country). This example shows
that this locale uses a comma for a radix point in numeric display. We have to
change <b>cin</b> to the same locale if we want to do input according to the
rules of this locale.</p>

<p class=MsoNormal>Each locale category is divided into number of <i>facets</i>,
which are classes encapsulating the functionality that pertains to that
category. For example, the <b>time</b> category has the facets <b>time_put</b>
and <b>time_get</b>, which contain functions for doing time and date <b>input</b>
and <b>output</b> respectively. The <b>monetary</b> category has facets <b>money_get</b>,
<b>money_put</b>, and <b>moneypunct</b>. (The latter facet determines the
currency symbol.) The following program illustrates the <b>moneypunct</b>
facet. (The <b>time</b> facet requires a sophisticated use of iterators which
is beyond the scope of this chapter.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C04:Facets.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;locale&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Change to French/France</p>

<p class=CodeChar style='margin-left:0in'>  locale loc(&quot;french&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout.imbue(loc);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  string currency =</p>

<p class=CodeChar style='margin-left:0in'>   
use_facet&lt;moneypunct&lt;char&gt; &gt;(loc).curr_symbol();</p>

<p class=CodeChar style='margin-left:0in'>  char point =</p>

<p class=CodeChar style='margin-left:0in'>   
use_facet&lt;moneypunct&lt;char&gt; &gt;(loc).decimal_point();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;I made &quot;
&lt;&lt; currency &lt;&lt; 12.34 &lt;&lt; &quot; today!&quot;</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The output shows the French currency symbol and decimal
separator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>I made Ç12,34 today!</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can also define your own facets to construct customized
locales<a href="#_ftn46" name="_ftnref46" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[46]</span></sup></span></span></sup></span></a>. Be
aware that the overhead for locales is considerable. In fact, some library
vendors provide different “flavors” of the standard C++ library to accommodate
environments that have limited space.<a href="#_ftn47" name="_ftnref47" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[47]</span></sup></span></span></sup></span></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440041">Summary</a></h2>

<p class=MsoNormal>This chapter has given you a fairly thorough introduction to
the iostream class library. In all likelihood, it is all you need to create
programs using iostreams. However, be aware that some additional features in
iostreams are not used often, but you can discover them by looking at the
iostream header files and by reading your compiler’s documentation on iostreams
or the references mentioned in this chapter and in the book’s preface. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0583"
title="Add Comment A0583">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440042"></a><a name="_Toc312373901">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Open a file by creating an <b>ifstream</b> object. Make an <b>ostringstream</b>
object and read the entire contents into the <b>ostringstream</b> using the <b>rdbuf(&nbsp;)</b>
member function. Extract a <b>string</b> copy of the underlying buffer and
capitalize every character in the file using the Standard C <b>toupper(&nbsp;)</b>
macro defined in <b>&lt;cctype&gt;</b>. Write the result out to a new file.<span
style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I190&gt;</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a program that opens a file (the first argument on the
command line) and searches it for any one of a set of words (the remaining
arguments on the command line). Read the input a line at a time, and write out
the lines (with line numbers) that match to the new file.<span
style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I191&gt;</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that adds a copyright notice to the beginning of
all source-code files indicated by the program’s command-line arguments.<span
style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I192&gt;</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use your favorite text-searching program (<b>grep</b>, for
example) to output the names (only) of all the files that contain a particular
pattern. Redirect the output into a file. Write a program that uses the
contents of that file to generate a batch file that invokes your editor on each
of the files found by the search program.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>We know that <b>setw(&nbsp;)</b> allows for a minimum of
characters read in, but what if you wanted to read a maximum? Write an effector
that allows the user to specify a maximum number of characters to extract. Have
your effector also work for output, in such a way that output fields are
truncated, if necessary, to stay within width limits.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Demonstrate to yourself that if the fail or bad bit is set, and
you subsequently turn on stream exceptions, that the stream will immediately
throw an exception.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>String streams accommodate easy conversions, but they come with a
price. Write a program that races <b>atoi(&nbsp;)</b> against the <b>stringstream</b>
conversion system to see the effect of the overhead involved with <b>stringstream</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>8. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make a <b>Person</b> struct with fields such as name, age,
address, etc.  Make the string fields fixed-size arrays. The social security
number will be the key for each record.  Implement the following <b>Database</b>
class.</p>

<p class=Exercises style='margin-left:.75in;text-indent:0in'>&nbsp;</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>class DataBase {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // Find where a record is on disk</p>

<p class=CodeChar style='margin-left:0in'>  size_t query(size_t ssn);</p>

<p class=CodeChar style='margin-left:0in'>  // Return the person at rn (record
number)</p>

<p class=CodeChar style='margin-left:0in'>  Person retrieve(size_t rn);</p>

<p class=CodeChar style='margin-left:0in'>  // Record a record on disk</p>

<p class=CodeChar style='margin-left:0in'>  void add(const Person&amp; p);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal style='margin-left:1.0in'>Write some <b>Person</b> records to
disk (do not keep them all in memory). When the user requests a record, read it
off the disk and return it. The IO operations in the <b>DataBase</b> class use <b>read(&nbsp;)</b>
and <b>write(&nbsp;)</b> to process all <b>Person</b> records.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>9. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write an <b>operator&lt;&lt;</b> inserter for the <b>Person</b>
struct that can be used to display records in a format easily read. Practice
writing it out to file.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>10. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Suppose your database for your <b>Person</b> structs was lost but
that you have the file you wrote from the previous exercise.  Recreate your
database using this file. Be sure to use error checking.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>11. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write <b>size_t(-1)</b> (the largest <b>unsigned int</b> on your
platform)  to a text file 1,000,000 times. Repeat, but write to a binary file.
Compare the two files for size, and see how much room is saved using the binary
format. (You may first want to try to calculate how much will be saved on your
platform.)</p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section11>

<h1 style='margin-left:-81.35pt'><a name="_Toc312374096"></a><a
name="_Toc305628757"></a><a name="_Toc305593285"></a><a name="_Toc45440043">5:
Templates in depth</a></h1>

<p class=Intro style='margin-left:.25in'>The C++ template facility goes far
beyond simple “containers of T.” While the original motivation was to enable
type-safe, generic containers, in modern C++, templates are also used to
generate custom code, and to optimize program execution through compile-time
programming constructs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1846"
title="Add Comment A1846"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

<p class=MsoNormal>In this chapter we offer a practical look at the power (and
pitfalls) of programming with templates in modern C++. For a more complete
analysis of template-related language issues and “gotchas”, we recommend the
superb book by David Vandevoorde and Nico Josuttis<a href="#_ftn48"
name="_ftnref48" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[48]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1847"
title="Add Comment A1847"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440044"></a><a
name=AdvancedTemplatesChapter></a>Template parameters</h2>

<p class=MsoNormal>As we illustrated in Volume 1, templates come in two
flavors: function templates and class templates. Both are wholly characterized
by their parameters. Each template parameter itself may represent one of the
following categories of arguments:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>types
(either built-in or user-defined)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>compile-time
constant values (i.e., integers, and pointers and references to global
entities; these are often referred to as “non-type” parameters)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>other
templates</p>

<p class=MsoNormal>The examples in Volume 1 all fall into the first category,
and are the most common. The canonical example for simple container-like
templates nowadays seems to be a <b>Stack</b> class. Being a container, a <b>Stack</b>
object is not concerned with the type of object it stores; the logic of holding
objects is independent of the type of objects being held. For this reason you
can use a type parameter to represent the contained type: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1848"
title="Add Comment A1848"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Stack {</p>

<p class=CodeChar style='margin-left:0in'>  T* data;</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; t);</p>

<p class=CodeChar style='margin-left:0in'>  // etc.</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You provide the actual type to be used for a particular <b>Stack</b>
instance by means of an argument for the parameter <b>T</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>Stack&lt;int&gt; myStack; 
// A Stack of ints</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The compiler then provides an <b>int</b>-version of <b>Stack</b>
by substituting <b>int</b> for <b>T</b> and generating the corresponding code.
The name of the class instance generated from the template in this case is <b>Stack&lt;int&gt;</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1849"
title="Add Comment A1849"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440045">Non-type template parameters</a></h3>

<p class=MsoNormal>It is also possible to provide a non-type template
parameter, as long as it represents a value that is known at compile time. You
can make a fixed-size <b>Stack</b>, for instance, by specifying a non-type
parameter to be used as the dimension for the underlying array, as follows. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1850"
title="Add Comment A1850"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, size_t N&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Stack {</p>

<p class=CodeChar style='margin-left:0in'>  T data[N];  // Fixed capacity is N</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; t);</p>

<p class=CodeChar style='margin-left:0in'>  // etc.</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You must provide a compile-time constant value for the
parameter <b>N</b> when you request an instance of this template, such as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>Stack&lt;int, 100&gt;
myFixedStack;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Because the value of <b>N</b> is known at compile time, the
underlying array (<b>data</b>) can be placed on the runtime stack instead of
the free store, which can improve runtime performance by avoiding the overhead
associated with dynamic memory allocation. Following the pattern mentioned
earlier, the name of the class above is <b>Stack&lt;int, 100&gt;</b>. This
means that each distinct value of <b>N</b> results in a unique class type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1851"
title="Add Comment A1851"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>bitset</b> class template, discussed in detail in
chapter 7, is the only class in the standard C++ library that uses a non-type
template parameter, which happens to specify the number of bits the <b>bitset</b>
object can hold. The following random number generator example uses a <b>bitset</b>
to track numbers so all the numbers in its range are returned in random order
without repetition before starting over again. This example also overloads <b>operator(&nbsp;)</b>
to produce a familiar function-call syntax. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0586"
title="Add Comment A0586"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Urand.h</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Unique random number generator</p>

<p class=CodeChar style='margin-left:0in'>#ifndef URAND_H</p>

<p class=CodeChar style='margin-left:0in'>#define URAND_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;bitset&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::size_t;</p>

<p class=CodeChar style='margin-left:0in'>using std::bitset;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;size_t upperBound&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Urand {</p>

<p class=CodeChar style='margin-left:0in'>  bitset&lt;upperBound&gt; used;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Urand() {</p>

<p class=CodeChar style='margin-left:0in'>    srand(time(0));  // randomize</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  size_t operator()(); // The
&quot;generator&quot; function</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;size_t upperBound&gt;</p>

<p class=CodeChar style='margin-left:0in'>inline size_t
Urand&lt;upperBound&gt;::operator()() {</p>

<p class=CodeChar style='margin-left:0in'>  if(used.count() == upperBound)</p>

<p class=CodeChar style='margin-left:0in'>    used.reset();  // start over
(clear bitset)</p>

<p class=CodeChar style='margin-left:0in'>  size_t newval;</p>

<p class=CodeChar style='margin-left:0in'>  while(used[newval = rand() %
upperBound])</p>

<p class=CodeChar style='margin-left:0in'>    ; // Until unique value is found</p>

<p class=CodeChar style='margin-left:0in'>  used[newval] = true;</p>

<p class=CodeChar style='margin-left:0in'>  return newval;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>#endif // URAND_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The uniqueness of <b>Urand</b> is produced by tracking with
a <b>bitset</b> all the numbers possible in the random space (the upper bound
is set with the template argument) and recording each one as it’s used by
setting the corresponding position bit in <b>used</b>. When the numbers are all
used up, it clears the <b>bitset</b> to start all over again. Here’s a simple
test program that illustrates how to use a <b>Urand</b> object: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1852"
title="Add Comment A1852"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:UrandTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Urand.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Urand&lt;10&gt; u;</p>

<p class=CodeChar style='margin-left:0in'>  for (int i = 0; i &lt; 20; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; u() &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As we explain later in this chapter, non-type template
arguments are also important in the optimization of numeric computations. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0587"
title="Add Comment A0587"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440046">Default template arguments</a></h3>

<p class=MsoNormal>You can provide default arguments for template parameters in
class templates (they are not allowed in function templates). As with default
function arguments, they should only be defined once, the first time a template
declaration or definition is seen by the compiler. To make the fixed-size <b>Stack</b>
template shown earlier a little friendlier, for example, you can add a default
argument like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1853"
title="Add Comment A1853"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, size_t N =
100&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Stack {</p>

<p class=CodeChar style='margin-left:0in'>  T data[N];  // Fixed capacity is N</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; t);</p>

<p class=CodeChar style='margin-left:0in'>  // etc.</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now, if you leave off the second template argument when
declaring a <b>Stack</b> object, the value for <b>N</b> will default to 100. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1854"
title="Add Comment A1854"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can provide defaults for all arguments, if you like, but
you must use an empty set of brackets when declaring an instance so the
compiler knows that a class template is involved. Here’s how:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T = int, size_t N =
100&gt;  // both defaulted</p>

<p class=CodeChar style='margin-left:0in'>class Stack {</p>

<p class=CodeChar style='margin-left:0in'>  T data[N];  // Fixed capacity is N</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; t);</p>

<p class=CodeChar style='margin-left:0in'>  // etc.</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>Stack&lt;&gt; myStack;  //
same as Stack&lt;int, 100&gt; <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1855"
title="Add Comment A1855"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Default arguments are used heavily in the standard C++
library. The <b>vector</b> class template, for instance, is declared as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class T, class Allocator
= allocator&lt;T&gt; &gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>class vector;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This declaration reveals that <b>vector</b> actually takes
two arguments: the type of the contained objects it holds, and a type that
represents the allocator used by the vector (we talk more about allocators in
Chapter 7). Whenever you leave off the second argument, it defaults to an
instance of the standard <b>allocator</b> template, parameterized by the first
template parameter. This declaration also shows that you can use template
parameters in other, subsequent template parameters, as <b>T</b> is used here. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1856"
title="Add Comment A1856"><sup>Comment</sup></a></p>

<p class=MsoNormal>While you cannot use default template arguments in function
templates, you can use template parameters in normal function default
arguments. The following function template adds the elements in a sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1857"
title="Add Comment A1857"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:FuncDef.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>T sum(T* b, T* e, T init = T()) {</p>

<p class=CodeChar style='margin-left:0in'>  while (b != e)</p>

<p class=CodeChar style='margin-left:0in'>    init += *b++;</p>

<p class=CodeChar style='margin-left:0in'>  return init;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {1,2,3};</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; sum(a, a+sizeof a /
sizeof a[0]) &lt;&lt; endl; // 6</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The third argument to <b>sum(&nbsp;)</b> is the initial
value for the accumulation of the elements. Since we left it off, it defaults
to <b>T(&nbsp;)</b>, which in the case of <b>int</b> and other built-in types
invokes a pseudo-constructor that performs zero-initialization. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1858"
title="Add Comment A1858"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440047">Template template parameters</a></h3>

<p class=MsoNormal>The third type of parameter a template can accept is another
class template. This may sound strange, since templates are types, and type
parameters are already allowed, but if you are going to use a template type
parameter as a template in your code, the compiler needs to know that the
parameter is a template in the first place. The following example illustrates a
template template parameter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1859"
title="Add Comment A1859"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:TempTemp.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates a template template
parameter</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Array { // A simple, expandable
sequence</p>

<p class=CodeChar style='margin-left:0in'>  enum {INIT = 10};</p>

<p class=CodeChar style='margin-left:0in'>  T *data;</p>

<p class=CodeChar style='margin-left:0in'>  size_t capacity;</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Array() {</p>

<p class=CodeChar style='margin-left:0in'>    count = 0;</p>

<p class=CodeChar style='margin-left:0in'>    data = new T[capacity = INIT];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void push_back(const T&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    if (count == capacity) {</p>

<p class=CodeChar style='margin-left:0in'>      // Grow underlying array</p>

<p class=CodeChar style='margin-left:0in'>      size_t newCap = 2*capacity;</p>

<p class=CodeChar style='margin-left:0in'>      T* newData = new T[newCap];</p>

<p class=CodeChar style='margin-left:0in'>      for (size_t i = 0; i &lt;
count; ++i)</p>

<p class=CodeChar style='margin-left:0in'>        <span lang=IT>newData[i] =
data[i];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      delete data;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      </span>data =
newData;</p>

<p class=CodeChar style='margin-left:0in'>      capacity = newCap;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    data[count++] = t;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop_back() {</p>

<p class=CodeChar style='margin-left:0in'>    if (count &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>      --count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() {</p>

<p class=CodeChar style='margin-left:0in'>    return data;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() {</p>

<p class=CodeChar style='margin-left:0in'>    return data + count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;class
T, template&lt;class&gt; class Seq&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>class
Container {</p>

<p class=CodeChar style='margin-left:0in'>  Seq&lt;T&gt; seq;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void append(const T&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    seq.push_back(t);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() {</p>

<p class=CodeChar style='margin-left:0in'>    return seq.begin();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() {</p>

<p class=CodeChar style='margin-left:0in'>    return seq.end();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Container&lt;int, Array&gt; theData;</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(1);</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(2);</p>

<p class=CodeChar style='margin-left:0in'>  int* p = theData.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while (p != theData.end())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *p++ &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Array</b> class template is a trivial sequence
container. The <b>Container</b> template takes two parameters: the type of the
objects it is to hold, and a sequence data structure to do the holding. The
following line in the implementation of the <b>Container</b> class requires
that we inform the compiler that <b>Seq</b> is a template: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1860"
title="Add Comment A1860"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>  Seq&lt;T&gt; seq;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If we hadn’t declared <b>Seq</b> to be a template template
parameter, the compiler would complain here that <b>Seq</b> is not a template,
since we’re using it as such. In the <b>main(&nbsp;)</b> program a <b>Container</b>
is instantiated to use an <b>Array</b> to hold integers, so <b>Seq</b> stands
for <b>Array</b> in this example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1861"
title="Add Comment A1861"><sup>Comment</sup></a></p>

<p class=MsoNormal>Note that it is not necessary in this case to name the
parameter for <b>Seq</b> inside of <b>Container</b>’s declaration. The line in
question is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>template&lt;class T,
template&lt;class&gt; class Seq&gt;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>While we could have written</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>template&lt;class T,
template&lt;class U&gt; class Seq&gt;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>the parameter <b>U</b> is not needed anywhere. All that
matters is that <b>Seq</b> is a class template that takes a single type
parameter. This is analogous to omitting the names of function parameters when
they’re not needed, such as when you overload the post-increment operator: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1862"
title="Add Comment A1862"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>T operator++(int);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>int</b> here is merely a placeholder and therefore
needs no name.</p>

<p class=MsoNormal>The following program uses a fixed-size array, which has an
extra template parameter representing the array dimension:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span lang=IT>//: C05:TempTemp2.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>// A multi-variate
template template parameter</span></p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, size_t N&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Array {</p>

<p class=CodeChar style='margin-left:0in'>  T data[N];</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Array() { count = 0; }</p>

<p class=CodeChar style='margin-left:0in'>  void push_back(const T&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    if (count &lt; N)</p>

<p class=CodeChar style='margin-left:0in'>      data[count++] = t;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop_back() {</p>

<p class=CodeChar style='margin-left:0in'>    if (count &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>      --count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() { return data; }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() { return data + count; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T,size_t
N,template&lt;class,size_t&gt; class Seq&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Container {</p>

<p class=CodeChar style='margin-left:0in'>  Seq&lt;T,N&gt; seq;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void append(const T&amp; t) {
seq.push_back(t); }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() { return seq.begin(); }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() { return seq.end(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const size_t N = 10;</p>

<p class=CodeChar style='margin-left:0in'>  Container&lt;int, N, Array&gt;
theData;</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(1);</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(2);</p>

<p class=CodeChar style='margin-left:0in'>  int* p = theData.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while (p != theData.end())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *p++ &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Once again, parameter names are not needed in the
declaration of <b>Seq</b> inside <b>Container</b>’s declaration, but we need
two parameters to declare the data member <b>seq</b>, hence the appearance of
the non-type parameter <b>N</b> at the top level. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1863"
title="Add Comment A1863"><sup>Comment</sup></a></p>

<p class=MsoNormal>Combining default arguments with template template
parameters is slightly more problematic. The difficulty lies in the fact that
when the compiler looks at the inner parameters of a template template
parameter, default arguments are not considered, so you have to repeat the
defaults in order to get an exact match.  The following example uses a default
argument for the fixed-size <b>Array</b> template, and shows how to accommodate
this quirk in the language. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1864"
title="Add Comment A1864"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:TempTemp3.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>// Combining template template
parameters and</p>

<p class=CodeChar style='margin-left:0in'>// default arguments</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, size_t N =
10&gt;  // a default argument</p>

<p class=CodeChar style='margin-left:0in'>class Array {</p>

<p class=CodeChar style='margin-left:0in'>  T data[N];</p>

<p class=CodeChar style='margin-left:0in'>  size_t count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Array() { count = 0; }</p>

<p class=CodeChar style='margin-left:0in'>  void push_back(const T&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    if (count &lt; N)</p>

<p class=CodeChar style='margin-left:0in'>      data[count++] = t;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop_back() {</p>

<p class=CodeChar style='margin-left:0in'>    if (count &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>      --count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() { return data; }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() { return data + count; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T,
template&lt;class, size_t = 10&gt; class Seq&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Container {</p>

<p class=CodeChar style='margin-left:0in'>  Seq&lt;T&gt; seq;  // default used</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void append(const T&amp; t) {
seq.push_back(t); }</p>

<p class=CodeChar style='margin-left:0in'>  T* begin() { return seq.begin(); }</p>

<p class=CodeChar style='margin-left:0in'>  T* end() { return seq.end(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Container&lt;int, Array&gt;
theData;</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(1);</p>

<p class=CodeChar style='margin-left:0in'>  theData.append(2);</p>

<p class=CodeChar style='margin-left:0in'>  int* p = theData.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while (p != theData.end())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *p++ &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It is necessary to include the default dimension of 10 in
the line:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>template&lt;class T,
template&lt;class, size_t = 10&gt; class Seq&gt;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Both the definition of <b>seq</b> in <b>Container</b> and <b>theData</b>
in <b>main(&nbsp;)</b> use the default. The only way to use something other
than the default value is as the previous program (<b>TempTemp2.cpp</b>)
illustrated. This is the only exception to the rule stated earlier that default
arguments should appear only once in a compilation unit. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1865"
title="Add Comment A1865"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since the standard sequence containers (<b>vector</b>, <b>list</b>,
and <b>deque</b>, discussed in depth in Chapter 7) have a default allocator
argument, the technique shown above is helpful should you ever want to pass one
of these sequences as a template parameter. The following program passes a <b>vector</b>
and then a <b>list</b> to two instances of <b>Container</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1866"
title="Add Comment A1866"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:TempTemp4.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>// Passes standard sequences as
template arguments</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;memory&gt;  // declares
allocator&lt;T&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;class
T, template&lt;class U, class = allocator&lt;U&gt; &gt;   </p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>                 
class Seq&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Container {</p>

<p class=CodeChar style='margin-left:0in'>  Seq&lt;T&gt; seq; // default of
allocator&lt;T&gt; applied implicitly</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push_back(const T&amp; t) {
seq.push_back(t); }</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq&lt;T&gt;::iterator
begin() { return seq.begin(); }</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq&lt;T&gt;::iterator
end() { return seq.end(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Use a vector</p>

<p class=CodeChar style='margin-left:0in'>  Container&lt;int, vector&gt;
theData;</p>

<p class=CodeChar style='margin-left:0in'>  theData.push_back(1);</p>

<p class=CodeChar style='margin-left:0in'>  theData.push_back(2);</p>

<p class=CodeChar style='margin-left:0in'> </p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  for
(vector&lt;int&gt;::iterator p = theData.begin();</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>       p !=
theData.end(); ++p) {</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>    cout
&lt;&lt; *p &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Use a list</p>

<p class=CodeChar style='margin-left:0in'>  Container&lt;int, list&gt;
theOtherData;</p>

<p class=CodeChar style='margin-left:0in'>  theOtherData.push_back(3);</p>

<p class=CodeChar style='margin-left:0in'>  theOtherData.push_back(4);</p>

<p class=CodeChar style='margin-left:0in'>  </p>

<p class=CodeChar style='margin-left:0in'>  for (list&lt;int&gt;::iterator p2 =
theOtherData.begin();</p>

<p class=CodeChar style='margin-left:0in'>       p2 != theOtherData.end();
++p2) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *p2 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this case we name the first parameter of the inner
template <b>Seq</b> (with the name <b>U</b>), because the allocators in the
standard sequences must themselves be parameterized with the same type as the
contained objects in the sequence. Also, since the default <b>allocator</b>
parameter is known, we can omit it in the subsequent references to <b>Seq&lt;T&gt;</b>,
as we did in the previous program. To fully explain this example, however, we
have to discuss the semantics of the <b>typename</b> keyword. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1867"
title="Add Comment A1867"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440048">The typename keyword</a></h3>

<p class=MsoNormal>Consider the following: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0588"
title="Add Comment A0588"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:TypenamedID.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Uses 'typename' as a prefix for
nested types </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; class X {</p>

<p class=CodeChar style='margin-left:0in'>  // Without typename, you should get
an error:</p>

<p class=CodeChar style='margin-left:0in'>  typename T::id i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() { i.g(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Y {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  class id {</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    void g() {}</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  X&lt;Y&gt; xy;</p>

<p class=CodeChar style='margin-left:0in'>  xy.f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The template definition assumes that the class <b>T</b> that
you hand it must have a nested identifier of some kind called <b>id</b>. But <b>id</b>
could be a member object of <b>T</b>, in which case you can perform operations
on <b>id </b>directly, but you couldn’t “create an object” of “the type <b>id</b>.”
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1868"
title="Add Comment A1868"><sup>Comment</sup></a></p>

<p class=MsoNormal>However, that’s exactly what is happening here: the
identifier <b>id </b>is being treated as if it were actually a nested type
inside <b>T</b>. In the case of class <b>Y</b>, <b>id</b> is in fact a nested
type, but (without the <b>typename </b>keyword) the compiler can’t know that
when it’s compiling <b>X</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0589"
title="Add Comment A0589"><sup>Comment</sup></a></p>

<p class=MsoNormal>If, when it sees an identifier in a template, the compiler
has the option of treating that identifier as a type or as something other than
a type, then it will assume that the identifier refers to something other than
a type. That is, it will assume that the identifier refers to an object
(including variables of primitive types), an enumeration or something similar.
However, it will not–cannot–just assume that it is a type. Thus, the compiler
gets confused when we pretend it’s a type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0590"
title="Add Comment A0590"><sup>Comment</sup></a><sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0591"
title="Add Comment A0591"></a></p>

<p class=MsoNormal>Because the default behavior of the compiler is to assume
that a name that fits the above two points is not a type, you must use <b>typename</b>
for nested names (except in constructor initializer lists, where it is neither
needed nor allowed). In the above example, when the compiler sees <b>T::id</b>,
it knows (because of the <b>typename</b> keyword) that <b>id</b> refers to a
nested type and thus it can create an object of that type.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0592"
title="Add Comment A0592"><sup>Comment</sup></a></p>

<p class=MsoNormal>The short version of the rule is: if a type referred to
inside a template is qualified by a template type parameter, and doesn’t appear
in a base class specification or initializer list, then you must use <b>typename</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0593"
title="Add Comment A0593"><sup>Comment</sup></a></p>

<p class=MsoNormal>All the above explains the use of the <b>typename</b>
keyword in the program <b>TempTemp4.cpp</b>. Without it, the compiler would
assume that the expression <b>Seq&lt;T&gt;::iterator</b> is not a type, but we
were using it to define the return type of the <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
member functions. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1869"
title="Add Comment A1869"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example, which defines a function template
that can print any standard C++ sequence, shows a similar use of <b>typename</b>.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:PrintSeq.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>// A print function for standard C++
sequences</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;memory&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T,
template&lt;class U, class = allocator&lt;U&gt; &gt;  </p>

<p class=CodeChar style='margin-left:0in'>                  class Seq&gt;</p>

<p class=CodeChar style='margin-left:0in'>void printSeq(Seq&lt;T&gt;&amp; seq)
{</p>

<p class=CodeChar style='margin-left:0in'>  for (typename
Seq&lt;T&gt;::iterator b = seq.begin(); </p>

<p class=CodeChar style='margin-left:0in'>       b != seq.end();)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *b++ &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Process a vector</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v;</p>

<p class=CodeChar style='margin-left:0in'>  v.push_back(1);</p>

<p class=CodeChar style='margin-left:0in'>  v.push_back(2);</p>

<p class=CodeChar style='margin-left:0in'>  printSeq(v);</p>

<p class=CodeChar style='margin-left:0in'>  // Process a list</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;int&gt; lst;</p>

<p class=CodeChar style='margin-left:0in'>  lst.push_back(3);</p>

<p class=CodeChar style='margin-left:0in'>  lst.push_back(4);</p>

<p class=CodeChar style='margin-left:0in'>  printSeq(lst);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Once again, without the <b>typename</b> keyword the compiler
will interpret <b>iterator</b> as a static data member of <b>Seq&lt;T&gt;</b>,
which is a syntax error, since a type is required. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1870"
title="Add Comment A1870"><sup>Comment</sup></a></p>

<h4>Typedef-ing a typename</h4>

<p class=MsoNormal>It’s important not to assume that the <b>typename</b>
keyword creates a new type name. It doesn’t. Its purpose is to inform the
compiler that the token it precedes is to be interpreted as a type. A line
which reads: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0594"
title="Add Comment A0594"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typename
Seq&lt;T&gt;::iterator It;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>causes a variable named <b>It</b> to be declared of type <b>Seq&lt;T&gt;::iterator</b>.
If you mean to create a new type name, you should use <b>typedef</b>, as usual,
as in: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0595"
title="Add Comment A0595"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef typename
Seq&lt;It&gt;::iterator It;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h4>Using <span style='font-weight:normal'>typename</span> instead of <span
style='font-weight:normal'>class</span></h4>

<p class=MsoNormal>Another role of the <b>typename</b> keyword is to provide
you the option of using <b>typename</b> instead of <b>class</b> in the template
argument list of a template definition. To some, this produces clearer code
(your mileage may vary): <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0596"
title="Add Comment A0596"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:UsingTypename.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using 'typename' in the template
argument list</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt; class X {
}; </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  X&lt;int&gt; x;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You probably won’t see a great deal of code which uses <b>typename</b>
in this fashion, since the keyword was added to the language a relatively long
time after templates were introduced. As a stylistic convention, Herb Sutter
has suggested using <b>typename</b> when a template parameter can be passed
arguments of any type (including built-ins), and using <b>class</b> when only
class types are expected<a href="#_ftn49" name="_ftnref49" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[49]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0597"
title="Add Comment A0597"><sup>Comment</sup></a></p>

<h3><a name="_Toc312374089"></a><a name="_Toc305628754"></a><a
name="_Toc305593282"></a><a name="_Toc45440049">Using the </a><span
style='font-weight:normal'>template</span> keyword as a hint</h3>

<p class=MsoNormal>Just as the <b>typename</b> keyword helps the compiler in
those situations where a type identifier is not expected, there is also a
potential difficulty with tokens that are not identifiers, such as the <b>&lt;</b>
and <b>&gt;</b> characters; sometimes they represent the less-than or
greater-than symbols, and sometimes they delimit template parameter lists. As
an example, we’ll once more use the <b>bitset</b> class: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1871"
title="Add Comment A1871"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:DotTemplate.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrate the .template construct</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;bitset&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT, size_t N&gt;</p>

<p class=CodeChar style='margin-left:0in'>basic_string&lt;charT&gt;
bitsetToString(const bitset&lt;N&gt;&amp; bs) {</p>

<p class=CodeChar style='margin-left:0in'>  return bs.template
to_string&lt;charT, char_traits&lt;charT&gt;, </p>

<p class=CodeChar style='margin-left:0in'>                              
allocator&lt;charT&gt; &gt;();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  bitset&lt;10&gt; bs;</p>

<p class=CodeChar style='margin-left:0in'>  bs.set(1);</p>

<p class=CodeChar style='margin-left:0in'>  bs.set(5);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; bs &lt;&lt; endl; //
0000100010</p>

<p class=CodeChar style='margin-left:0in'>  string s =
bitsetToString&lt;char&gt;(bs);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s &lt;&lt; endl;  //
0000100010</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>bitset</b> class supports conversion to string object
via its <b>to_string</b> member function. To support multiple string classes, <b>to_string</b>
is itself a template, following the pattern established by the <b>basic_string</b>
template discussed in Chapter 3. The declaration of <b>to_string</b> inside of <b>bitset</b>
looks like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1872"
title="Add Comment A1872"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class charT, class
traits, class Allocator&gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>basic_string&lt;charT,
traits, Allocator&gt; to_string() const;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Our <b>bitsetToString(&nbsp;)</b> function template above
allows you to request different types of string representations of a <b>bitset</b>.
To get a wide string, for instance, you would change the call to the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>  wstring s =
bitsetToString&lt;wchar_t&gt;(bs);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note that <b>basic_string</b> uses default template
arguments, so we don’t have to repeat the <b>char_traits</b> and <b>allocator</b>
arguments in the return value. Unfortunately, <b>bitset::to_string</b> does not
use default arguments. Using <b>bitsetToString&lt;char&gt;(&nbsp;bs)</b> is
more convenient than typing a fully-qualified call to <b>bs.template
to_string&lt;char, char_traits, allocator&lt;char&gt; &gt;(&nbsp;)</b>  every
time. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1873"
title="Add Comment A1873"><sup>Comment</sup></a></p>

<p class=MsoNormal>The return statement in <b>bitsetToString(&nbsp;)</b>
contains the <b>template</b> keyword in an odd place—right after the dot
operator applied to the <b>bitset</b> object <b>bs</b>. This is because when
the template is parsed, the <b>&lt;</b> character after the <b>to_string</b>
token would be interpreted as a less-than operation instead of the beginning or
a template argument list. We explain exactly why this confusion exists in the
section “Name lookup issues” later on in this chapter. The “<b>.template</b>”
construct tells the compiler that what follows is a template, causing the <b>&lt;</b>
character to be interpreted correctly. The same reasoning applies to the <b>-&gt;</b>
and <b>::</b> operators when applied to templates. As with the <b>typename</b>
keyword, this template disambiguation technique can only be used within a
template<a href="#_ftn50" name="_ftnref50" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[50]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1874"
title="Add Comment A1874"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440050">Member Templates</a></h3>

<p class=MsoNormal>The <b>bitset::to_string(&nbsp;)</b> function template is an
example of a <i>member template</i>: a template declared within another class
or class template. This allows many combinations of independent template
arguments to be combined. A useful example is found in the <b>complex</b> class
template in the standard C+ library. The <b>complex</b> template has a type
parameter meant to represent an underlying floating-point type to hold the real
and imaginary parts of a complex number. The following code snippet from the
standard library shows a member-template constructor in the <b>complex</b>
class template: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1875"
title="Add Comment A1875"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;typename
T&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>class complex
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  template&lt;class X&gt;
complex(const complex&lt;X&gt;&amp;);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The standard <b>complex</b> template comes ready-made with
specializations that use <b>float</b>, <b>double</b>, and <b>long double</b>
for the parameter <b>T</b>. The member-template constructor above allows you to
create a new complex number that uses a different floating-point type as its
base type, as seen in the code below: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1876"
title="Add Comment A1876"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'> 
complex&lt;float&gt; z(1,2);</p>

<p class=CodeInlineCharChar style='margin-left:0in;page-break-after:avoid'> 
complex&lt;double&gt; w(z);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In the declaration of <b>w</b>, the <b>complex</b> template
parameter <b>T</b> is <b>double</b> and <b>X</b> is <b>float</b>. Member
templates make this kind of flexible conversion easy. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1877"
title="Add Comment A1877"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since defining a template within a template is a nesting
operation, the prefixes that introduce the templates must reflect that nesting
if you define the member template outside of the outer class definition. For
example, if you were to implement the <b>complex</b> class template, and if you
were to define the member-template constructor above outside of the <b>complex</b>
template class definition, you would have to do it like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1878"
title="Add Comment A1878"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;typename
T&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;typename
X&gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in;page-break-after:avoid'>complex&lt;T&gt;::complex(const
complex&lt;X&gt;&amp; c) {/*body here…*/}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Another use of member function templates in the standard
library is in the initialization of sequences, such as a <b>vector</b>. Suppose
we have a <b>vector</b> of <b>int</b>s and we want to initialize a new vector
of <b>doubles</b> with it, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1879"
title="Add Comment A1879"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  int data[5] = {1,2,3,4,5};</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v1(data, data+5);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  vector&lt;double&gt;
v2(v1.begin(), v1.end());</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As long as the elements in <b>v1</b> are
assignment-compatible with the elements in <b>v2</b> (as <b>double</b> and <b>int</b>
are here), all is well. The <b>vector</b> class template has the following
member template constructor: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1880"
title="Add Comment A1880"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class InputIterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>vector(InputIterator first,
InputIterator last,</p>

<p class=CodeInlineCharChar style='margin-left:0in'>       const Allocator&amp;
= Allocator());</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This constructor is actually used twice in the vector
declarations above. When <b>v1</b> is initialized from the array of <b>int</b>s,
the type <b>InputIterator</b> is <b>int*</b>. When <b>v2</b> is initialized
from <b>v1</b>, an instance of the member template constructor is used with <b>InputIterator</b>
representing <b>vector&lt;int&gt;::iterator</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1881"
title="Add Comment A1881"><sup>Comment</sup></a></p>

<p class=MsoNormal>Member templates can also be classes (they don’t have to be
functions, although that’s usually what you need). The following example show a
member class template inside of an outer class template. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1923"
title="Add Comment A1923"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:MemberClass.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A member class template</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Outer {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  template&lt;class R&gt;</p>

<p class=CodeChar style='margin-left:0in'>  class Inner {</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    void f();</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>    </p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; template
&lt;class R&gt;</p>

<p class=CodeChar style='margin-left:0in'>void
Outer&lt;T&gt;::Inner&lt;R&gt;::f() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Outer == &quot;
&lt;&lt; typeid(T).name() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Inner == &quot;
&lt;&lt; typeid(R).name() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Full Inner ==
&quot; &lt;&lt; typeid(*this).name() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Outer&lt;int&gt;::Inner&lt;bool&gt;
inner;</p>

<p class=CodeChar style='margin-left:0in'>  inner.f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>typeid</b> operator, which is covered in Chapter 8,
returns an object whose <b>name(&nbsp;)</b> member function yields a string
representation of a type, or of the type of a variable. Although the exact representation
varies from compiler to compiler, the output of the program above should be
something like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1921"
title="Add Comment A1921"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Outer == int</p>

<p class=CodeChar style='margin-left:0in'>Inner == bool</p>

<p class=CodeInlineCharChar style='margin-left:0in'>Full Inner ==
Outer&lt;int&gt;::Inner&lt;bool&gt;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The declaration of the variable <b>inner</b> in the main
program causes both <b>Inner&lt;bool&gt;</b> and <b>Outer&lt;int&gt;</b> to be
instantiated. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1922"
title="Add Comment A1922"><sup>Comment</sup></a></p>

<p class=MsoNormal>It is important to realize that member template functions
cannot be declared <b>virtual</b>. One fundamental reason is because current
compiler technology expects to be able to fix the size of a class’s virtual
function table when the class is parsed. Allowing virtual member template
functions would require knowing all calls to such member functions everywhere
in the program ahead of time, which is not feasible, especially for multi-file
projects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1882"
title="Add Comment A1882"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440051">Function template</a> issues</h2>

<p class=MsoNormal>Just as a class template describes a family of classes, a
function template represents a family of functions. The syntax for creating
either type of template is virtually identical, but they differ somewhat in how
they are used. You must always use angle brackets when instantiating class
templates and all non-default template arguments must be supplied. With function
templates, on the other hand, you can often omit the template arguments, and
default template arguments are not even allowed.<sup>  </sup>Consider a typical
implementation of the <b>min(&nbsp;)</b> function template declared in the <b>&lt;algorithm&gt;</b>
header, which looks something like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0598"
title="Add Comment A0598"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>const T&amp; min(const T&amp; a,
const T&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (a &lt; b) ? a : b;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You could invoke this template by providing the type of the
arguments in angle brackets, just like you do with class templates, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'><span lang=SV>int z =
min&lt;int&gt;(i, j);</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span lang=SV>&nbsp;</span></p>

<p class=MsoNormal>This syntax tells the compiler that a specialization of the <b>min</b>
template is needed with <b>int</b> used in place of the parameter <b>T</b>,
whereupon the compiler generates the corresponding code. Following the pattern
of naming the classes generated from class templates, you can think of the name
of the instantiated function as <b>min&lt;int&gt;</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1883"
title="Add Comment A1883"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440052">Type deduction of function template arguments</a></h3>

<p class=MsoNormal>You can always use such explicit function template
specification as in the example above, but it is often convenient to leave off
the template arguments and let the compiler deduce them from the function
arguments, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1884"
title="Add Comment A1884"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>int z = min(i, j);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If both <b>i</b> and <b>j</b> are <b>int</b>s, then the
compiler knows that you need <b>min&lt;int&gt;</b>, which it then instantiates
automatically. It is important to realize that the types must be identical,
because the template was originally specified with only one template type
argument used for both function parameters. No standard conversions are applied
for function arguments whose type is specified by a template parameter. For
example, if you wanted to find the minimum of an <b>int</b> and a <b>double</b>,
the following attempt at a call to <b>min</b> would fail: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1885"
title="Add Comment A1885"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>int z = min(x, j); // x is
a double</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>x</b> and <b>j</b> are distinct types, there is no
single parameter to match the template parameter <b>T</b> in the definition of <b>min</b>,
so the call does not match the template declaration. You can work around this
difficulty by casting one argument to the other’s type, or by reverting back to
the fully-specified call syntax, as in: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1886"
title="Add Comment A1886"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>int z =
min&lt;double&gt;(x, j);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This tells the compiler to generate the <b>double</b>
version of <b>min</b>, after which <b>j</b> can be promoted to a <b>double</b>
by normal standard conversion rules (because the function <b>min&lt;double&gt;(const
double&amp;, const double&amp;)</b> would then exist). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1887"
title="Add Comment A1887"><sup>Comment</sup></a></p>

<p class=MsoNormal>You might be tempted to require two parameters for <b>min</b>,
allowing the types of the arguments to be independent, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;typename
T, typename U&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>const T&amp;
min(const T&amp; a, const U&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (a &lt; b) ? a : b;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This is often a good strategy, but in this case it is
problematic because <b>min</b> must return a value, and there is no
satisfactory way to determine which type it should be (<b>T</b> or <b>U</b>?). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1888"
title="Add Comment A1888"><sup>Comment</sup></a></p>

<p class=MsoNormal>If the return type of a function template is an independent
template parameter, then you must always specify its type explicitly when you
call it, since there is no argument from which to deduce it. Such is the case
with the <b>fromString</b> template below. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1889"
title="Add Comment A1889"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><a name="_Toc312374090">//:
C05:StringConv.h</a></p>

<p class=CodeChar style='margin-left:0in'>#ifndef STRINGCONV_H</p>

<p class=CodeChar style='margin-left:0in'>#define STRINGCONV_H</p>

<p class=CodeChar style='margin-left:0in'>// Function templates to convert to
and from strings</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>T fromString(const std::string&amp;
s) {</p>

<p class=CodeChar style='margin-left:0in'>  std::istringstream is(s);</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>  is &gt;&gt; t;</p>

<p class=CodeChar style='margin-left:0in'>  return t;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>std::string toString(const T&amp; t)
{</p>

<p class=CodeChar style='margin-left:0in'>  std::ostringstream s;</p>

<p class=CodeChar style='margin-left:0in'>  s &lt;&lt; t;</p>

<p class=CodeChar style='margin-left:0in'>  return s.str();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // STRINGCONV_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>These function templates provide conversions to and from <b>std::
string</b> for any types that provide a stream inserter or extractor,
respectively. Here’s a test program that includes the use of the Standard
Library <b>complex</b> number type: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0601"
title="Add Comment A0601"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:StringConvTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;StringConv.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;complex&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>int i = 1234;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cout &lt;&lt; &quot;i
== \&quot;&quot; &lt;&lt; toString(i) &lt;&lt; &quot;\&quot;\n&quot;;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>float x =
567.89;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;x ==
\&quot;&quot; &lt;&lt; toString(x) &lt;&lt; &quot;\&quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  complex&lt;float&gt; c(1.0, 2.0);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c ==
\&quot;&quot; &lt;&lt; toString(c) &lt;&lt; &quot;\&quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>cout &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  i =
fromString&lt;int&gt;(string(&quot;1234&quot;));</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>cout &lt;&lt;
&quot;i == &quot; &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  x =
fromString&lt;float&gt;(string(&quot;567.89&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;x == &quot;
&lt;&lt; x &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  c = fromString&lt; complex&lt;float&gt;
&gt;(string(&quot;(1.0,2.0)&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c == &quot;
&lt;&lt; c &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The output is what you’d expect: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0602"
title="Add Comment A0602"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>i == &quot;1234&quot;</p>

<p class=CodeChar style='margin-left:0in'>x == &quot;567.89&quot;</p>

<p class=CodeChar style='margin-left:0in'>c == &quot;(1,2)&quot;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>i == 1234</p>

<p class=CodeChar style='margin-left:0in'>x == 567.89</p>

<p class=CodeInlineCharChar style='margin-left:0in'>c == (1,2)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that in each of the instantiations of <b>fromString</b>,
the template parameter is specified in the call. If you have a function
template with template parameters for the parameter types as well as the return
types, it is important to declare the return type parameter first, otherwise
you won’t be able to omit the type parameters for the function parameters. As
an illustration, consider the following well-known function template<a
href="#_ftn51" name="_ftnref51" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[51]</span></sup></span></span></sup></span></a>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1890"
title="Add Comment A1890"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>//:
C05:ImplicitCast.cpp</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;typename
R, typename P&gt;</p>

<p class=CodeChar style='margin-left:0in'>R implicit_cast(const P&amp; p) {</p>

<p class=CodeChar style='margin-left:0in'>  return p;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int i = 1;</p>

<p class=CodeChar style='margin-left:0in'>  float x =
implicit_cast&lt;float&gt;(i);</p>

<p class=CodeChar style='margin-left:0in'>  int j = implicit_cast&lt;int&gt;(x);</p>

<p class=CodeChar style='margin-left:0in'>  // char* p =
implicit_cast&lt;char*&gt;(i);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If you interchange <b>R</b> and <b>P</b> in the template
parameter list near the top of the file, it will be impossible to call this
program because the return type will remain unspecified (since the first
template parameter would be the function’s parameter type). The last line
(which is commented-out) is illegal because there is no standard conversion
from <b>int</b> to <b>char*</b>; <b>implicit_cast</b> is for revealing in your
code conversions that are allowed naturally. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1891"
title="Add Comment A1891"><sup>Comment</sup></a></p>

<p class=MsoNormal>With a little care you can even deduce array dimensions. The
following example has an array-initialization function template (<b>init2</b>)
that does just that.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:ArraySize.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::size_t;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;size_t R, size_t C,
typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void init1(T a[R][C]) {</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt; R; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t j = 0; j &lt; C; ++j)</p>

<p class=CodeChar style='margin-left:0in'>      a[i][j] = T();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;size_t R, size_t C, class
T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void init2(T (&amp;a)[R][C]) {  //
reference parameter</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt; R; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t j = 0; j &lt; C; ++j)</p>

<p class=CodeChar style='margin-left:0in'>      a[i][j] = T();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[10][20];</p>

<p class=CodeChar style='margin-left:0in'>  init1&lt;10,20&gt;(a);  // must
specify</p>

<p class=CodeChar style='margin-left:0in'>  init2(a);         // sizes deduced</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Array dimensions are not passed as part of a function
parameter’s type unless that parameter is passed by pointer or reference. The
function template <b>init2</b> declares <b>a</b> to be a reference to a
two-dimensional array, so its dimensions <b>R</b> and <b>C</b> are deduced by
the template facility, making <b>init2</b> a handy way to initialize a
two-dimensional array of any size. The template <b>init1</b> does not pass the
array by reference, so the sizes must be explicitly specified, although it can
still deduce the type parameter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1892"
title="Add Comment A1892"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440053">Function template overloading</a></h3>

<p class=MsoNormal>As with functions, you can overload function templates that
have the same name. When the compiler processes a function call in a program,
it has to decide which template or ordinary function is the “best” fit for the
call. Assuming the existence of the <b>min</b> function template introduced
earlier, let’s add some ordinary functions to the mix: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1893"
title="Add Comment A1893"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:MinTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::strcmp;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>using std::endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt; const
T&amp; min(const T&amp; a, const T&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (a &lt; b) ? a : b;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>const char* min(const char* a, const
char* b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (strcmp(a, b) &lt; 0) ? a :
b;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>double min(double x, double y) {</p>

<p class=CodeChar style='margin-left:0in'>  return (x &lt; y) ? x : y;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const char *s2 = &quot;say
\&quot;Ni-!\&quot;&quot;, *s1 = &quot;knights who&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min(1, 2) &lt;&lt;
endl;      // 1: 1 (template)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min(1.0, 2.0)
&lt;&lt; endl;  // 2: 1 (double)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min(1, 2.0) &lt;&lt;
endl;    // 3: 1 (double)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min(s1, s2) &lt;&lt;
endl;    // 4: knights who (const </p>

<p class=CodeChar style='margin-left:0in'>                                 
//                 char*)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min&lt;&gt;(s1, s2)
&lt;&lt; endl;  // 5: say &quot;Ni-!&quot; </p>

<p class=CodeChar style='margin-left:0in'>                                 
//    (template)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In addition to the function template, this program defines
two non-template functions: a C-style string version of <b>min</b> and a <b>double</b>
version. If the template didn’t exist at all, the call in line 1 above would
have invoked the <b>double</b> version of <b>min</b> because of the standard
conversion from <b>int</b> to <b>double</b>. Since the template is able to
generate an <b>int</b> version, however, that is considered a better match (of
course!), so that’s what happens. The call in line 2 is an exact match for the <b>double</b>
version, of course, and the call in line 3 also invokes the same function,
implicitly converting 1 to 1.0. In line 4 the <b>const char*</b> version of <b>min</b>
is called directly. In line 5 we force the compiler to use the template
facility by appending empty angle brackets to the function name, whereupon it
generates a <b>const char*</b> version from the template and uses it (which is
verified by the wrong answer—it’s just comparing addresses!).  If you’re
wondering why we used using declarations in lieu of the <b>using namespace std;</b>
directive, some compilers include headers behind the scenes that bring in <b>std::min</b>,
which would conflict with our declarations of the name <b>min</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1894"
title="Add Comment A1894"><sup>Comment</sup></a></p>

<p class=MsoNormal>As stated above, you can overload templates of the same
name, as long as they can be distinguished by the compiler. You could, for
example, declare a <b>min</b> function template that processes three arguments:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>const T&amp; min(const
T&amp; a, const T&amp; b, const T&amp; c);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Versions of this template will be generated only for calls
to <b>min(&nbsp;)</b> that have three arguments of the same type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1895"
title="Add Comment A1895"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440054">Taking the address of a generated function template</a>
</h3>

<p class=MsoNormal>There are a number of situations where you need to take the
address of a function. For example, you may have a function that takes an
argument of a pointer to another function. Of course it’s possible that this
other function might be generated from a template function so you need some way
to take that kind of address<a href="#_ftn52" name="_ftnref52" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[52]</span></sup></span></span></sup></span></a>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0617"
title="Add Comment A0617"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:TemplateFunctionAddress.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Taking the address of a function
generated</p>

<p class=CodeChar style='margin-left:0in'>// from a template.</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template &lt;typename T&gt; void
f(T*) {}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void h(void (*pf)(int*)) {}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template &lt;typename T&gt; </p>

<p class=CodeChar style='margin-left:0in'>  void g(void (*pf)(T*)) {}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Full type specification:</p>

<p class=CodeChar style='margin-left:0in'>  h(&amp;f&lt;int&gt;);</p>

<p class=CodeChar style='margin-left:0in'>  // Type deduction:</p>

<p class=CodeChar style='margin-left:0in'>  h(&amp;f);</p>

<p class=CodeChar style='margin-left:0in'>  // Full type specification:</p>

<p class=CodeChar style='margin-left:0in'>  g&lt;int&gt;(&amp;f&lt;int&gt;);</p>

<p class=CodeChar style='margin-left:0in'>  // Type deduction:</p>

<p class=CodeChar style='margin-left:0in'>  g(&amp;f&lt;int&gt;);</p>

<p class=CodeChar style='margin-left:0in'>  // Partial (but sufficient)
specification</p>

<p class=CodeChar style='margin-left:0in'>  g&lt;int&gt;(&amp;f);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example demonstrates a number of different issues.
First, even though you’re using templates, the signatures must match–the
function <b>h(&nbsp;)</b> takes a pointer to a function that takes an <b>int*</b>
and returns <b>void</b>, and that’s what the template <b>f</b> produces.
Second, the function that wants the function pointer as an argument can itself
be a template, as in the case of the template <b>g</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0618"
title="Add Comment A0618"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b> you can see that type deduction works
here, too. The first call to <b>h(&nbsp;)</b> explicitly gives the template
argument for <b>f</b>, but since <b>h(&nbsp;)</b> says that it will only take
the address of a function that takes an <b>int*</b>, that part can be induced
by the compiler. With <b>g(&nbsp;)</b> the situation is even more interesting
because there are two templates involved. The compiler cannot deduce the type
with nothing to go on, but if either <b>f</b> or <b>g</b> is given <b>int</b>,
then the rest can be deduced. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0619"
title="Add Comment A0619"><sup>Comment</sup></a></p>

<p class=MsoNormal>A very obscure issue arises when trying to pass the
functions <b>tolower</b> or <b>toupper</b>, declared in <b>&lt;cctype&gt;</b>
as parameters. It is possible to use these in conjunction with the <b>transform</b>
algorithm (which is covered in detail in the next chapter), for example, to
convert a string to lower or upper case. Care must be taken, however, because
there are multiple declarations for these functions. A naïve approach would be
to do something like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1896"
title="Add Comment A1896"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// The variable <b>s</b> is a
std::string</p>

<p class=CodeInlineCharChar style='margin-left:0in'>transform(s.begin(),
s.end(), s.begin(), tolower);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>transform</b> algorithm applies its fourth parameter
(<b>tolower</b> in this case) to each character in the string <b>s</b>, and
places the result in <b>s</b> itself, thus overwriting each character in <b>s</b>
with its lower-case equivalent. As it is written, this statement may or may not
work! It fails in the following context: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1897"
title="Add Comment A1897"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;LOWER&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  transform(s.begin(),s.end(),s.begin(),tolower);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Even if your compiler let’s you get away with this, it is
illegal. The reason is that the <b>&lt;iostream&gt;</b> header also makes
available a two-argument version of <b>tolower</b> and <b>toupper</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class charT&gt; charT
toupper(charT c,</p>

<p class=CodeChar style='margin-left:0in'>                                    
const locale&amp; loc);</p>

<p class=CodeChar style='margin-left:0in'>template &lt;class charT&gt; charT
tolower(charT c,</p>

<p class=CodeInlineCharChar style='margin-left:0in'>                                    
const locale&amp; loc);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>These function templates take a second argument of type <b>locale</b>.
The compiler has no way of knowing whether it should use the one-argument
version of <b>tolower</b> defined in <b>&lt;cctype&gt;</b>, or the one
mentioned above. You can solve this problem (almost!) with a cast in the call
to <b>transform</b>, as follows: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1898"
title="Add Comment A1898"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'> 
transform(s.begin(),s.end(),s.begin()</p>

<p class=CodeInlineCharChar style='margin-left:0in'>           
static_cast&lt;int (*)(int)&gt;(tolower));</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>(For historical reasons, <b>tolower</b> and <b>toupper</b>
traffic in <b>int</b> instead of <b>char</b>.) The cast above makes clear that
the single-argument version of <b>tolower</b> is desired. Once again, this
works with some compilers, but it is not required to. The reason, albeit
obscure, is that a library implementation is allowed to give “C linkage” (meaning
that the function name is not mangled like normal C++ functions are) to
functions inherited from the C language. If this is the case, the cast fails,
because <b>transform</b> is a C++ function template and expects its fourth
argument to have C++ linkage—and a cast is not allowed to change the linkage.
What a predicament! <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1899"
title="Add Comment A1899"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution is to place calls <b>tolower</b> in a context
where there is no ambiguity. For example, you could write a function, let’s
call it <b>strTolower(&nbsp;)</b>, and place it in its own file without
including <b>&lt;iostream&gt;</b>, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1900"
title="Add Comment A1900"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:StrTolower.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string strTolower(string s) {</p>

<p class=CodeChar style='margin-left:0in'>  transform(s.begin(), s.end(),
s.begin(), tolower);</p>

<p class=CodeChar style='margin-left:0in'>  return s;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>&lt;iostream&gt;</b> is not involved here, the two-argument
version of <b>tolower</b> is not even considered, so there’s no problem. You
can then use this function normally: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1901"
title="Add Comment A1901"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Tolower.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} StrTolower</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>string strTolower(string);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;LOWER&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; strTolower(s)
&lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Another solution is to write a wrapper function template
that calls the correct version of <b>tolower</b> explicitly:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:ToLower2.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT&gt;</p>

<p class=CodeChar style='margin-left:0in'>charT strTolower(charT c) {</p>

<p class=CodeChar style='margin-left:0in'>  return tolower(c);  // one-arg
version called</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;LOWER&quot;);</p>

<p class=CodeChar style='margin-left:0in'> 
transform(s.begin(),s.end(),s.begin(),&amp;strTolower&lt;char&gt;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This version has the advantage that it can process both wide
and narrow strings since the underlying character type is a template parameter.
The C++ standards committee is working on modifying the language so that the
first example (without the cast) will work, so someday these workarounds can be
ignored<a href="#_ftn53" name="_ftnref53" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[53]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1902"
title="Add Comment A1902"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440055"></a><a name="_Toc312374091">Applying a function to a</a>n
STL sequence</h3>

<p class=MsoNormal>Suppose you want to take an STL sequence container (which
you’ll learn more about in subsequent chapters; for now we can just use the
familiar <b>vector</b>) and apply a function to all the objects it contains.
Because a <b>vector</b> can contain any type of object, you need a function
that works with any type of <b>vector</b>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0620"
title="Add Comment A0620"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:ApplySequence.h</p>

<p class=CodeChar style='margin-left:0in'>// Apply a function to an STL
sequence container</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// 0 arguments, any type of return
value:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Seq, class T, class
R&gt;</p>

<p class=CodeChar style='margin-left:0in'>void apply(Seq&amp; sq, R (T::*f)())
{</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq::iterator it =
sq.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(it != sq.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    ((*it)-&gt;*f)();</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// 1 argument, any type of return
value:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Seq, class T, class
R, class A&gt;</p>

<p class=CodeChar style='margin-left:0in'>void apply(Seq&amp; sq, R(T::*f)(A),
A a) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq::iterator it =
sq.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(it != sq.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    ((*it)-&gt;*f)(a);</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// 2 arguments, any type of return
value:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Seq, class T, class
R, </p>

<p class=CodeChar style='margin-left:0in'>         class A1, class A2&gt;</p>

<p class=CodeChar style='margin-left:0in'>void apply(Seq&amp; sq, R(T::*f)(A1,
A2),</p>

<p class=CodeChar style='margin-left:0in'>    A1 a1, A2 a2) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq::iterator it =
sq.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(it != sq.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    ((*it)-&gt;*f)(a1, a2);</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>// Etc., to handle maximum
likely arguments ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>apply(&nbsp;) </b>function template takes a reference
to the container class and a pointer-to-member for a member function of the
objects contained in the class. It uses an iterator to move through the <b>Stack</b>
and apply the function to every object. <sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0621"
title="Add Comment A0621"><sup>Comment</sup></a></p>

<p class=MsoNormal>Notice that there are no STL header files (or any header
files, for that matter) included in <b>applySequence.h</b>, so it is actually
not limited to use with an STL sequence. However, it does make assumptions
(primarily, the name and behavior of the <b>iterator</b>) that apply to STL
sequences. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0622"
title="Add Comment A0622"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can see there is more than one version of <b>apply(&nbsp;)</b>,
further illustrating overloading of function templates. Although these
templates allow any type of return value (which is ignored, but the type
information is required to match the pointer-to-member), each version takes a
different number of arguments, and because it’s a template, those arguments can
be of any type. The only limitation here is that there’s no “super template” to
create templates for you; thus you must decide how many arguments will ever be
required. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0623"
title="Add Comment A0623"><sup>Comment</sup></a></p>

<p class=MsoNormal>To test the various overloaded versions of <b>apply(&nbsp;)</b>,
the class <b>Gromit</b><a href="#_ftn54" name="_ftnref54" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[54]</span></sup></span></span></sup></span></a> is
created containing functions with different numbers of arguments: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0624"
title="Add Comment A0624"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Gromit.h</p>

<p class=CodeChar style='margin-left:0in'>// The techno-dog. Has member
functions </p>

<p class=CodeChar style='margin-left:0in'>// with various numbers of arguments.</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Gromit { </p>

<p class=CodeChar style='margin-left:0in'>  int arf;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Gromit(int arf = 1) : arf(arf + 1)
{}</p>

<p class=CodeChar style='margin-left:0in'>  void speak(int) {</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; arf; i++)</p>

<p class=CodeChar style='margin-left:0in'>      std::cout &lt;&lt; &quot;arf!
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  char eat(float) {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt;
&quot;chomp!&quot; &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>    return 'z';</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int sleep(char, double) {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt;
&quot;zzz...&quot; &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>    return 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void sit() {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;
Sitting...)&quot; &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}; ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now the <b>apply(&nbsp;)</b> template functions can be
combined with a <b>vector&lt;Gromit*&gt;</b> to make a container that will call
member functions of the contained objects, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0625"
title="Add Comment A0625"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:ApplyGromit.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test ApplySequence.h</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;applySequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Gromit.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Gromit*&gt; dogs;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; 5; i++)</p>

<p class=CodeChar style='margin-left:0in'>    dogs.push_back(new Gromit(i));</p>

<p class=CodeChar style='margin-left:0in'>  apply(dogs, &amp;Gromit::speak, 1);</p>

<p class=CodeChar style='margin-left:0in'>  apply(dogs, &amp;Gromit::eat,
2.0f);</p>

<p class=CodeChar style='margin-left:0in'>  apply(dogs, &amp;Gromit::sleep,
'z', 3.0);</p>

<p class=CodeChar style='margin-left:0in'>  apply(dogs, &amp;Gromit::sit);</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
dogs.size(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>    delete dogs[i];</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Although the definition of <b>apply(&nbsp;)</b> is somewhat
complex and not something you’d ever expect a novice to understand, its use is
remarkably clean and simple, and a novice could easily use it knowing only<i>
what</i> it is intended to accomplish, not <i>how</i>. This is the type of
division you should strive for in all of your program components: The tough
details are all isolated on the designer’s side of the wall, and users are
concerned only with accomplishing their goals, and don’t see, know about, or
depend on details of the underlying implementation. We’ll explore even more
flexible ways of applying functions to sequences in the next chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0626"
title="Add Comment A0626"><sup>Comment</sup></a></p>

<h3><a name="_Toc312374092"></a><a name="_Toc45440056">Partial ordering of
function templates</a></h3>

<p class=MsoNormal>We mentioned earlier that an ordinary function overload of <b>min(&nbsp;)</b>
was preferable to using the template. This makes sense, because if a function
already exists to match a function call, why generate another? In the absence
of ordinary functions, however, it is possible that overloaded function
templates can lead to ambiguities. To minimize the chances of this, there is an
ordering defined for function templates, which chooses the <i>most specialized</i>
template, if such exists. A function template is considered more specialized
than another if every possible list of arguments that matches it also matches
the other, but not the other way around. Consider the following function
template declarations, taken from the C++ standard document: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1903"
title="Add Comment A1903"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; void f(T);</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; void f(T*);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>template&lt;class T&gt;
void f(const T*);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The second template is more specialized than the first
because only pointer types match it. In other words, you can look upon the set
of possible calls that match the second template to be a subset of the first. A
similar relationship exists between the second and third template declarations
above: the third can only be called for pointers to <b>const</b>, but the
second accommodates any pointer type. The following program illustrates these
rules. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1904"
title="Add Comment A1904"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:PartialOrder.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Reveals Ordering of Function
Templates</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void f(T) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;T\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void f(T*) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;T*\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void f(const T*) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;const
T*\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  f(0);            // T</p>

<p class=CodeChar style='margin-left:0in'>  int i = 0;</p>

<p class=CodeChar style='margin-left:0in'>  f(&amp;i);           // T*</p>

<p class=CodeChar style='margin-left:0in'>  const int j = 0;</p>

<p class=CodeChar style='margin-left:0in'>  f(&amp;j);           // const T*</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The call <b>f(&amp;i)</b> certainly matches the first
template, but since the second is more specialized, it is called. The third
can’t be called in this case since the pointer is not a pointer to <b>const</b>.
The call <b>f(&amp;j)</b> matches all three templates (e.g., <b>T</b> would be <b>const
int</b> in the second template), but again, the third template is more
specialized, so it is used instead. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1905"
title="Add Comment A1905"><sup>Comment</sup></a></p>

<p class=MsoNormal>If there is no “most specialized” template among a set of
overloaded function templates, an ambiguity remains and the compiler will
report an error. That is why this feature is called a “partial
ordering”—because it may not be able to resolve all possibilities. Similar
rules exist for class templates (see the section “Partial specialization”
below). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1906"
title="Add Comment A1906"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440057">Template specialization</a></h2>

<p class=MsoNormal>The term <i>specialization</i> has a specific,
template-related meaning in C++. A template definition is, by its very nature,
a <i>generalization</i>, because it describes a family of functions or classes
in general terms. When template arguments are supplied, the result is therefore
a specialization of the template, because it fixes a unique instance out of the
many possible instances of the family of functions or classes. The <b>min</b>
function template seen at the beginning of this chapter is a generalization of
a minimum-finding function, because the type of its parameters is left
unspecified. When you supply the type for the template parameter, whether
explicitly or implicitly via argument deduction, the resultant code generated
by the compiler (i.e., <b>min&lt;int&gt;</b>) is a specialization of the
template. The code generated is also considered an <i>instantiation</i> of the
template, of course, as are all code bodies generated by the template facility.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1907"
title="Add Comment A1907"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440058">Explicit specialization</a></h3>

<p class=MsoNormal>You can also provide the code yourself for a given template
specialization, should the need arise. Providing your own template
specializations is usually only needed with class templates, but we will begin
with the <b>min</b> function template to introduce the syntax. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1908"
title="Add Comment A1908"><sup>Comment</sup></a></p>

<p class=MsoNormal>Recall that in <b>MinTest.cpp</b> earlier in this chapter we
introduced the following ordinary function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>const char* min(const char* a, const
char* b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (strcmp(a, b) &lt; 0) ? a :
b;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This was so that a call to <b>min</b> would compare strings
and not addresses. Although it would provide no advantage in this case, we
could define instead a <b>const char*</b> specialization for <b>min</b>, as in
the following program: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1909"
title="Add Comment A1909"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:MinTest2.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::strcmp;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>using std::endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; const T&amp;
min(const T&amp; a, const T&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (a &lt; b) ? a : b;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>// An explicit specialization of the
min template</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>const char* const&amp; min&lt;const
char*&gt;(const char* const&amp; a, </p>

<p class=CodeChar style='margin-left:0in'>                                   
const char* const&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return (strcmp(a, b) &lt; 0) ? a :
b;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const char *s2 = &quot;say
\&quot;Ni-!\&quot;&quot;, *s1 = &quot;knights who&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min(s1, s2) &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; min&lt;&gt;(s1, s2)
&lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The “<b>template&lt;&gt;</b>” prefix tells the compiler that
what follows is a specialization of a template. The type for the specialization
must appear in angle brackets appended to the function name, as it normally
would in an explicitly-specified call. Note that we <i>carefully</i> substitute
<b>const char*</b> for <b>T</b> in the explicit specialization. Whenever the
original template specifies <b>const T</b>, that <b>const</b> modifies the <i>whole</i>
type <b>T</b>, so it is the pointer to a <b>const char*</b> that is <b>const</b>,
therefore we must write <b>const char* const</b> in place of <b>const T</b> in
the specialization. When the compiler sees a call to <b>min</b> with <b>const</b>
<b>char*</b> arguments in the program, it will cause our <b>const char*</b>
version of <b>min</b> to be instantiated in place of what the primary template
would have generated. The two calls to <b>min</b> in this program are
identical, since there is no ordinary function to be considered. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1910"
title="Add Comment A1910"><sup>Comment</sup></a></p>

<p class=MsoNormal>Explicit specializations tend to be more useful for class
templates than for function templates. When you provide a full specialization
for a class template, though, you must remember to implement all of the member
functions. This is because you are providing a separate class, and its
definition must be complete. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1911"
title="Add Comment A1911"><sup>Comment</sup></a></p>

<p class=MsoNormal>The standard library has an explicit specialization for <b>vector</b>
when it is used to hold object of type <b>bool</b>. As you saw earlier in this
chapter, the declaration for the primary <b>vector</b> class template is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class T, class Allocator
= allocator&lt;T&gt; &gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>class vector {…};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>To specialize for objects of type <b>bool</b>, you could
declare an explicit specialization as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class vector&lt; bool,
allocator&lt;bool&gt; &gt; {…};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Again, this is quickly recognized as a full, explicit
specialization because of the <b>template&lt;&gt;</b> prefix, and because all
of the primary template’s parameters are satisfied by the argument list
appended to the class name. The purpose for <b>vector&lt;bool&gt;</b> is to
allow library implementations to save space by packing bits into integers<a
href="#_ftn55" name="_ftnref55" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[55]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1914"
title="Add Comment A1914"><sup>Comment</sup></a></p>

<p class=MsoNormal>It turns out that <b>vector&lt;bool&gt;</b> is a little more
flexible than we have described, as seen in the next section.</p>

<h3><a name="_Toc45440059">Partial Specialization</a></h3>

<p class=MsoNormal>Class templates can also be partially specialized, meaning
that at least one of the template parameters is left “open” in some way in the
specialization. This is actually what <b>vector&lt;bool&gt;</b> does; it
specifies the object type (<b>bool</b>), but leaves the allocator type
unspecified. Here is the actual declaration of <b>vector&lt;bool&gt;</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class Allocator&gt;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>class vector&lt;bool,
Allocator&gt;;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can recognize a partial specialization because non-empty
parameter lists appear in angle brackets both after the template keyword (the
unspecified parameters) and also after the class (the specified arguments).
Because of the way <b>vector&lt;bool&gt;</b> is defined, a user can provide a
custom allocator type, even though the contained type of <b>bool</b> is fixed.
In other words, specialization, and partial specialization in particular,
constitutes a sort of “overloading” for class templates. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1913"
title="Add Comment A1913"><sup>Comment</sup></a></p>

<h4>Partial ordering of class templates</h4>

<p class=MsoNormal>You can also partially specify template parameters according
to whether they are pointer types or not, or whether they are equal or not. The
rules that determine which template is selected for instantiation are similar
to the partial ordering for function templates—the “most specialized” template
is selected. An illustration follows. (The string in each <b>f(&nbsp;)</b>
member function below explains the role of each template definition.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1916"
title="Add Comment A1916"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:PartialOrder2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Reveals partial ordering of class
templates</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class U&gt;
class C {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Primary
Template\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class U&gt; class
C&lt;int, U&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;T ==
int\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; class C&lt;T,
double&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;U ==
double\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class U&gt;
class C&lt;T*, U&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;T* used \n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class U&gt;
class C&lt;T, U*&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;U*
used\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class U&gt;
class C&lt;T*, U*&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;T* and U*
used\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; class C&lt;T,
T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;T ==
U\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float, int&gt;().f();    // 1:
Primary template</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;int, float&gt;().f();    // 2:
T == int</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float, double&gt;().f(); // 3:
U == double</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float, float&gt;().f();  // 4:
T == U</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float*, float&gt;().f(); // 5:
T* used [T is float]</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float, float*&gt;().f(); // 6:
U* used [U is float]</p>

<p class=CodeChar style='margin-left:0in'>  C&lt;float*, int*&gt;().f();  // 7:
T* and U* used [float,int]</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // The following are ambiguous:</p>

<p class=CodeChar style='margin-left:0in'>//   8: C&lt;int, int&gt;().f();</p>

<p class=CodeChar style='margin-left:0in'>//   9: C&lt;double,
double&gt;().f();</p>

<p class=CodeChar style='margin-left:0in'>//  10: C&lt;float*, float*&gt;().f();</p>

<p class=CodeChar style='margin-left:0in'>//  11: C&lt;int, int*&gt;().f();</p>

<p class=CodeChar style='margin-left:0in'>//  12: C&lt;int*, int*&gt;().f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It’s important to note that when the <b>T*</b>
specialization is used, such as is the case in line 5, <b>T</b> itself is not
the top-level pointer type that was passed—it is the type that the pointer
refers to (<b>float</b> here). The <b>T*</b> specification is merely a pattern
to allow matching against pointer types. If you were to use <b>int**</b> as the
first template argument, then <b>T</b> would be <b>int*</b>. Line 8 is
ambiguous because having the first parameter as an <b>int</b> vs. to having the
two parameters equal are independent issues—one is not more specialized than
the other. Similar logic applies to lines 9 through 12. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1915"
title="Add Comment A1915"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440060">A practical example</a></h3>

<p class=MsoNormal>There’s nothing to prevent you from using an instantiation
of a class template in any way you’d use an ordinary class. For example, you
can easily derive from a class template, and you can create a new template that
instantiates and inherits from an existing template. If the <b>vector </b>template
does everything you want, but you’d also like it to sort itself, you can easily
reuse the code and add value to it. The following example derives from <b>vector&lt;T&gt;</b>
and adds sorting. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0634"
title="Add Comment A0634"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Sorted.h</p>

<p class=CodeChar style='margin-left:0in'>// Template specialization</p>

<p class=CodeChar style='margin-left:0in'>#ifndef SORTED_H</p>

<p class=CodeChar style='margin-left:0in'>#define SORTED_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Sorted : public
std::vector&lt;T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void sort();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void Sorted&lt;T&gt;::sort() { // A
simple sort</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = size(); i &gt; 0; i--)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 1; j &lt; i; j++)</p>

<p class=CodeChar style='margin-left:0in'>      if(at(j-1) &gt; at(j)) {</p>

<p class=CodeChar style='margin-left:0in'>        T t = at(j-1);</p>

<p class=CodeChar style='margin-left:0in'>        at(j-1) = at(j);</p>

<p class=CodeChar style='margin-left:0in'>        at(j) = t;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Partial
specialization for pointers:</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;class
T&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>class
Sorted&lt;T*&gt; : public std::vector&lt;T*&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void sort();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void Sorted&lt;T*&gt;::sort() {</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = size(); i &gt; 0; i--)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 1; j &lt; i; j++)</p>

<p class=CodeChar style='margin-left:0in'>      if(*at(j-1) &gt; *at(j)) {</p>

<p class=CodeChar style='margin-left:0in'>        T* t = at(j-1);</p>

<p class=CodeChar style='margin-left:0in'>        at(j-1) = at(j);</p>

<p class=CodeChar style='margin-left:0in'>        at(j) = t;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Full specialization for char*:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>void Sorted&lt;char*&gt;::sort() {</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = size(); i &gt; 0; i--)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 1; j &lt; i; j++)</p>

<p class=CodeChar style='margin-left:0in'>      if(std::strcmp(at(j-1), at(j))
&gt; 0) {</p>

<p class=CodeChar style='margin-left:0in'>        char* t = at(j-1);</p>

<p class=CodeChar style='margin-left:0in'>        at(j-1) = at(j);</p>

<p class=CodeChar style='margin-left:0in'>        at(j) = t;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // SORTED_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Sorted</b> template imposes a restriction on all but
one of the classes it is instantiated for: They must contain a <b>&gt;</b>
operator. It only works correctly with non-pointer objects (including objects
of built-in types). Since it won’t sort pointers to objects correctly, the
partial specialization is necessary. Even then, the code generated by the
partial specialization won’t properly sort an array of <b>char*</b>. To solve
this, the full specialization compares the <b>char*</b> elements using <b>strcmp(&nbsp;)</b>
to produce the proper behavior. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0636"
title="Add Comment A0636"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here’s a test for <b>Sorted.h</b> that uses the unique
random number generator introduced earlier in the chapter: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0637"
title="Add Comment A0637"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Sorted.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Testing template specialization</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Sorted.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Urand.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#define asz(a) (sizeof a / sizeof
a[0])</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>char* words[] = {</p>

<p class=CodeChar style='margin-left:0in'>  &quot;is&quot;,
&quot;running&quot;, &quot;big&quot;, &quot;dog&quot;, &quot;a&quot;,</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>char* words2[] = {</p>

<p class=CodeChar style='margin-left:0in'>  &quot;this&quot;, &quot;that&quot;,
&quot;theother&quot;,</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Sorted&lt;int&gt; is;</p>

<p class=CodeChar style='margin-left:0in'>  Urand&lt;47&gt; rand;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; 15; i++)</p>

<p class=CodeChar style='margin-left:0in'>    is.push_back(rand());</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t l = 0; l &lt; is.size();
l++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; is[l] &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  is.sort();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t l = 0; l &lt; is.size();
l++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; is[l] &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // Uses the template partial
specialization:</p>

<p class=CodeChar style='margin-left:0in'>  Sorted&lt;string*&gt; ss;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
asz(words); i++)</p>

<p class=CodeChar style='margin-left:0in'>    ss.push_back(new string(words[i]));</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; ss.size();
i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *ss[i] &lt;&lt; '
';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  ss.sort();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; ss.size();
i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *ss[i] &lt;&lt; '
';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  </p>

<p class=CodeChar style='margin-left:0in'>  // Uses the full char*
specialization:</p>

<p class=CodeChar style='margin-left:0in'>  Sorted&lt;char*&gt; scp;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
asz(words2); i++)</p>

<p class=CodeChar style='margin-left:0in'>    scp.push_back(words2[i]);</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
scp.size(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; scp[i] &lt;&lt; '
';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  scp.sort();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
scp.size(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; scp[i] &lt;&lt; '
';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each of the template instantiations above uses a different
version of the template. <b>Sorted&lt;int&gt;</b> uses the primary template. <b>Sorted&lt;string*&gt;</b>
uses the partial specialization for pointers. Lastly, <b>Sorted&lt;char*&gt;</b>
uses the full specialization for <b>char*</b>. Note that without this full
specialization, you could be fooled into thinking that things were working
correctly because the <b>words</b> array would still sort out to “a big dog is
running” since the partial specialization would end up comparing the first character
of each array. However, <b>words2</b> would not sort correctly. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0638"
title="Add Comment A0638"><sup>Comment</sup></a></p>

<h4><a name="_Toc312374085">Design &amp; efficiency</a></h4>

<p class=MsoNormal>In <b>Sorted</b>, every time you call <b>add(&nbsp;)</b> the
element is inserted and the array is resorted. Here, the horribly inefficient
(but easy to understand and code) selection sort is used. This is perfectly appropriate, because it’s part of the <b>private</b> implementation. During
program development, your priorities are to <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0639"
title="Add Comment A0639"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Get the class interfaces correct.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create an accurate implementation as rapidly as possible so you
can:</p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Prove your design.</p>

<p class=MsoNormal>Very often, you will discover problems with the class
interface only when you assemble your initial “rough draft” of the working
system. You may also discover the need for “helper” classes like containers and
iterators during system assembly and during your first-pass implementation.
Sometimes it’s very difficult to discover these kinds of issues during analysis
– your goal in analysis should be to get a big-picture design that can be rapidly
implemented and tested. Only after the design has been proven should you spend
the time to flesh it out completely and worry about performance issues. If the
design fails, or if performance is not a problem, the simple sort algorithm is
good enough, and you haven’t wasted any time. (Of course, the ideal solution is
to use someone else’s sorted container; the Standard C++ template library is
the first place to look.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0640"
title="Add Comment A0640"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440061"></a><a name="_Toc312374086">Preventing template code
bloat</a></h3>

<p class=MsoNormal>Whenever a class template is instantiated, the code from the
class definition for the particular specialization is generated, along with all
of the member functions that are called in the program. Only the member
functions that are actually called are generated. This is a good thing, as the
following program makes clear: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1924"
title="Add Comment A1924"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:DelayedInstantiation.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Member functions of class
templates are not</p>

<p class=CodeChar style='margin-left:0in'>// instantiated until they're needed.</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class X {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void f() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Y {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void g() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template &lt;typename T&gt; class Z {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void a() { t.f(); }</p>

<p class=CodeChar style='margin-left:0in'>  void b() { t.g(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Z&lt;X&gt; zx;</p>

<p class=CodeChar style='margin-left:0in'>  zx.a(); // Doesn't create
Z&lt;X&gt;::b()</p>

<p class=CodeChar style='margin-left:0in'>  Z&lt;Y&gt; zy;</p>

<p class=CodeChar style='margin-left:0in'>  zy.b(); // Doesn't create
Z&lt;Y&gt;::a()</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here, even though the template <b>Z</b> purports to use both
<b>f(&nbsp;)</b> and <b>g(&nbsp;)</b> member functions of <b>T</b>, the fact
that the program compiles shows you that it only generates <b>Z&lt;X&gt;::a(&nbsp;)</b>
when it is explicitly called for <b>zx</b> (if <b>Z&lt;X&gt;::b(&nbsp;)</b>
were also generated at the same time, a compile-time error message would be
generated, because it would attempt to call <b>X::g(&nbsp;)</b>, which doesn’t
exist). Similarly, the call to <b>zy.b(&nbsp;)</b> doesn’t generate <b>Z&lt;Y&gt;::a(&nbsp;)</b>.
As a result, the <b>Z</b> template can be used with <b>X</b> and <b>Y</b>,
whereas if all the member functions were generated when the class was first
created it would significantly limit the use of many templates. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0647"
title="Add Comment A0647"><sup>Comment</sup></a></p>

<p class=MsoNormal>To motivate another way to save generated code, suppose you
have a container, a <b>Stack</b> say, and you use specializations for <b>int</b>,
<b>int*</b>, and <b>char*</b>. Then there will be three versions of the <b>Stack</b>
code generated and linked as part of your program. One of the reasons for using
a template in the first place is so you don’t have to replicate code by hand;
but code still gets replicated—it’s just the compiler that does it instead of
you. There is a way to factor the bulk of the implementation for storing
pointer types into a single class by using a combination of full and partial
specialization. The key is to fully specialize for <b>void*</b>, and then have
all other pointer types derive from the <b>void*</b> implementation so the
common code can be shared. The program below illustrates this technique. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1919"
title="Add Comment A1919"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Nobloat.h</p>

<p class=CodeChar style='margin-left:0in'>// Shares code for storing pointers
in a Stack</p>

<p class=CodeChar style='margin-left:0in'>#ifndef NOBLOAT_H</p>

<p class=CodeChar style='margin-left:0in'>#define NOBLOAT_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The primary template</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Stack {</p>

<p class=CodeChar style='margin-left:0in'>  T* data;</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t count;</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t capacity;</p>

<p class=CodeChar style='margin-left:0in'>  enum {INIT = 5};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Stack() {</p>

<p class=CodeChar style='margin-left:0in'>    count = 0;</p>

<p class=CodeChar style='margin-left:0in'>    capacity = INIT;</p>

<p class=CodeChar style='margin-left:0in'>    data = new T[INIT];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    if (count == capacity) {</p>

<p class=CodeChar style='margin-left:0in'>      // Grow array store</p>

<p class=CodeChar style='margin-left:0in'>      std::size_t newCapacity =
2*capacity;</p>

<p class=CodeChar style='margin-left:0in'>      T* newData = new
T[newCapacity];</p>

<p class=CodeChar style='margin-left:0in'>      for (size_t i = 0; i &lt;
count; ++i)</p>

<p class=CodeChar style='margin-left:0in'>        <span lang=IT>newData[i] =
data[i];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      delete [] data;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      </span>data =
newData;</p>

<p class=CodeChar style='margin-left:0in'>      capacity = newCapacity;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &lt; capacity);</p>

<p class=CodeChar style='margin-left:0in'>    data[count++] = t;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &gt; 0);</p>

<p class=CodeChar style='margin-left:0in'>    --count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  T top() const {</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &gt; 0);</p>

<p class=CodeChar style='margin-left:0in'>    return data[count-1];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  size_t size() const {return count;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Full specialization for void*</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Stack&lt;void *&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  void** data;</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t count;</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t capacity;</p>

<p class=CodeChar style='margin-left:0in'>  enum {INIT = 5};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Stack() {</p>

<p class=CodeChar style='margin-left:0in'>    count = 0;</p>

<p class=CodeChar style='margin-left:0in'>    capacity = INIT;</p>

<p class=CodeChar style='margin-left:0in'>    data = new void*[INIT];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void push(void* const &amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    if (count == capacity) {</p>

<p class=CodeChar style='margin-left:0in'>      std::size_t newCapacity =
2*capacity;</p>

<p class=CodeChar style='margin-left:0in'>      void** newData = new
void*[newCapacity];</p>

<p class=CodeChar style='margin-left:0in'>      std::memcpy(newData, data,
count*sizeof(void*));</p>

<p class=CodeChar style='margin-left:0in'>      <span lang=IT>delete [] data;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      data = newData;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>      capacity =
newCapacity;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>    </span>}</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &lt; capacity);</p>

<p class=CodeChar style='margin-left:0in'>    data[count++] = t;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &gt; 0);</p>

<p class=CodeChar style='margin-left:0in'>    --count;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void* top() const {</p>

<p class=CodeChar style='margin-left:0in'>    assert(count &gt; 0);</p>

<p class=CodeChar style='margin-left:0in'>    return data[count-1];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t size() const {return
count;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Partial
specialization for other pointer types</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;class
T&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>class
Stack&lt;T*&gt; : private Stack&lt;void *&gt; {</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  typedef
Stack&lt;void *&gt; Base;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void push(T* const &amp; t)
{Base::push(t);}</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {Base::pop();}</p>

<p class=CodeChar style='margin-left:0in'>  T* top() const {return
static_cast&lt;T*&gt;(Base::top());}</p>

<p class=CodeChar style='margin-left:0in'>  std::size_t size() {return
Base::size();}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // NOBLOAT_H ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1920"
title="Add Comment A1920"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This simple stack expands as it fills its capacity. The <b>void*</b>
specialization stands out as a full specialization by virtue of the <b>template&lt;&gt;</b>
prefix (i.e., the template parameter list is empty). As mentioned earlier, it
is necessary to implement all member functions in a class template
specialization. The savings occurs with all other pointer types. The partial
specialization for other pointer types derives from <b>Stack&lt;void*&gt;</b>
privately, since we are merely using <b>Stack&lt;void*&gt;</b> for
implementation purposes, and do not wish to expose any of its interface
directly to the user. The member functions for each pointer instantiation are
small forwarding functions to the corresponding functions in <b>Stack&lt;void*&gt;</b>.
Hence, whenever a pointer type other than <b>void*</b> is instantiated, it is a
fraction of the size it would have been had the primary template alone been
used. Here is a test program: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1918"
title="Add Comment A1918"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:NobloatTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Nobloat.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class StackType&gt;</p>

<p class=CodeChar style='margin-left:0in'>void emptyStack(StackType&amp; stk) {</p>

<p class=CodeChar style='margin-left:0in'>  while (stk.size() &gt; 0) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; stk.top() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    stk.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>// An overload for emptyStack (not a
specialization!)</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void emptyStack(Stack&lt;T*&gt;&amp;
stk) {</p>

<p class=CodeChar style='margin-left:0in'>  while (stk.size() &gt; 0) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *stk.top() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    stk.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Stack&lt;int&gt; s1;</p>

<p class=CodeChar style='margin-left:0in'>  s1.push(1);</p>

<p class=CodeChar style='margin-left:0in'>  s1.push(2);</p>

<p class=CodeChar style='margin-left:0in'>  emptyStack(s1);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  Stack&lt;int *&gt; s2;</p>

<p class=CodeChar style='margin-left:0in'>  int i = 3;</p>

<p class=CodeChar style='margin-left:0in'>  int j = 4;</p>

<p class=CodeChar style='margin-left:0in'>  s2.push(&amp;i);</p>

<p class=CodeChar style='margin-left:0in'>  s2.push(&amp;j);</p>

<p class=CodeChar style='margin-left:0in'>  emptyStack(s2);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>For convenience we have included two <b>emptyStack</b>
function templates. Since function templates don’t support partial
specialization, we provide overloaded templates. The second version of <b>emptyStack</b>
is more specialized than the first, so it is chosen whenever pointer types are
used. There are three class templates instantiated in this program: <b>Stack&lt;int&gt;</b>,
<b>Stack&lt;void*&gt;</b>, and <b>Stack&lt;int*&gt;</b>. <b>Stack&lt;void*&gt;</b>
is implicitly instantiated because <b>Stack&lt;int*&gt;</b> derives from it. If
a program uses instantiations for many pointer types, the savings in code size
over just using a single <b>Stack</b> template can be substantial. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1917"
title="Add Comment A1917"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440062">Name lookup issues</a></h2>

<p class=MsoNormal>When the compiler encounters an identifier it must determine
the type and scope (and in the case of variables, the lifetime) of the entity
the identifier represents. This is common knowledge among software developers,
but the plot thickens when templates are involved. Because not everything is
known about a template when its definition is first seen by the compiler, the
compiler must hold off until the template is instantiated before it can
determine whether it is being used properly. This predicament leads to a
two-phase process for template compilation. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1925"
title="Add Comment A1925"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440063">Names in templates</a></h3>

<p class=MsoNormal>In the first phase the compiler parses the template
definition looking for obvious syntax errors and resolving all the names it
can. The names it can resolve during parsing are those which do not depend on
template parameters, which the compiler takes care of through normal name
lookup means (and also through argument-dependent lookup, discussed below, if
necessary). The names it can’t resolve are the so-called <i>dependent names</i>,
which are names that in some way depend on template parameters. These can’t be
resolved until the template is instantiated with its actual arguments.
Instantiation, therefore, is the second phase of template compilation. During
this second phase, the compiler determines whether an explicit specialization
of the template in question needs to be used instead of the primary template. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1926"
title="Add Comment A1926"><sup>Comment</sup></a></p>

<p class=MsoNormal>Before you see an example, there are two more terms that
need to be defined. A <i>qualified name</i> is a name that appears with a class
name used in conjunction with the scope resolution operator (<b>::</b>), or an
object name or pointer that appears with the dot or arrow operators,
respectively. Examples of qualified names are found in the following
expressions: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1927"
title="Add Comment A1927"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>MyClass::s();</p>

<p class=CodeChar style='margin-left:0in'>x.f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>p-&gt;f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We have used qualified names many times in this book, and
most recently in connection with the <b>typename</b> disambiguation keyword.
These are called qualified names because the target names (e.g., <b>s</b> and <b>f</b>
above) are explicitly associated with a class, which tells the compiler where
to look for the declarations of those names. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1928"
title="Add Comment A1928"><sup>Comment</sup></a></p>

<p class=MsoNormal>The other term to discuss is <b>argument-dependent lookup</b><a
href="#_ftn56" name="_ftnref56" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[56]</span></sup></span></span></sup></span></a> (ADL), which is a
technique originally designed to simplify using non-member function calls
(including operators) declared in namespaces. Consider the following simple
code excerpt: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1929"
title="Add Comment A1929"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>//…</p>

<p class=CodeChar style='margin-left:0in'>  std::string s(&quot;hello&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  std::cout &lt;&lt; s
&lt;&lt; std::endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note that there is no <b>using namespace std;</b> directive,
which is the typical practice inside header files, for example. Without such a
directive, it is necessary to use the <b>std::</b> qualifier on the items that
are in the <b>std</b> namespace. We have, however, not qualified everything
from <b>std</b> that we are using. Can you see what we have left unqualified? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1930"
title="Add Comment A1930"><sup>Comment</sup></a></p>

<p class=MsoNormal>We have not specified which operator functions to use. What
we want to have happen is the following, but we don’t want to have to type it!</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout,s),std::endl);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In order to make the original output statement work as
desired, ADL specifies that when an unqualified function call appears and its
declaration is not in (normal) scope, the namespaces (or class scopes) of each
of its arguments are searched for a matching function declaration. In the original
statement, the first function call is: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1931"
title="Add Comment A1931"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>operator&lt;&lt;(std::cout,
s);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since there is no such function in scope in our original
excerpt, the compiler notes that this function’s first argument (<b>std::cout</b>)
is in the namespace <b>std</b>, so it adds that namespace to the list of scopes
to search for a unique function that best matches the signature <b>operator&lt;&lt;(std::ostream&amp;,
std::string)</b>. It finds this function declared in the <b>std</b> namespace
via the <b>&lt;string&gt;</b> header, so that is the function that is called.
Namespaces would be very inconvenient without ADL. (But note that, in general,
ADL brings in <i>all</i> declarations of the name in question from all eligible
namespaces—if there is no best match, an ambiguity will result). To turn off
ADL, you can enclose the function name in parentheses: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1932"
title="Add Comment A1932"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>(f)(x, y);  // ADL
suppressed</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now consider the following program, from a presentation by
Herb Sutter:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Lookup.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Only works on EDG and Metrowerks
(special option)</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f(double) { cout &lt;&lt;
&quot;f(double)\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class X {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void g() { f(1); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f(int) { cout &lt;&lt;
&quot;f(int)\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  X&lt;int&gt;().g();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The only compiler we have that gets this correct right out
of the box is the Edison Design Group front end. (A number of compilers use
this front end, including Comeau C++). The output should be: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1933"
title="Add Comment A1933"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>f(double)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>because <b>f</b> is a non-dependent name that does not
require ADL, and is therefore resolved early, when only <b>f(double)</b> is in
scope. Unfortunately, there is a lot of code in existence that depends on the
non-standard behavior of binding the call to <b>f(1)</b> inside <b>g(&nbsp;)</b>
to the latter <b>f(int)</b>, so compiler writers have been reluctant to make
the change. (Some compilers, like the Metrowerks compiler, have an option to
enable the correct lookup behavior). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1934"
title="Add Comment A1934"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here is a more detailed example, also based on an example
from Herb Sutter:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Lookup2.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>// Microsoft: use option –Za (ANSI
mode)</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>using std::endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void g() { cout &lt;&lt; &quot;global
g()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template &lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Y {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void g() { cout &lt;&lt;
&quot;Y&lt;&quot; &lt;&lt; typeid(T).name()</p>

<p class=CodeChar style='margin-left:0in'>                  &lt;&lt;
&quot;&gt;::g()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void h() { cout &lt;&lt;
&quot;Y&lt;&quot; &lt;&lt; typeid(T).name()</p>

<p class=CodeChar style='margin-left:0in'>                  &lt;&lt;
&quot;&gt;::h()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  typedef int E;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef double E;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void swap(T&amp; t1, T&amp; t2) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;global
swap\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  T temp = t1;</p>

<p class=CodeChar style='margin-left:0in'>  t1 = t2;</p>

<p class=CodeChar style='margin-left:0in'>  t2 = temp;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class X : public Y&lt;T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  E f() {</p>

<p class=CodeChar style='margin-left:0in'>    g();</p>

<p class=CodeChar style='margin-left:0in'>    this-&gt;h();</p>

<p class=CodeChar style='margin-left:0in'>    T t1 = T(), t2 = T(1);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; t1 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    swap(t1, t2);</p>

<p class=CodeChar style='margin-left:0in'>    std::swap(t1, t2);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; typeid(E).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    return E(t2);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  X&lt;int&gt; x;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; x.f() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The output from this program should be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>global g()</p>

<p class=CodeChar style='margin-left:0in'>Y&lt;int&gt;::h()</p>

<p class=CodeChar style='margin-left:0in'>0</p>

<p class=CodeChar style='margin-left:0in'>global swap</p>

<p class=CodeChar style='margin-left:0in'>double</p>

<p class=CodeInlineCharChar style='margin-left:0in'>1</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Looking at the declarations inside of <b>X::f(&nbsp;)</b>,
we observe the following:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
return type of <b>X::f(&nbsp;)</b>, which is <b>E</b>, is not a dependent name,
so it is looked up when the template is parsed, and the <b>typedef</b> naming <b>E</b>
as a <b>double</b> is found. This may seem strange, since with non-template
classes the declaration of <b>E</b> in the base class would be found first, but
“them’s the rules.” (The base class, <b>Y</b>, is a <i>dependent base class</i>,
so it can’t be searched at template definition time). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1935"
title="Add Comment A1935"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
call to <b>g(&nbsp;)</b> is also non-dependent, since there is no mention of <b>T</b>.
If <b>g</b> had parameters which were of class type of defined in another
namespace, then ADL would take over, since there is no <b>g</b> with parameters
in scope, but as it is, this call matches the global declaration of <b>g(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1936"
title="Add Comment A1936"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
call <b>this-&gt;h(&nbsp;)</b> is a qualified name, and the object that
qualifies it (<b>this</b>) refers to the current object, which is of type <b>X</b>,
which in turn depends on the name <b>Y&lt;T&gt;</b> by inheritance. There is no
function <b>h(&nbsp;)</b> inside of <b>X</b>, so lookup will naturally want to
search the scope of <b>X</b>’s base class, <b>Y&lt;T&gt;</b>. Since this is a
dependent name, it is looked up at instantiation time, when <b>Y&lt;T&gt;</b>
can be reliably known (including any potential specializations that might have
been written after the definition of <b>X</b>), so it calls <b>Y&lt;int&gt;::h(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1937"
title="Add Comment A1937"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
declarations of <b>t1</b> and <b>t2</b> are dependent, of course. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1938"
title="Add Comment A1938"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
call to <b>operator&lt;&lt;(cout, t1)</b> is dependent, since <b>t1</b> is of
type <b>T</b>. This is looked up later when <b>T</b> is <b>int</b>, and the
inserter for <b>int</b> is found in <b>std</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1939"
title="Add Comment A1939"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
unqualified call to <b>swap(&nbsp;)</b> is dependent because its arguments are
of type <b>T</b>. This ultimately causes a global <b>swap(int&amp;, int&amp;)</b>
to be instantiated, of course. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1940"
title="Add Comment A1940"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>7.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
qualified call to <b>std::swap(&nbsp;)</b> is <i>not</i> dependent, because <b>std</b>
is a fixed namespace, so the compiler knows to look there for the proper
declaration. (The qualifier on the left of the “<b>::</b>” must mention a
template parameter for a qualified name to be considered dependent.) The <b>std::swap(&nbsp;)</b>
function template later generates <b>std::swap(int&amp;, int&amp;)</b>, at
instantiation time. No more dependent names remain in <b>X&lt;T&gt;::f(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1941"
title="Add Comment A1941"><sup>Comment</sup></a></p>

<p class=MsoNormal>To clarify and summarize: name lookup is done at the point
of instantiation if the name is dependent, except that for unqualified
dependent names the normal name lookup is also attempted early, at the point of
definition. (If necessary, another lookup occurs at instantiation time, when
the type of the actual argument is known.) All non-dependent names in templates
are looked up early, at the time the template definition is parsed. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1942"
title="Add Comment A1942"><sup>Comment</sup></a></p>

<p class=MsoNormal>(Whew!) If you have studied this example to the point that
you understand it, prepare yourself for yet another surprise in the next
section when <b>friend</b> declarations enter the picture.</p>

<h3><a name="_Toc45440064">Templates and friends</a></h3>

<p class=MsoNormal>A friend function declaration inside a class allows a
non-member function to access non-public members of that class. If the friend
function name is qualified, it will of course be found in the namespace or
class that qualifies it. If it is unqualified, however, the compiler must make
an assumption on where the definition of the friend function will be, since all
identifiers must have a unique scope. The expectation is that the function will
be defined in the nearest enclosing namespace (non-class) scope that contains
the class granting friendship. Very often this is just the global scope. The
following non-template example clarifies this issue. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1943"
title="Add Comment A1943"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:FriendScope.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Friendly {</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Friendly(int theInt) { i = theInt;
}</p>

<p class=CodeChar style='margin-left:0in'>  friend void f(const Friendly&amp;);
// needs global def.</p>

<p class=CodeChar style='margin-left:0in'>  void g() { f(*this); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void h() {</p>

<p class=CodeChar style='margin-left:0in'>  f(Friendly(1));  // uses ADL</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void f(const Friendly&amp; fo) {  //
definition of friend</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; fo.i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  h();               // prints 1</p>

<p class=CodeChar style='margin-left:0in'>  Friendly(2).g();   // prints 2</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The declaration of <b>f(&nbsp;)</b> inside the <b>Friendly</b>
class is unqualified, so the compiler will expect to be able to eventually link
that declaration to a definition at file scope (the namespace scope that
contains <b>Friendly</b> in this case). That definition appears after the
definition of the function <b>h(&nbsp;)</b>. The linking of the call to <b>f(&nbsp;)</b>
inside <b>h(&nbsp;)</b> to the same function is a separate matter, however.
This is resolved by ADL. Since the argument of <b>f(&nbsp;)</b> inside <b>h(&nbsp;)</b>
is a <b>Friendly</b> object, the <b>Friendly</b> class is searched for a
declaration of <b>f(&nbsp;)</b>, which succeeds. If the call were <b>f(1)</b>
instead (which makes some sense since 1 can be implicitly converted to <b>Friendly(1)</b>),
the call should fail, since there is no hint of where the compiler should look
for the declaration of <b>f(&nbsp;)</b>. The EDG compiler correctly complains
that <b>f</b> is undefined in that case. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1944"
title="Add Comment A1944"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now suppose that <b>Friendly</b> and <b>f</b> are both
templates, as in the following program.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:FriendScope2.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// Necessary forward declarations</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Friendly;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void f(const Friendly&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Friendly {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Friendly(const T&amp; theT) :
t(theT) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend void f&lt;&gt;(const
Friendly&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  void g() { f(*this); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void h() {</p>

<p class=CodeChar style='margin-left:0in'>  f(Friendly&lt;int&gt;(1));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void f(const Friendly&lt;T&gt;&amp;
fo) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; fo.t &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  h();</p>

<p class=CodeChar style='margin-left:0in'>  Friendly&lt;int&gt;(2).g();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>First notice that angle brackets in the declaration of <b>f</b>
inside of <b>Friendly</b>. This is necessary to tell the compiler that <b>f</b>
is a template. Otherwise, the compiler will look for an ordinary function named
<b>f</b> and of course not find it. We could have inserted the template
parameter (<b>&lt;T&gt;</b>) in the brackets, but it is easily deduced from the
declaration. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1945"
title="Add Comment A1945"><sup>Comment</sup></a></p>

<p class=MsoNormal>The forward declaration of the function template <b>f</b>
before the class definition is necessary, even though it wasn’t in the previous
example when <b>f</b> was a not a template; the language specifies that friend
function templates must be previously declared. Of course, to properly declare <b>f</b>,
<b>Friendly</b> must also have been declared, since <b>f</b> takes a <b>Friendly</b>
argument, hence the forward declaration of <b>Friendly</b> in the beginning. We
could have placed the full definition of <b>f</b> right after the initial
declaration of <b>Friendly</b> instead of separating its definition and
declaration, but we chose instead to leave it in a form that more closely
resembles the previous example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1946"
title="Add Comment A1946"><sup>Comment</sup></a></p>

<p class=MsoNormal>One last option remains for using friends inside of
templates: fully define them inside the class itself. Here is how the previous
example would appear with that change:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:FriendScope3.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Microsoft: use the -Za
(ANSI-compliant) option</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Friendly {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Friendly(const T&amp; theT) :
t(theT) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend void f(const
Friendly&lt;T&gt;&amp; fo) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; fo.t &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>  void g() { f(*this); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void h() {</p>

<p class=CodeChar style='margin-left:0in'>  f(Friendly&lt;int&gt;(1));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  h();</p>

<p class=CodeChar style='margin-left:0in'>  Friendly&lt;int&gt;(2).g();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>There is a very important difference between this and the
previous example: <b>f</b> is not a template here, but is an ordinary function
(remember that angle brackets were necessary before to imply that <b>f</b> was
a template). Every time the <b>Friendly</b> class template is instantiated, a
new, ordinary function overload is created that takes an argument of the
current <b>Friendly</b> specialization. This is what Dan Saks has called
“making new friends”<a href="#_ftn57" name="_ftnref57" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[57]</span></sup></span></span></sup></span></a>.
This is the most convenient way of defining friend functions for templates. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1947"
title="Add Comment A1947"><sup>Comment</sup></a></p>

<p class=MsoNormal>To make this perfectly clear, suppose you have a class
template to which you wish to add non-member operators as friends. Here is a
simple class template that simply holds a generic value:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Box {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Box(const T&amp; theT) : t(theT) {}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Without understanding the likes of the previous examples in
this section, novices find themselves frustrated because they can’t get a
simple stream output inserter to work. If you don’t define your operators
inside the definition of <b>Box</b>, then you must provide the forward
declarations we showed earlier: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1948"
title="Add Comment A1948"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Box1.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Defines template operators</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// Forward declarations</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Box;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>Box&lt;T&gt; operator+(const
Box&lt;T&gt;&amp;, const Box&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp;, const Box&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Box {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Box(const T&amp; theT) : t(theT) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend Box operator+&lt;&gt;(const
Box&lt;T&gt;&amp;, const Box&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;&lt;&gt;(ostream&amp;, const Box&lt;T&gt;&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>Box&lt;T&gt; operator+(const
Box&lt;T&gt;&amp; b1, const Box&lt;T&gt;&amp; b2) {</p>

<p class=CodeChar style='margin-left:0in'>  return Box&lt;T&gt;(b1.t + b2.t);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Box&lt;T&gt;&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt; '[' &lt;&lt; b.t
&lt;&lt; ']';</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Box&lt;int&gt; b1(1), b2(2);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b1 + b2 &lt;&lt;
endl;  // [3]</p>

<p class=CodeChar style='margin-left:0in'>//  cout &lt;&lt; b1 + 2 &lt;&lt;
endl; // no implicit conversions!</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here we are defining both an addition operator and an output
stream operator. Note the funny-looking triple left angle bracket in the friend
declaration of the output operator (“&lt;&lt;&lt;”; Dan Saks calls this the
“sergeant operator” :-). The main program reveals a disadvantage of this
approach: you can’t depend on implicit conversions (see the expression <b>b1 +
2</b>) because templates do not provide them. Using the in-class, non-template
approach is shorter and more robust: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1949"
title="Add Comment A1949"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Box2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Defines non-template operators</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Box {</p>

<p class=CodeChar style='margin-left:0in'>  T t;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Box(const T&amp; theT) : t(theT) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend Box operator+(const
Box&lt;T&gt;&amp; b1,</p>

<p class=CodeChar style='margin-left:0in'>                         const
Box&lt;T&gt;&amp; b2) {</p>

<p class=CodeChar style='margin-left:0in'>    return Box&lt;T&gt;(b1.t + b2.t);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os,</p>

<p class=CodeChar style='margin-left:0in'>                               const
Box&lt;T&gt;&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; '[' &lt;&lt;
b.t &lt;&lt; ']';</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Box&lt;int&gt; b1(1), b2(2);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b1 + b2 &lt;&lt;
endl;  // [3]</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b1 + 2 &lt;&lt;
endl;   // [3]</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Because the operators are normal functions (overloaded for
each specialization of <b>Box</b>—just <b>int</b> in this case, of course),
implicit conversions are applied as normal, so the expression <b>b1 + 2</b> is
valid. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1950"
title="Add Comment A1950"><sup>Comment</sup></a></p>

<h4>Friend templates</h4>

<p class=MsoNormal>You can be very precise as to which specializations of a
template are friends of a class. In the examples in the previous section, only
the specialization of the function template <b>f</b> with the same type that
specialized <b>Friendly</b> was a friend. For example, only the specialization <b>f&lt;int&gt;(const
Friendly&lt;int&gt;&amp;)</b> is a friend of the class <b>Friendly&lt;int&gt;</b>.
This was accomplished by using the template parameter for <b>Friendly</b> to
specialize <b>f</b> in its friend declaration. If we had wanted to, we could
have made a particular, fixed specialization of <b>f</b> a friend to all
instances of <b>Friendly</b>, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1951"
title="Add Comment A1951"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Inside of Friendly:</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  friend void
f&lt;&gt;(const Friendly&lt;double&gt;&amp;);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>By using <b>double</b> instead of <b>T</b>, the <b>double</b>
specialization of <b>f</b> has access to the non-public members of any <b>Friendly</b>
specialization. The specialization <b>f&lt;double&gt;(&nbsp;)</b> still isn’t
instantiated unless it is explicitly called, of course. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1952"
title="Add Comment A1952"><sup>Comment</sup></a></p>

<p class=MsoNormal>Likewise, if you were to declare a non-template function
with no parameters dependent on <b>T</b>, then that single function would be a
friend to all instances of <b>Friendly</b>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1953"
title="Add Comment A1953"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Inside of Friendly:</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  friend void g(int);  //
g(int) befriends all Friendly’s</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As always, since <b>g(int)</b> is unqualified, it must be
defined at file scope (the namespace scope containing <b>Friendly</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1954"
title="Add Comment A1954"><sup>Comment</sup></a></p>

<p class=MsoNormal>It is also possible to arrange for all specializations of <b>f</b>
to be friends for all specializations of <b>Friendly</b>, with a so-called <i>friend
template</i>, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Friendly {</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  template&lt;class U&gt;
friend void f&lt;&gt;(const Friendly&lt;U&gt;&amp;);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since the template argument for the friend declaration is
independent of <b>T</b>, any combination of <b>T</b> and <b>U</b> is allowed,
achieving the friendship objective. Like member templates, friend templates can
appear within non-template classes as well. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1955"
title="Add Comment A1955"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440065">Template programming idioms</a></h2>

<p class=MsoNormal>Since language is a tool of thought, new language features
tend to spawn new programming techniques. In this section we cover some
commonly-used template programming idioms that have emerged in the years since
templates were added to the C++ language<a href="#_ftn58" name="_ftnref58"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[58]</span></sup></span></span></sup></span></a>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1956"
title="Add Comment A1956"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440066">Traits</a></h3>

<p class=MsoNormal>The traits template technique, pioneered by Nathan Myers, is
a means of bundling type-dependent declarations together. In essence, using
traits allows you to “mix and match” certain types and and values with contexts
that use them in a flexible manner, while keeping your code readable and
maintainable. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1957"
title="Add Comment A1957"><sup>Comment</sup></a></p>

<p class=MsoNormal>The simplest example of a traits template is the <b>numeric_limits</b>
class template defined in <b>&lt;limits&gt;</b>. The primary template is
defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; class
numeric_limits {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_specialized =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static T min() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static T max() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static const int digits = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static const int digits10 = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_signed =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_integer =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_exact = false;</p>

<p class=CodeChar style='margin-left:0in'>  static const int radix = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static T epsilon() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static T round_error() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static const int min_exponent = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static const int min_exponent10 =
0;</p>

<p class=CodeChar style='margin-left:0in'>  static const int max_exponent = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static const int max_exponent10 =
0;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool has_infinity =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool has_quiet_NaN =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool has_signaling_NaN
= false;</p>

<p class=CodeChar style='margin-left:0in'>  static const float_denorm_style
has_denorm = </p>

<p class=CodeChar style='margin-left:0in'>                                  denorm_absent;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool has_denorm_loss =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static T infinity() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static T quiet_NaN() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static T signaling_NaN() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static T denorm_min() throw();</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_iec559 =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_bounded =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool is_modulo =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool traps = false;</p>

<p class=CodeChar style='margin-left:0in'>  static const bool tinyness_before =
false;</p>

<p class=CodeChar style='margin-left:0in'>  static const float_round_style
round_style = </p>

<p class=CodeChar style='margin-left:0in'>                                 round_toward_zero;</p>

<p class=CodeInline style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The <b>&lt;limits&gt;</b> header defines specializations for
all fundamental, numeric types (in which case the member <b>is_specialized</b>
is set to <b>true</b>).  To obtain the base for the <b>double</b> version of
your floating-point number system, for example, you can use the expression <b>numeric_limits(&nbsp;)&lt;double&gt;::radix</b>.
To find the smallest integer value available, you can use <b>numeric_limits&lt;int&gt;::min(&nbsp;)</b>.
Not all members of <b>numeric_limits</b> apply to all fundamental types, of
course (e.g., <b>epsilon(&nbsp;)</b> is only for floating-point types). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1958"
title="Add Comment A1958"><sup>Comment</sup></a></p>

<p class=MsoNormal>The values that will always be integral are static data
members of <b>numeric_limits</b>; those that may not be integral, such as the
minimum value for <b>float</b>, are implemented as static inline member
functions. This is because C++ only allows <i>integral</i> static data member
constants to be initialized inside of a class definition. Other members, such
as floating-point values, must be initialized at file scope outside of the
class definition, and which is not appropriate in a header file. Since the
needed value in that case will be placed in an implementation (.cpp) file, the
value will not be available for compile-time optimization. Inline member
functions of a class template, on the other hand, can be included in a header
file, and thus facilitate compile-time optimization. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1959"
title="Add Comment A1959"><sup>Comment</sup></a></p>

<p class=MsoNormal>In chapter 3 you saw how traits are used to control the
character-processing functionality used by the string classes. The classes <b>std::string</b>
and <b>std::wstring</b> are specializations of the <b>std::basic_string</b>
template, which is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class charT,</p>

<p class=CodeChar style='margin-left:0in'>  class traits =
char_traits&lt;charT&gt;,</p>

<p class=CodeChar style='margin-left:0in'>  class allocator =
allocator&lt;charT&gt; &gt;</p>

<p class=CodeInline style='margin-left:0in'>  class basic_string;</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The template parameter <b>charT</b> represents the
underlying character type, which is usually either <b>char</b> or <b>wchar_t</b>. 
The primary <b>char_traits</b> template is typically empty, and specializations
for <b>char</b> and <b>wchar_t</b> are provided by the standard library. Here
is the specification of the specialization <b>char_traits&lt;char&gt;</b>
according to the C++ standard: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1960"
title="Add Comment A1960"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct char_traits&lt;char&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  typedef char char_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef int int_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef streamoff off_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef streampos pos_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef mbstate_t state_type;</p>

<p class=CodeChar style='margin-left:0in'>  static void assign(char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq(const char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static bool lt(const char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static int compare(const char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                     const char_type*
s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static size_t length(const
char_type* s);</p>

<p class=CodeChar style='margin-left:0in'>  static const char_type* find(const
char_type* s,</p>

<p class=CodeChar style='margin-left:0in'>                               size_t
n,</p>

<p class=CodeChar style='margin-left:0in'>                               const
char_type&amp; a);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* move(char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                         const
char_type* s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* copy(char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                         const
char_type* s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* assign(char_type*
s, size_t n, </p>

<p class=CodeChar style='margin-left:0in'>                           char_type
a);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type not_eof(const
int_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type to_char_type(const
int_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type to_int_type(const
char_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq_int_type(const
int_type&amp; c1,</p>

<p class=CodeChar style='margin-left:0in'>                          const
int_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type eof();</p>

<p class=CodeInline style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>These functions are used by the <b>basic_string</b> class
template for character-based operations common to string processing. When you
declare a <b>string</b> variable, such as: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1961"
title="Add Comment A1961"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'>std::string s;</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>you are actually declaring <b>s</b> as follows (because of
the default temaplte arguments in the specification of <b>basic_string</b>):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>std::basic_string&lt;char,
std::char_traits&lt;char&gt;, </p>

<p class=CodeChar style='margin-left:0in'>                 
std::allocator&lt;char&gt; &gt; s;</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>Because the character traits have been separated from the <b>basic_string</b>
class template, you can supply a custom traits class to replace <b>std::char_traits</b>.
The following example illustrates this flexibility. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1962"
title="Add Comment A1962"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:PoohCorner.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates traits classes</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Item classes (traits of guests):</p>

<p class=CodeChar style='margin-left:0in'>class Water {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Water&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Water&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Milk {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Milk&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Milk&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Honey {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Honey&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Honey&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Cookies {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Cookies&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Cookies&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Guest classes:</p>

<p class=CodeChar style='margin-left:0in'>class Bear {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Bear&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Pooh&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Boy {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Boy&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Christopher Robin&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Primary traits template (empty—could
hold common types)</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Guest&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Traits specializations for Guest
types</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits&lt;Bear&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef Water beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Honey snack_type;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits&lt;Boy&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef Milk beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Cookies snack_type;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A custom traits class</p>

<p class=CodeChar style='margin-left:0in'>class MixedUpTraits {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef Milk beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Honey snack_type;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The Guest template (uses a traits
class)</p>

<p class=CodeChar style='margin-left:0in'>template&lt; class Guest, class
traits = GuestTraits&lt;Guest&gt; &gt;</p>

<p class=CodeChar style='margin-left:0in'>class PoohCorner {</p>

<p class=CodeChar style='margin-left:0in'>  Guest theGuest;</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename
traits::beverage_type beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename traits::snack_type
snack_type;</p>

<p class=CodeChar style='margin-left:0in'>  beverage_type bev;</p>

<p class=CodeChar style='margin-left:0in'>  snack_type snack;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner(const Guest&amp; g)</p>

<p class=CodeChar style='margin-left:0in'>    : theGuest(g),
bev(beverage_type()),</p>

<p class=CodeChar style='margin-left:0in'>      snack(snack_type()) {}</p>

<p class=CodeChar style='margin-left:0in'>  void entertain() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Entertaining
&quot; &lt;&lt; theGuest</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot; serving
&quot; &lt;&lt; bev</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot; and &quot;
&lt;&lt; snack &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Boy cr;</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner&lt;Boy&gt; pc1(cr);</p>

<p class=CodeChar style='margin-left:0in'>  pc1.entertain();</p>

<p class=CodeChar style='margin-left:0in'>  Bear pb;</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner&lt;Bear&gt; pc2(pb);</p>

<p class=CodeChar style='margin-left:0in'>  pc2.entertain();</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner&lt;Bear,
MixedUpTraits&gt; pc3(pb);</p>

<p class=CodeChar style='margin-left:0in'>  pc3.entertain();</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>In this program, instances of the guest classes <b>Boy</b>
and <b>Bear</b> are served items appropriate to their tastes. <b>Boy</b>s like
milk and cookies and <b>Bear</b>s like water and honey. This association of
guests to items is done via specializations of a primary (empty) traits class
template. The default arguments to <b>PoohCorner</b> ensure that guests get
their proper items, but you can override this by simply providing a class that
meets the requirements of the traits class, as we do with the <b>MixedUpTraits</b>
class above. The output of this program is: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1963"
title="Add Comment A1963"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Entertaining Christopher Robin
serving Milk and Cookies</p>

<p class=CodeChar style='margin-left:0in'>Entertaining Pooh serving Water and
Honey</p>

<p class=CodeInline style='margin-left:0in'>Entertaining Pooh serving Milk and
Honey</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>Using traits provides two key advantages: 1) allowing
flexibility in pairing objects with associated attributes or functionality, and
2) keeping template parameter lists small and readable. If our there were
thirty types associated with a guest, it would be very inconvenient to have to
specify all thirty arguments directly in each <b>PoohCorner</b> declaration. Factoring
the types into a separate traits class simplifies things considerably. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1964"
title="Add Comment A1964"><sup>Comment</sup></a></p>

<p class=MsoNormal>The traits technique is also used in implementing streams
and locales, as we showed in Chapter 4.</p>

<h3><a name="_Toc45440067">Policies</a></h3>

<p class=MsoNormal>If you inspect the <b>char_traits</b> specialization for <b>wchar_t</b>,
you’ll see that it is practically identical to its <b>char</b> counterpart:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>  struct char_traits&lt;wchar_t&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  typedef wchar_t char_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef wint_t int_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef streamoff off_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef wstreampos pos_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef mbstate_t state_type;</p>

<p class=CodeChar style='margin-left:0in'>  static void assign(char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq(const char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static bool lt(const char_type&amp;
c1, const char_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static int compare(const char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                     const
char_type*  s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static size_t length(const
char_type* s);</p>

<p class=CodeChar style='margin-left:0in'>  static const char_type* find(const
char_type* s,</p>

<p class=CodeChar style='margin-left:0in'>                               size_t
n,</p>

<p class=CodeChar style='margin-left:0in'>                               const
char_type&amp; a);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* move(char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                         const
char_type* s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* copy(char_type*
s1,</p>

<p class=CodeChar style='margin-left:0in'>                         const
char_type* s2, size_t n);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type* assign(char_type*
s, size_t n, </p>

<p class=CodeChar style='margin-left:0in'>                           char_type
a);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type not_eof(const
int_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static char_type to_char_type(const
int_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type to_int_type(const
char_type&amp; c);</p>

<p class=CodeChar style='margin-left:0in'>  static bool eq_int_type(const
int_type&amp; c1,</p>

<p class=CodeChar style='margin-left:0in'>                          const
int_type&amp; c2);</p>

<p class=CodeChar style='margin-left:0in'>  static int_type eof();</p>

<p class=CodeInline style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The only real difference between the two versions is the set
of types involved (<b>char</b> and <b>int</b> vs. <b>wchar_t</b> and <b>wint_t</b>).
The functionality provided is the same<a href="#_ftn59" name="_ftnref59"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[59]</span></sup></span></span></sup></span></a>.
This highlights the fact that traits classes are indeed for <i>traits</i>, and
therefore the things that change between related traits classes are usually
types and constant values, or fixed algorithms that use types related template
parameters. Traits classes tend to be templates themselves, since the types and
constants they contain are seen as characteristics of the primary template
parameter(s) (e.g., <b>char</b> and <b>wchar_t</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1965"
title="Add Comment A1965"><sup>Comment</sup></a></p>

<p class=MsoNormal>It is also useful to be able to associate <i>functionality</i>
with template arguments, so that client programmers can easily customize
behavior when they code. The following version of the <b>PoohCorner</b> program,
for instance, supports different types of entertainment: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1966"
title="Add Comment A1966"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:PoohCorner2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates policy classes</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Item classes:</p>

<p class=CodeChar style='margin-left:0in'>class Water {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Water&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Water&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Milk {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Milk&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Milk&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Honey {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Honey&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Honey&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Cookies {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Cookies&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Cookies&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Guest classes:</p>

<p class=CodeChar style='margin-left:0in'>class Bear {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Bear&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Pooh&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Boy {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Boy&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Christopher Robin&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Traits template</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Guest&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Traits specializations for Guest
types</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits&lt;Bear&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef Water beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Honey snack_type;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>class GuestTraits&lt;Boy&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef Milk beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Cookies snack_type;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Policy classes (require a static
doAction() function)</p>

<p class=CodeChar style='margin-left:0in'>class Feed {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static const char* doAction() {</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;Feeding&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Stuff {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static const char* doAction() {</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;Stuffing&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The Guest template (uses a policy
and a traits class)</p>

<p class=CodeChar style='margin-left:0in'>template&lt; class Guest, class
Action, class traits = </p>

<p class=CodeChar style='margin-left:0in'>                                     GuestTraits&lt;Guest&gt;
&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PoohCorner {</p>

<p class=CodeChar style='margin-left:0in'>  Guest theGuest;</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename
traits::beverage_type beverage_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename traits::snack_type
snack_type;</p>

<p class=CodeChar style='margin-left:0in'>  beverage_type bev;</p>

<p class=CodeChar style='margin-left:0in'>  snack_type snack;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner(const Guest&amp; g)</p>

<p class=CodeChar style='margin-left:0in'>    : theGuest(g),
bev(beverage_type()), snack(snack_type()) {}</p>

<p class=CodeChar style='margin-left:0in'>  void entertain() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; Action::doAction()
&lt;&lt; &quot; &quot; &lt;&lt; theGuest</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot; with &quot;
&lt;&lt; bev</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot; and &quot;
&lt;&lt; snack &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Boy cr;</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner&lt;Boy, Feed&gt;
pc1(cr);</p>

<p class=CodeChar style='margin-left:0in'>  pc1.entertain();</p>

<p class=CodeChar style='margin-left:0in'>  Bear pb;</p>

<p class=CodeChar style='margin-left:0in'>  PoohCorner&lt;Bear, Stuff&gt;
pc2(pb);</p>

<p class=CodeChar style='margin-left:0in'>  pc2.entertain();</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The <b>Action</b> template parameter in the <b>PoohCorner</b>
class expects to have a static member function named <b>doAction(&nbsp;)</b>,
which is used in <b>PoohCorner&lt;&gt;::entertain(&nbsp;)</b>. Users can choose
<b>Feed</b> or <b>Stuff</b> at will, both of which provide the required
function. Classes that encapsulate functionality in this way are referred to as
<i>policy classes</i>. The entertainment “policies” are provided above through <b>Feed::doAction(&nbsp;)</b>
and <b>Stuff::doAction(&nbsp;)</b>. These policy classes happen to be ordinary
classes, but they can be templates, and can be combined with inheritance to
great advantage. For more in-depth information on policy-based design, the
definitive resource is Andrei Alexandrescu’s book<a href="#_ftn60"
name="_ftnref60" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[60]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1967"
title="Add Comment A1967"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440068">The curiously-recurring template pattern</a></h3>

<p class=MsoNormal>Any novice C++ programmer can figure out how to modify a
class to keep track of the number of objects of that class that current exist.
All you have to do is to add static members, and modify constructor and
destructor logic, as follows: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1968"
title="Add Comment A1968"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:CountedClass.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Object counting via static members</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class CountedClass {</p>

<p class=CodeChar style='margin-left:0in'>  static int count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass() { ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass(const
CountedClass&amp;) { ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  ~CountedClass() { --count; }</p>

<p class=CodeChar style='margin-left:0in'>  static int getCount() { return
count; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int CountedClass::count = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass a;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; CountedClass::getCount()
&lt;&lt; endl;   // 1</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass b;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;   // 2</p>

<p class=CodeChar style='margin-left:0in'>  { // an arbitrary scope:</p>

<p class=CodeChar style='margin-left:0in'>    CountedClass c(b);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl; // 3</p>

<p class=CodeChar style='margin-left:0in'>    a = c;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl; // 3</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;   // 2</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All constructors of <b>CountedClass</b> increment the static
data member <b>count</b>, and the destructor decrements it. The static member
function <b>getCount(&nbsp;)</b> yields the number of current objects whenever
it called. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1969"
title="Add Comment A1969"><sup>Comment</sup></a></p>

<p class=MsoNormal>It would be tremendously tedious to have to manually add
these members every time you wanted to add object counting to a class. What is
the usual object-oriented device to which one turns to repeat or share code?
It’s inheritance, of course, which, unfortunately, is only half a solution in
this case. Observe what happens when we collect the counting logic into a base
class. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1970"
title="Add Comment A1970"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>//:
C05:CountedClass2.cpp</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Erroneous
attempt to count objects</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Counted {</p>

<p class=CodeChar style='margin-left:0in'>  static int count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Counted() { ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  Counted(const Counted&amp;) {
++count; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Counted() { --count; }</p>

<p class=CodeChar style='margin-left:0in'>  static int getCount() { return
count; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int Counted::count = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class CountedClass : public Counted
{};</p>

<p class=CodeChar style='margin-left:0in'>class CountedClass2 : public Counted
{};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass a;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;    // 1</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass b;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;    // 2</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass2 c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass2::getCount() &lt;&lt; endl;   // 3 (Error)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All classes that derive from <b>Counted</b> share the same,
single static data member, so the number of objects is tracked collectively
across all classes in the <b>Counted</b> hierarchy. What is needed is a way to
automatically generate a <i>different</i> base class for each derived class.
This is accomplished by the curious template construct illustrated below: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1971"
title="Add Comment A1971"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:CountedClass3.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Counted {</p>

<p class=CodeChar style='margin-left:0in'>  static int count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Counted() { ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  Counted(const
Counted&lt;T&gt;&amp;) { ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Counted() { --count; }</p>

<p class=CodeChar style='margin-left:0in'>  static int getCount() { return
count; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>int Counted&lt;T&gt;::count = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Curious class definitions</p>

<p class=CodeChar style='margin-left:0in'>class CountedClass : public
Counted&lt;CountedClass&gt; {};</p>

<p class=CodeChar style='margin-left:0in'>class CountedClass2 : public
Counted&lt;CountedClass2&gt; {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass a;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;    // 1</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass b;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass::getCount() &lt;&lt; endl;    // 2</p>

<p class=CodeChar style='margin-left:0in'>  CountedClass2 c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
CountedClass2::getCount() &lt;&lt; endl;   // 1 (!)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each derived class derives from a unique base class that is
determined by using itself (the derived class) as a template parameter! This
may seem like a circular definition, and it would be, had the base class any
non-static members. Since everything in <b>Counted</b> is static, its size
(which is 0!) is known when the template is parsed. It doesn’t matter,
therefore, which argument is used to instantiate <b>Counted</b>; its size is
always the same. Therefore, any derivation from an instance of <b>Counted</b>
can be completed when it is parsed, and there is no recursion. Since each base
class is unique, it has its own static data, thus constituting a very handy
technique for adding counting to any class whatsoever. Jim Coplien was the
first to mention this interesting derivation idiom in print, which he cited in
an article, entitled “Curiously Recurring Template Patterns.”<span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'> </span></sup></span><a href="#_ftn61" name="_ftnref61" title=""><span
style='font-size:10.5pt;font-family:Georgia'>[61]</span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1972"
title="Add Comment A1972"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440069">Template metaprogramming</a></h2>

<p class=MsoNormal>In 1993 compilers were beginning to support simple template
constructs so that users could define generic containers and functions. About
the same time that the STL was being considered for adoption into standard C++,
standards committee member Erwin Unruh passed around a few code examples with
surprising behavior, one of which looked something like the following: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1973"
title="Add Comment A1973"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Factorial.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Compile-time computation!</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Factorial</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>   enum {val =
Factorial&lt;n-1&gt;::val * n};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Factorial&lt;0&gt;</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = 1};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>int main()</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>{</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt;
Factorial&lt;12&gt;::val &lt;&lt; endl; // 479001600</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The fact that this program prints the correct value of <b>12!</b>
is not alarming, but when it actually does the arithmetic is; the computation
is complete before the program even runs! <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1974"
title="Add Comment A1974"><sup>Comment</sup></a></p>

<p class=MsoNormal>When the compiler attempts to instantiate <b>Factorial&lt;12&gt;</b>,
it finds it must also instantiate <b>Factorial&lt;11&gt;</b>, which requires <b>Factorial&lt;10&gt;</b>,
and so on. Eventually the recursion ends with the specialization <b>Factorial&lt;1&gt;</b>,
and the computation unwinds. Eventually, <b>Factorial&lt;12&gt;::val</b> is
replaced by the integral constant 479001600, and compilation ends. Since all
the computation is done by the compiler, the values involved must be
compile-time constants, hence the use of <b>enum</b><a href="#_ftn62"
name="_ftnref62" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[62]</span></sup></span></span></sup></span></a>. When the program
runs, the only work left to do is print that constant followed by a newline. To
convince yourself that a specialization of <b>Factorial</b> results in the correct
compile-time value, you could use it as an array dimension, such as: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1975"
title="Add Comment A1975"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>double nums[Factorial&lt;5&gt;::val];</p>

<p class=CodeInline style='margin-left:0in'>assert(sizeof nums == sizeof(double)*120);</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<h3><a name="_Toc45440070">Compile-time programming</a></h3>

<p class=MsoNormal>So what was meant to be a convenient way to perform type
parameter substitution turned out to be a mechanism to support compile-time
programming. Such a program is called a <b>template</b> <b>metaprogram</b>
(since you’re in effect “programming a program”), and it turns out that you can
do quite a lot with such a beast. In fact, template metaprogramming is <i>Turing
complete</i> because it supports selection (if-else) and looping (through
recursion), so theoretically you can perform any computation with it<a
href="#_ftn63" name="_ftnref63" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[63]</span></sup></span></span></sup></span></a>. The factorial
example above shows how to implement repetition; write a recursive template and
provide a stopping criterion via a specialization. The following example shows
how to compute Fibonacci numbers at compile time by the same technique. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1976"
title="Add Comment A1976"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Fibonacci.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Fib {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = Fib&lt;n-1&gt;::val +
Fib&lt;n-2&gt;::val};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Fib&lt;1&gt; {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = 1};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>struct
Fib&lt;0&gt; {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = 0};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Fib&lt;5&gt;::val
&lt;&lt; endl;   // 6</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Fib&lt;20&gt;::val
&lt;&lt; endl;  // 6765</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>Fibonacci numbers are defined mathematically as:</p>

<p class=MsoNormal><sub><img border=0 width=143 height=75
src="TicV2_files/image008.gif"></sub></p>

<p class=MsoNormal>The first two cases lead to the template specializations
above, and the rule in the third line becomes the primary template. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1977"
title="Add Comment A1977"><sup>Comment</sup></a></p>

<h4>Compile-time looping</h4>

<p class=MsoNormal>To compute any loop in a template metaprogram, it must first
be reformulated recursively. For example, to raise the integer <b>n</b> to the
power <b>p</b>, instead of using a loop such as in the following lines: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1978"
title="Add Comment A1978"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>int val = 1;</p>

<p class=CodeChar style='margin-left:0in'>while (p--)</p>

<p class=CodeInline style='margin-left:0in'>  val *= n;</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>you would have to think of it as a recursive procedure:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>int power(int n, int p) {</p>

<p class=CodeChar style='margin-left:0in'>  return (p &lt;= 0) ? 1 : n*power(n,
p-1);</p>

<p class=CodeInline style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>This can now be easily rendered as a template metaprogram as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Power.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int N, int P&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Power {</p>

<p class=CodeChar style='margin-left:0in'>  enum {val = N * Power&lt;N,
P-1&gt;::val};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int N&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Power&lt;N, 0&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  enum {val = 1};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; Power&lt;2,
5&gt;::val &lt;&lt; endl;  // 32</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>Note that we need to use a partial specialization for the
stopping condition, since the value <b>N</b> is still a free template
parameter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1979"
title="Add Comment A1979"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following metaprogram adapted from Czarnecki and
Eisenecker<a href="#_ftn64" name="_ftnref64" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[64]</span></sup></span></span></sup></span></a> is
interesting in that it uses a template template parameter, and simulates passing
a function as a parameter to another function, which “loops through” the
numbers <b>0..n</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1980"
title="Add Comment A1980"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Accumulate.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Passes a &quot;function&quot; as a
parameter at compile time</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// Accumulates the results of
F(0)..F(n)</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n,
template&lt;int&gt; class F&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Accumulate {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = Accumulate&lt;n-1,
F&gt;::val + F&lt;n&gt;::val};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>// The stopping criterion (returns
the value F(0))</p>

<p class=CodeChar style='margin-left:0in'>template&lt;template&lt;int&gt; class
F&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Accumulate&lt;0, F&gt; {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = F&lt;0&gt;::val};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>// Various &quot;functions&quot;:</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>template&lt;int
n&gt;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>struct
Identity {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = n};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Square {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = n*n};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Cube {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = n*n*n};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Accumulate&lt;4,
Identity&gt;::val &lt;&lt; endl; // 10</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Accumulate&lt;4,
Square&gt;::val &lt;&lt; endl;   // 30</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Accumulate&lt;4,
Cube&gt;::val &lt;&lt; endl;     // 100</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The primary <b>Accumulate</b> template attempts to compute
the sum <b>F(n)+F(n&#8209;1)…F(0)</b>. The stopping criterion is obtained by a
partial specialization, which “returns” <b>F(0)</b>. The parameter <b>F</b> is
itself a template, and acts like a function as in the previous examples in this
section. The templates <b>Identity</b>, <b>Square</b>, and <b>Cube</b> compute
the corresponding functions of their template parameter that their names
suggest. The first instantiation of <b>Accumulate</b> in <b>main(&nbsp;)</b>
computes the sum 4+3+2+1+0, because the <b>Identity</b> function simply
“returns” its template parameter. The second line in <b>main(&nbsp;)</b> adds
the squares of those numbers (16+9+4+1+0), and the last computes the sum of the
cubes (64+27+8+1+0). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1981"
title="Add Comment A1981"><sup>Comment</sup></a></p>

<h5>Loop unrolling</h5>

<p class=MsoNormal>(TBD)</p>

<h4>Compile-time selection</h4>

<p class=MsoNormal>To simulate conditionals at compile time you can use the
conditional ternary operator in an <b>enum</b> declaration. The following
program uses this technique to calaculate the maximum of two integers at
compile time. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1982"
title="Add Comment A1982"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Max.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int n1, int n2&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Max {</p>

<p class=CodeChar style='margin-left:0in'>   enum {val = n1 &gt; n2 ? n1 : n2};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; Max&lt;10,
20&gt;::val &lt;&lt; endl;  // 20</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>If you want to use compile-time conditions to govern custom
code generation, you can once again use specializations of the values <b>true</b>
and <b>false</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:Conditionals.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses compile-time conditions to
choose code</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;bool cond&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Select {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Select&lt;true&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  static inline void f() {
statement1(); }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  static inline void statement1() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;This
is&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot; statement1
executing\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct Select&lt;false&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  static inline void f() {
statement2(); }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  static inline void statement2() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;This
is&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot; statement2
executing\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;bool cond&gt;</p>

<p class=CodeChar style='margin-left:0in'>void execute() {</p>

<p class=CodeChar style='margin-left:0in'>  Select&lt;cond&gt;::f();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  execute&lt;sizeof int == 4&gt;();</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>This program is the equivalent of the expression:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>if (cond)</p>

<p class=CodeChar style='margin-left:0in'>  statement1();</p>

<p class=CodeChar style='margin-left:0in'>else</p>

<p class=CodeInline style='margin-left:0in'>  statement2();</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>except that the condition <b>cond</b> is evaluated at
compile time, and the appropriate versions of <b>execute&lt;&gt;(&nbsp;)</b> and
<b>Select&lt;&gt;</b> are instantiated<b> </b>by the compiler. The function <b>Select&lt;&gt;::f(&nbsp;)</b>
executes at runtime, of course. A <b>switch</b> statement can be emulated in
similar fashion, but specializing on each case value instead of the values <b>true</b>
and <b>false</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1983"
title="Add Comment A1983"><sup>Comment</sup></a></p>

<p class=MsoNormal>&lt;TBD: using type parameters instead of values&gt;</p>

<h4>Compile-time assertions</h4>

<p class=MsoNormal>In Chapter 2 we touted the virtues of using assertions as
part of an overall defensive programming strategy. An assertion is basically an
evaluation of a boolean expression followed by a suitable action: do nothing if
the condition ws true, or halt with a diagnostic message otherwise. The
previous section showed how to evaluate compile-time boolean expressions. The
remaining challenge is to print a meaningful error message and halt. All that
is required to halt the compiler is a compile error; the trick is to insert
helpful text into the error message. The following example of Alexandrescu<a
href="#_ftn65" name="_ftnref65" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[65]</span></sup></span></span></sup></span></a> uses template specialization,
a local class, and a little macro magic to do the job. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1984"
title="Add Comment A1984"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:StaticAssert.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A template and a specialization</p>

<p class=CodeChar style='margin-left:0in'>template&lt;bool&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct StaticCheck {</p>

<p class=CodeChar style='margin-left:0in'>   StaticCheck(...);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct StaticCheck&lt;false&gt;{};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The macro (generates a local
class)</p>

<p class=CodeChar style='margin-left:0in'>#define STATIC_CHECK(expr, msg)
{              \</p>

<p class=CodeChar style='margin-left:0in'>   class Error_##msg{};                        \</p>

<p class=CodeChar style='margin-left:0in'>   sizeof((StaticCheck&lt;expr&gt;(Error_##msg())));
\</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Detects narrowing conversions</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class To, class From&gt;</p>

<p class=CodeChar style='margin-left:0in'>To safe_cast(From from) {</p>

<p class=CodeChar style='margin-left:0in'>   STATIC_CHECK(sizeof(From) &lt;=
sizeof(To), </p>

<p class=CodeChar style='margin-left:0in'>                NarrowingConversion);</p>

<p class=CodeChar style='margin-left:0in'>   return reinterpret_cast&lt;To&gt;(from);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>int main() {</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>   void* p =
0;</p>

<p class=CodeChar style='margin-left:0in'>   int i = safe_cast&lt;int&gt;(p);</p>

<p class=CodeChar style='margin-left:0in'>   cout &lt;&lt; &quot;int cast
okay\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>//!   char c =
safe_cast&lt;char&gt;(p);</p>

<p class=CodeInline style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>This example defines a function template, <b>safe_cast(&nbsp;)</b>,
that checks to see if the object it is casting from is no larger than the type
of object it casts to. If the size of the target object type is smaller, then
the user will be notified at compile time that a narrowing conversion was
attempted. Notice that the <b>StaticCheck</b> class template has the curious
feature that <i>anything</i> can be converted to an instance of <b>StaticCheck&lt;true&gt;</b>
(because of the ellipsis in its constructor), and <i>nothing</i> can be
converted to a <b>StaticCheck&lt;false&gt;</b>, because no conversions are
supplied for that specialization. The idea is to attempt to create an instance
of a new class and attempt to convert it to <b>StaticCheck&lt;true&gt;</b> <i>at
compile time</i> whenever the condition of interest is true, or to a <b>StaticCheck&lt;false&gt;</b>
object when the condition being tested is false. Since the <b>sizeof</b>
operator does its work at compile time, it is used to attempt the conversion.
If the condition is false, the compiler will complain that it doesn’t know how
to convert from the new class type to <b>StaticCheck&lt;false&gt;</b>. (The
extra parentheses inside the <b>sizeof</b> invocation are to stop the compiler
thinking that we’re trying to take the <b>sizeof</b> a function, which is
illegal.) To get some meaningful information inserted into the error message,
the new class name carries key text in its name. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1985"
title="Add Comment A1985"><sup>Comment</sup></a></p>

<p class=MsoNormal>The best way to understand this technique is to walk through
a specific case. Consider the line in <b>main(&nbsp;)</b> above which reads:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'>   int i = safe_cast&lt;int&gt;(p);</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The call to <b>safe_cast&lt;int&gt;(p)</b> contains the
following macro expansion replacing its first line of code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>{                                                
  \</p>

<p class=CodeChar style='margin-left:0in'>   class
Error_NarrowingConversion{};               \</p>

<p class=CodeChar style='margin-left:0in'>   sizeof(StaticCheck&lt;sizeof(void*)
&lt;= sizeof(int)&gt; \  </p>

<p class=CodeChar style='margin-left:0in'>           (Error_NarrowingConversion())); 
        \</p>

<p class=CodeInline style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>(Recall that the token-pasting preprecessing operator, <b>##</b>,
concatenates its operand into a single token, so <b>Error_##NarrowingConversion</b>
becomes the token <b>Error_NarrowingConversion</b>). The class <b>Error_NarrowingConversion</b>
is a <i>local class</i> (meaning that it is declared inside of a non-namespace
scope) because it is not needed elsewhere in the program. The application of
the <b>sizeof</b> operator attempts to determine the size of an instance of <b>StaticCheck&lt;true&gt;</b>
(because <b>sizeof(void*) &lt;= sizeof(int)</b> is true on our platforms) that
is created implicitly from the temporary object to be created by the expression
<b>Error_NarrowingConversion(&nbsp;)</b>. The compiler knows the size of the
new class <b>Error_NarrowingConversion</b> (it’s empty), and so the
compile-time use of <b>sizeof</b> is valid. Since the conversion from the <b>Error_NarrowingConversion</b>
temporary to <b>StaticCheck&lt;true&gt;</b> succeeds, so does the call to <b>sizeof</b>,
and execution continues. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1986"
title="Add Comment A1986"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now consider what would happen if the comment were removed
from the last line of <b>main(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'>   char c =
safe_cast&lt;char&gt;(p);</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>In this case the <b>STATIC_CHECK</b> macro inside <b>safe_cast&lt;char&gt;(p)</b>
expands to:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>{                                                    \</p>

<p class=CodeChar style='margin-left:0in'>   class
Error_NarrowingConversion{};                \</p>

<p class=CodeChar style='margin-left:0in'>  
sizeof(StaticCheck&lt;sizeof(void*) &lt;= sizeof(char)&gt; \  </p>

<p class=CodeChar style='margin-left:0in'>          
(Error_NarrowingConversion()));           \</p>

<p class=CodeInline style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>Since the expression <b>sizeof(void*) &lt;= sizeof(char)</b>
is false, then a conversion from a <b>Error_NarrowingConversion</b> temporary
to <b>StaticCheck&lt;false&gt;</b> is attempted, which fails, so the compiler
halts with a message something like the following: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1987"
title="Add Comment A1987"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Cannot cast from
'Error_NarrowingConversion' to 'StaticCheck&lt;0&gt;' in function</p>

<p class=CodeInline style='margin-left:0in'>char safe_cast&lt;char,void <span
class=CodeInlineCharCharChar1>*&gt;(void *)</span></p>

</div>

<p class=CodeInlineTrailer>&nbsp;</p>

<p class=MsoNormal>The class name <b>Error_NarrowingConversion</b> is the
meaningful message judiciously arrange by the coder. In general, to perform a
static assertion with this technique, you just invoke the <b>STATIC_CHECK</b>
macro with the compile-time condition to check, and a meaningful name to
describe the error. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1988"
title="Add Comment A1988"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440071">Expression templates</a></h3>

<p class=MsoNormal>(TBD)</p>

<h2 style='margin-left:0in'><a name="_Toc45440072">Template compilation models</a></h2>

<p class=MsoNormal>(TBD)</p>

<h3><a name="_Toc45440073"></a><a name="_Toc312374093">Explicit instantiation</a></h3>

<p class=MsoNormal>At times it is useful to explicitly instantiate a template;
that is, to tell the compiler to lay down the code for a specific version of
that template even though you’re not creating an object at that point. To do
this, you use the <b>template</b> keyword as follows: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0643"
title="Add Comment A0643"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template class Bobbin&lt;thread&gt;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>template void
sort&lt;char&gt;(char*[]);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here’s a version of the <b>Sorted.cpp</b> example that
explicitly instantiates a template before using it:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0644"
title="Add Comment A0644"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C05:ExplicitInstantiation.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Urand.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Sorted.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Explicit instantiation:</p>

<p class=CodeChar style='margin-left:0in'>template class Sorted&lt;int&gt;;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Sorted&lt;int&gt; is;</p>

<p class=CodeChar style='margin-left:0in'>  Urand&lt;47&gt; rand1;</p>

<p class=CodeChar style='margin-left:0in'>  for(int k = 0; k &lt; 15; k++)</p>

<p class=CodeChar style='margin-left:0in'>    is.push_back(rand1());</p>

<p class=CodeChar style='margin-left:0in'>  is.sort();</p>

<p class=CodeChar style='margin-left:0in'>  for(int l = 0; l &lt; is.size();
l++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; is[l] &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this example, the explicit instantiation doesn’t really
accomplish anything; the program would work the same without it. Explicit
instantiation is only for special cases where extra control is needed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0645"
title="Add Comment A0645"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440074">Summary</a></h2>

<p class=MsoNormal>One of the greatest weaknesses of C++ templates will be
shown to you when you try to write code that uses templates, especially STL
code (introduced in the next two chapters), and start getting compile-time
error messages. When you’re not used to it, the quantity of inscrutable text
that will be spewed at you by the compiler will be quite overwhelming. After a
while you’ll adapt (although it always feels a bit barbaric), and if it’s any
consolation, C++ compilers have actually gotten a lot <i>better</i> about this
– previously they would only give the line where you tried to instantiate the
template, and most of them now go to the line in the template definition that
caused the problem. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0648"
title="Add Comment A0648"><sup>Comment</sup></a></p>

<p class=MsoNormal>The issue is that <i>a template implies an interface</i>.
That is, even though the <b>template</b> keyword says “I’ll take any type,” the
code in a template definition actually requires that certain operators and
member functions be supported – that’s the interface. So in reality, a template
definition is saying “I’ll take any type that supports this interface.” Things
would be much nicer if the compiler could simply say “hey, this type that
you’re trying to instantiate the template with doesn’t support that interface –
can’t do it.” The Java language has a feature called <b>interface</b> that
would be a perfect match for this (Java, however, has no parameterized type
mechanism), but it will be many years, if ever, before you will see such a
thing in C++ (at this writing the C++ Standard has only just been accepted and
it will be a while before all the compilers even achieve compliance). Compilers
can only get so good at reporting template instantiation errors, so you’ll have
to grit your teeth, go to the first line reported as an error and figure it
out. <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0649"
title="Add Comment A0649"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440075">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Exercise 1</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Exercise 2</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Exercise 3</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Etc.</p>

<p class=MsoNormal><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0650"
title="Add Comment A0650"><sup>Comment</sup></a></p>

</div>

<span style='font-size:13.0pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section12>

<h1 style='margin-left:-81.35pt'><a name="_Toc45440076"></a><a
name="_Toc22433866">6: Generic algorithms</a></h1>

<p class=Intro style='margin-left:.25in'><a name=STLAlgorithmsChapter></a>Algorithms
are at the core of computing. To be able to write an algorithm once and for all
to work with any type of sequence makes your programs both simpler and safer.
The ability to customize algorithms at runtime has revolutionalized software
development.</p>

<p class=MsoNormal>The subset of the standard C++ library known as the Standard
Template Library (STL) was originally designed around <i>generic algorithms</i>—code
that processes sequences of any type of values in a type-safe manner. The goal
was to use predefined algorithms for almost every task, instead of hand-coding
loops every time you need to process a collection of data. This power comes
with a bit of a learning curve, however. By the time you get to the end of this
chapter, you should be able to decide for yourself whether you find the
algorithms addictive or too confusing to remember. If you’re like most people,
you’ll resist them at first but then tend to use them more and more. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0651"
title="Add Comment A0651"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440077"></a><a name="_Toc22433867">A
first look</a></h2>

<p class=MsoNormal>Among other things, the generic algorithms in the standard
library provide a <i>vocabulary</i> with which to describe solutions. That is,
once you become familiar with the algorithms, you’ll have a new set of words
with which to discuss what you’re doing, and these words are at a higher level
than what you had before. You don’t have to say, “This loop moves through and
assigns from here to there … oh, I see, it’s copying!” Instead, you just say <b>copy(&nbsp;)</b>.
This is the kind of thing we’ve been doing in computer programming from the
beginning—creating high-level abstractions to express <i>what</i> you’re doing
and spending less time saying <i>how</i> you’re doing it. The <i>how</i> has
been solved once and for all and is hidden in the algorithm’s code, ready to be
reused on demand. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0652"
title="Add Comment A0652"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here’s an example of how to use the <b>copy</b> algorithm:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyInts.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Copies ints without an explicit
loop</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;  // For
size_t</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  int b[SIZE];</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a + SIZE, b);</p>

<p class=CodeChar style='margin-left:0in'>  for (int i = 0; i &lt; SIZE; ++i)</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=IT>assert(a[i] ==
b[i]);</span></p>

<p class=CodeChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1614"
title="Add Comment A1614"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>copy</b> algorithm’s first two parameters represent
the <i>range</i> of the input sequence—in this case the array <b>a</b>. Ranges
are denoted by a pair of pointers. The first points to the first element of the
sequence, and the second points one position <i>past the end</i> of the array
(right after the last element). This may seem strange at first, but it is an
old C idiom that comes in quite handy. For example, the difference of these two
pointers yields the number of elements in the sequence. More important, in
implementing <b>copy(&nbsp;)</b>, the second pointer can act as a sentinel to
stop the iteration through the sequence. The third argument refers to the
beginning of the output sequence, which is the array <b>b</b> in this example.
It is assumed that the array that <b>b</b> represents has enough space to
receive the copied elements. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1615"
title="Add Comment A1615"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>copy(&nbsp;)</b> algorithm wouldn’t be very exciting
if it could only process integers. It can in fact copy any sequence. The
following example copies <b>string</b> objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1616"
title="Add Comment A1616"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyStrings.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Copies strings</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string a[] = {&quot;read&quot;,
&quot;my&quot;, &quot;lips&quot;};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  string b[SIZE];</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a + SIZE, b);</p>

<p class=CodeChar style='margin-left:0in'>  assert(equal(a, a + SIZE, b));</p>

<p class=CodeChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1617"
title="Add Comment A1617"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example introduces another algorithm, <b>equal(&nbsp;)</b>,
which returns <b>true</b> only if each element in the first sequence is equal
(using its <b>operator==(&nbsp;)</b>) to the corresponding element in the
second sequence. This example traverses each sequence twice, once for the copy,
and once for the comparison, without a single explicit loop! <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1618"
title="Add Comment A1618"><sup>Comment</sup></a></p>

<p class=MsoNormal>Generic algorithms achieve this flexibility because they are
function templates, of course. If you guessed that the implementation of <b>copy(&nbsp;)</b>
looked something like the following, you’d be “almost” right. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1619"
title="Add Comment A1619"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void copy(T* begin, T* end, T* dest)
{</p>

<p class=CodeChar style='margin-left:0in'>  while (begin != end)</p>

<p class=CodeChar style='margin-left:0in'>    *dest++ = *begin++;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1620"
title="Add Comment A1620"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We say “almost,” because <b>copy(&nbsp;)</b> can actually
process sequences delimited by anything that acts like a pointer, such as an
iterator. In this way, <b>copy(&nbsp;)</b> can duplicate a vector, as in the
following example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1621"
title="Add Comment A1621"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyVector.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Copies the contents of a vector</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v1(a, a + SIZE);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v2(SIZE);</p>

<p class=CodeChar style='margin-left:0in'>  copy(v1.begin(), v1.end(),
v2.begin());</p>

<p class=CodeChar style='margin-left:0in'>  assert(equal(v1.begin(), v1.end(),
v2.begin()));</p>

<p class=CodeChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1622"
title="Add Comment A1622"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first vector, <b>v1</b>, is initialized from the
sequence of integers in the array <b>a</b>. The definition of the vector <b>v2</b>
uses a different vector constructor that makes room for <b>SIZE</b> elements,
initialized to zero (the default value for integers).</p>

<p class=MsoNormal>As with the array example earlier, it’s important that <b>v2</b>
have enough space to receive a copy of the contents of <b>v1</b>. For
convenience, a special library function, <b>back_inserter(&nbsp;)</b>, returns
a special type of iterator that <i>inserts</i> elements instead of <i>overwriting</i>
them, so memory is expanded automatically by the container as needed. The
following example uses <b>back_inserter(&nbsp;),</b> so it doesn’t have to
expand the size of the output vector, <b>v2</b>, ahead of time. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1623"
title="Add Comment A1623"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:InsertVector.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Appends the contents of a vector
to another</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v1(a, a + SIZE);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v2;  // v2 is
empty here</p>

<p class=CodeChar style='margin-left:0in'>  copy(v1.begin(), v1.end(),
back_inserter(v2));</p>

<p class=CodeChar style='margin-left:0in'>  assert(equal(v1.begin(), v1.end(),
v2.begin()));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ </p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>back_inserter(&nbsp;)</b> function is defined in the <b>&lt;iterator&gt;</b>
header. We’ll explain how insert iterators work in depth in the next chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1656"
title="Add Comment A1656"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since iterators are identical to pointers in all essential
ways, you can write the algorithms in the standard library in such a way as to
allow both pointer and iterator arguments. For this reason, the implementation
of <b>copy(&nbsp;)</b> looks more like the following code. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1624"
title="Add Comment A1624"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;typename Iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>void copy(Iterator begin, Iterator
end, Iterator dest) {</p>

<p class=CodeChar style='margin-left:0in'>  while (begin != end)</p>

<p class=CodeChar style='margin-left:0in'>    *begin++ = *dest++;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Whichever argument type you use in the call, <b>copy(&nbsp;)</b>
assumes it properly implements the indirection and increment operators. If it
doesn’t, you’ll get a compile-time error. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1625"
title="Add Comment A1625"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440078"></a><a name="_Toc22433868">Predicates</a></h3>

<p class=MsoNormal>At times, you might want to copy only a well-defined subset
of one sequence to another, such as only those elements that satisfy a certain
condition. To achieve this flexibility, many algorithms have alternate calling
sequences that allow you to supply a <i>predicate</i>, which is simply a
function that returns a Boolean value based on some criterion. Suppose, for
example, that you only want to extract from a sequence of integers those
numbers that are less than or equal to 15. A version of <b>copy(&nbsp;)</b>
called <b>remove_copy_if(&nbsp;)</b> can do the job, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1626"
title="Add Comment A1626"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyInts2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Ignores ints that satisfy a
predicate</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// You supply this predicate</p>

<p class=CodeChar style='margin-left:0in'>bool gt15(int x) {</p>

<p class=CodeChar style='margin-left:0in'>  return 15 &lt; x;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  int b[SIZE];</p>

<p class=CodeChar style='margin-left:0in'>  int* endb = remove_copy_if(a,
a+SIZE, b, gt15);</p>

<p class=CodeChar style='margin-left:0in'>  int* beginb = b;</p>

<p class=CodeChar style='margin-left:0in'>  while (beginb != endb)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *beginb++ &lt;&lt;
endl; // Prints 10 only</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1627"
title="Add Comment A1627"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>remove_copy_if(&nbsp;)</b> function template takes
the usual range-delimiting pointers, followed by a predicate of your choosing.
The predicate must be a pointer to function<a href="#_ftn66" name="_ftnref66"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[66]</span></sup></span></span></sup></span></a> that
takes a single argument of the same type as the elements in the sequence, and
it must return a <b>bool</b>. In this case, the function <b>gt15</b> returns <b>true</b>
if its argument is greater than 15. The <b>remove_copy_if(&nbsp;)</b> algorithm
applies <b>gt15(&nbsp;)</b> to each element in the input sequence and ignores
those elements when writing to the output sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1628"
title="Add Comment A1628"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following program illustrates yet another variation of
the <b>copy</b> algorithm.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyStrings2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Replaces strings that satisfy a
predicate</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>// The predicate</p>

<p class=CodeChar style='margin-left:0in'>bool contains_e(const string&amp; s)
{</p>

<p class=CodeChar style='margin-left:0in'>  return s.find('e') != string::npos;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string a[] = {&quot;read&quot;,
&quot;my&quot;, &quot;lips&quot;};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  string b[SIZE];</p>

<p class=CodeChar style='margin-left:0in'>  string* endb =</p>

<p class=CodeChar style='margin-left:0in'>    replace_copy_if(a, a + SIZE, b, contains_e,
</p>

<p class=CodeChar style='margin-left:0in'>                    <span lang=SV>string(&quot;kiss&quot;));</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  string* beginb = b;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>while (beginb
!= endb)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *beginb++ &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1629"
title="Add Comment A1629"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Instead of just ignoring elements that don’t satisfy the
predicate, <b>replace_copy_if(&nbsp;)</b> substitutes a fixed value for such
elements when populating the output sequence. The output in this case is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>kiss</p>

<p class=CodeChar style='margin-left:0in'>my</p>

<p class=CodeInlineCharChar style='margin-left:0in'>lips</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>because the original occurrence of “read”, the only input
string containing the letter <i>e</i>, is replaced by the word “kiss”, as
specified in the last argument in the call to <b>replace_copy_if(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1630"
title="Add Comment A1630"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>replace_if(&nbsp;)</b> algorithm changes the original
sequence in place, instead of writing to a separate output sequence, as the
following program shows.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:ReplaceStrings.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Replaces strings in-place</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>bool contains_e(const string&amp; s)
{</p>

<p class=CodeChar style='margin-left:0in'>  return s.find('e') != string::npos;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string a[] = {&quot;read&quot;,
&quot;my&quot;, &quot;lips&quot;};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  replace_if(a, a + SIZE, contains_e,
string(&quot;kiss&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  string* p = a;</p>

<p class=CodeChar style='margin-left:0in'>  while (p != a + SIZE)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *p++ &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440079"></a><a name="_Toc22433869">Stream iterators</a></h3>

<p class=MsoNormal>Like any good software library, the Standard C++ Library
attempts to provide convenient ways to automate common tasks. We mentioned in
the beginning of this chapter that you can use generic algorithms in place of
looping constructs. So far, however, our examples have still used an explicit
loop to print their output. Since printing output is one of the most common
tasks, you would hope for a way to automate that too. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1631"
title="Add Comment A1631"><sup>Comment</sup></a></p>

<p class=MsoNormal>That’s where <i>stream iterators</i> come in. A stream
iterator allows you to use a stream as either an input or an output sequence.
To eliminate the output loop in the <b>CopyInts2.cpp</b> program, for instance,
you can do something like the following. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1632"
title="Add Comment A1632"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyInts3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses an output stream iterator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>bool gt15(int x) {</p>

<p class=CodeChar style='margin-left:0in'>  return 15 &lt; x;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  remove_copy_if(a, a + SIZE,</p>

<p class=CodeChar style='margin-left:0in'>                
ostream_iterator&lt;int&gt;(cout, &quot;\n&quot;), gt15);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1633"
title="Add Comment A1633"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this example we’ve replaced the output sequence <b>b</b>
in the third argument to <b>remove_copy_if(&nbsp;)</b> with an <i>output</i>
stream iterator, which is an instance of the <b>ostream_iterator</b> class
template declared in the <b>&lt;iterator&gt;</b> header. Output stream
iterators overload their copy-assignment operators to write to their stream.
This particular instance of <b>ostream_iterator</b> is attached to the output
stream <b>cout</b>. Every time <b>remove_copy_if(&nbsp;)</b> assigns an integer
from the sequence <b>a</b> to <b>cout</b> through this iterator, the iterator
writes the integer to <b>cout</b> and also automatically writes an instance of
the separator string found in its second argument, which in this case contains
just the newline character.</p>

<p class=MsoNormal>It is just as easy to write to a file instead of to <b>cout</b>,
of course. All you have to do is provide an output file stream instead of <b>cout</b>:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1639"
title="Add Comment A1639"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyIntsToFile.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses an output file stream
iterator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>bool gt15(int x) {</p>

<p class=CodeChar style='margin-left:0in'>  return 15 &lt; x;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
outf(&quot;ints.out&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  remove_copy_if(a, a + SIZE,</p>

<p class=CodeChar style='margin-left:0in'>                
ostream_iterator&lt;int&gt;(outf, &quot;\n&quot;), gt15);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1638"
title="Add Comment A1638"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>An <i>input</i> stream iterator allows an algorithm to get
its input sequence from an input stream. This is accomplished by having both
the constructor and <b>operator++(&nbsp;)</b> read the next element from the
underlying stream and by overloading <b>operator*(&nbsp;)</b> to yield the
value previously read. Since algorithms require two pointers to delimit an
input sequence, you can construct an <b>istream_iterator </b>in two ways, as
you can see in the program that follows. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1637"
title="Add Comment A1637"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyIntsFromFile.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses an input stream iterator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>bool gt15(int x) {</p>

<p class=CodeChar style='margin-left:0in'>  return 15 &lt; x;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
inf(&quot;someInts.dat&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(inf,
&quot;someInts.dat&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  remove_copy_if(istream_iterator&lt;int&gt;(inf),  
</p>

<p class=CodeChar style='margin-left:0in'>                
istream_iterator&lt;int&gt;(),</p>

<p class=CodeChar style='margin-left:0in'>                
ostream_iterator&lt;int&gt;(cout, &quot;\n&quot;), gt15);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1636"
title="Add Comment A1636"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first argument to <b>replace_copy_if(&nbsp;)</b> in this
program attaches an <b>istream_iterator</b> object to the input file stream
containing <b>int</b>s. The second argument uses the default constructor of the
<b>istream_iterator</b> class. This call constructs a special value of <b>istream_iterator</b>
that indicates end-of-file, so that when the first iterator finally encounters
the end of the physical file, it compares equal to the value <b>istream_iterator&lt;int&gt;(&nbsp;)</b>,
allowing the algorithm to terminate correctly. Note that this example avoids using
an explicit array altogether. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1635"
title="Add Comment A1635"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440080"></a><a name="_Toc22433870">Algorithm complexity</a></h3>

<p class=MsoNormal>Using a software library is a matter of trust. You trust the
implementers to not only provide correct functionality, but you also hope that
the functions execute as efficiently as possible. It’s better to write your own
loops than to use algorithms that degrade performance. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1640"
title="Add Comment A1640"><sup>Comment</sup></a></p>

<p class=MsoNormal>To guarantee quality library implementations, the C++
standard not only specifies what an algorithm should do, but how fast it should
do it and sometimes how much space it should use. Any algorithm that does not
meet the performance requirements does not conform to the standard. The measure
of an algorithm’s operational efficiency is called its <i>complexity</i>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1641"
title="Add Comment A1641"><sup>Comment</sup></a></p>

<p class=MsoNormal>When possible, the standard specifies the exact number of
operation counts an algorithm should use. The <b>count_if(&nbsp;)</b>
algorithm, for example, returns the number of elements in a sequence satisfying
a given predicate. The following call to <b>count_if(&nbsp;)</b>, if applied to
a sequence of integers similar to the examples earlier in this chapter, yields
the number of integer elements that are greater than 15: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1642"
title="Add Comment A1642"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>size_t n = count_if(a, a +
SIZE, gt15);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>count_if(&nbsp;)</b> must look at every element
exactly once, it is specified to make a number of comparisons exactly equal to
the number of elements in the sequence. Naturally, the <b>copy(&nbsp;)</b>
algorithm has the same specification. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1643"
title="Add Comment A1643"><sup>Comment</sup></a></p>

<p class=MsoNormal>Other algorithms can be specified to take <i>at most</i> a
certain number of operations. The <b>find(&nbsp;)</b> algorithm searches
through a sequence in order until it encounters an element equal to its third
argument: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1644"
title="Add Comment A1644"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>int* p = find(a, a + SIZE,
20);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It stops as soon as the element is found and returns a
pointer to that first occurrence. If it doesn’t find one, it returns a pointer
one position past the end of the sequence (<b>a+SIZE</b> in this example).
Therefore, <b>find</b> is said to make at most a number of comparisons equal to
the number of elements in the sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1645"
title="Add Comment A1645"><sup>Comment</sup></a></p>

<p class=MsoNormal>Sometimes the number of operations an algorithm takes cannot
be measured with such precision. In such cases, the standard specifies the
algorithm’s <i>asymptotic complexity</i>, which is a measure of how the
algorithm behaves with large sequences compared to well-known formulas. A good
example is the <b>sort(&nbsp;)</b> algorithm, which the standard says takes
“approximately <b>n log n</b> comparisons on average” (<b>n</b> is the number
of elements in the sequence)<a href="#_ftn67" name="_ftnref67" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[67]</span></sup></span></span></sup></span></a>.
Such complexity measures give a “feel” for the cost of an algorithm and at
least give a meaningful basis for comparing algorithms. As you’ll see in the
next chapter, the <b>find(&nbsp;)</b> member function for the <b>set</b>
container has logarithmic complexity, which means that the cost of searching
for an element in a <b>set</b> will, for large sets, be proportional to the
logarithm of the number of elements. This is much smaller than the number of
elements for large <b>n</b>, so it is always better to search a <b>set</b> by
using its <b>find(&nbsp;)</b> member function rather than by using the generic <b>find(&nbsp;)</b>
algorithm. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1646"
title="Add Comment A1646"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440081"></a><a name="_Toc22433871">Function
objects</a></h2>

<p class=MsoNormal>As you study some of the examples earlier in this chapter,
you will probably notice the limited utility of the function <b>gt15(&nbsp;)</b>.
What if you want to use a number other than 15 as a comparison threshold? You
may need a <b>gt20(&nbsp;)</b> or <b>gt25(&nbsp;)</b> or others as well. Having
to write a separate function for each such comparison has two distasteful
difficulties:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>You
may have to write a lot of functions!</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>You
must know all required values when you write your application code.</p>

<p class=MsoNormal>The second limitation means that you can’t use runtime
values<a href="#_ftn68" name="_ftnref68" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[68]</span></sup></span></span></sup></span></a> to
govern your searches, which is downright unacceptable. Overcoming this
difficulty requires a way to pass information to predicates at runtime. For
example, you would need a greater-than function that you can initialize with an
arbitrary comparison value. Unfortunately, you can’t pass that value as a
function parameter, because unary predicates, such as our <b>gt15(&nbsp;)</b>,
are applied to each value in a sequence individually and must therefore take
only one parameter.</p>

<p class=MsoNormal>The way out of this dilemma is, as always, to create an
abstraction. In this case, we need an abstraction that can act like a function
as well as store state, without disturbing the number of function parameters it
accepts when used. This abstraction is called a <i>function object</i><a
href="#_ftn69" name="_ftnref69" title=""><span class=MsoFootnoteReference><i><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><b><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[69]</span></sup></b></span></span></sup></i></span></a>.</p>

<p class=MsoNormal>A function object is an instance of a class that overloads <b>operator(&nbsp;)</b>,
the function call operator. This operator allows an object to be used with
function call syntax. As with any other object, you can initialize it via its
constructors. Here is a function object that can be used in place of <b>gt15(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:GreaterThanN.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>class gt_n {</p>

<p class=CodeChar style='margin-left:0in'>  int value;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  gt_n(int val) : value(val) {}</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(int n) {</p>

<p class=CodeChar style='margin-left:0in'>    return n &gt; value;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  gt_n f(4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; f(3) &lt;&lt; endl; 
// Prints 0 (for false)</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; f(5) &lt;&lt; endl; 
// Prints 1 (for true)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The fixed value to compare against (4) is passed when the
function object <b>f</b> is created. The expression <b>f(3)</b> is then
evaluated by the compiler as the following function call:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>f.operator()(3);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which returns the value of the expression <b>3 &gt; value</b>,
which is false when <b>value</b> is 4, as it is in this example.</p>

<p class=MsoNormal>Since such comparisons apply to types other than <b>int</b>,
it would make sense to define <b>gt_n(&nbsp;)</b> as a class template. It turns
out you don’t have to do it yourself, though—the standard library has already
done it for you. The following descriptions of function objects should not only
make that topic clear, but also give you a better understanding of how the
generic algorithms work. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0656"
title="Add Comment A0656"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440082"></a><a name="_Toc22433872">Classification of
function objects</a></h3>

<p class=MsoNormal>The standard C++ library classifies function objects based
on the number of arguments that their <b>operator(&nbsp;)</b> takes and the
kind of value it returns. This classification is organized according to whether
a function object’s <b>operator(&nbsp;)</b> takes zero, one, or two arguments,
as the following definitions illustrate. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0657"
title="Add Comment A0657"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>Generator</b>: A type of function object that takes <i>no
arguments</i> and returns a value of an arbitrary type. A random number
generator is an example of a generator. The standard library provides one
generator, the function <b>rand(&nbsp;)</b> declared in <b>&lt;cstdlib&gt;</b>,
and has some algorithms, such as <b>generate_n(&nbsp;)</b>, which apply
generators to a sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0658"
title="Add Comment A0658"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>Unary Function</b>: A type of function object that takes
a <i>single argument</i> of any type and returns a value that may be of a
different type (which may be <b>void</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0659"
title="Add Comment A0659"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>Binary Function</b>: A type of function object that takes
<i>two arguments</i> of any two (possibly distinct) types and returns a value
of any type (including <b>void</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0660"
title="Add Comment A0660"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>Unary Predicate</b>: A Unary Function that returns a <b>bool</b>.</p>

<p class=MsoNormal><b>Binary Predicate</b>: A Binary Function that returns a <b>bool</b>.</p>

<p class=MsoNormal><b>Strict Weak Ordering</b>: A binary predicate that allows
for a more general interpretation of “equality.” Some of the standard
containers consider two elements equivalent if neither is less than the other
(using <b>operator&lt;(&nbsp;)</b>). This is important when comparing
floating-point values, and objects of other types where <b>operator==(&nbsp;)</b>
is unreliable or unavailable. This notion also applies if you want to sort a
sequence of data records (<b>struct</b>s) on a subset of the <b>struct</b>’s
fields, that comparison scheme is considered a strict weak ordering because two
records with equal keys are not really “equal” as total objects, but they are
equal as far as the comparison you’re using is concerned. The importance of
this concept will become clearer in the next chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0664"
title="Add Comment A0664"><sup>Comment</sup></a></p>

<p class=MsoNormal>In addition, certain algorithms make assumptions about the
operations available for the types of objects they process. We will use the
following terms to indicate these assumptions: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0665"
title="Add Comment A0665"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>LessThanComparable</b>: A class that has a less-than <b>operator&lt;</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0666"
title="Add Comment A0666"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>Assignable</b>: A class that has a copy-assignment <b>operator=</b>
for its own type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0667"
title="Add Comment A0667"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>EqualityComparable</b>: A class that has an equivalence <b>operator==</b>
for its own type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0668"
title="Add Comment A0668"><sup>Comment</sup></a></p>

<p class=MsoNormal>We will use these terms later in this chapter to describe
the generic algorithms in the standard library.</p>

<h3><a name="_Toc45440083"></a><a name="_Toc22433873">Automatic creation of
function objects</a></h3>

<p class=MsoNormal>The <b>&lt;functional&gt;</b> header defines a number of
useful generic function objects. They are admittedly simple, but you can use
them to compose more complicated function objects. Consequently, in many
instances, you can construct complicated predicates without writing a single
function yourself! You do so by using <i>function object adapters</i> to take
the simple function objects and adapt them for use with other function objects
in a chain of operations. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0669"
title="Add Comment A0669"><sup>Comment</sup></a></p>

<p class=MsoNormal>To illustrate, let’s use only standard function objects to
accomplish what <b>gt15(&nbsp;)</b> did earlier. The standard function object, <b>greater</b>,
is a <i>binary</i> function object that returns <b>true</b> if its first
argument is greater than its second argument. We cannot apply this directly to
a sequence of integers through an algorithm such as <b>remove_copy_if(&nbsp;)</b>,
because <b>remove_copy_if(&nbsp;)</b> expects a <i>unary</i> predicate. No
problem. We can construct a unary predicate on the fly that uses <b>greater</b>
to compare its first argument to a <i>fixed value</i>. We fix the value of the
second parameter that <b>greater</b> will use to be 15 with the function object
adapter <b>bind2nd</b>, like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1650"
title="Add Comment A1650"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CopyInts4.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses a standard function object
and adapter</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  remove_copy_if(a, a + SIZE,</p>

<p class=CodeChar style='margin-left:0in'>                
ostream_iterator&lt;int&gt;(cout, &quot;\n&quot;),</p>

<p class=CodeChar style='margin-left:0in'>                
bind2nd(greater&lt;int&gt;(), 15));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1649"
title="Add Comment A1649"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This program accomplishes the same thing as <b>CopyInts3.cpp</b>,
but without our having to write our own predicate function <b>gt15(&nbsp;)</b>.
The function object adapter <b>bind2nd(&nbsp;)</b> is a template function that
creates a function object of type <b>binder2nd</b>, which simply stores the two
arguments passed to <b>bind2nd(&nbsp;)</b>, the first of which must be a binary
function or function object (that is, anything that can be called with two
arguments). The <b>operator(&nbsp;)</b> function in <b>binder2nd</b>, which is
itself a unary function, calls the binary function it stored, passing it its
incoming parameter and the fixed value it stored. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1648"
title="Add Comment A1648"><sup>Comment</sup></a></p>

<p class=MsoNormal>To make the explanation concrete for this example, let’s
call the instance of <b>binder2nd</b> created by <b>bind2nd(&nbsp;)</b> by the
name <b>b</b>. When <b>b</b> is created, it receives two parameters (<b>greater&lt;int&gt;(&nbsp;)</b>
and 15) and stores them. Let’s call the instance of <b>greater&lt;int&gt;</b>
by the name <b>g</b>. For convenience, let’s also call the instance of the
output stream iterator by the name <b>o</b>. Then the call to <b>remove_copy_if(&nbsp;)</b>
earlier becomes the following:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1651"
title="Add Comment A1651"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>remove_copy_if(a, a + SIZE,
o, b(g, 15).operator());</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As <b>remove_copy_if(&nbsp;)</b> iterates through the
sequence, it calls <b>b</b> on each element, to determine whether to ignore the
element when copying to the destination. If we denote the current element by
the name <b>e</b>, that call inside <b>remove_copy_if(&nbsp;)</b> is equivalent
to <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1652"
title="Add Comment A1652"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if (b(e))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>but <b>binder2nd</b>’s function call operator just turns
around and calls <b>g(e,15)</b>, so the earlier call is the same as <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1653"
title="Add Comment A1653"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if (greater&lt;int&gt;(e,
15))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which is the comparison we were seeking. There is also a <b>bind1st(&nbsp;)</b>
adapter that creates a <b>binder1st</b> object, which fixes the <i>first</i>
argument of the associated input binary function. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1647"
title="Add Comment A1647"><sup>Comment</sup></a></p>

<p class=MsoNormal>As another example, let’s count the number of elements in
the sequence not equal to 20. This time we’ll use the algorithm <b>count_if(&nbsp;)</b>,
introduced earlier. There is a standard binary function object, <b>equal_to</b>,
and also a function object adapter, <b>not1(&nbsp;)</b>, that take a unary
function object as a parameter and invert its truth  value. The following
program will do the job. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1654"
title="Add Comment A1654"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CountNotEqual.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Count elements not equal to 20</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = {10, 20, 30};</p>

<p class=CodeChar style='margin-left:0in'>  const size_t SIZE = sizeof a /
sizeof a[0];</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; count_if(a, a + SIZE,</p>

<p class=CodeChar style='margin-left:0in'>                   not1(bind1st(equal_to&lt;int&gt;(),
20)));// 2</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1657"
title="Add Comment A1657"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As <b>remove_copy_if(&nbsp;)</b> did in the previous
example, <b>count_if(&nbsp;)</b> calls the predicate in its third argument
(let’s call it <b>n</b>) for each element of its sequence and increments its
internal counter each time <b>true</b> is returned. If, as before, we call the
current element of the sequence by the name <b>e</b>, the statement <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1658"
title="Add Comment A1658"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if (n(e))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>in the implementation of <b>count_if </b>is interpreted as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if
(!bind1st(equal_to&lt;int&gt;, 20)(e))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which of course ends up as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if
(!equal_to&lt;int&gt;(20, e))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>because <b>not1(&nbsp;)</b> returns the logical negation of
the result of calling its unary function argument. The first argument to <b>equal_to</b>
is 20 in this case because we used <b>bind1st(&nbsp;)</b> instead of <b>bind2nd(&nbsp;)</b>.
Since testing for equality is symmetric in its arguments, we could have used
either <b>bind1st(&nbsp;)</b> or <b>bind2nd(&nbsp;)</b> in this example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1655"
title="Add Comment A1655"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following table shows the templates that generate the
standard function objects, along with the kinds of expressions to which they
apply. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0670"
title="Add Comment A0670"><sup>Comment</sup></a></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <thead>
  <tr style='height:18.05pt'>
   <td width=145 valign=top style='width:108.9pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
   <p class=tablehead0>Name</p>
   </td>
   <td width=156 valign=top style='width:117.0pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
   <p class=tablehead0>Type</p>
   </td>
   <td width=210 valign=top style='width:157.5pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
   <p class=tablehead0>Result produced </p>
   </td>
  </tr>
 </thead>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>plus</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 + arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>minus</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 - arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>multiplies</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 * arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>divides</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 / arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>modulus</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 % arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>negate</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>UnaryFunction</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>- arg1</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>equal_to</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 == arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>not_equal_to</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 != arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>greater</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 &gt; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>less</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 &lt; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>greater_equal</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 &gt;= arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>less_equal</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 &lt;= arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>logical_and</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 &amp;&amp; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>logical_or</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>arg1 || arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>logical_not</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>UnaryPredicate</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>!arg1</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>unary_negate</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>Unary Logical</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>!(UnaryPredicate(arg1))</p>
  </td>
 </tr>
 <tr style='height:18.05pt'>
  <td width=145 valign=top style='width:108.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>binary_negate</p>
  </td>
  <td width=156 valign=top style='width:117.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>Binary Logical</p>
  </td>
  <td width=210 valign=top style='width:157.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:18.05pt'>
  <p class=tabletext>!(BinaryPredicate(arg1, arg2))</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0671"
title="Add Comment A0671"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440084"></a><a name="_Toc22433874">Adaptable function
objects</a></h3>

<p class=MsoNormal>Standard function adapters such as <b>bind1st(&nbsp;)</b>
and <b>bind2nd(&nbsp;)</b> make some assumptions about the function objects
they process. To illustrate, consider the following expression from the last
line of the earlier <b>CountNotEqual.cpp</b> program: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1659"
title="Add Comment A1659"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>not1(bind1st(equal_to&lt;int&gt;(),
20))</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>bind1st(&nbsp;)</b> adapter creates a unary function
object of type <b>binder1st</b>, which simply stores an instance of <b>equal_to&lt;int&gt;</b>
and the value 20. The <b>binder1st::operator(&nbsp;)</b> function needs to know
its argument type and its return type; otherwise, it will not have a valid
declaration. The convention to solve this problem is to expect all function
objects to provide nested type definitions for these types. For unary functions,
the type names are <b>argument_type</b> and <b>result_type</b>; for binary
function objects they are <b>first_argument_type</b>, <b>second_argument_type</b>,
and <b>result_type</b>. Looking at the implementation of <b>bind1st(&nbsp;)</b>
and <b>binder1st</b> in the <b>&lt;functional&gt;</b> header reveals these
expectations. First inspect <b>bind1st(&nbsp;)</b>, as it might appear in a
typical library implementation: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1660"
title="Add Comment A1660"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class Op, class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>binder1st&lt;Op&gt; </p>

<p class=CodeChar style='margin-left:0in'>bind1st(const Op&amp; f, const T&amp;
val) </p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename
Op::first_argument_type Arg1_t;</p>

<p class=CodeChar style='margin-left:0in'>  return binder1st&lt;Op&gt;(f,
Arg1_t(val));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note that the template parameter, <b>Op</b>, which
represents the type of the binary function being adapted by <b>bind1st(&nbsp;)</b>,
must have a nested type named <b>first_argument_type</b>. (Note also the use of
<b>typename</b> to inform the compiler that it is a member <i>type</i> name, as
explained in Chapter 5.) Now notice how <b>binder1st</b> uses the type names in
<b>Op</b> in its declaration of its function call operator: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1661"
title="Add Comment A1661"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Inside the implementation for
binder1st&lt;Op&gt;…</p>

<p class=CodeChar style='margin-left:0in'>typename Op::result_type</p>

<p class=CodeChar style='margin-left:0in'>operator()(const typename
Op::second_argument_type&amp; x) </p>

<p class=CodeInlineCharChar style='margin-left:0in'>  const;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Function objects whose classes provide these type names are
called <i>adaptable function objects</i>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1662"
title="Add Comment A1662"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since these names are expected of all standard function objects
as well as of any function objects you create that you want to use with the
function object adapters, the <b>&lt;functional&gt;</b> header provides two
templates that define these types for you: <b>unary_function</b> and <b>binary_function</b>.
You simply derive from these classes while filling in the argument types as
template parameters. Suppose, for example, that we want to make the function
object <b>gt_n</b>, defined earlier in this chapter, adaptable. All we need to
do is the following: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1663"
title="Add Comment A1663"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>class gt_n : public
unary_function&lt;int, bool&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  int value;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  gt_n(int val) : value(val) {}</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(int n) {</p>

<p class=CodeChar style='margin-left:0in'>    return n &gt; value;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}; <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1664"
title="Add Comment A1664"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All <b>unary_function</b> does is to provide the appropriate
type definitions, which it infers from its template parameters as you can see
in its definition: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1665"
title="Add Comment A1665"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class Arg, class
Result&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct unary_function {</p>

<p class=CodeChar style='margin-left:0in'>  typedef Arg argument_type;</p>

<p class=CodeChar style='margin-left:0in'>  typedef Result result_type;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>These types become accessible through <b>gt_n</b> because it
derives publicly from <b>unary_function</b>. The <b>binary_function</b>
template behaves in a similar manner. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1666"
title="Add Comment A1666"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440085"></a><a name="_Toc22433875">More function object
examples</a></h3>

<p class=MsoNormal>The following <b>FunctionObjects.cpp</b> example provides
simple tests for most of the built-in basic function object templates. This
way, you can see how to use each template, along with their resulting behavior.
This example uses one of the following generators for convenience: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0672"
title="Add Comment A0672"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Generators.h</p>

<p class=CodeChar style='margin-left:0in'>// Different ways to fill sequences</p>

<p class=CodeChar style='margin-left:0in'>#ifndef GENERATORS_H</p>

<p class=CodeChar style='margin-left:0in'>#define GENERATORS_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>// Microsoft namespace work-around</p>

<p class=CodeChar style='margin-left:0in'>#ifndef _MSC_VER</p>

<p class=CodeChar style='margin-left:0in'>using std::rand;</p>

<p class=CodeChar style='margin-left:0in'>using std::srand;</p>

<p class=CodeChar style='margin-left:0in'>using std::time;</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>// A generator that can skip over
numbers:</p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>class SkipGen {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  int i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  int skp;</span></p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  SkipGen(int start = 0, int skip =
1)</p>

<p class=CodeChar style='margin-left:0in'>    : i(start), skp(skip) {}</p>

<p class=CodeChar style='margin-left:0in'>  int operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    int r = i;</p>

<p class=CodeChar style='margin-left:0in'>    i += skp;</p>

<p class=CodeChar style='margin-left:0in'>    return r;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Generate unique random numbers
from 0 to mod:</p>

<p class=CodeChar style='margin-left:0in'>class URandGen {</p>

<p class=CodeChar style='margin-left:0in'>  std::set&lt;int&gt; used;</p>

<p class=CodeChar style='margin-left:0in'>  int limit;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  URandGen(int lim) : limit(lim) { </p>

<p class=CodeChar style='margin-left:0in'>    srand(time(0)); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    while(true) {</p>

<p class=CodeChar style='margin-left:0in'>      int i = int(rand()) % limit;</p>

<p class=CodeChar style='margin-left:0in'>      if(used.find(i) == used.end())
{</p>

<p class=CodeChar style='margin-left:0in'>        used.insert(i);</p>

<p class=CodeChar style='margin-left:0in'>        return i;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Produces
random characters:</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>class CharGen
{</p>

<p class=CodeChar style='margin-left:0in'>  static const char* source;</p>

<p class=CodeChar style='margin-left:0in'>  static const int len;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  CharGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  char operator()() { </p>

<p class=CodeChar style='margin-left:0in'>    return source[rand() % len];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Statics created here for
convenience, but</p>

<p class=CodeChar style='margin-left:0in'>// will cause problems if multiply
included:</p>

<p class=CodeChar style='margin-left:0in'>const char* CharGen::source =
&quot;ABCDEFGHIJK&quot;</p>

<p class=CodeChar style='margin-left:0in'> 
&quot;LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;</p>

<p class=CodeChar style='margin-left:0in'>const int CharGen::len =
strlen(source);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // GENERATORS_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We’ll be using these generating functions in various
examples throughout this chapter. The <b>SkipGen</b> function object returns
the next number of an arithmetic sequence whose common difference is held in
its <b>skp</b> data member. A <b>URandGen</b> object generates a unique random
number in a specified range. (It uses a <b>set</b> container, which we’ll
discuss in the next chapter.) A <b>CharGen</b> object returns a random
alphabetic character. Here is the sample program we promised, which uses <b>URandGen</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1673"
title="Add Comment A1673"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:FunctionObjects.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates selected predefined
function object</p>

<p class=CodeChar style='margin-left:0in'>// templates from the standard C++
library</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Iter&gt; </p>

<p class=CodeChar style='margin-left:0in'>void print(Iter b, Iter e, char* msg
= &quot;&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>  if(msg != 0 &amp;&amp; *msg != 0)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; msg &lt;&lt;
&quot;:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  typedef typename Iter::value_type
T;</p>

<p class=CodeChar style='margin-left:0in'>  copy(b, e,
ostream_iterator&lt;T&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename Contain,
typename UnaryFunc&gt; </p>

<p class=CodeChar style='margin-left:0in'>void testUnary(Contain&amp; source,
Contain&amp; dest,</p>

<p class=CodeChar style='margin-left:0in'>  UnaryFunc f) {</p>

<p class=CodeChar style='margin-left:0in'>  transform(source.begin(),
source.end(), </p>

<p class=CodeChar style='margin-left:0in'>    dest.begin(), f);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename Contain1,
typename Contain2, </p>

<p class=CodeChar style='margin-left:0in'>  typename BinaryFunc&gt; </p>

<p class=CodeChar style='margin-left:0in'>void testBinary(Contain1&amp; src1,
Contain1&amp; src2,</p>

<p class=CodeChar style='margin-left:0in'>  Contain2&amp; dest, BinaryFunc f) {</p>

<p class=CodeChar style='margin-left:0in'>  transform(src1.begin(), src1.end(),
</p>

<p class=CodeChar style='margin-left:0in'>    src2.begin(), dest.begin(), f);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Executes the expression, then
stringizes the</p>

<p class=CodeChar style='margin-left:0in'>// expression into the print
statement:</p>

<p class=CodeChar style='margin-left:0in'>#define T(EXPR) EXPR; print(r.begin(),
r.end(), \</p>

<p class=CodeChar style='margin-left:0in'>  &quot;After &quot; #EXPR);</p>

<p class=CodeChar style='margin-left:0in'>// For Boolean tests:</p>

<p class=CodeChar style='margin-left:0in'>#define B(EXPR) EXPR;
print(br.begin(), br.end(), \</p>

<p class=CodeChar style='margin-left:0in'>  &quot;After &quot; #EXPR);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Boolean random generator:</p>

<p class=CodeChar style='margin-left:0in'>struct BRand {</p>

<p class=CodeChar style='margin-left:0in'>  BRand() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    return rand() &gt; RAND_MAX / 2;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 10;</p>

<p class=CodeChar style='margin-left:0in'>  const int max = 50;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; x(sz), y(sz),
r(sz);</p>

<p class=CodeChar style='margin-left:0in'>  // An integer random number
generator:</p>

<p class=CodeChar style='margin-left:0in'>  URandGen urg(max);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(x.begin(), sz, urg);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(y.begin(), sz, urg);</p>

<p class=CodeChar style='margin-left:0in'>  // Add one to each to guarantee
nonzero divide:</p>

<p class=CodeChar style='margin-left:0in'>  transform(y.begin(), y.end(),
y.begin(),</p>

<p class=CodeChar style='margin-left:0in'>    bind2nd(plus&lt;int&gt;(), 1));</p>

<p class=CodeChar style='margin-left:0in'>  // Guarantee one pair of elements
is ==:</p>

<p class=CodeChar style='margin-left:0in'>  x[0] = y[0];</p>

<p class=CodeChar style='margin-left:0in'>  print(x.begin(), x.end(),
&quot;x&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(y.begin(), y.end(),
&quot;y&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Operate on each element pair of
x &amp; y,</p>

<p class=CodeChar style='margin-left:0in'>  // putting the result into r:</p>

<p class=CodeChar style='margin-left:0in'>  T(testBinary(x, y, r,
plus&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  T(testBinary(x, y, r,
minus&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  T(testBinary(x, y, r,
multiplies&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  T(testBinary(x, y, r,
divides&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  T(testBinary(x, y, r,
modulus&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  T(testUnary(x, r,
negate&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;bool&gt; br(sz); // For
Boolean results</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br,
equal_to&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br,
not_equal_to&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br,
greater&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br, less&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br,
greater_equal&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br,
less_equal&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(x, y, br, </p>

<p class=CodeChar style='margin-left:0in'>   
not2(greater_equal&lt;int&gt;())));</p>

<p class=CodeChar style='margin-left:0in'> 
B(testBinary(x,y,br,not2(less_equal&lt;int&gt;())));</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;bool&gt; b1(sz), b2(sz);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(b1.begin(), sz,
BRand());</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(b2.begin(), sz,
BRand());</p>

<p class=CodeChar style='margin-left:0in'>  print(b1.begin(), b1.end(),
&quot;b1&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(b2.begin(), b2.end(),
&quot;b2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(b1, b2, br,
logical_and&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testBinary(b1, b2, br,
logical_or&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testUnary(b1, br,
logical_not&lt;int&gt;()));</p>

<p class=CodeChar style='margin-left:0in'>  B(testUnary(b1, br,
not1(logical_not&lt;int&gt;())));</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>To keep this example short, we used a few handy tricks. The <b>print(&nbsp;)</b>
template is designed to print any sequence, along with an optional message.
Since <b>print(&nbsp;)</b> uses the <b>copy(&nbsp;)</b> algorithm to send
objects to <b>cout</b> via an <b>ostream_iterator</b>, the <b>ostream_iterator</b>
must know the type of object it is printing, which we infer from the <b>value_type</b>
member of the iterator passed<a href="#_ftn70" name="_ftnref70" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[70]</span></sup></span></span></sup></span></a>. As
you can see in <b>main(&nbsp;)</b>, however, the compiler can deduce the type
of <b>T</b> when you hand it a <b>vector&lt;T&gt;</b>, so you don’t have to
specify that template argument explicitly; you just say <b>print(x)</b> to
print the <b>vector&lt;T&gt; x</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0673"
title="Add Comment A0673"><sup>Comment</sup></a></p>

<p class=MsoNormal>The next two template functions automate the process of
testing the various function object templates. There are two since the function
objects are either unary or binary. The <b>testUnary(&nbsp;)</b> function takes
a source vector, a destination vector, and a unary function object to apply to
the source vector to produce the destination vector. In <b>testBinary(&nbsp;)</b>,
two source vectors are fed to a binary function to produce the destination
vector. In both cases, the template functions simply turn around and call the <b>transform(&nbsp;)</b>
algorithm, which applies the unary function/function object found in its fourth
parameter to each sequence element, writing the result to the sequence
indicated by its third parameter, which in this case is the same as the input
sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0674"
title="Add Comment A0674"><sup>Comment</sup></a></p>

<p class=MsoNormal>For each test, you want to see a string describing the test,
followed by the results of the test. To automate this, the preprocessor comes
in handy; the <b>T(&nbsp;)</b> and <b>B(&nbsp;)</b> macros each take the
expression you want to execute. After evaluating the expression, they pass the
appropriate range to <b>print(&nbsp;)</b>. To produce the message the
expression is “string-ized” using the preprocessor. That way you see the code
of the expression that is executed followed by the result vector. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0675"
title="Add Comment A0675"><sup>Comment</sup></a></p>

<p class=MsoNormal>The last little tool, <b>BRand</b>, is a generator object
that creates random <b>bool</b> values. To do this, it gets a random number
from <b>rand(&nbsp;)</b> and tests to see if it’s greater than <b>(RAND_MAX+1)/2</b>.
If the random numbers are evenly distributed, this should happen half the time.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0676"
title="Add Comment A0676"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, three vectors of <b>int</b> are
created: <b>x</b> and <b>y</b> for source values, and <b>r</b> for results. To
initialize <b>x</b> and <b>y</b> with random values no greater than 50, a
generator of type <b>URandGen</b> from <b>Generators.h</b> is used. The
standard <b>generate_n(&nbsp;)</b> algorithm populates the sequence specified
in its first argument by invoking its third argument (which must be a
generator) a given number of times (specified in its second argument). Since
there is one operation in which elements of <b>x</b> are divided by elements of
<b>y</b>, we must ensure that there are no zero values of <b>y</b>. This is
accomplished by once again using the <b>transform(&nbsp;)</b> algorithm, taking
the source values from <b>y</b> and putting the results back into <b>y</b>. The
function object for this is created with the expression: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0677"
title="Add Comment A0677"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>bind2nd(plus&lt;int&gt;(),
1)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This expression uses the <b>plus</b> function object to add
1 to its first argument. As we did earlier in this chapter, we use a binder
adapter to make this a unary function so it can applied to the sequence by a
single call to <b>transform(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1672"
title="Add Comment A1672"><sup>Comment</sup></a></p>

<p class=MsoNormal>Another test in the program compares the elements in the two
vectors for equality, so it is interesting to guarantee that at least one pair
of elements is equivalent; in this case element zero is chosen. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0679"
title="Add Comment A0679"><sup>Comment</sup></a></p>

<p class=MsoNormal>Once the two vectors is printed, <b>T(&nbsp;)</b> is used to
test each of the function objects that produces a numeric value, and then <b>B(&nbsp;)</b>
is used to test each function object that produces a Boolean result. The result
is placed into a <b>vector&lt;bool&gt;</b>, and when this vector is printed, it
produces a ‘<b>1</b>’ for a true value and a ‘<b>0</b>’ for a false value. Here
is the output from an execution of <b>FunctionObjects.cpp</b>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0680"
title="Add Comment A0680"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>x:</p>

<p class=CodeChar style='margin-left:0in'>4 8 18 36 22 6 29 19 25 47 </p>

<p class=CodeChar style='margin-left:0in'>y:</p>

<p class=CodeChar style='margin-left:0in'>4 14 23 9 11 32 13 15 44 30 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, r,
plus&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>8 22 41 45 33 38 42 34 69 77 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, r,
minus&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 -6 -5 27 11 -26 16 4 -19 17 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, r,
multiplies&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>16 112 414 324 242 192 377 285 1100
1410 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, r,
divides&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>1 0 0 4 2 0 2 1 0 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, r,
limit&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 8 18 0 0 6 3 4 25 17 </p>

<p class=CodeChar style='margin-left:0in'>After testUnary(x, r,
negate&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>-4 -8 -18 -36 -22 -6 -29 -19 -25 -47 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
equal_to&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>1 0 0 0 0 0 0 0 0 0 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
not_equal_to&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 1 1 1 1 1 1 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
greater&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 0 0 1 1 0 1 1 0 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
less&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 1 0 0 1 0 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
greater_equal&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>1 0 0 1 1 0 1 1 0 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
less_equal&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>1 1 1 0 0 1 0 0 1 0 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(x, y, br,
not2(greater_equal&lt;int&gt;())):</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 1 0 0 1 0 </p>

<p class=CodeChar style='margin-left:0in'>After
testBinary(x,y,br,not2(less_equal&lt;int&gt;())):</p>

<p class=CodeChar style='margin-left:0in'>0 0 0 1 1 0 1 1 0 1 </p>

<p class=CodeChar style='margin-left:0in'>b1:</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 0 1 0 1 1 </p>

<p class=CodeChar style='margin-left:0in'>b2:</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 0 1 0 1 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(b1, b2, br,
logical_and&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 0 1 0 1 1 </p>

<p class=CodeChar style='margin-left:0in'>After testBinary(b1, b2, br, logical_or&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>0 1 1 0 0 0 1 0 1 1 </p>

<p class=CodeChar style='margin-left:0in'>After testUnary(b1, br,
logical_not&lt;int&gt;()):</p>

<p class=CodeChar style='margin-left:0in'>1 0 0 1 1 1 0 1 0 0 </p>

<p class=CodeChar style='margin-left:0in'>After testUnary(b1, br,
not1(logical_not&lt;int&gt;())):</p>

<p class=CodeInlineCharChar style='margin-left:0in'>0 1 1 0 0 0 1 0 1 1</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A binder doesn’t have to produce a unary <i>predicate</i>;
it can also create any unary <i>function</i> (that is, a function that returns
something other than <b>bool</b>). For example, suppose you’d like to multiply
every element in a <b>vector</b> by 10. Using a binder with the <b>transform(&nbsp;)</b>
algorithm does the trick: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0689"
title="Add Comment A0689"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:FBinder.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Binders aren't limited to
producing predicates</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;int&gt;
out(cout,&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v(15);</p>

<p class=CodeChar style='margin-left:0in'>  generate(v.begin(), v.end(),
URandGen(20));</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(), out);</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'> 
transform(v.begin(), v.end(), v.begin(),</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>           
bind2nd(multiplies&lt;int&gt;(), 10));</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(), out);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since the third argument to <b>transform(&nbsp;) </b>is the
same as the first, the resulting elements are copied back into the source
vector. The function object created by <b>bind2nd(&nbsp;)</b> in this case
produces an <b>int</b> result. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0690"
title="Add Comment A0690"><sup>Comment</sup></a></p>

<p class=MsoNormal>The “bound” argument to a binder cannot be a function
object, but it does not have to be a compile-time constant. For example: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0691"
title="Add Comment A0691"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:BinderValue.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The bound argument can vary</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int boundedRand() { return rand() %
100; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int SZ = 20;</p>

<p class=CodeChar style='margin-left:0in'>  int a[SZ], b[SZ] = {0};</p>

<p class=CodeChar style='margin-left:0in'>  generate(a, a + SZ, boundedRand);</p>

<p class=CodeChar style='margin-left:0in'>  int val = boundedRand();</p>

<p class=CodeChar style='margin-left:0in'>  int* end = remove_copy_if(a, a +
SZ, b,</p>

<p class=CodeChar style='margin-left:0in'>                            bind2nd(greater&lt;int&gt;(),
val));</p>

<p class=CodeChar style='margin-left:0in'>  // Sort for easier viewing:</p>

<p class=CodeChar style='margin-left:0in'>  sort(a, a + SZ);</p>

<p class=CodeChar style='margin-left:0in'>  sort(b, end);</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;int&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Original
Sequence:\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a + SZ, out); cout &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Values less
&lt;= &quot; &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(b, end, out); cout &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here, an array is filled with 20 random numbers between 0
and 100, and the user provides a value on the command line. In the <b>remove_copy_if(&nbsp;)</b>
call, you can see that the bound argument to <b>bind2nd(&nbsp;)</b> is random
number in the same range as the sequence. The output of a sample execution
follows. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0692"
title="Add Comment A0692"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Original Sequence:</p>

<p class=CodeChar style='margin-left:0in'>4 12 15 17 19 21 26 30 47 48 56 58 60
63 71 79 82 90 92 95 </p>

<p class=CodeChar style='margin-left:0in'>Values less &lt;= 41</p>

<p class=CodeInlineCharChar style='margin-left:0in'>4 12 15 17 19 21 26 30</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440086"></a><a name="_Toc22433876">Function pointer adapters</a></h3>

<p class=MsoNormal>Wherever a function-like entity is expected by an algorithm,
you can supply either a pointer to an ordinary function or a function object.
When the algorithm issues a call, if it is through a function pointer, than the
native function-call mechanism is used. If it through a function object, then
that objects <b>operator(&nbsp;)</b> member executes. You saw earlier, for
example, that we passed a raw function, <b>gt15(&nbsp;)</b>, as a predicate to <b>remove_copy_if(&nbsp;)</b>
in the program <b>CopyInts2.cpp</b>. We also passed pointers to functions
returning random numbers to <b>generate(&nbsp;)</b> and <b>generate_n(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0693"
title="Add Comment A0693"><sup>Comment</sup></a></p>

<p class=MsoNormal>You cannot, however, use raw functions with function object
adapters, such as <b>bind2nd(&nbsp;)</b>, because they assume the existence of
type definitions for the argument and result types. Instead of manually
converting your native functions into function objects yourself, the standard
library provides a family of adapters to do the work for you. The <b>ptr_fun(&nbsp;)
</b>adapters take a pointer to a function and turn it into a function object.
They are not designed for a function that takes no arguments—they must only be
used with unary functions or binary functions. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1671"
title="Add Comment A1671"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following program uses <b>ptr_fun(&nbsp;)</b> to wrap a
unary function.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:PtrFun1.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using ptr_fun() with a unary
function</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int d[] = {123, 94, 10, 314, 315};</p>

<p class=CodeChar style='margin-left:0in'>const int DSZ = sizeof d / sizeof *d;</p>

<p class=CodeChar style='margin-left:0in'>bool isEven(int x) {</p>

<p class=CodeChar style='margin-left:0in'>  return x % 2 == 0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;bool&gt; vb;</p>

<p class=CodeChar style='margin-left:0in'>  transform(d, d + DSZ,
back_inserter(vb), </p>

<p class=CodeChar style='margin-left:0in'>    not1(ptr_fun(isEven)));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;bool&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Output: 1 0 0 0 1</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We can’t simply pass <b>isEven</b> to <b>not1</b>, because <b>not1</b>
needs to know the actual argument type and return type its argument uses. The <b>ptr_fun(&nbsp;)</b>
adapter deduces those types through template argument deduction. The definition
of the unary version of <b>ptr_fun(&nbsp;)</b> looks something like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1670"
title="Add Comment A1670"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class Arg, class
Result&gt;</p>

<p class=CodeChar style='margin-left:0in'>pointer_to_unary_function&lt;Arg,
Result&gt;</p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>ptr_fun(Result
(*fptr)(Arg))</span></p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  return pointer_to_unary_function&lt;Arg,
Result&gt;(fptr);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As you can see, this version of <b>ptr_fun(&nbsp;)</b>
deduces the argument and result types from <b>fptr</b> and uses them to
initialize a <b>pointer_to_unary_function</b> object that stores <b>fptr</b>.
The function call operator for <b>pointer_to_unary_function</b> just calls <b>fptr</b>,
as you can see by the last line of its code: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1669"
title="Add Comment A1669"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class Arg, class
Result&gt;</p>

<p class=CodeChar style='margin-left:0in'>class pointer_to_unary_function</p>

<p class=CodeChar style='margin-left:0in'>: public unary_function&lt;Arg,
Result&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  Result (*fptr)(Arg); // stores the
f-ptr</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  pointer_to_unary_function(Result
(*x)(Arg))</p>

<p class=CodeChar style='margin-left:0in'>    : fptr(x) {}</p>

<p class=CodeChar style='margin-left:0in'>  Result operator()(Arg x) const
{return fptr(x);}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>pointer_to_unary_function</b> derives from <b>unary_function</b>,
the appropriate type definitions come along for the ride and are available to <b>not1</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1668"
title="Add Comment A1668"><sup>Comment</sup></a></p>

<p class=MsoNormal>There is also a binary version of <b>ptr_fun(&nbsp;),</b>
which returns a <b>pointer_to_binary_function</b> object (which derives from <b>binary_function</b>,
of course) that behaves analogously to the unary case. The following program
uses the binary version of <b>ptr_fun(&nbsp;)</b> to raise numbers in a
sequence to a power. It also reveals a “gotcha” when passing overloaded
functions to <b>ptr_fun(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0697"
title="Add Comment A0697"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:PtrFun2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using ptr_fun() for a binary
function</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cmath&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>double d[] = { 01.23, 91.370, 56.661,</p>

<p class=CodeChar style='margin-left:0in'>  023.230, 19.959, 1.0, 3.14159 };</p>

<p class=CodeChar style='margin-left:0in'>const int DSZ = sizeof d / sizeof *d;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;double&gt; vd;</p>

<p class=CodeChar style='margin-left:0in'>  transform(d, d + DSZ,
back_inserter(vd), </p>

<p class=CodeChar style='margin-left:0in'>    bind2nd(ptr_fun&lt;double,
double, double&gt;(pow), 2.0));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vd.begin(), vd.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;double&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;    </p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>pow(&nbsp;)</b> function is overloaded in the standard
C++ header <b>&lt;cmath&gt;</b> for each of the floating-point data types, as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>float pow(float, int);  // efficient
int power versions…</p>

<p class=CodeChar style='margin-left:0in'>double pow(double, int);</p>

<p class=CodeChar style='margin-left:0in'>long double pow(long double, int);</p>

<p class=CodeChar style='margin-left:0in'>float pow(float, float);</p>

<p class=CodeChar style='margin-left:0in'>double pow(double, double);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>long double pow(long
double, long double);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since there are multiple versions of <b>pow(&nbsp;)</b>, the
compiler has no way of knowing which to choose. In this case, we have to help
the compiler by using explicit function template specialization, as explained
in the previous chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1667"
title="Add Comment A1667"><sup>Comment</sup></a></p>

<p class=MsoNormal>An even trickier problem is that of converting a member
function into a function object suitable for using with the generic algorithms.
As a simple example, suppose we have the classical “shape” problem and want to
apply the <b>draw(&nbsp;)</b> member function to each pointer in a container of
<b>Shape</b>: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0699"
title="Add Comment A0699"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:MemFun1.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Applying pointers to member
functions</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Circle::Draw()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Circle::~Circle()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Square::Draw()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Square::~Square()&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Shape*&gt; vs;</p>

<p class=CodeChar style='margin-left:0in'>  vs.push_back(new Circle);</p>

<p class=CodeChar style='margin-left:0in'>  vs.push_back(new Square);</p>

<p class=CodeChar style='margin-left:0in'>  for_each(vs.begin(), vs.end(), </p>

<p class=CodeChar style='margin-left:0in'>    mem_fun(&amp;Shape::draw));</p>

<p class=CodeChar style='margin-left:0in'>  purge(vs);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>for_each(&nbsp;)</b> algorithm does just what it
sounds like it: it passes each element in a sequence to the function object
denoted by its third argument. In this case, we want the function object to
wrap one of the member functions of the class itself, and so the function
object’s “argument” becomes the pointer to the object that the member function
is called for. To produce such a function object, the <b>mem_fun(&nbsp;)</b>
template takes a pointer to a member as its argument. The <b>purge(&nbsp;)</b>
function is just a little something we wrote that calls delete on every element
of sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0700"
title="Add Comment A0700"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>mem_fun(&nbsp;)</b> functions are for producing
function objects that are called using a pointer to the object that the member
function is called for, while <b>mem_fun_ref(&nbsp;)</b> is used for calling
the member function directly for an object. One set of overloads of both <b>mem_fun(&nbsp;)</b>
and <b>mem_fun_ref(&nbsp;)</b> is for member functions that take zero arguments
and one argument, and this is multiplied by two to handle <b>const</b> vs. non-<b>const</b>
member functions. However, templates and overloading takes care of sorting all
that out; all you need to remember is when to use <b>mem_fun(&nbsp;)</b> vs. <b>mem_fun_ref(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0701"
title="Add Comment A0701"><sup>Comment</sup></a></p>

<p class=MsoNormal>Suppose you have a container of objects (not pointers), and
you want to call a member function that takes an argument. The argument you
pass should come from a second container of objects. To accomplish this, use
the second overloaded form of the <b>transform(&nbsp;)</b> algorithm: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0702"
title="Add Comment A0702"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:MemFun2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Calling member functions through
an object reference</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Angle {</p>

<p class=CodeChar style='margin-left:0in'>  int degrees;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Angle(int deg) : degrees(deg) {}</p>

<p class=CodeChar style='margin-left:0in'>  int mul(int times) {</p>

<p class=CodeChar style='margin-left:0in'>    return degrees *= times;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Angle&gt; va;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 50; i += 10)</p>

<p class=CodeChar style='margin-left:0in'>    va.push_back(Angle(i));</p>

<p class=CodeChar style='margin-left:0in'>  int x[] = { 1, 2, 3, 4, 5 };</p>

<p class=CodeChar style='margin-left:0in'>  transform(va.begin(), va.end(), x,</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;),</p>

<p class=CodeChar style='margin-left:0in'>    mem_fun_ref(&amp;Angle::mul));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Output: 0 20 60 120 200</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Because the container is holding objects, <b>mem_fun_ref(&nbsp;)</b>
must be used with the pointer-to-member function. This version of <b>transform(&nbsp;)</b>
takes the start and end point of the first range (where the objects live); the
starting point of the second range, which holds the arguments to the member
function; the destination iterator, which in this case is standard output; and
the function object to call for each object. This function object is created
with <b>mem_fun_ref(&nbsp;)</b> and the desired pointer to member. Notice that
the <b>transform(&nbsp;)</b> and <b>for_each(&nbsp;)</b> template functions are
incomplete; <b>transform(&nbsp;)</b> requires that the function it calls return
a value, and there is no <b>for_each(&nbsp;)</b> that passes two arguments to
the function it calls. Thus, you cannot call a member function that returns <b>void</b>
and takes an argument using <b>transform(&nbsp;)</b> or <b>for_each(&nbsp;)</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0703"
title="Add Comment A0703"><sup>Comment</sup></a></p>

<p class=MsoNormal>Most any member function works with <b>mem_fun_ref(&nbsp;)</b>.
You can also use standard library member functions, if your compiler doesn’t
add any default arguments beyond the normal arguments specified in the standard<a
href="#_ftn71" name="_ftnref71" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[71]</span></sup></span></span></sup></span></a>. For example, suppose
you’d like to read a file and search for blank lines; your compiler may allow
you to use the <b>string::empty(&nbsp;)</b> member function like this: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0704"
title="Add Comment A0704"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:FindBlanks.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrates mem_fun_ref() with
string::empty()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef
vector&lt;string&gt;::iterator LSI;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;FindBlanks.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; vs;</p>

<p class=CodeChar style='margin-left:0in'>  string s;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, s))</p>

<p class=CodeChar style='margin-left:0in'>    vs.push_back(s);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; cpy = vs; //
For testing</p>

<p class=CodeChar style='margin-left:0in'>  LSI lsi = find_if(vs.begin(),
vs.end(),</p>

<p class=CodeChar style='margin-left:0in'>    
mem_fun_ref(&amp;string::empty));</p>

<p class=CodeChar style='margin-left:0in'>  while(lsi != vs.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    *lsi = &quot;A BLANK LINE&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    lsi = find_if(vs.begin(),
vs.end(),</p>

<p class=CodeChar style='margin-left:0in'>     
mem_fun_ref(&amp;string::empty));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
cpy.size(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    if(cpy[i].size() == 0)</p>

<p class=CodeChar style='margin-left:0in'>      assert(vs[i] == &quot;A BLANK
LINE&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    else</p>

<p class=CodeChar style='margin-left:0in'>      assert(vs[i] != &quot;A BLANK
LINE&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example uses <b>find_if(&nbsp;)</b> to locate the first
blank line in the given range using <b>mem_fun_ref(&nbsp;)</b> with <b>string::empty(&nbsp;)</b>.
After the file is opened and read into the vector, the process is repeated to
find every blank line in the file. Each time a blank line is found, it is
replaced with the characters “A BLANK LINE.” All you have to do to accomplish
this is dereference the iterator to select the current string. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0705"
title="Add Comment A0705"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440087"></a><a name="_Toc22433877">Writing your own function
object adapters</a></h3>

<p class=MsoNormal>Consider how to write a program that converts strings
representing floating-point numbers to their actual numeric values. To get
things started, here’s a generator that creates the strings: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0706"
title="Add Comment A0706"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:NumStringGen.h</p>

<p class=CodeChar style='margin-left:0in'>// A random number generator that
produces </p>

<p class=CodeChar style='margin-left:0in'>// strings representing
floating-point numbers</p>

<p class=CodeChar style='margin-left:0in'>#ifndef NUMSTRINGGEN_H</p>

<p class=CodeChar style='margin-left:0in'>#define NUMSTRINGGEN_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class NumStringGen {</p>

<p class=CodeChar style='margin-left:0in'>  const int SZ; // Number of digits
to make</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  NumStringGen(int ssz = 5) : SZ(ssz)
{ </p>

<p class=CodeChar style='margin-left:0in'>    std::srand(std::time(0)); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  std::string operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    static char n[] =
&quot;0123456789&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    const int NSZ = sizeof n / sizeof
*n;</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>std::string r(SZ, '
');</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    for(int i = 0; i
&lt; SZ; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>      </span>if(i ==
SZ/2)</p>

<p class=CodeChar style='margin-left:0in'>        r[i] = '.'; // Insert a
decimal point</p>

<p class=CodeChar style='margin-left:0in'>      else</p>

<p class=CodeChar style='margin-left:0in'>        r[i] = n[std::rand() % NSZ];</p>

<p class=CodeChar style='margin-left:0in'>    return r;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // NUMSTRINGGEN_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You tell it how big the strings should be when you create
the <b>NumStringGen</b> object. The random number generator is used to select
digits, and a decimal point is placed in the middle. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0707"
title="Add Comment A0707"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following program uses <b>NumStringGen</b> to fill a <b>vector&lt;string&gt;</b>.
However, to use the standard C library function <b>atof(&nbsp;)</b> to convert
the strings to floating-point numbers, the <b>string</b> objects must first be
turned into <b>char</b> pointers, since there is no automatic type conversion
from <b>string</b> to <b>char*</b>. The <b>transform(&nbsp;)</b> algorithm can
be used with <b>mem_fun_ref(&nbsp;)</b> and <b>string::c_str(&nbsp;)</b> to
convert all the <b>string</b>s to <b>char*</b>, and then these can be
transformed using <b>atof</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0708"
title="Add Comment A0708"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:MemFun3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using mem_fun()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;NumStringGen.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int SZ = 9;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; vs(SZ);</p>

<p class=CodeChar style='margin-left:0in'>  // Fill it with random number
strings:</p>

<p class=CodeChar style='margin-left:0in'>  generate(vs.begin(), vs.end(),
NumStringGen());</p>

<p class=CodeChar style='margin-left:0in'>  copy(vs.begin(), vs.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(cout, &quot;\t&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  const char* vcp[SZ];</p>

<p class=CodeChar style='margin-left:0in'>  transform(vs.begin(), vs.end(),
vcp, </p>

<p class=CodeChar style='margin-left:0in'>    mem_fun_ref(&amp;string::c_str));</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;double&gt; vd;</p>

<p class=CodeChar style='margin-left:0in'>  transform(vcp, vcp + SZ,
back_inserter(vd),</p>

<p class=CodeChar style='margin-left:0in'>    std::atof);</p>

<p class=CodeChar style='margin-left:0in'>  copy(vd.begin(), vd.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;double&gt;(cout, &quot;\t&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This program does two transformations: one to convert
strings to C-style strings (arrays of characters), and one to convert the
C-style strings to numbers via <b>atof(&nbsp;)</b>. It would be nice to combine
these two operations into one. After all, we can compose functions in
mathematics, so why not C++? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1674"
title="Add Comment A1674"><sup>Comment</sup></a></p>

<p class=MsoNormal>The obvious approach takes the two functions as arguments
and applies them in the proper order:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:ComposeTry.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A first attempt at implementing
function composition</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename R, typename E,
typename F1, typename F2&gt;</p>

<p class=CodeChar style='margin-left:0in'>class unary_composer {</p>

<p class=CodeChar style='margin-left:0in'>   F1 f1;</p>

<p class=CodeChar style='margin-left:0in'>   F2 f2;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   unary_composer(F1 fone, F2 ftwo) :
f1(fone), f2(ftwo) {}</p>

<p class=CodeChar style='margin-left:0in'>   R operator()(E x) {</p>

<p class=CodeChar style='margin-left:0in'>      return f1(f2(x));</p>

<p class=CodeChar style='margin-left:0in'>   }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename R, typename E,
typename F1, typename F2&gt;</p>

<p class=CodeChar style='margin-left:0in'>unary_composer&lt;R, E, F1, F2&gt;
compose(F1 f1, F2 f2) {</p>

<p class=CodeChar style='margin-left:0in'>   return unary_composer&lt;R, E, F1,
F2&gt;(f1, f2);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main()</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  double x =</p>

<p class=CodeChar style='margin-left:0in'>    compose&lt;double, const
string&amp;&gt;(atof, </p>

<p class=CodeChar style='margin-left:0in'>     
mem_fun_ref(&amp;string::c_str))(&quot;12.34&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(x == 12.34);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>unary_composer</b> object in this example stores the
function pointers <b>atof</b> and <b>string::c_str</b> such that the latter
function is applied first when its <b>operator(&nbsp;)</b> is called. The <b>compose(&nbsp;)</b>
function adapter is a convenience, so we don’t have to supply all four template
arguments explicitly—<b>F1</b> and <b>F2</b> are deduced from the call. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1675"
title="Add Comment A1675"><sup>Comment</sup></a></p>

<p class=MsoNormal>It would be much better, of course, if we didn’t have to
supply any template arguments at all. This is achieved by adhering to the
convention for type definitions for adaptable function objects; in other words,
we will assume that the functions to be composed are adaptable. This requires
that we use <b>ptr_fun(&nbsp;)</b> for <b>atof(&nbsp;)</b>. For maximum
flexibility, we also make <b>unary_composer</b> adaptable in case it gets
passed to a function adapter. The following program does so and easily solves
the original problem. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1676"
title="Add Comment A1676"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:ComposeFinal.cpp</p>

<p class=CodeChar style='margin-left:0in'>// An adaptable composer</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;NumStringGen.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename F1, typename
F2&gt;</p>

<p class=CodeChar style='margin-left:0in'>class unary_composer</p>

<p class=CodeChar style='margin-left:0in'>  : public unary_function&lt;typename
F2::argument_type,</p>

<p class=CodeChar style='margin-left:0in'>                          typename
F1::result_type&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   unary_composer(F1 f1, F2 f2) :
f1(f1), f2(f2) {}</p>

<p class=CodeChar style='margin-left:0in'>   typename F1::result_type</p>

<p class=CodeChar style='margin-left:0in'>     operator()(typename
F2::argument_type x) {</p>

<p class=CodeChar style='margin-left:0in'>      return f1(f2(x));</p>

<p class=CodeChar style='margin-left:0in'>   }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>   F1 f1;</p>

<p class=CodeChar style='margin-left:0in'>   F2 f2;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename F1, typename
F2&gt;</p>

<p class=CodeChar style='margin-left:0in'>unary_composer&lt;F1, F2&gt;
compose(F1 f1, F2 f2) {</p>

<p class=CodeChar style='margin-left:0in'>   return unary_composer&lt;F1,
F2&gt;(f1, f2);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 9;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; vs(sz);</p>

<p class=CodeChar style='margin-left:0in'>  // Fill it with random number
strings:</p>

<p class=CodeChar style='margin-left:0in'>  generate(vs.begin(), vs.end(),
NumStringGen());</p>

<p class=CodeChar style='margin-left:0in'>  copy(vs.begin(), vs.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(cout, &quot;\t&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;double&gt; vd;</p>

<p class=CodeChar style='margin-left:0in'>  transform(vs.begin(), vs.end(), back_inserter(vd),</p>

<p class=CodeChar style='margin-left:0in'>    compose(ptr_fun(atof),
mem_fun_ref(&amp;string::c_str)));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vd.begin(), vd.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;double&gt;(cout, &quot;\t&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Once again we must use <b>typename</b> to let the compiler
know that the member we are referring to is a nested type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1677"
title="Add Comment A1677"><sup>Comment</sup></a></p>

<p class=MsoNormal>Some implementations<a href="#_ftn72" name="_ftnref72"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[72]</span></sup></span></span></sup></span></a> support
composition of function objects as an extension, and the C++ standards
committee is likely to add these capabilities to the next version of standard
C++. <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1678"
title="Add Comment A1678"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440088"></a><a name="_Toc22433878">A
catalog of STL algorithms</a></h2>

<p class=MsoNormal>This section provides a quick reference for when you’re
searching for the appropriate algorithm. We leave the full exploration of all
the STL algorithms to other references (see the end of this chapter, and
Appendix A), along with the more intimate details of performance, and so on.
Our goal here is for you to become rapidly comfortable and facile with the
algorithms, and we’ll assume you will look into the more specialized references
if you need more depth of detail. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0720"
title="Add Comment A0720"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although you will often see the algorithms described using
their full template declaration syntax, we’re not doing that here because you
already know they are templates, and it’s quite easy to see what the template
arguments are from the function declarations. The type names for the arguments
provide descriptions for the types of iterators required. We think you’ll find
this form is easier to read, and you can quickly find the full declaration in
the template header file if for some reason you feel the need. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0721"
title="Add Comment A0721"><sup>Comment</sup></a></p>

<p class=MsoNormal>The reason for all the fuss about iterators is to
accommodate any type of container that meets the requirements in the standard
library. So far we have illustrated the generic algorithms with only arrays and
vectors as sequences, but in the next chapter you’ll see a broad range of data
structures that support less robust iteration. For this reason, the algorithms
are categorized in part by the types of iteration facilities they require. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1680"
title="Add Comment A1680"><sup>Comment</sup></a></p>

<p class=MsoNormal>The names of the iterator classes describe the iterator type
to which they must conform. There are no interface base classes to enforce
these iteration operations—they are just expected to be there. If they are not,
your compiler will complain. The various flavors of iterators are described
briefly as follows. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0722"
title="Add Comment A0722"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>InputIterator</b>.<b> </b> An input iterator only allows <i>reading</i>
elements of its sequence in a single, forward pass using <b>operator++</b> and <b>operator*.</b>
Input iterators<b> </b>can also be tested with <b>operator==</b> and <b>operator!=</b>.
That’s all.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0723"
title="Add Comment A0723"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>OutputIterator</b>.<b> </b>An output iterator only allows
<i>writing</i> elements to a sequence in a single, forward pass using <b>operator++</b>
and <b>operator*.</b> <b>OutputIterator</b>s cannot be tested with <b>operator==</b>
and <b>operator!=</b>, however, because you assume that you can just keep
sending elements to the destination and that you don’t have to see if the
destination’s end marker has been reached. That is, the container that an <b>OutputIterator</b>
references can take an infinite number of objects, so no end-checking is
necessary. This requirement is important so that an <b>OutputIterator</b> can
be used with <b>ostream</b>s (via <b>ostream_iterator</b>), but you’ll also
commonly use the “insert” iterators such as are the type of iterator returned
by <b>back_inserter(&nbsp;)</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0724"
title="Add Comment A0724"><sup>Comment</sup></a></p>

<p class=MsoNormal>There ius no way to determine whether multiple <b>InputIterators</b>
or <b>OutputIterators</b> point within the same range, so there is no way to us
multiple such iterators in concert. Just think in terms of iterators to support
<b>istream</b>s and <b>ostream</b>s, and <b>InputIterator</b> and <b>OutputIterator</b>
will make perfect sense. Also note that algorithms that use <b>InputIterators</b>
or <b>OutputIterators</b> put the weakest restrictions on the types of
iterators they will accept, which means that you can use any “more
sophisticated” type of iterator when you see <b>InputIterator</b> or <b>OutputIterator</b>
used as STL algorithm template arguments. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0725"
title="Add Comment A0725"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>ForwardIterator</b>. Because you can only read from an <b>InputIterator</b>
and write to an <b>OutputIterator</b>, you can’t use either of them to
simultaneously read and modify a range, and you can’t dereference such an
iterator more than once. With a <b>ForwardIterator</b> these restrictions are
relaxed; you can still only move forward using <b>operator++</b>, but you can
both write and read, and you can compare such iterators in the same range for
equality. Since forward iterators can both read and write, they can of course
be used wherever an input or output iterator is called for. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0726"
title="Add Comment A0726"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>BidirectionalIterator</b>.<b> </b>Effectively, this is a <b>ForwardIterator</b>
that can also go backward. That is, a <b>BidirectionalIterator</b> supports all
the operations that a <b>ForwardIterator</b> does, but in addition it has an <b>operator--</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0727"
title="Add Comment A0727"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>RandomAccessIterator</b>. This type of iterator supports
all the operations that a regular pointer does: you can add and subtract
integral values to move it forward and backward by jumps (rather than just one
element at a time), you can subscript it with <b>operator[&nbsp;]</b>, you can
subtract one iterator from another, and you can compare iterators to see which
is greater using <b>operator&lt;</b>, <b>operator&gt;</b>, and so on. If you’re
implementing a sorting routine or something similar, random access iterators
are necessary to be able to create an efficient algorithm. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0728"
title="Add Comment A0728"><sup>Comment</sup></a></p>

<p class=MsoNormal>The names used for the template parameter types in the
algorithm descriptions later in this chapter consist of the listed iterator
types (sometimes with a ‘1’ or ‘2’ appended to distinguish different template
arguments) and can also include other arguments, often function objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0729"
title="Add Comment A0729"><sup>Comment</sup></a></p>

<p class=MsoNormal>When describing the group of elements that an operation is
performed on, mathematical “range” notation is often used. In this, the square
bracket means “includes the end point,” and the parenthesis means “does not
include the end point.” When using iterators, a range is determined by the
iterator pointing to the initial element and by the “past-the-end” iterator,
pointing past the last element. Since the past-the-end element is never used,
the range determined by a pair of iterators can thus be expressed as <b>[first,
last)</b>, in which <b>first</b> is the iterator pointing to the initial
element, and <b>last</b> is the past-the-end iterator. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0730"
title="Add Comment A0730"><sup>Comment</sup></a></p>

<p class=MsoNormal>Most books and discussions of the STL algorithms arrange
them according to side-effects: <i>non-mutating</i> algorithms don’t change the
elements in the range, <i>mutating</i> algorithms do change the elements, and
so on. These descriptions are based primarily on the underlying behavior or
implementation of the algorithm—that is, on the designer’s perspective. In
practice, we don’t find this a useful categorization, so instead we’ll organize
them according to the problem you want to solve: are you searching for an
element or set of elements, performing an operation on each element, counting
elements, replacing elements, and so on. This should help you find the
algorithm you want more easily. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0731"
title="Add Comment A0731"><sup>Comment</sup></a></p>

<p class=MsoNormal>Note that all the algorithms are in the namespace<b> std</b>.
If you do not see a different header such as <b>&lt;utility&gt;</b> or <b>&lt;numeric&gt;</b>
above the function declarations, it appears in <b>&lt;algorithm&gt;</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0732"
title="Add Comment A0732"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440089"></a><a name="_Toc22433879">Support tools for example
creation</a></h3>

<p class=MsoNormal>It’s useful to create some basic tools with which to test
the algorithms. In the examples that follow we’ll use the generators mentioned
earlier in <b>Generators.h</b>, as well as what appears below. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0733"
title="Add Comment A0733"><sup>Comment</sup></a></p>

<p class=MsoNormal>Displaying a range is something that will be done
constantly, so here is a templatized function that let you print any sequence,
regardless of the type in that sequence: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0734"
title="Add Comment A0734"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:PrintSequence.h</p>

<p class=CodeChar style='margin-left:0in'>// Prints the contents of any
sequence</p>

<p class=CodeChar style='margin-left:0in'>#ifndef PRINTSEQUENCE_H</p>

<p class=CodeChar style='margin-left:0in'>#define PRINTSEQUENCE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename InputIter&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(InputIter first, InputIter
last,</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>char* nm =
&quot;&quot;, char* sep = &quot;\n&quot;, </span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>std::ostream&amp;
os = std::cout) { </p>

<p class=CodeChar style='margin-left:0in'>  if(nm != 0 &amp;&amp; *nm != '\0')</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; nm &lt;&lt; &quot;:
&quot; &lt;&lt; sep;</p>

<p class=CodeChar style='margin-left:0in'>  while(first != last)</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>os &lt;&lt;
*first++ &lt;&lt; sep;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  os &lt;&lt;
std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // PRINTSEQUENCE_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The default prints to <b>cout</b> with newlines as
separators, but you can change that. You can also provide a message to print at
the head of the output. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0736"
title="Add Comment A0736"><sup>Comment</sup></a></p>

<p class=MsoNormal>Finally, a number of the STL algorithms that move elements
of a sequence around distinguish between “stable” and “unstable” reordering of
a sequence. This refers to preserving the original relative order of those
elements that are equivalent as far as the comparison function is concerned.
For example, consider a sequence <b>{ c(1), b(1), c(2), a(1), b(2), a(2) }</b>.
These elements are tested for equivalence based on their letters, but their
numbers indicate how they first appeared in the sequence. If you sort (for
example) this sequence using an unstable sort, there’s no guarantee of any
particular order among equivalent letters, so you could end up with <b>{ a(2),
a(1), b(1), b(2), c(2), c(1) }</b>. However, if you use a stable sort, you will
get <b>{ a(1), a(2), b(1), b(2), c(1), c(2) }</b>. The STL <b>sort(&nbsp;)</b>
algorithm uses a variation of <i>quicksort</i> and is therefore unstable, but a
<b>stable_sort(&nbsp;)</b> is also provided<a href="#_ftn73" name="_ftnref73"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[73]</span></sup></span></span></sup></span></a>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0742"
title="Add Comment A0742"><sup>Comment</sup></a></p>

<p class=MsoNormal>To demonstrate the stability versus instability of
algorithms that reorder a sequence, we need some way to keep track of how the
elements originally appeared. The following is a kind of <b>string</b> object
that keeps track of the order in which that particular object originally
appeared, using a <b>static map</b> that maps <b>NString</b>s to <b>Counter</b>s.
Each <b>NString</b> then contains an <b>occurrence</b> field that indicates the
order in which this <b>NString</b> was discovered. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0743"
title="Add Comment A0743"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:NString.h</p>

<p class=CodeChar style='margin-left:0in'>// A &quot;numbered string&quot; that
indicates which</p>

<p class=CodeChar style='margin-left:0in'>// occurrence this is of a particular
word</p>

<p class=CodeChar style='margin-left:0in'>#ifndef NSTRING_H</p>

<p class=CodeChar style='margin-left:0in'>#define NSTRING_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;utility&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>typedef std::pair&lt;std::string,
int&gt; psi;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Only compare on the first element</p>

<p class=CodeChar style='margin-left:0in'>bool operator==(const psi&amp; l,
const psi&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>  return l.first == r.first;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class NString {</p>

<p class=CodeChar style='margin-left:0in'>  std::string s;</p>

<p class=CodeChar style='margin-left:0in'>  int thisOccurrence;</p>

<p class=CodeChar style='margin-left:0in'>  // Keep track of the number of
occurrences:</p>

<p class=CodeChar style='margin-left:0in'>  typedef std::vector&lt;psi&gt; vp;</p>

<p class=CodeChar style='margin-left:0in'>  typedef vp::iterator vpit;</p>

<p class=CodeChar style='margin-left:0in'>  static vp words;</p>

<p class=CodeChar style='margin-left:0in'>  void addString(const
std::string&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    psi p(x, 0);</p>

<p class=CodeChar style='margin-left:0in'>    vpit it = std::find(words.begin(),
words.end(), p);</p>

<p class=CodeChar style='margin-left:0in'>    if(it != words.end())</p>

<p class=CodeChar style='margin-left:0in'>      thisOccurrence =
++it-&gt;second;</p>

<p class=CodeChar style='margin-left:0in'>    else {</p>

<p class=CodeChar style='margin-left:0in'>      thisOccurrence = 0;</p>

<p class=CodeChar style='margin-left:0in'>      words.push_back(p);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  NString() : thisOccurrence(0) {}</p>

<p class=CodeChar style='margin-left:0in'>  NString(const std::string&amp; x) :
s(x) {</p>

<p class=CodeChar style='margin-left:0in'>    addString(x);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  NString(const char* x) : s(x) {</p>

<p class=CodeChar style='margin-left:0in'>    addString(x);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // The implicit operator= and</p>

<p class=CodeChar style='margin-left:0in'>  // copy-constructor are OK here</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp;
operator&lt;&lt;(</p>

<p class=CodeChar style='margin-left:0in'>    std::ostream&amp; os, const
NString&amp; ns) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; ns.s &lt;&lt;
&quot; [&quot;</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; ns.thisOccurrence
&lt;&lt; &quot;]&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Need this for sorting. Notice it
only</p>

<p class=CodeChar style='margin-left:0in'>  // compares strings, not
occurrences:</p>

<p class=CodeChar style='margin-left:0in'>  friend bool</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;(const NString&amp; l,
const NString&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>    return l.s &lt; r.s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend</p>

<p class=CodeChar style='margin-left:0in'>  bool operator==(const NString&amp;
l, const NString&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>    return l.s == r.s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // For sorting with
greater&lt;NString&gt;:</p>

<p class=CodeChar style='margin-left:0in'>  friend bool</p>

<p class=CodeChar style='margin-left:0in'>  operator&gt;(const NString&amp; l,
const NString&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>    return l.s &gt; r.s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // To get at the string directly:</p>

<p class=CodeChar style='margin-left:0in'>  operator const std::string&amp;()
const {return s;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Allocate static member object.
Done here for</p>

<p class=CodeChar style='margin-left:0in'>// brevity, but should normally be
done in a</p>

<p class=CodeChar style='margin-left:0in'>// separate cpp file:</p>

<p class=CodeChar style='margin-left:0in'>NString::vp NString::words;</p>

<p class=CodeChar style='margin-left:0in'>#endif // NSTRING_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We would normally use a <b>map</b> container to associate a
string with its number of occurrences, but maps don’t appear until the next
chapter, so we use a <b>vector</b> of pairs instead. You’ll see plenty of
similar examples there. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0744"
title="Add Comment A0744"><sup>Comment</sup></a></p>

<p class=MsoNormal>To do an ordinary ascending sort, the only operator that’s
necessary is <b>NString::operator&lt;(&nbsp;)</b>; however, to sort in reverse
order, the <b>operator&gt;(&nbsp;)</b> is also provided so that the <b>greater</b>
template can call it. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0745"
title="Add Comment A0745"><sup>Comment</sup></a></p>

<p class=MsoNormal>As this is just a demonstration class, we are taking the
liberty of placing the definition of the static members <b>words</b> and <b>occurrences</b>
in this header file, but this will break down if the header file is included in
more than one place, so you should normally place all <b>static</b> definitions
to <b>cpp</b> files. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0746"
title="Add Comment A0746"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440090"></a><a name="_Toc22433880">Filling and generating</a></h3>

<p class=MsoNormal>These algorithms let you automatically fill a range with a
particular value or generate a set of values for a particular range. The “fill”
functions insert a single value multiple times into the container, and the
“generate” functions use an object called a <i>generator</i> (described
earlier) to create the values to insert into the container. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0747"
title="Add Comment A0747"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>fill</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value);<br>
void <b>fill_n</b>(OutputIterator first, Size n, const T&amp; value);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0748"
title="Add Comment A0748"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal><b>fill(&nbsp;)</b> assigns <b>value</b> to every element in
the range <b>[first, last)</b>. <b>fill_n(&nbsp;)</b> assigns <b>value</b> to <b>n</b>
elements starting at <b>first</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0749"
title="Add Comment A0749"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>generate</b>(ForwardIterator
first, ForwardIterator last, Generator gen);<br>
void <b>generate_n</b>(OutputIterator first, Size n, Generator gen);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0750"
title="Add Comment A0750"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal><b>generate(&nbsp;)</b> makes a call to <b>gen(&nbsp;)</b>
for each element in the range <b>[first, last)</b>, presumably<b> </b>to
produce a different value for each element. <b>generate_n(&nbsp;)</b> calls <b>gen(&nbsp;)</b>
<b>n</b> times and assigns each result to <b>n</b> elements starting at <b>first</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0751"
title="Add Comment A0751"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>The following example fills and generates into <b>vector</b>s.
It also shows the use of <b>print(&nbsp;)</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0752"
title="Add Comment A0752"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:FillGenerateTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrates &quot;fill&quot; and
&quot;generate&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; v1(5);</p>

<p class=CodeChar style='margin-left:0in'>  fill(v1.begin(), v1.end(),
&quot;howdy&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(v1.begin(), v1.end(),
&quot;v1&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; v2;</p>

<p class=CodeChar style='margin-left:0in'>  fill_n(back_inserter(v2), 7,
&quot;bye&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(v2.begin(), v2.end(),
&quot;v2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v3(10);</p>

<p class=CodeChar style='margin-left:0in'>  generate(v3.begin(), v3.end(),
SkipGen(4,5));</p>

<p class=CodeChar style='margin-left:0in'>  print(v3.begin(), v3.end(),
&quot;v3&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v4;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(v4),15, URandGen(30));</p>

<p class=CodeChar style='margin-left:0in'>  print(v4.begin(), v4.end(),
&quot;v4&quot;, &quot; &quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>vector&lt;string&gt;</b> is created with a predefined
size. Since storage has already been created for all the <b>string</b> objects
in the <b>vector</b>, <b>fill(&nbsp;)</b> can use its assignment operator to
assign a copy of “howdy” to each space in the <b>vector</b>. Also, the default
newline separator is replaced with a space. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0753"
title="Add Comment A0753"><sup>Comment</sup></a></p>

<p class=MsoNormal>The second <b>vector&lt;string&gt; v2</b> is not given an
initial size, so <b>back_inserter</b> must be used to force new elements in
instead of trying to assign to existing locations. Just as an example, the
other <b>print(&nbsp;)</b> is used, which requires a range. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0754"
title="Add Comment A0754"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>generate(&nbsp;)</b> and <b>generate_n(&nbsp;)</b>
functions have the same form as the “fill” functions except that they use a
generator instead of a constant value; here, both generators are demonstrated.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0755"
title="Add Comment A0755"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440091"></a><a name="_Toc22433881">Counting</a></h3>

<p class=MsoNormal>All containers have a member function <b>size(&nbsp;)</b>
that will tells you how many elements they hold. The return type of <b>size(&nbsp;)</b>
is the iterator’s <b>difference_type</b><a href="#_ftn74" name="_ftnref74"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[74]</span></sup></span></span></sup></span></a> (usually
<b>ptrdiff_t</b>), which we denote by <b>IntegralValue</b> in the following.
The following two algorithms count objects that satisfy certain criteria.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0756"
title="Add Comment A0756"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>IntegralValue <b>count</b>(InputIterator
first, InputIterator last, const EqualityComparable&amp; value);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0757"
title="Add Comment A0757"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Produces the number of elements in <b>[first, last)</b> that
are equivalent to <b>value</b> (when tested using <b>operator==</b>).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0758"
title="Add Comment A0758"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>IntegralValue <b>count_if</b>(InputIterator
first, InputIterator last, Predicate pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0759"
title="Add Comment A0759"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Produces the number of elements<b> </b>in <b>[first, last)</b>
that each cause <b>pred</b> to return <b>true</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0760"
title="Add Comment A0760"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>Here, a <b>vector&lt;char&gt; v</b> is<b> </b>filled with
random characters (including some duplicates). A <b>set&lt;char&gt;</b> is
initialized from <b>v</b>, so it holds only one of each letter represented in <b>v</b>.
This <b>set</b> is used to count all the instances of all the characters, which
are then displayed: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0761"
title="Add Comment A0761"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Counting.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The counting algorithms</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;char&gt; v;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(v), 50,
CharGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;v&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Create a set of the characters
in v:</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;char&gt; cs(v.begin(),
v.end());</p>

<p class=CodeChar style='margin-left:0in'>  typedef set&lt;char&gt;::iterator
sci;</p>

<p class=CodeChar style='margin-left:0in'>  for(sci it = cs.begin(); it !=
cs.end(); it++) {</p>

<p class=CodeChar style='margin-left:0in'>    int n = count(v.begin(), v.end(),
*it);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it &lt;&lt;
&quot;: &quot; &lt;&lt; n &lt;&lt; &quot;, &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int lc = count_if(v.begin(),
v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    bind2nd(greater&lt;char&gt;(),
'a'));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\nLowercase
letters: &quot; &lt;&lt; lc &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  sort(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;sorted&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>count_if(&nbsp;)</b> algorithm is demonstrated by
counting all the lowercase letters; the predicate is created using the <b>bind2nd(&nbsp;)</b>
and <b>greater</b> function object templates. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0762"
title="Add Comment A0762"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440092"></a><a name="_Toc22433882">Manipulating sequences</a></h3>

<p class=MsoNormal>These algorithms let you move sequences around. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0763"
title="Add Comment A0763"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>copy</b>(InputIterator
first, InputIterator last, OutputIterator destination);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0764"
title="Add Comment A0764"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Using assignment, copies from <b>[first, last)</b> to <b>destination</b>,
incrementing <b>destination</b> after each assignment. This is essentially a “shuffle-left”
operation, and so the source sequence must not contain the destination. Because
assignment is used, you cannot directly insert elements into an empty container
or at the end of a container, but instead you must wrap the <b>destination</b>
iterator in an <b>insert_iterator</b> (typically by using <b>back_inserter(&nbsp;)</b>
or by using <b>inserter(&nbsp;)</b> in the case of an associative container). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0765"
title="Add Comment A0765"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>BidirectionalIterator2 <b>copy_backward</b>(BidirectionalIterator1
first, BidirectionalIterator1 last, BidirectionalIterator2 destinationEnd);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0767"
title="Add Comment A0767"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Like <b>copy(&nbsp;)</b>, but actually copies the elements
in reverse order. This is essentially a “shuffle-right” operation, and, like <b>copy(&nbsp;)</b>,
the source sequence must not contain the destination. The source range <b>[first,
last)</b> is copied to the destination, but the first destination element is <b>destinationEnd
- 1</b>. This iterator is then decremented after each assignment. The space in
the destination range must already exist (to allow assignment), and the
destination range cannot be within the source range.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0768"
title="Add Comment A0768"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>reverse</b>(BidirectionalIterator
first, BidirectionalIterator last);<br>
OutputIterator <b>reverse_copy</b>(BidirectionalIterator first,
BidirectionalIterator last, OutputIterator destination);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0769"
title="Add Comment A0769"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Both forms of this function reverse the range <b>[first,
last)</b>. <b>reverse(&nbsp;)</b> reverses the range in place, and <b>reverse_copy(&nbsp;)</b>
leaves the original range alone and copies the reversed elements into <b>destination</b>,
returning the past-the-end iterator of the resulting range. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0770"
title="Add Comment A0770"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator2 <b>swap_ranges</b>(ForwardIterator1
first1, ForwardIterator1 last1, ForwardIterator2 first2);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0771"
title="Add Comment A0771"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Exchanges the contents of two ranges of equal size by swapping
corresponding elements.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0772"
title="Add Comment A0772"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>rotate</b>(ForwardIterator
first, ForwardIterator middle, ForwardIterator last);<br>
OutputIterator <b>rotate_copy</b>(ForwardIterator first, ForwardIterator
middle, ForwardIterator last, OutputIterator destination);</p>

</div>

<p class=MsoNormal>Moves the contents of  <b>[first, middle)</b> to the end of
the sequence, and the contents of <b>[middle, last)</b> to the beginning. With <b>rotate(&nbsp;)</b>,
the swap is performed in place; and with <b>rotate_copy(&nbsp;)</b> the
original range is untouched, and the rotated version is copied into <b>destination</b>,
returning the past-the-end iterator of the resulting range. Note that while <b>swap_ranges(&nbsp;)</b>
requires that the two ranges be exactly the same size, the “rotate” functions
do not. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0773"
title="Add Comment A0773"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>next_permutation</b>(BidirectionalIterator
first, BidirectionalIterator last);<br>
bool <b>next_permutation</b>(BidirectionalIterator first, BidirectionalIterator
last, StrictWeakOrdering binary_pred);<br>
bool <b>prev_permutation</b>(BidirectionalIterator first, BidirectionalIterator
last);<br>
bool <b>prev_permutation</b>(BidirectionalIterator first, BidirectionalIterator
last, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0774"
title="Add Comment A0774"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>A <i>permutation</i> is one unique ordering of a set of
elements. If you have <b>n</b> unique elements, there are <b>n!</b> (<b>n</b>
factorial) distinct possible combinations of those elements. All these
combinations can be conceptually sorted into a sequence using a lexicographical
(dictionary-like) ordering and thus produce a concept of a “next” and
“previous” permutation. Therefore, whatever the current ordering of elements in
the range, there is a distinct “next” and “previous” permutation in the
sequence of permutations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0775"
title="Add Comment A0775"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>next_permutation(&nbsp;)</b> and <b>prev_permutation(&nbsp;)</b>
functions rearrange the elements into their next or previous permutation and if
successful return <b>true</b>. If there are no more “next” permutations, the
elements are in sorted order; so <b>next_permutation(&nbsp;)</b> returns <b>false</b>.
If there are no more “previous” permutations, the elements are in descending
sorted order; so <b>previous_permutation(&nbsp;)</b> returns <b>false</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0776"
title="Add Comment A0776"><sup>Comment</sup></a></p>

<p class=MsoNormal>The versions of the functions that have a <b>StrictWeakOrdering</b>
argument perform the comparisons using <b>binary_pred</b> instead of <b>operator&lt;</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0777"
title="Add Comment A0777"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>random_shuffle</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>random_shuffle</b>(RandomAccessIterator first, RandomAccessIterator
last RandomNumberGenerator&amp; rand);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0778"
title="Add Comment A0778"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>This function randomly rearranges the elements in the range.
It yields uniformly distributed results if the random-number generator does.
The first form uses an internal random number generator, and the second uses a
user-supplied random-number generator. The generator must return a value in the
range [0, n) for some positive n. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0779"
title="Add Comment A0779"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>BidirectionalIterator <b>partition</b>(BidirectionalIterator
first, BidirectionalIterator last, Predicate pred);<br>
BidirectionalIterator <b>stable_partition</b>(BidirectionalIterator first,  
BidirectionalIterator last, Predicate pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0780"
title="Add Comment A0780"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>The “partition” functions move elements that satisfy <b>pred</b>
to the beginning of the sequence. An iterator pointing one past the last of
those elements is returned (which is, in effect, and “end” iterator” for the
initial subsequence of elements that satisfy <b>pred</b>). This location is
often called the “partition point”.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0781"
title="Add Comment A0781"><sup>Comment</sup></a></p>

<p class=MsoNormal>With <b>partition(&nbsp;)</b>, the order of the elements in
each resulting subsequence after the function call is not specified, but with <b>stable_parition(&nbsp;),</b>
the relative order of the elements before and after the partition point will be
the same as before the partitioning process. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0782"
title="Add Comment A0782"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>This gives a basic demonstration of sequence manipulation:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0783"
title="Add Comment A0783"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Manipulations.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Shows basic manipulations</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;NString.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v1(10);</p>

<p class=CodeChar style='margin-left:0in'>  // Simple counting:</p>

<p class=CodeChar style='margin-left:0in'>  generate(v1.begin(), v1.end(),
SkipGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(v1.begin(), v1.end(),
&quot;v1&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v2(v1.size());</p>

<p class=CodeChar style='margin-left:0in'>  copy_backward(v1.begin(), v1.end(),
v2.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(v2.begin(), v2.end(),
&quot;copy_backward&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  reverse_copy(v1.begin(), v1.end(),
v2.begin());</p>

<p class=CodeChar style='margin-left:0in'>  print(v2.begin(), v2.end(),
&quot;reverse_copy&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  reverse(v1.begin(), v1.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(v1.begin(), v1.end(),
&quot;reverse&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int half = v1.size() / 2;</p>

<p class=CodeChar style='margin-left:0in'>  // Ranges must be exactly the same
size:</p>

<p class=CodeChar style='margin-left:0in'>  swap_ranges(v1.begin(), v1.begin()
+ half,</p>

<p class=CodeChar style='margin-left:0in'>    v1.begin() + half);</p>

<p class=CodeChar style='margin-left:0in'>  print(v1.begin(), v1.end(),
&quot;swap_ranges&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Start with fresh sequence:</p>

<p class=CodeChar style='margin-left:0in'>  generate(v1.begin(), v1.end(),
SkipGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(v1.begin(), v1.end(),
&quot;v1&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int third = v1.size() / 3;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 10; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    rotate(v1.begin(), v1.begin() +
third, </p>

<p class=CodeChar style='margin-left:0in'>      v1.end());</p>

<p class=CodeChar style='margin-left:0in'>    print(v1.begin(), v1.end(),
&quot;rotate&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Second rotate
example:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  char c[] =
&quot;aabbccddeeffgghhiijj&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  const char csz = strlen(c);</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 10; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    rotate(c, c + 2, c + csz);</p>

<p class=CodeChar style='margin-left:0in'>    print(c, c + csz, &quot;&quot;,
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;All n!
permutations of abcd:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  int nf = 4 * 3 * 2 * 1;</p>

<p class=CodeChar style='margin-left:0in'>  char p[] = &quot;abcd&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; nf; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    next_permutation(p, p + 4);</p>

<p class=CodeChar style='margin-left:0in'>    print(p, p + 4, &quot;&quot;,
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Using
prev_permutation:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; nf; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    prev_permutation(p, p + 4);</p>

<p class=CodeChar style='margin-left:0in'>    print(p, p + 4, &quot;&quot;,
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;random_shuffling a word:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  string s(&quot;hello&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 5; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    random_shuffle(s.begin(),
s.end());</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  NString sa[] = { &quot;a&quot;,
&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;c&quot;, &quot;d&quot;,
&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;,
&quot;b&quot;, &quot;c&quot;};</p>

<p class=CodeChar style='margin-left:0in'>  const int sasz = sizeof sa / sizeof
*sa;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>vector&lt;NString&gt;
ns(sa, sa + sasz);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>print(ns.begin(),
ns.end(), &quot;ns&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;NString&gt;::iterator it
= </p>

<p class=CodeChar style='margin-left:0in'>    partition(ns.begin(), ns.end(), </p>

<p class=CodeChar style='margin-left:0in'>     
bind2nd(greater&lt;NString&gt;(), &quot;b&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Partition
point: &quot; &lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(ns.begin(), ns.end(),
&quot;&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Reload vector:</p>

<p class=CodeChar style='margin-left:0in'>  copy (sa, sa + sasz, ns.begin());</p>

<p class=CodeChar style='margin-left:0in'>  it = stable_partition(ns.begin(),
ns.end(),</p>

<p class=CodeChar style='margin-left:0in'>    bind2nd(greater&lt;NString&gt;(),
&quot;b&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Stable
partition&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Partition
point: &quot; &lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(ns.begin(), ns.end(),
&quot;&quot;, &quot; &quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The best way to see the results of this program is to run
it. (You’ll probably want to redirect the output to a file.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0784"
title="Add Comment A0784"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>vector&lt;int&gt; v1</b> is initially loaded with a
simple ascending sequence and printed. You’ll see that the effect of <b>copy_backward(&nbsp;)</b>
(which copies into <b>v2</b>, which is the same size as <b>v1</b>) is the same
as an ordinary copy. Again, <b>copy_backward(&nbsp;)</b> does the same thing as
<b>copy(&nbsp;)</b>; it just performs the operations in reverse order.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0785"
title="Add Comment A0785"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>reverse_copy(&nbsp;)</b>, however, actually does create a
reversed copy, and <b>reverse(&nbsp;)</b> performs the reversal in place. Next,
<b>swap_ranges(&nbsp;)</b> swaps the upper half of the reversed sequence with
the lower half. Of course, the ranges could be smaller subsets of the entire
vector, as long as they are of equivalent size.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0786"
title="Add Comment A0786"><sup>Comment</sup></a></p>

<p class=MsoNormal>After re-creating the ascending sequence, <b>rotate(&nbsp;)</b>
is demonstrated by rotating one third of <b>v1</b> multiple times. A second <b>rotate(&nbsp;)</b>
example uses characters and just rotates two characters at a time. This also
demonstrates the flexibility of both the STL algorithms and the <b>print(&nbsp;)</b>
template, since they can both be used with arrays of <b>char</b> as easily as
with anything else.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0787"
title="Add Comment A0787"><sup>Comment</sup></a></p>

<p class=MsoNormal>To demonstrate <b>next_permutation(&nbsp;)</b> and <b>prev_permutation(&nbsp;)</b>,
a set of four characters “abcd” is permuted through all <b>n!</b> (<b>n</b>
factorial) possible combinations. You’ll see from the output that the
permutations move through a strictly defined order (that is, permuting is a
deterministic process).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0788"
title="Add Comment A0788"><sup>Comment</sup></a></p>

<p class=MsoNormal>A quick-and-dirty demonstration of <b>random_shuffle(&nbsp;)</b>
is to apply it to a <b>string</b> and see what words result. Because a <b>string</b>
object has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> member functions that
return the appropriate iterators, it too can be easily used with many of the
STL algorithms. Of course, an array of <b>char</b> could also have been used.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0789"
title="Add Comment A0789"><sup>Comment</sup></a></p>

<p class=MsoNormal>Finally, the <b>partition(&nbsp;)</b> and <b>stable_partition(&nbsp;)</b>
are demonstrated, using an array of <b>NString</b>. You’ll note that the
aggregate initialization expression uses <b>char</b> arrays, but <b>NString</b>
has a <b>char*</b> constructor that is automatically used.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0790"
title="Add Comment A0790"><sup>Comment</sup></a></p>

<p class=MsoNormal>You’ll see from the output that with the unstable partition,
the objects are correctly above and below the partition point, but in no
particular order; whereas with the stable partition, their original order is
maintained.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0795"
title="Add Comment A0795"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440093"></a><a name="_Toc22433883">Searching and replacing</a></h3>

<p class=MsoNormal>All these algorithms are used for searching for one or more
objects within a range defined by the first two iterator arguments.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0796"
title="Add Comment A0796"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>InputIterator <b>find</b>(InputIterator
first, InputIterator last,<br>
  const EqualityComparable&amp; value);</p>

</div>

<p class=MsoNormal>Searches for <b>value </b>within a range of elements.
Returns an iterator in the range <b>[first, last)</b> that points to the first
occurrence of <b>value</b>. If <b>value</b> isn’t in the range, <b>find(&nbsp;)</b>
returns <b>last</b>. This is a <i>linear search</i>; that is, it starts at the
beginning and looks at each sequential element without making any assumptions
about the way the elements are ordered. In contrast, a <b>binary_search(&nbsp;)</b>
(defined later) works on a sorted sequence and can thus be much faster.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0797"
title="Add Comment A0797"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>InputIterator <b>find_if</b>(InputIterator
first, InputIterator <br>
  last, Predicate pred<span style='font-family:"Times New Roman"'>);</span></p>

</div>

<p class=MsoNormal>Just like <b>find(&nbsp;)</b>, <b>find_if(&nbsp;)</b>
performs a linear search through the range. However, instead of searching for <b>value</b>,
<b>find_if(&nbsp;)</b> looks for an element such that the <b>Predicate pred</b>
returns <b>true</b> when applied to that element. Returns <b>last</b> if no
such element can be found.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0798"
title="Add Comment A0798"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>adjacent_find</b>(ForwardIterator
first, <br>
  ForwardIterator last);<br>
ForwardIterator <b>adjacent_find</b>(ForwardIterator first, <br>
  ForwardIterator last, BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0799"
title="Add Comment A0799"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Like <b>find(&nbsp;)</b>, performs a linear search through
the range, but instead of looking for only one element, it searches for two
adjacent elements that are equivalent. The first form of the function looks for
two elements that are equivalent (via <b>operator==</b>). The second form looks
for two adjacent elements that, when passed together to <b>binary_pred</b>,
produce a <b>true</b> result. An iterator to the first of the two elements is
returned if a pair is found; otherwise, <b>last</b> is returned.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0800"
title="Add Comment A0800"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>find_first_of</b>(ForwardIterator1
first1, <br>
  ForwardIterator1 last1, ForwardIterator2 first2, <br>
  ForwardIterator2 last2);<br>
ForwardIterator1 <b>find_first_of</b>(ForwardIterator1 first1, <br>
  ForwardIterator1 last1, ForwardIterator2 first2, <br>
  ForwardIterator2 last2, BinaryPredicate binary_pred); <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0801"
title="Add Comment A0801"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Like <b>find(&nbsp;)</b>, performs a linear search through
the range. Both forms search for an element in the second range that’s
equivalent to one in the first, the first form using <b>operator==</b>, and the
second using the supplied predicate. In the second form, the current element
from the first range becomes the first argument to <b>binary_pred</b>, and the
element from the second range becomes the second argument.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0802"
title="Add Comment A0802"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>search</b>(ForwardIterator1
first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2
last2);<br>
ForwardIterator1 <b>search</b>(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2 BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0803"
title="Add Comment A0803"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Checks to see if the second range occurs (in the exact order
of the second range) within the first range, and if so returns an iterator
pointing to the place in the first range where the second range begins. Returns
<b>last1</b> if no subset can be found. The first form performs its test using <b>operator==</b>,
and the second checks to see if each pair of objects being compared causes <b>binary_pred</b>
to return <b>true</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0804"
title="Add Comment A0804"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>find_end</b>(ForwardIterator1
first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2
last2);<br>
ForwardIterator1 <b>find_end</b>(ForwardIterator1 first1, ForwardIterator1
last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate
binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0805"
title="Add Comment A0805"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>The forms and arguments are just like <b>search(&nbsp;)</b>
in that they look for the second range appearing as a subset of the first
range, but while <b>search(&nbsp;)</b> looks for the first occurrence of the
subset, <b>find_end(&nbsp;)</b> looks for the <i>last</i> occurrence and
returns an iterator to its first element. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0806"
title="Add Comment A0806"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>search_n</b>(ForwardIterator
first, ForwardIterator last, Size count, const T&amp; value);<br>
ForwardIterator <b>search_n</b>(ForwardIterator first, ForwardIterator last,
Size count, const T&amp; value, BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0807"
title="Add Comment A0807"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Looks for a group of <b>count</b> consecutive values in <b>[first,
last)</b> that are all equal to <b>value</b> (in the first form) or that all
cause a return value of <b>true</b> when passed into <b>binary_pred</b> along
with <b>value</b> (in the second form). Returns <b>last</b> if such a group
cannot be found.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0808"
title="Add Comment A0808"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>min_element</b>(ForwardIterator
first, ForwardIterator last);<br>
ForwardIterator <b>min_element</b>(ForwardIterator first, ForwardIterator last,
BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0809"
title="Add Comment A0809"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns an iterator pointing to the first occurrence of the
“smallest” value in the range (as explained below—there may be multiple
occurrences of this value.) Returns <b>last</b> if the range is empty. The
first version performs comparisons with <b>operator&lt;,</b> and the value <b>r
</b> returned is such that *<b>e &lt; *r</b> is false for every element <b>e</b>
in the range <b>[first, r)</b>. The second version compares using <b>binary_pred,</b>
and the value <b>r</b> returned is such that <b>binary_pred (*e, *r)</b> is
false for every element <b>e</b> in the range <b>[first, r)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0810"
title="Add Comment A0810"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>max_element</b>(ForwardIterator
first, ForwardIterator last);<br>
ForwardIterator <b>max_element</b>(ForwardIterator first, ForwardIterator last,
BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0811"
title="Add Comment A0811"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns an iterator pointing to the first occurrence of the
largest value in the range. (There may be multiple occurrences of the largest
value.) Returns <b>last</b> if the range is empty. The first version performs
comparisons with <b>operator&lt;,</b> and the value <b>r </b> returned is such
that *<b>r &lt; *e</b> is false for every element <b>e</b> in the range <b>[first,
r)</b>. The second version compares using <b>binary_pred,</b> and the value <b>r</b>
returned is such that <b>binary_pred (*r, *e)</b> is false for every element <b>e</b>
in the range <b>[first, r)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0812"
title="Add Comment A0812"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>replace</b>(ForwardIterator
first, ForwardIterator last, <br>
const T&amp; old_value, const T&amp; new_value);<br>
void <b>replace_if</b>(ForwardIterator first, ForwardIterator last, Predicate
pred, const T&amp; new_value);<br>
OutputIterator <b>replace_copy</b>(InputIterator first, InputIterator last,
OutputIterator result, const T&amp; old_value, const T&amp; new_value);<br>
OutputIterator <b>replace_copy_if</b>(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred, const T&amp; new_value);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0813"
title="Add Comment A0813"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Each of the “replace” forms moves through the range <b>[first,
last)</b>, finding values that match a criterion and replacing them with <b>new_value</b>.
Both <b>replace(&nbsp;)</b> and <b>replace_copy(&nbsp;)</b> simply look for <b>old_value</b>
to replace; <b>replace_if(&nbsp;)</b> and <b>replace_copy_if(&nbsp;)</b> look
for values that satisfy the predicate <b>pred</b>. The “copy” versions of the
functions do not modify the original range but instead make a copy with the
replacements into <b>result</b> (incrementing <b>result</b> after each
assignment).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0814"
title="Add Comment A0814"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>To provide easy viewing of the results, this example manipulates
<b>vector</b>s of <b>int</b>. Again, not every possible version of each
algorithm is shown. (Some that should be obvious have been omitted.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0815"
title="Add Comment A0815"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:SearchReplace.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The STL search and replace
algorithms</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct PlusOne {</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(int i, int j) {</p>

<p class=CodeChar style='margin-left:0in'>    return j == i + 1;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class MulMoreThan {</p>

<p class=CodeChar style='margin-left:0in'>  int value;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  MulMoreThan(int val) : value(val)
{}</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(int v, int m) {</p>

<p class=CodeChar style='margin-left:0in'>    return v * m &gt; value;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = { 1, 2, 3, 4, 5, 6, 6, 7,
7, 7,</p>

<p class=CodeChar style='margin-left:0in'>    8, 8, 8, 8, 11, 11, 11, 11, 11 };</p>

<p class=CodeChar style='margin-left:0in'>  const int asz = sizeof a / sizeof
*a;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v(a, a + asz);</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;v&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt;::iterator it =</p>

<p class=CodeChar style='margin-left:0in'>    find(v.begin(), v.end(), 4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;find: &quot;
&lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  it = find_if(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    bind2nd(greater&lt;int&gt;(),
8));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;find_if: &quot;
&lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  it = adjacent_find(v.begin(),
v.end());</p>

<p class=CodeChar style='margin-left:0in'>  while(it != v.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;adjacent_find: &quot; &lt;&lt; *it </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;, &quot;
&lt;&lt; *(it + 1) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    it = adjacent_find(it + 1,
v.end());</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  it = adjacent_find(v.begin(), v.end(),
</p>

<p class=CodeChar style='margin-left:0in'>    PlusOne());</p>

<p class=CodeChar style='margin-left:0in'>  while(it != v.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;adjacent_find
PlusOne: &quot; &lt;&lt; *it</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;, &quot;
&lt;&lt; *(it + 1) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    it = adjacent_find(it + 1,
v.end(), </p>

<p class=CodeChar style='margin-left:0in'>      PlusOne());</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int b[] = { 8, 11 };</p>

<p class=CodeChar style='margin-left:0in'>  const int bsz = sizeof b / sizeof
*b;</p>

<p class=CodeChar style='margin-left:0in'>  print(b, b + bsz, &quot;b&quot;,
&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = find_first_of(v.begin(),
v.end(),</p>

<p class=CodeChar style='margin-left:0in'>    b, b + bsz);</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it + bsz,
&quot;find_first_of&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = find_first_of(v.begin(),
v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    b, b + bsz, PlusOne());</p>

<p class=CodeChar style='margin-left:0in'>  print(it,it +
bsz,&quot;find_first_of PlusOne&quot;,&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = search(v.begin(), v.end(), b,
b + bsz);</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it + bsz,
&quot;search&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int c[] = { 5, 6, 7 };</p>

<p class=CodeChar style='margin-left:0in'>  const int csz = sizeof c / sizeof
*c;</p>

<p class=CodeChar style='margin-left:0in'>  print(c, c + csz, &quot;c&quot;,
&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = search(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    c, c + csz, PlusOne());</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it + csz,&quot;search
PlusOne&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int d[] = { 11, 11, 11 };</p>

<p class=CodeChar style='margin-left:0in'>  const int dsz = sizeof d / sizeof
*d;</p>

<p class=CodeChar style='margin-left:0in'>  print(d, d + dsz, &quot;d&quot;,
&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = find_end(v.begin(), v.end(),
d, d + dsz);</p>

<p class=CodeChar style='margin-left:0in'>  print(it,
v.end(),&quot;find_end&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>int e[] = { 9, 9 };</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  print(e, e + 2,
&quot;e&quot;, &quot; &quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>it =
find_end(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    e, e + 2, PlusOne());</p>

<p class=CodeChar style='margin-left:0in'>  print(it, v.end(),&quot;find_end
PlusOne&quot;,&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = search_n(v.begin(), v.end(),
3, 7);</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it + 3, &quot;search_n 3,
7&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = search_n(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    6, 15, MulMoreThan(100));</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it + 6, </p>

<p class=CodeChar style='margin-left:0in'>    &quot;search_n 6, 15,
MulMoreThan(100)&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;min_element:
&quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>    *min_element(v.begin(), v.end())
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;max_element:
&quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>    *max_element(v.begin(), v.end())
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; v2;</p>

<p class=CodeChar style='margin-left:0in'>  replace_copy(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>    back_inserter(v2), 8, 47);</p>

<p class=CodeChar style='margin-left:0in'>  print(v2.begin(), v2.end(),
&quot;replace_copy 8 -&gt; 47&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  replace_if(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
bind2nd(greater_equal&lt;int&gt;(), 7), -1);</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;replace_if &gt;= 7 -&gt; -1&quot;, &quot; &quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The example begins with two predicates: <b>PlusOne,</b>
which is a binary predicate that returns <b>true</b> if the second argument is
equivalent to one plus the first argument; and <b>MulMoreThan,</b> which
returns <b>true</b> if the first argument times the second argument is greater
than a value stored in the object. These binary predicates are used as tests in
the example.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0816"
title="Add Comment A0816"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, an array <b>a</b> is created and fed
to the constructor for <b>vector&lt;int&gt; v</b>. This vector is used as the
target for the search and replace activities, and you’ll note that there are
duplicate elements—these are discovered by some of the search/replace routines.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0817"
title="Add Comment A0817"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first test demonstrates <b>find(&nbsp;)</b>, discovering
the value 4 in <b>v</b>. The return value is the iterator pointing to the first
instance of 4, or the end of the input range (<b>v.end(&nbsp;)</b>) if the
search value is not found.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0818"
title="Add Comment A0818"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> find_if(&nbsp;)</b> algorithm  uses a predicate to
determine if it has discovered the correct element. In this example, this
predicate is created on the fly using <b>greater&lt;int&gt;</b> (that is, “see
if the first <b>int </b>argument is greater than the second”) and <b>bind2nd(&nbsp;)</b>
to fix the second argument to 8. Thus, it returns true if the value in <b>v</b>
is greater than 8.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0819"
title="Add Comment A0819"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since two identical objects appear next to each other in a
number of cases in <b>v</b>, the test of <b>adjacent_find(&nbsp;)</b> is
designed to find them all. It starts looking from the beginning and then drops
into a <b>while</b> loop, making sure that the iterator <b>it</b> has not
reached the end of the input sequence (which would mean that no more matches
can be found). For each match it finds, the loop prints out the matches and then
performs the next <b>adjacent_find(&nbsp;)</b>, this time using <b>it + 1</b>
as the first argument (this way, it will still find two pairs in a triple).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0820"
title="Add Comment A0820"><sup>Comment</sup></a></p>

<p class=MsoNormal>You might look at the <b>while</b> loop and think that you
can do it a bit more cleverly, to wit:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0821"
title="Add Comment A0821"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  while(it != v.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;adjacent_find: &quot; &lt;&lt; *it++</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;, &quot;
&lt;&lt; *it++ &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    it = adjacent_find(it, v.end());</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  }</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Of course, this is exactly what we tried first. However, we
did not get the output we expected, on any compiler. This is because there is
no guarantee about when the increments occur in this expression. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0822"
title="Add Comment A0822"><sup>Comment</sup></a></p>

<p class=MsoNormal>The next test uses <b>adjacent_find(&nbsp;)</b> with the <b>PlusOne</b>
predicate, which discovers all the places where the next number in the sequence
<b>v</b> changes from the previous by one. The same <b>while</b> approach is
used to find all the cases.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0823"
title="Add Comment A0823"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> find_first_of(&nbsp;)</b> algorithm requires a second
range of objects for which to hunt; this is provided in the array <b>b</b>.
Notice that, because the first range and the second range in <b>find_first_of(&nbsp;)</b>
are controlled by separate template arguments, those ranges can refer to two
different types of containers, as seen here. The second form of <b>find_first_of(&nbsp;)</b>
is also tested, using <b>PlusOne</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0824"
title="Add Comment A0824"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> search(&nbsp;)</b> algorithm finds exactly the second
range inside the first one, with the elements in the same order. The second
form of <b>search(&nbsp;)</b> uses a predicate, which is typically just
something that defines equivalence, but it also presents some interesting
possibilities—here, the <b>PlusOne</b> predicate causes the range <b>{ 4, 5, 6
}</b> to be found.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0825"
title="Add Comment A0825"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>find_end(&nbsp;)</b> test discovers the <i>last</i>
occurrence of the entire sequence <b>{ 11, 11, 11 }</b>. To show that it has in
fact found the last occurrence, the rest of <b>v</b> starting from <b>it</b> is
printed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0826"
title="Add Comment A0826"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first <b>search_n(&nbsp;)</b> test looks for 3 copies of
the value 7, which it finds and prints. When using the second version of <b>search_n(&nbsp;)</b>,
the predicate is ordinarily meant to be used to determine equivalence between
two elements, but we’ve taken some liberties and used a function object that
multiplies the value in the sequence by (in this case) 15 and checks to see if
it’s greater than 100. That is, the <b>search_n(&nbsp;)</b> test says “find me
6 consecutive values that, when multiplied by 15, each produce a number greater
than 100.” Not exactly what you normally expect to do, but it might give you
some ideas the next time you have an odd searching problem.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0827"
title="Add Comment A0827"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> min_element(&nbsp;)</b> and <b>max_element(&nbsp;)</b>
algorithms are straightforward; the only thing that’s a bit odd is that it
looks like the function is being dereferenced with a ‘<b>*</b>’. Actually, the
returned iterator is being dereferenced to produce the value for printing.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0828"
title="Add Comment A0828"><sup>Comment</sup></a></p>

<p class=MsoNormal>To test replacements, <b>replace_copy(&nbsp;)</b> is used
first (so it doesn’t modify the original vector) to replace all values of 8
with the value 47. Notice the use of <b>back_inserter(&nbsp;)</b> with the
empty vector <b>v2</b>. To demonstrate <b>replace_if(&nbsp;)</b>, a function
object is created using the standard template <b>greater_equal</b> along with <b>bind2nd</b>
to replace all the values that are greater than or equal to 7 with the value
-1.<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0829"
title="Add Comment A0829"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440094"></a><a name="_Toc22433884">Comparing ranges</a></h3>

<p class=MsoNormal>These algorithms provide ways to compare two ranges. At
first glance, the operations they perform seem close to the <b>search(&nbsp;)</b>
function. However, <b>search(&nbsp;)</b> tells you where the second sequence
appears within the first, and <b>equal(&nbsp;)</b> and <b>lexicographical_compare(&nbsp;)
</b>simply tell you how two sequences compare. On the other hand, <b>mismatch(&nbsp;)</b>
does tell you where the two sequences go out of sync, but those sequences must
be exactly the same length.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0830"
title="Add Comment A0830"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>equal</b>(InputIterator
first1, InputIterator last1, InputIterator first2);<br>
bool <b>equal</b>(InputIterator first1, InputIterator last1, InputIterator
first2 BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0831"
title="Add Comment A0831"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>In both these functions, the first range is the typical one,
<b>[first1, last1)</b>. The second range starts at <b>first2</b>, but there is
no “last2” because its length is determined by the length of the first range.
The <b>equal(&nbsp;)</b> function returns true if both ranges are exactly the
same (the same elements in the same order); in the first case, the <b>operator==</b>
is used to perform the comparison, and in the second case <b>binary_pred</b> is
used to decide if two elements are the same.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0832"
title="Add Comment A0832"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>lexicographical_compare</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);<br>
bool <b>lexicographical_compare</b>(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate
binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0833"
title="Add Comment A0833"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>These two functions determine if the first range is
“lexicographically less” than the second. (They return <b>true</b> if range 1
is less than range 2, and false otherwise.) Lexicographical comparison, or
“dictionary” comparison, means that the comparison is done the same way we
establish the order of strings in a dictionary, one element at a time. The
first elements determine the result if these elements are different, but if
they’re equal, the algorithm moves on to the next elements and looks at those,
and so on until it finds a mismatch. At that point, it looks at the elements,
and if the element from range 1 is less than the element from range two, <b>lexicographical_compare(&nbsp;)</b>
returns <b>true</b>; otherwise, it returns <b>false</b>. If it gets all the way
through one range or the other (the ranges may be different lengths for this
algorithm) without finding an inequality, range 1 is <i>not </i>less than range
2, so the function returns <b>false</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0834"
title="Add Comment A0834"><sup>Comment</sup></a></p>

<p class=MsoNormal>If the two ranges are different lengths, a missing element
in one range acts as one that “precedes” an element that exists in the other
range, so “abc” precedes “abcd”. If the algorithm reaches the end of one of the
ranges without a mismatch, then the shorter range comes first. In that case, if
the shorter range is the first range, the result is <b>true</b>, otherwise it
is <b>false</b>.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0835"
title="Add Comment A0835"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the first version of the function, <b>operator&lt;</b> is
used to perform the comparisons, and in the second version, <b>binary_pred</b>
is used.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0836"
title="Add Comment A0836"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>pair&lt;InputIterator1,
InputIterator2&gt; <b>mismatch</b>(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);<br>
pair&lt;InputIterator1, InputIterator2&gt; <b>mismatch</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate
binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0837"
title="Add Comment A0837"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>As in <b>equal(&nbsp;)</b>, the length of both ranges is
exactly the same, so only the first iterator in the second range is necessary,
and the length of the first range is used as the length of the second range.
Whereas <b>equal(&nbsp;)</b> just tells you whether the two ranges are the
same, <b>mismatch(&nbsp;)</b> tells you where they begin to differ. To
accomplish this, you must be told (1) the element in the first range where the
mismatch occurred and (2) the element in the second range where the mismatch
occurred. These two iterators are packaged together into a <b>pair</b> object
and returned. If no mismatch occurs, the return value is <b>last1</b> combined
with the past-the-end iterator of the second range. The <b>pair</b> template
class is a <b>struct</b> with two elements denoted by the member names <b>first</b>
and <b>second</b> and is defined in the <b>&lt;utility&gt;</b> header. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0838"
title="Add Comment A0838"><sup>Comment</sup></a></p>

<p class=MsoNormal>As in <b>equal(&nbsp;)</b>, the first function tests for
equality using <b>operator==</b> while the second one uses <b>binary_pred</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0839"
title="Add Comment A0839"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>Because the standard C++ <b>string</b> class is built like a
container (it has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> member functions
that produce objects of type <b>string::iterator</b>), it can be used to conveniently
create ranges of characters to test with the STL comparison algorithms.
However, you should note that <b>string </b>has a fairly complete set of native
operations, so you should look at the <b>string</b> class before using the STL
algorithms to perform operations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0840"
title="Add Comment A0840"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Comparison.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The STL range comparison
algorithms</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // strings provide a convenient way
to create</p>

<p class=CodeChar style='margin-left:0in'>  // ranges of characters, but you
should </p>

<p class=CodeChar style='margin-left:0in'>  // normally look for native string
operations:</p>

<p class=CodeChar style='margin-left:0in'>  string s1(&quot;This is a
test&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string s2(&quot;This is a
Test&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;s1: &quot;
&lt;&lt; s1 &lt;&lt; endl </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot;s2: &quot;
&lt;&lt; s2 &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;compare s1
&amp; s1: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; equal(s1.begin(),
s1.end(), s1.begin())</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;compare s1
&amp; s2: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; equal(s1.begin(),
s1.end(), s2.begin())</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;lexicographical_compare s1 &amp; s1: &quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>   
lexicographical_compare(s1.begin(), s1.end(),</p>

<p class=CodeChar style='margin-left:0in'>      s1.begin(), s1.end()) &lt;&lt; 
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;lexicographical_compare s1 &amp; s2: &quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>   
lexicographical_compare(s1.begin(), s1.end(),</p>

<p class=CodeChar style='margin-left:0in'>      s2.begin(), s2.end()) &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;lexicographical_compare s2 &amp; s1: &quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>   
lexicographical_compare(s2.begin(), s2.end(),</p>

<p class=CodeChar style='margin-left:0in'>      s1.begin(), s1.end()) &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;lexicographical_compare shortened &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &quot;s1 &amp; full-length s2:
&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  string s3(s1);</p>

<p class=CodeChar style='margin-left:0in'>  while(s3.length() != 0) {</p>

<p class=CodeChar style='margin-left:0in'>    bool result =
lexicographical_compare(</p>

<p class=CodeChar style='margin-left:0in'>      s3.begin(), s3.end(),
s2.begin(),s2.end());</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; s3 &lt;&lt; endl
&lt;&lt; s2 &lt;&lt; &quot;, result = &quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; result &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    if(result == true) break;</p>

<p class=CodeChar style='margin-left:0in'>    s3 = s3.substr(0, s3.length() -
1);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  pair&lt;string::iterator,
string::iterator&gt; p =</p>

<p class=CodeChar style='margin-left:0in'>    mismatch(s1.begin(), s1.end(),
s2.begin());</p>

<p class=CodeChar style='margin-left:0in'>  print(p.first, s1.end(),
&quot;p.first&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(p.second, s2.end(),
&quot;p.second&quot;,&quot;&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note that the only difference between <b>s1</b> and <b>s2</b>
is the capital ‘T’ in <b>s2</b>’s “Test.” Comparing <b>s1</b> and <b>s1</b> for
equality yields <b>true</b>, as expected, while <b>s1</b> and <b>s2</b> are not
equal because of the capital ‘T’.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0841"
title="Add Comment A0841"><sup>Comment</sup></a></p>

<p class=MsoNormal>To understand the output of the <b>lexicographical_compare(&nbsp;)</b>
tests, you must remember two things: first, the comparison is performed
character-by-character, and, second, on our platform, capital letters “precede”
lowercase letters. In the first test, <b>s1</b> is compared to <b>s1</b>. These
are exactly equivalent. One is <i>not</i> lexicographically less than the other
(which is what the comparison is looking for), and thus the result is <b>false</b>.
The second test is asking “does <b>s1</b> precede <b>s2</b>?” When the
comparison gets to the ‘t’ in “test”, it discovers that the lowercase ‘t’ in <b>s1</b>
is “greater” than the uppercase ‘T’ in <b>s2</b>, so the answer is again <b>false</b>.
However, if we test to see whether <b>s2</b> precedes <b>s1</b>, the answer is <b>true</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0842"
title="Add Comment A0842"><sup>Comment</sup></a></p>

<p class=MsoNormal>To further examine lexicographical comparison, the next test
in this example compares <b>s1</b> with <b>s2</b> again (which returned <b>false</b>
before). But this time it repeats the comparison, trimming one character off the
end of <b>s1</b> (which is first copied into <b>s3</b>) each time through the
loop until the test evaluates to <b>true</b>. What you’ll see is that, as soon
as the uppercase ‘T’ is trimmed off <b>s3</b> (the copy of <b>s1</b>), the
characters, which are exactly equal up to that point, no longer count. Because <b>s3</b>
is shorter than <b>s2,</b> it lexicographically precedes <b>s2</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0843"
title="Add Comment A0843"><sup>Comment</sup></a></p>

<p class=MsoNormal>The final test uses<b> mismatch(&nbsp;)</b>. To capture the
return value, you must first create the appropriate <b>pair p</b>, constructing
the template using the iterator type from the first range and the iterator type
from the second range (in this case, both <b>string::iterator</b>s). To print
the results, the iterator for the mismatch in the first range is <b>p.first</b>,
and for the second range is <b>p.second</b>. In both cases, the range is
printed from the mismatch iterator to the end of the range so you can see
exactly where the iterator points.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0844"
title="Add Comment A0844"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440095"></a><a name="_Toc22433885">Removing elements</a></h3>

<p class=MsoNormal>Because of the genericity of the STL, the concept of removal
is a bit constrained. Since elements can only be “removed” via iterators, and
iterators can point to arrays, vectors, lists, and so on, it is not safe or
reasonable to actually try to destroy the elements that are being removed and
to change the size of the input range <b>[first, last).</b> (An array, for
example, cannot have its size changed.) So instead, what the STL “remove”
functions do is rearrange the sequence so that the “removed” elements are at
the end of the sequence, and the “un-removed” elements are at the beginning of
the sequence (in the same order that they were before, minus the removed
elements—that is, this is a <i>stable</i> operation). Then the function will
return an iterator to the “new last” element of the sequence, which is the end
of the sequence without the removed elements and the beginning of the sequence
of the removed elements. In other words, if <b>new_last</b> is the iterator
that is returned from the “remove” function, <b>[first, new_last)</b> is the
sequence without any of the removed elements, and <b>[new_last, last)</b> is
the sequence of removed elements.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0845"
title="Add Comment A0845"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you are simply using your sequence, including the removed
elements, with more STL algorithms, you can just use <b>new_last</b> as the new
past-the-end iterator. However, if you’re using a resizable container <b>c </b>(not
an array) and you actually want to eliminate the removed elements from the
container, you can use <b>erase(&nbsp;)</b> to do so, for example:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0846"
title="Add Comment A0846"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>c.erase(remove(c.begin(),
c.end(), value), c.end());</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can also use the <b>resize(&nbsp;)</b> member function
that belongs to all standard sequences (more on this in the next chapter). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1681"
title="Add Comment A1681"><sup>Comment</sup></a></p>

<p class=MsoNormal>The return value of <b>remove(&nbsp;)</b> is the <b>new_last</b>
iterator, so <b>erase(&nbsp;)</b> deletes all the removed elements from <b>c</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0847"
title="Add Comment A0847"><sup>Comment</sup></a></p>

<p class=MsoNormal>The iterators in <b>[new_last, last)</b> are
dereferenceable, but the element values are unspecified and should not be used.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0848"
title="Add Comment A0848"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>remove</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>remove_if</b>(ForwardIterator first, ForwardIterator last,
Predicate pred);<br>
OutputIterator <b>remove_copy</b>(InputIterator first, InputIterator last,
OutputIterator result, const T&amp; value);<br>
OutputIterator <b>remove_copy_if</b>(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0849"
title="Add Comment A0849"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Each of the “remove” forms moves through the range <b>[first,
last)</b>, finding values that match a removal criterion and copying the
unremoved elements over the removed elements (thus effectively removing them).
The original order of the unremoved elements is maintained. The return value is
an iterator pointing past the end of the range that contains none of the
removed elements. The values that this iterator points to are unspecified.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0850"
title="Add Comment A0850"><sup>Comment</sup></a></p>

<p class=MsoNormal>The “if” versions pass each element to <b>pred(&nbsp;)</b>
to determine whether it should be removed. (If <b>pred(&nbsp;)</b> returns <b>true</b>,
the element is removed.) The “copy” versions do not modify the original
sequence, but instead copy the unremoved values into a range beginning at <b>result</b>
and return an iterator indicating the past-the-end value of this new range.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0851"
title="Add Comment A0851"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>unique</b>(ForwardIterator
first, ForwardIterator last);<br>
ForwardIterator <b>unique</b>(ForwardIterator first, ForwardIterator last,
BinaryPredicate binary_pred);<br>
OutputIterator <b>unique_copy</b>(InputIterator first, InputIterator last,
OutputIterator result);<br>
OutputIterator <b>unique_copy</b>(InputIterator first, InputIterator last,
OutputIterator result,  BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0852"
title="Add Comment A0852"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Each of the “unique” functions moves through the range <b>[first,
last)</b>, finding adjacent values that are equivalent (that is, duplicates)
and “removing” the duplicate elements by copying over them. The original order
of the unremoved elements is maintained. The return value is an iterator
pointing past the end of the range that has the adjacent duplicates removed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0853"
title="Add Comment A0853"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because only duplicates that are adjacent are removed, it’s
likely that you’ll want to call <b>sort(&nbsp;)</b> before calling a “unique”
algorithm, since that will guarantee that <i>all</i> the duplicates are
removed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0854"
title="Add Comment A0854"><sup>Comment</sup></a></p>

<p class=MsoNormal>For each iterator value <b>i</b> in the input range, the
versions containing <b>binary_pred</b> call:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0855"
title="Add Comment A0855"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>binary_pred(*i, *(i-1));</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>and if the result is <b>true</b>, <b>*i</b> is considered a
duplicate.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0856"
title="Add Comment A0856"><sup>Comment</sup></a></p>

<p class=MsoNormal>The “copy” versions do not modify the original sequence, but
instead copy the unremoved values into a range beginning at <b>result</b> and
return an iterator indicating the past-the-end value of this new range.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0857"
title="Add Comment A0857"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>This example gives a visual demonstration of the way the
“remove” and “unique” functions work.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0858"
title="Add Comment A0858"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Removing.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The removing algorithms</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct IsUpper {</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(char c) {</p>

<p class=CodeChar style='margin-left:0in'>    return isupper(c);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  string v;</p>

<p class=CodeChar style='margin-left:0in'>  v.resize(25);</p>

<p class=CodeChar style='margin-left:0in'>  generate(v.begin(), v.end(),
CharGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(), &quot;v
original&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Create a set of the characters
in v:</p>

<p class=CodeChar style='margin-left:0in'>  string us(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>  sort(us.begin(), us.end());</p>

<p class=CodeChar style='margin-left:0in'>  string::iterator it = us.begin(),
cit = v.end(),</p>

<p class=CodeChar style='margin-left:0in'>    uend = unique(us.begin(),
us.end());</p>

<p class=CodeChar style='margin-left:0in'>  // Step through and remove
everything:</p>

<p class=CodeChar style='margin-left:0in'>  while(it != uend) {</p>

<p class=CodeChar style='margin-left:0in'>    cit = remove(v.begin(), cit,
*it);</p>

<p class=CodeChar style='margin-left:0in'>    print(v.begin(), v.end(),
&quot;Complete v&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>    print(v.begin(), cit,
&quot;Pseudo v &quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Removed
element:\t&quot; &lt;&lt; *it</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;\nPsuedo Last
Element:\t&quot;</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; *cit &lt;&lt; endl
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  generate(v.begin(), v.end(),
CharGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;v&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cit = remove_if(v.begin(), v.end(),
IsUpper());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), cit, &quot;v after
remove_if IsUpper&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Copying versions are not shown
for remove</p>

<p class=CodeChar style='margin-left:0in'>  // and remove_if.</p>

<p class=CodeChar style='margin-left:0in'>  sort(v.begin(), cit);</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), cit,
&quot;sorted&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string v2;</p>

<p class=CodeChar style='margin-left:0in'>  v2.resize(cit -
v.begin());                   </p>

<p class=CodeChar style='margin-left:0in'>  unique_copy(v.begin(), cit,
v2.begin());</p>

<p class=CodeChar style='margin-left:0in'>  print(v2.begin(), v2.end(),
&quot;unique_copy&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Same behavior:</p>

<p class=CodeChar style='margin-left:0in'>  cit = unique(v.begin(), cit,
equal_to&lt;char&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), cit, &quot;unique
equal_to&lt;char&gt;&quot;, &quot; &quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The<b> </b>string <b>v</b>, which is a container of
characters, as you know, is filled with randomly generated characters. Each
character is used in a <b>remove</b> statement, but the entire string<b> v</b>
is printed out each time so you can see what happens to the rest of the range,
after the resulting endpoint (which is stored in <b>cit</b>).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0859"
title="Add Comment A0859"><sup>Comment</sup></a></p>

<p class=MsoNormal>To demonstrate <b>remove_if(&nbsp;)</b>, the address of the
standard C library function <b>isupper(&nbsp;) </b>(in <b>&lt;cctype&gt; </b>is
called inside the function object class <b>IsUpper</b>, an object of which is<b>
</b>passed as the predicate for <b>remove_if(&nbsp;)</b>.<b> </b>This returns <b>true</b>
only if a character is uppercase, so only lowercase characters will remain.
Here, the end of the range is used in the call to <b>print(&nbsp;)</b> so only
the remaining elements will appear. The copying versions of <b>remove(&nbsp;)</b>
and <b>remove_if(&nbsp;)</b> are not shown because they are a simple variation
on the noncopying versions, which you should be able to use without an example.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0860"
title="Add Comment A0860"><sup>Comment</sup></a></p>

<p class=MsoNormal>The range of lowercase letters is sorted in preparation for
testing the “unique” functions. (The “unique” functions are not undefined if
the range isn’t sorted, but it’s probably not what you want.).. First, <b>unique_copy(&nbsp;)</b>
puts the unique elements into a new <b>vector</b> using the default element
comparison, and then the form of <b>unique(&nbsp;)</b> that takes a predicate
is used; the predicate used is the built-in function object <b>equal_to(&nbsp;)</b>,
which produces the same results as the default element comparison.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0861"
title="Add Comment A0861"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440096"></a><a name="_Toc22433886">Sorting and operations on
sorted ranges</a></h3>

<p class=MsoNormal>A significant category of STL algorithms requires that the
range they operate on be in sorted order.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0862"
title="Add Comment A0862"><sup>Comment</sup></a></p>

<p class=MsoNormal>STL provides a number of separate sorting algorithms,
depending on whether the sort should be stable, partial, or just regular
(non-stable). Oddly enough, only the partial sort has a copying version;
otherwise you’ll need to make your own copy before sorting if that’s what you
want. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0863"
title="Add Comment A0863"><sup>Comment</sup></a></p>

<p class=MsoNormal>Once your sequence is sorted, you can perform many
operations on that sequence, from simply locating an element or group of
elements to merging with another sorted sequence or manipulating sequences as
mathematical sets.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0864"
title="Add Comment A0864"><sup>Comment</sup></a></p>

<p class=MsoNormal>Each algorithm involved with sorting or operations on sorted
sequences has two versions. The first uses the object’s own <b>operator&lt;</b>
to perform the comparison, and the second uses <b>operator(&nbsp;)(a, b)</b> to
determine the relative order of <b>a</b> and <b>b</b>. Other than this, there
are no differences, so this distinction will not be pointed out in the
description of each algorithm.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0865"
title="Add Comment A0865"><sup>Comment</sup></a></p>

<h4>Sorting</h4>

<p class=MsoNormal>The sort algorithms require ranges delimited by
random-access iterators, such as a <b>vector</b> or <b>deque</b>. The <b>list</b>
container has its own built-in <b>sort(&nbsp;)</b> function, since it only
supports bi-directional iteration.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0866"
title="Add Comment A0866"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>sort</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>sort</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0867"
title="Add Comment A0867"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Sorts <b>[first, last)</b> into ascending order. The first
form uses <b>operator&lt;</b> and the second form uses the supplied comparator
object to determine the order.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0868"
title="Add Comment A0868"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>stable_sort</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>stable_sort</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0869"
title="Add Comment A0869"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Sorts <b>[first, last)</b> into ascending order, preserving
the original ordering of equivalent elements. (This is important if elements
can be equivalent but not identical.)<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0870"
title="Add Comment A0870"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>partial_sort</b>(RandomAccessIterator
first, RandomAccessIterator middle, RandomAccessIterator last);<br>
void <b>partial_sort</b>(RandomAccessIterator first, RandomAccessIterator
middle, RandomAccessIterator last, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0871"
title="Add Comment A0871"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Sorts the number of elements from <b>[first, last)</b> that
can be placed in the range <b>[first, middle)</b>. The rest of the elements end
up in <b>[middle, last)</b> and have no guaranteed order.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0872"
title="Add Comment A0872"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>RandomAccessIterator <b>partial_sort_copy</b>(InputIterator
first, InputIterator last, RandomAccessIterator result_first,
RandomAccessIterator result_last);<br>
RandomAccessIterator <b>partial_sort_copy</b>(InputIterator first,
InputIterator last, RandomAccessIterator result_first, RandomAccessIterator
result_last, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0873"
title="Add Comment A0873"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Sorts the number of elements from <b>[first, last)</b> that
can be placed in the range <b>[result_first, result_last)</b> and copies those
elements into <b>[result_first, result_last)</b>. If the range <b>[first, last)</b>
is smaller than <b>[result_first, result_last)</b>, the smaller number of
elements is used.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0874"
title="Add Comment A0874"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>nth_element</b>(RandomAccessIterator
first, RandomAccessIterator nth, RandomAccessIterator last);<br>
void <b>nth_element</b>(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0875"
title="Add Comment A0875"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Just like <b>partial_sort(&nbsp;)</b>, <b>nth_element(&nbsp;)</b>
partially orders a range of elements. However, it’s much “less ordered” than <b>partial_sort(&nbsp;)</b>.
The only thing that <b>nth_element(&nbsp;)</b> guarantees is that whatever <i>location
</i>you choose will become a dividing point. All the elements in the range <b>[first,
nth) </b>will pair-wise satisfy the binary predicate (<b>operator&lt;</b> by default,
as usual),<b> </b>and all the elements in the range <b>(nth, last]</b> will
not. However, neither subrange is in any particular order, unlike <b>partial_sort(&nbsp;)</b>
which has the first range in sorted order.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0876"
title="Add Comment A0876"><sup>Comment</sup></a></p>

<p class=MsoNormal>If all you need is this very weak ordering (if, for example,
you’re determining medians, percentiles, and that sort of thing), this
algorithm is faster than <b>partial_sort(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0877"
title="Add Comment A0877"><sup>Comment</sup></a></p>

<h4>Locating elements in sorted ranges</h4>

<p class=MsoNormal>Once a range is sorted, you can use a group of operations to
find elements within those ranges. In the following functions, there are always
two forms. One assumes the intrinsic <b>operator&lt;</b> has been used to
perform the sort, and the second must be used if some other comparison function
object has been used to perform the sort. You must use the same comparison for
locating elements as you do to perform the sort; otherwise, the results are
undefined. In addition, if you try to use these functions on unsorted ranges,
the results will be undefined.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0883"
title="Add Comment A0883"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>binary_search</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value);<br>
bool <b>binary_search</b>(ForwardIterator first, ForwardIterator last, const
T&amp; value, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0884"
title="Add Comment A0884"><sup><span style='font-family:"Times New Roman"'>Comment</span></sup></a></p>

</div>

<p class=MsoNormal>Tells you whether <b>value</b> appears in the sorted range <b>[first,
last)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0885"
title="Add Comment A0885"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>lower_bound</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>lower_bound</b>(ForwardIterator first, ForwardIterator last,
const T&amp; value, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0886"
title="Add Comment A0886"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns an iterator indicating the first occurrence of <b>value</b>
in the sorted range <b>[first, last)</b>. If <b>value</b> is not present, an
iterator to where it would fit in the sequence is returned. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0887"
title="Add Comment A0887"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>upper_bound</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>upper_bound</b>(ForwardIterator first, ForwardIterator last,
const T&amp; value, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0888"
title="Add Comment A0888"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns an iterator indicating one past the last occurrence
of <b>value</b> in the sorted range <b>[first, last)</b>. If <b>value</b> is
not present, an iterator to where it would fit in the sequence is returned.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0889"
title="Add Comment A0889"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>pair&lt;ForwardIterator,
ForwardIterator&gt; <b>equal_range</b>(ForwardIterator first, ForwardIterator
last, const T&amp; value);<br>
pair&lt;ForwardIterator, ForwardIterator&gt; <b>equal_range</b>(ForwardIterator
first, ForwardIterator last, const T&amp; value, StrictWeakOrdering
binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0890"
title="Add Comment A0890"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>Essentially
combines <b>lower_bound(&nbsp;)</b> and <b>upper_bound(&nbsp;)</b> to return a <b>pair</b>
indicating the first and one-past-the-last occurrences of <b>value</b> in the
sorted range <b>[first, last)</b>. Both iterators indicate the location where <b>value</b>
would fit if it is not found.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0891"
title="Add Comment A0891"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>You may find
it surprising that the binary search algorithms take a forward iterator instead
of a random access iterator. (Most explanations of binary search use indexing.)
Remember that a random access iterator “is-a” forward iterator, and can be used
wherever the latter is specified. If the iterator passed to one of these algorithms
in fact supports random access, then the efficient logarithmic-time procedure
is used, otherwise a linear search is performed<a href="#_ftn75"
name="_ftnref75" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[75]</span></sup></span></span></sup></span></a>.</p>

</div>

<h4>Example</h4>

<p class=MsoNormal>The<b> </b>following example turns each input word into an <b>NString</b>
and added to a <b>vector&lt;NString&gt;</b>. The <b>vector</b> is then used to
demonstrate the various sorting and searching algorithms. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0878"
title="Add Comment A0878"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:SortedSearchTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test searching in sorted ranges</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;NString.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot; </p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  typedef
vector&lt;NString&gt;::iterator sit;</p>

<p class=CodeChar style='margin-left:0in'>  char* fname = &quot;test.txt&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  cout.setf(ios::boolalpha);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;NString&gt; original;</p>

<p class=CodeChar style='margin-left:0in'>  copy(istream_iterator&lt;string&gt;(in),
</p>

<p class=CodeChar style='margin-left:0in'>    istream_iterator&lt;string&gt;(),
back_inserter(original));</p>

<p class=CodeChar style='margin-left:0in'>  require(original.size() &gt;= 4,
&quot;Must have four elements&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;NString&gt;
v(original.begin(), original.end()), </p>

<p class=CodeChar style='margin-left:0in'>    w(original.size() / 2);</p>

<p class=CodeChar style='margin-left:0in'>  sort(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;sort&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  v = original;</p>

<p class=CodeChar style='margin-left:0in'>  stable_sort(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;stable_sort&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  v = original;</p>

<p class=CodeChar style='margin-left:0in'>  sit it = v.begin(), it2;</p>

<p class=CodeChar style='margin-left:0in'>  // Move iterator to middle</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; v.size() /
2; i++)</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  partial_sort(v.begin(), it,
v.end());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;middle = &quot;
&lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;partial_sort&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  v = original;</p>

<p class=CodeChar style='margin-left:0in'>  // Move iterator to a quarter
position</p>

<p class=CodeChar style='margin-left:0in'>  it = v.begin();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; v.size() /
4; i++)</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  // Less elements to copy from than
to the destination</p>

<p class=CodeChar style='margin-left:0in'>  partial_sort_copy(v.begin(), it,
w.begin(), w.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(w.begin(), w.end(),
&quot;partial_sort_copy&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Not enough room in destination</p>

<p class=CodeChar style='margin-left:0in'>  partial_sort_copy(v.begin(),
v.end(), w.begin(), </p>

<p class=CodeChar style='margin-left:0in'>    w.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(w.begin(), w.end(), &quot;w
partial_sort_copy&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // v remains the same through all
this process</p>

<p class=CodeChar style='margin-left:0in'>  assert(v == original);</p>

<p class=CodeChar style='margin-left:0in'>  nth_element(v.begin(), it,
v.end());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;The nth_element
= &quot; &lt;&lt; *it &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(v.begin(), v.end(),
&quot;nth_element&quot;);   </p>

<p class=CodeChar style='margin-left:0in'>  string f = original[rand() %
original.size()];</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;binary search:
&quot;</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; binary_search(v.begin(),
v.end(), f)</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  sort(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>  it = lower_bound(v.begin(),
v.end(), f);</p>

<p class=CodeChar style='margin-left:0in'>  it2 = upper_bound(v.begin(), v.end(),
f);</p>

<p class=CodeChar style='margin-left:0in'>  print(it, it2, &quot;found
range&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  pair&lt;sit, sit&gt; ip =</p>

<p class=CodeChar style='margin-left:0in'>    equal_range(v.begin(), v.end(),
f);</p>

<p class=CodeChar style='margin-left:0in'>  print(ip.first, ip.second,</p>

<p class=CodeChar style='margin-left:0in'>    &quot;equal_range&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example uses the <b>NString</b> class seen earlier,
which stores an occurrence number with copies of a string. The call to
stable_sort(&nbsp;) shows how the original order for objects with equal strings
is preserved. You can also see what happens during a partial sort (the
remaining unsorted elements are in no particular order). There is no “partial stable
sort.”<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0880"
title="Add Comment A0880"><sup>Comment</sup></a></p>

<p class=MsoNormal>Notice in the call to <b>nth_element(&nbsp;)</b> that,
whatever the nth element turns out to be (which will vary from one run to
another because of <b>URandGen</b>), the elements before that are less, and
after that are greater, but the elements have no particular order other than
that. Because of <b>URandGen</b>, there are no duplicates, but if you use a
generator that allows duplicates, you’ll see that the elements before the nth
element will be less than or equal to the nth element.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0882"
title="Add Comment A0882"><sup>Comment</sup></a></p>

<p class=MsoNormal>This example also illustrates all three binary search
algorithms. As advertised, <b>lower_bound(&nbsp;)</b> refers to the first
element in the sequence equal to a given key, <b>upper_bound(&nbsp;)</b> points
one past the last, and <b>equal_range(&nbsp;)</b> returns both results as a
pair. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1686"
title="Add Comment A1686"><sup>Comment</sup></a></p>

<h4>Merging sorted ranges</h4>

<p class=MsoNormal>As before, the first form of each function assumes the
intrinsic <b>operator&lt;</b> has been used to perform the sort. The second
form must be used if some other comparison function object has been used to
perform the sort. You must use the same comparison for locating elements as you
do to perform the sort; otherwise, the results are undefined. In addition, if
you try to use these functions on unsorted ranges, the results will be
undefined.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0895"
title="Add Comment A0895"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>merge</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);<br>
OutputIterator <b>merge</b>(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, OutputIterator result,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0896"
title="Add Comment A0896"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Copies elements from <b>[first1, last1)</b> and <b>[first2,
last2)</b> into <b>result</b>, such that the resulting range is sorted in
ascending order. This is a stable operation.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0897"
title="Add Comment A0897"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>inplace_merge</b>(BidirectionalIterator
first, BidirectionalIterator middle, BidirectionalIterator last);<br>
void <b>inplace_merge</b>(BidirectionalIterator first, BidirectionalIterator
middle, BidirectionalIterator last, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0898"
title="Add Comment A0898"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>This assumes that <b>[first, middle)</b> and <b>[middle,
last)</b> are each sorted ranges in the same sequence. The two ranges are
merged so that the resulting range <b>[first, last)</b> contains the combined
ranges in sorted order. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0899"
title="Add Comment A0899"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>It’s easier to see what goes on with merging if <b>int</b>s
are used; the following example also emphasizes how the algorithms (and our own
<b>print</b> template) work with arrays as well as containers. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0900"
title="Add Comment A0900"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:MergeTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Test merging in sorted ranges</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 15;</p>

<p class=CodeChar style='margin-left:0in'>  int a[sz*2] = {0};</p>

<p class=CodeChar style='margin-left:0in'>  // Both ranges go in the same
array:</p>

<p class=CodeChar style='margin-left:0in'>  generate(a, a + sz, SkipGen(0, 2));</p>

<p class=CodeChar style='margin-left:0in'>  a[3] = 4;</p>

<p class=CodeChar style='margin-left:0in'>  a[4] = 4;</p>

<p class=CodeChar style='margin-left:0in'>  generate(a + sz, a + sz*2,
SkipGen(1, 3));</p>

<p class=CodeChar style='margin-left:0in'>  print(a, a + sz,
&quot;range1&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(a + sz, a + sz*2,
&quot;range2&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int b[sz*2] = {0}; // Initialize
all to zero</p>

<p class=CodeChar style='margin-left:0in'>  merge(a, a + sz, a + sz, a + sz*2,
b);</p>

<p class=CodeChar style='margin-left:0in'>  print(b, b + sz*2,
&quot;merge&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Reset b</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>for(int i = 0; i &lt;
sz*2; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>b[i] = 0;</p>

<p class=CodeChar style='margin-left:0in'>  inplace_merge(a, a + sz, a + sz*2);</p>

<p class=CodeChar style='margin-left:0in'>  print(a, a + sz*2,
&quot;inplace_merge&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int* end = set_union(a, a + sz, a +
sz, a + sz*2, b);</p>

<p class=CodeChar style='margin-left:0in'>  print(b, end,
&quot;set_union&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, instead of creating two separate
arrays, both ranges are created end to end in the same array <b>a.</b> (This
will come in handy for the <b>inplace_merge.</b>) The first call to <b>merge(&nbsp;)</b>
places the result in a different array, <b>b</b>. For comparison, <b>set_union(&nbsp;)</b>
is also called, which has the same signature and similar behavior, exept that
it removes duplicates from the second set. Finally, <b>inplace_merge(&nbsp;)</b>
is used to combine both parts of <b>a</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0901"
title="Add Comment A0901"><sup>Comment</sup></a></p>

<h4>Set operations on sorted ranges</h4>

<p class=MsoNormal>Once ranges have been sorted, you can perform mathematical
set operations on them.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0902"
title="Add Comment A0902"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>includes</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);<br>
bool <b>includes</b>(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0903"
title="Add Comment A0903"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns <b>true</b> if <b>[first2, last2)</b> is a subset of
<b>[first1, last1)</b>. Neither range is required to hold only unique elements,
but if <b>[first2, last2)</b> holds <b>n</b> elements of a particular value, <b>[first1,
last1)</b> must also hold at least <b>n</b> elements if the result is to be <b>true</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0904"
title="Add Comment A0904"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_union</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);<br>
OutputIterator <b>set_union</b>(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, OutputIterator result,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0905"
title="Add Comment A0905"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Creates the mathematical union of two sorted ranges in the <b>result</b>
range, returning the end of the output range. Neither input range is required
to hold only unique elements, but if a particular value appears multiple times
in both input sets, the resulting set will contain the larger number of
identical values.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0906"
title="Add Comment A0906"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_intersection</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);<br>
OutputIterator <b>set_intersection</b>(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0907"
title="Add Comment A0907"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Produces, in <b>result</b>, the intersection of the two
input sets, returning the end of the output range—that is, the set of values
that appear in both input sets. Neither input range is required to hold only
unique elements, but if a particular value appears multiple times in both input
sets, the resulting set will contain the smaller number of identical values.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0908"
title="Add Comment A0908"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_difference</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);<br>
OutputIterator <b>set_difference</b>(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0909"
title="Add Comment A0909"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Produces, in <b>result</b>, the mathematical set difference,
returning the end of the output range. All the elements that are in <b>[first1,
last1)</b> but not in <b>[first2, last2)</b> are placed in the result set.
Neither input range is required to hold only unique elements, but if a
particular value appears multiple times in both input sets (<b>n</b> times in
set 1 and <b>m</b> times in set 2), the resulting set will contain <b>max(n-m,
0)</b> copies of that value.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0910"
title="Add Comment A0910"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_symmetric_difference</b>(InputIterator1
first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);<br>
OutputIterator <b>set_symmetric_difference</b>(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result, StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0911"
title="Add Comment A0911"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Constructs, in <b>result</b>, the set containing:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0912"
title="Add Comment A0912"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All the elements in set 1 that are not in set 2</p>

<p class=Numbered><span style='font-family:Verdana'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All the elements in set 2 that are not in set 1.</p>

<p class=MsoNormal>Neither input range is required to hold only unique
elements, but if a particular value appears multiple times in both input sets (<b>n</b>
times in set 1 and <b>m</b> times in set 2), the resulting set will contain <b>abs(n-m)</b>
copies of that value, in which <b>abs(&nbsp;)</b> is the absolute value. The
return value is the end of the output range.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0913"
title="Add Comment A0913"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>It’s easiest to see the set operations demonstrated using
simple vectors of characters, so you view the sets more easily. These
characters are randomly generated and then sorted, but the duplicates are not
removed so you can see what the set operations do when duplicates are involved.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0914"
title="Add Comment A0914"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:SetOperations.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Set operations on sorted ranges</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Generators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 30;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>char v[sz + 1], v2[sz
+ 1];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  CharGen g;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  generate(v, v + sz,
g);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  generate(v2, v2 + sz,
g);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  sort(v, v + sz);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  sort(v2, v2 + sz);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>print(v, v +
sz, &quot;v&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(v2, v2 + sz, &quot;v2&quot;,
&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  bool b = includes(v, v + sz, v +
sz/2, v + sz);</p>

<p class=CodeChar style='margin-left:0in'>  cout.setf(ios::boolalpha);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;includes:
&quot; &lt;&lt; b &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  char v3[sz*2 + 1], *end;</p>

<p class=CodeChar style='margin-left:0in'>  end = set_union(v, v + sz, v2, v2 +
sz, v3);</p>

<p class=CodeChar style='margin-left:0in'>  print(v3, end,
&quot;set_union&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  end = set_intersection(v, v + sz,</p>

<p class=CodeChar style='margin-left:0in'>    v2, v2 + sz, v3);</p>

<p class=CodeChar style='margin-left:0in'>  print(v3, end,
&quot;set_intersection&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  end = set_difference(v, v + sz, v2,
v2 + sz, v3);</p>

<p class=CodeChar style='margin-left:0in'>  print(v3, end,
&quot;set_difference&quot;, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  end = set_symmetric_difference(v, v
+ sz,</p>

<p class=CodeChar style='margin-left:0in'>    v2, v2 + sz, v3);</p>

<p class=CodeChar style='margin-left:0in'>  print(v3, end,
&quot;set_symmetric_difference&quot;,&quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>After <b>v</b> and <b>v2</b> are generated, sorted, and
printed, the <b>includes(&nbsp;)</b> algorithm is tested by seeing if the
entire range of <b>v</b> contains the last half of <b>v</b>, which of course it
does; so the result should always be true. The array <b>v3</b> holds the output
of <b>set_union(&nbsp;)</b>, <b>set_intersection(&nbsp;)</b>, <b>set_difference(&nbsp;),</b>
and <b>set_symmetric_difference(&nbsp;)</b>, and the results of each are
displayed so you can ponder them and convince yourself that the algorithms do
indeed work as promised. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0915"
title="Add Comment A0915"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440097"></a><a name="_Toc22433887">Heap operations</a></h3>

<p class=MsoNormal>A heap is an array-like data structure used to implement a
“priority queue”, which is just a range that is organized in a way that
accommodates retrieving elements by priority according to some comparison
function. The heap operations in the standard library allow a sequence to be
treated as a “heap” data structure, which always efficiently returns the
element of highest priority, without fully ordering the entire sequence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0916"
title="Add Comment A0916"><sup>Comment</sup></a></p>

<p class=MsoNormal>As with the “sort” operations, there are two versions of
each function. The first uses the object’s own <b>operator&lt;</b> to perform
the comparison; the second uses an additional <b>StrictWeakOrdering</b>
object’s <b>operator(&nbsp;)(a, b)</b> to compare two objects for <b>a</b> <b>&lt;</b>
<b>b</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0917"
title="Add Comment A0917"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>make_heap</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>make_heap</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0918"
title="Add Comment A0918"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Turns an arbitrary range into a heap. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0919"
title="Add Comment A0919"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>push_heap</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>push_heap</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0920"
title="Add Comment A0920"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Adds the element *(<b>last-1)</b> to the heap determined by
the range <b>[first, last-1)</b>. In other words, it places the last element in
its proper location in the heap.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0921"
title="Add Comment A0921"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>pop_heap</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>pop_heap</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0922"
title="Add Comment A0922"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Places the largest element (which is actually in <b>*first</b>,
before the operation, because of the way heaps are defined) into the position <b>*(last-1)</b>
<i>and</i> reorganizes the remaining range so that it’s still in heap order. If
you simply grabbed <b>*first</b>, the next element would not be the
next-largest element; so you must use <b>pop_heap(&nbsp;)</b> if you want to
maintain the heap in its proper priority-queue order.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0923"
title="Add Comment A0923"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>sort_heap</b>(RandomAccessIterator
first, RandomAccessIterator last);<br>
void <b>sort_heap</b>(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0924"
title="Add Comment A0924"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>This could be thought of as the complement of <b>make_heap(&nbsp;)</b>.
It takes a range that is in heap order and turns it into ordinary sorted order,
so it is no longer a heap. That means that if you call <b>sort_heap(&nbsp;),</b>
you can no longer use <b>push_heap(&nbsp;)</b> or <b>pop_heap(&nbsp;)</b> on
that range. (Rather, you can use those functions, but they won’t do anything
sensible.) This is not a stable sort.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0925"
title="Add Comment A0925"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440098"></a><a name="_Toc22433888">Applying an operation to
each element in a range</a></h3>

<p class=MsoNormal>These algorithms move through the entire range and perform
an operation on each element. They differ in what they do with the results of
that operation: <b>for_each(&nbsp;)</b> discards the return value of the
operation, and <b>transform(&nbsp;)</b> places the results of each operation
into a destination sequence (which can be the original sequence).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0926"
title="Add Comment A0926"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>UnaryFunction <b>for_each</b>(InputIterator
first, InputIterator last, UnaryFunction f); <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0927"
title="Add Comment A0927"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Applies the function object <b>f</b> to each element in <b>[first,
last)</b>, discarding the return value from each individual application of <b>f</b>.
If <b>f </b>is just a function pointer, you are typically not interested in the
return value; but if <b>f </b>is an object that maintains some internal state,
it can capture the combined return value of being applied to the range. The
final return value of <b>for_each(&nbsp;)</b> is <b>f</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0928"
title="Add Comment A0928"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>transform</b>(InputIterator
first, InputIterator last, OutputIterator result, UnaryFunction f);<br>
OutputIterator <b>transform</b>(InputIterator1 first, InputIterator1 last,
InputIterator2 first2, OutputIterator result, BinaryFunction f);</p>

</div>

<p class=MsoNormal>Like <b>for_each(&nbsp;)</b>, <b>transform(&nbsp;)</b>
applies a function object <b>f</b> to each element in the range <b>[first,
last)</b>. However, instead of discarding the result of each function call, <b>transform(&nbsp;)</b>
copies the result (using <b>operator=</b>) into <b>*result</b>, incrementing <b>result</b>
after each copy. (The sequence pointed to by <b>result</b> must have enough
storage; otherwise, you should use an inserter to force insertions instead of
assignments.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0929"
title="Add Comment A0929"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first form of <b>transform(&nbsp;)</b> simply calls <b>f(*first)</b>,
where first ranges through the input sequence. Similarly, the second form calls
<b>f(*first1, *first2)</b>.<b> </b>(Note that the length of the second input
range is determined by the length of the first.) The return value in both cases
is the past-the-end iterator for the resulting output range.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0930"
title="Add Comment A0930"><sup>Comment</sup></a></p>

<h4>Examples</h4>

<p class=MsoNormal>Since much of what you do with objects in a container is to
apply an operation to all those objects, these are fairly important algorithms
and merit several illustrations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0931"
title="Add Comment A0931"><sup>Comment</sup></a></p>

<p class=MsoNormal>First, consider <b>for_each(&nbsp;)</b>. This sweeps through
the range, pulling out each element and passing it as an argument as it calls
whatever function object it’s been given. Thus, <b>for_each(&nbsp;)</b>
performs operations that you might normally write out by hand. If you look in
your compiler’s header file at the template defining <b>for_each(&nbsp;)</b>,
you’ll see something like this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0933"
title="Add Comment A0933"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class InputIterator,
class Function&gt;</p>

<p class=CodeChar style='margin-left:0in'>Function for_each(InputIterator
first, </p>

<p class=CodeChar style='margin-left:0in'>                  InputIterator last,
</p>

<p class=CodeChar style='margin-left:0in'>                  Function f) {</p>

<p class=CodeChar style='margin-left:0in'>    while (first != last)
f(*first++);</p>

<p class=CodeChar style='margin-left:0in'>    return f;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=MsoNormal>The following example shows several ways this template can
be expanded. First, we need a class that keeps track of its objects so we can
know that it’s being properly destroyed: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0934"
title="Add Comment A0934"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Counted.h</p>

<p class=CodeChar style='margin-left:0in'>// An object that keeps track of
itself</p>

<p class=CodeChar style='margin-left:0in'>#ifndef COUNTED_H</p>

<p class=CodeChar style='margin-left:0in'>#define COUNTED_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Counted {</p>

<p class=CodeChar style='margin-left:0in'>  static int count;</p>

<p class=CodeChar style='margin-left:0in'>  char* ident;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Counted(char* id) : ident(id) {
count++; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  ~Counted() { </p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; ident &lt;&lt;
&quot; count = &quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; --count &lt;&lt;
std::endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int Counted::count = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class CountedVector : </p>

<p class=CodeChar style='margin-left:0in'>  public std::vector&lt;Counted*&gt;
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  CountedVector(char* id) {</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; 5; i++)</p>

<p class=CodeChar style='margin-left:0in'>      push_back(new Counted(id));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // COUNTED_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>class Counted</b> keeps a static count of how many <b>Counted</b>
objects have been created and tells you as they are destroyed<a href="#_ftn76"
name="_ftnref76" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[76]</span></sup></span></span></sup></span></a>. In addition, each <b>Counted</b>
keeps a <b>char*</b> identifier to make tracking the output easier.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0935"
title="Add Comment A0935"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>CountedVector</b> is derived from <b>vector&lt;Counted*&gt;</b>,
and in the constructor it creates some <b>Counted</b> objects, handing each one
your desired <b>char*</b>. The <b>CountedVector</b> makes testing quite simple,
as you’ll see. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0936"
title="Add Comment A0936"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:ForEach.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Use of STL for_each() algorithm</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Counted.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Function object:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class DeleteT {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void operator()(T* x) { delete x; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Template function:</p>

<p class=CodeChar style='margin-left:0in'>template &lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void wipe(T* x) { delete x; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CountedVector B(&quot;two&quot;);</p>

<p class=CodeChar style='margin-left:0in'> 
for_each(B.begin(),B.end(),DeleteT&lt;Counted&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  CountedVector C(&quot;three&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  for_each(C.begin(), C.end(),
wipe&lt;Counted&gt;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since this is obviously something you might want to do a
lot, why not create an algorithm to <b>delete</b> all the pointers in a
container? You could use <b>transform(&nbsp;)</b>. The value of <b>transform(&nbsp;)</b>
over <b>for_each(&nbsp;)</b> is that <b>transform(&nbsp;)</b> assigns the
result of calling the function object into a resulting range, which can
actually be the input range. That case means a literal transformation for the
input range, since each element would be a modification of its previous value.
In this example, this approach would be especially useful since it’s more
appropriate to assign to each pointer the safe value of zero after calling <b>delete</b>
for that pointer. <b>Transform(&nbsp;)</b> can easily do this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0938"
title="Add Comment A0938"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Transform.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Use of STL transform() algorithm</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Counted.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>T* deleteP(T* x) { delete x; return
0; }</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#ifdef _MSC_VER</p>

<p class=CodeChar style='margin-left:0in'>// Microsoft needs explicit
instantiation</p>

<p class=CodeChar style='margin-left:0in'>template Counted* deleteP(Counted*
x);</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt; struct
Deleter {</p>

<p class=CodeChar style='margin-left:0in'>  T* operator()(T* x) { delete x;
return 0; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CountedVector cv(&quot;one&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  transform(cv.begin(), cv.end(),
cv.begin(), </p>

<p class=CodeChar style='margin-left:0in'>    deleteP&lt;Counted&gt;);</p>

<p class=CodeChar style='margin-left:0in'>  CountedVector cv2(&quot;two&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  transform(cv2.begin(), cv2.end(),
cv2.begin(),</p>

<p class=CodeChar style='margin-left:0in'>    Deleter&lt;Counted&gt;());</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This shows both approaches: using a template function or a
templatized function object. After the call to <b>transform(&nbsp;)</b>, the
vector contains five null pointers, which is safer since any duplicate <b>delete</b>s
will have no effect.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0939"
title="Add Comment A0939"><sup>Comment</sup></a></p>

<p class=MsoNormal>One thing you cannot do is <b>delete</b> every pointer in a
collection without wrapping the call to <b>delete </b>inside a function or an
object. That is, you do the following: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0940"
title="Add Comment A0940"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>for_each(a.begin(),
a.end(), ptr_fun(operator delete));</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This has the same problem as the call to <b>destroy ( )</b>
did earlier: <b>operator delete(&nbsp;)</b> takes a void*, but iterators aren’t
void pointers (or pointers at all). Even if you could make it compile, what
you’d get is a sequence of calls to the function that releases the storage. You
will not get the effect of calling <b>delete</b> for each pointer in <b>a</b>,
however; the destructor will not be called. This is typically not what you
want, so you will need wrap your calls to <b>delete</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0941"
title="Add Comment A0941"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the previous example of <b>for_each(&nbsp;)</b>, the
return value of the algorithm was ignored. This return value is the function
that is passed in to <b>for_each(&nbsp;)</b>. If the function is just a pointer
to a function, the return value is not very useful, but if it is a function
object, that function object may have internal member data that it uses to
accumulate information about all the objects that it sees during <b>for_each(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0942"
title="Add Comment A0942"><sup>Comment</sup></a></p>

<p class=MsoNormal>For example, consider a simple model of inventory. Each <b>Inventory</b>
object has the type of product it represents (here, single characters will be
used for product names), the quantity of that product, and the price of each
item:<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0943"
title="Add Comment A0943"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:Inventory.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef INVENTORY_H</p>

<p class=CodeChar style='margin-left:0in'>#define INVENTORY_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#ifndef _MSC_VER</p>

<p class=CodeChar style='margin-left:0in'>// Microsoft namespace work-around</p>

<p class=CodeChar style='margin-left:0in'>using std::rand;</p>

<p class=CodeChar style='margin-left:0in'>using std::srand;</p>

<p class=CodeChar style='margin-left:0in'>using std::time;</p>

<p class=CodeChar style='margin-left:0in'>#endif</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Inventory {</p>

<p class=CodeChar style='margin-left:0in'>  char item;</p>

<p class=CodeChar style='margin-left:0in'>  int quantity;</p>

<p class=CodeChar style='margin-left:0in'>  int value;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Inventory(char it, int quant, int
val) </p>

<p class=CodeChar style='margin-left:0in'>    : item(it), quantity(quant),
value(val) {}</p>

<p class=CodeChar style='margin-left:0in'>  // Synthesized operator= &amp;
copy-constructor OK</p>

<p class=CodeChar style='margin-left:0in'>  char getItem() const { return item;
}</p>

<p class=CodeChar style='margin-left:0in'>  int getQuantity() const { return
quantity; }</p>

<p class=CodeChar style='margin-left:0in'>  void setQuantity(int q) { quantity
= q; }</p>

<p class=CodeChar style='margin-left:0in'>  int getValue() const { return
value; }</p>

<p class=CodeChar style='margin-left:0in'>  void setValue(int val) { value =
val; }</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp;
operator&lt;&lt;(</p>

<p class=CodeChar style='margin-left:0in'>    std::ostream&amp; os, const
Inventory&amp; inv) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; inv.item
&lt;&lt; &quot;: &quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;quantity &quot;
&lt;&lt; inv.quantity </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;, value &quot;
&lt;&lt; inv.value;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A generator:</p>

<p class=CodeChar style='margin-left:0in'>struct InvenGen {</p>

<p class=CodeChar style='margin-left:0in'>  InvenGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  Inventory operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    static char c = 'a';</p>

<p class=CodeChar style='margin-left:0in'>    int q = rand() % 100;</p>

<p class=CodeChar style='margin-left:0in'>    int v = rand() % 500;</p>

<p class=CodeChar style='margin-left:0in'>    return Inventory(c++, q, v);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // INVENTORY_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Member functions get the item name and get and set quantity
and value. An <b>operator&lt;&lt;</b> prints the <b>Inventory</b> object to an <b>ostream</b>.
A generator creates objects that have sequentially labeled items and random
quantities and values.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0944"
title="Add Comment A0944"><sup>Comment</sup></a></p>

<p class=MsoNormal>To find out the total number of items and total value, you
can create a function object to use with <b>for_each(&nbsp;)</b> that has data
members to hold the totals:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0945"
title="Add Comment A0945"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:CalcInventory.cpp</p>

<p class=CodeChar style='margin-left:0in'>// More use of for_each()</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Inventory.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// To calculate inventory totals:</p>

<p class=CodeChar style='margin-left:0in'>class InvAccum {</p>

<p class=CodeChar style='margin-left:0in'>  int quantity;</p>

<p class=CodeChar style='margin-left:0in'>  int value;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  InvAccum() : quantity(0), value(0)
{}</p>

<p class=CodeChar style='margin-left:0in'>  void operator()(const
Inventory&amp; inv) {</p>

<p class=CodeChar style='margin-left:0in'>    quantity += inv.getQuantity();</p>

<p class=CodeChar style='margin-left:0in'>    value += inv.getQuantity() *
inv.getValue();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const InvAccum&amp; ia) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; &quot;total
quantity: &quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; ia.quantity</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;, total value:
&quot; &lt;&lt; ia.value;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Inventory&gt; vi;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>generate_n(back_inserter(vi),
15, InvenGen());</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  print(vi.begin(),
vi.end(), &quot;vi&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>InvAccum ia =
for_each(vi.begin(),vi.end(),</p>

<p class=CodeChar style='margin-left:0in'>    InvAccum());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; ia &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><b>InvAccum</b>’s <b>operator(&nbsp;)</b> takes a single
argument, as required by <b>for_each(&nbsp;)</b>. As <b>for_each(&nbsp;)</b>
moves through its range, it takes each object in that range and passes it to <b>InvAccum::operator(&nbsp;)</b>,
which performs calculations and saves the result. At the end of this process, <b>for_each(&nbsp;)</b>
returns the <b>InvAccum</b> object that you can then examine; in this case, it
is simply printed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0946"
title="Add Comment A0946"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can do most things to the <b>Inventory</b> objects using
<b>for_each(&nbsp;)</b>. For example, <b>for_each(&nbsp;)</b> can handily
increase all the prices by 10%. But you’ll notice that the <b>Inventory</b>
objects have no way to change the <b>item</b> value. The programmers who
designed <b>Inventory</b> thought this was a good idea. After all, why would
you want to change the name of an item? But marketing has decided that they
want a “new, improved” look by changing all the item names to uppercase;
they’ve done studies and determined that the new names will boost sales (well,
marketing has to have <i>something</i> to do …). So <b>for_each(&nbsp;)</b>
will not work here, but <b>transform(&nbsp;)</b> will:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0947"
title="Add Comment A0947"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:TransformNames.cpp</p>

<p class=CodeChar style='margin-left:0in'>// More use of transform()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Inventory.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct NewImproved {</p>

<p class=CodeChar style='margin-left:0in'>  Inventory operator()(const
Inventory&amp; inv) {</p>

<p class=CodeChar style='margin-left:0in'>    return
Inventory(toupper(inv.getItem()), </p>

<p class=CodeChar style='margin-left:0in'>      inv.getQuantity(),
inv.getValue());</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>vector&lt;Inventory&gt;
vi;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV> 
generate_n(back_inserter(vi), 15, InvenGen());</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  print(vi.begin(),
vi.end(), &quot;vi&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>transform(vi.begin(),
vi.end(), vi.begin(),</p>

<p class=CodeChar style='margin-left:0in'>    NewImproved());</p>

<p class=CodeChar style='margin-left:0in'>  print(vi.begin(), vi.end(),
&quot;vi&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Notice that the resulting range is the same as the input
range; that is, the transformation is performed in place.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0948"
title="Add Comment A0948"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now suppose that the sales department needs to generate
special price lists with different discounts for each item. The original list
must stay the same, and any number of special lists need to be generated. Sales
will give you a separate list of discounts for each new list. To solve this problem,
we can use the second version of <b>transform(&nbsp;)</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0949"
title="Add Comment A0949"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:SpecialList.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using the second version of
transform()</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Inventory.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct Discounter {</p>

<p class=CodeChar style='margin-left:0in'>  Inventory operator()(const
Inventory&amp; inv,</p>

<p class=CodeChar style='margin-left:0in'>    float discount) {</p>

<p class=CodeChar style='margin-left:0in'>    return Inventory(inv.getItem(), </p>

<p class=CodeChar style='margin-left:0in'>      inv.getQuantity(), </p>

<p class=CodeChar style='margin-left:0in'>      int(inv.getValue() * (1 -
discount)));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct DiscGen {</p>

<p class=CodeChar style='margin-left:0in'>  DiscGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  float operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    float r = float(rand() % 10);</p>

<p class=CodeChar style='margin-left:0in'>    return r / 100.0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Inventory&gt; vi;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>generate_n(back_inserter(vi),
15, InvenGen());</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  print(vi.begin(),
vi.end(), &quot;vi&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>vector&lt;float&gt;
disc;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(disc), 15,
DiscGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(disc.begin(), disc.end(),
&quot;Discounts:&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Inventory&gt; discounted;</p>

<p class=CodeChar style='margin-left:0in'>  transform(vi.begin(),vi.end(),
disc.begin(), </p>

<p class=CodeChar style='margin-left:0in'>    back_inserter(discounted),
Discounter());</p>

<p class=CodeChar style='margin-left:0in'>  print(discounted.begin(),
discounted.end(), </p>

<p class=CodeChar style='margin-left:0in'>        &quot;discounted&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Given an <b>Inventory</b> object and a discount percentage,
the Discounter function object produces a new <b>Inventory</b> with the
discounted price. The <b>DiscGen</b> function object just generates random
discount values between 1% and 10% to use for testing. In <b>main(&nbsp;)</b>,
two <b>vector</b>s are created, one for <b>Inventory</b> and one for discounts.
These are passed to <b>transform(&nbsp;)</b> along with a <b>Discounter</b>
object, and <b>transform(&nbsp;) </b>fills a new <b>vector&lt;Inventory&gt;</b>
called <b>discounted</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0950"
title="Add Comment A0950"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440099"></a><a name="_Toc22433889">Numeric algorithms</a></h3>

<p class=MsoNormal>These algorithms are all tucked into the header <b>&lt;numeric&gt;</b>,
since they are primarily useful for performing numeric calculations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0951"
title="Add Comment A0951"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;numeric&gt;<br>
T <b>accumulate</b>(InputIterator first, InputIterator last, T result);<br>
T <b>accumulate</b>(InputIterator first, InputIterator last, T result,
BinaryFunction f);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0952"
title="Add Comment A0952"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>The first form is a generalized summation; for each element
pointed to by an iterator <b>i</b> in <b>[first, last)</b>, it performs the
operation <b>result = result + *i</b>, in which <b>result</b> is of type <b>T</b>.
However, the second form is more general; it applies the function <b>f(result,
*i)</b> on each element <b>*i</b> in the range from beginning to end.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0953"
title="Add Comment A0953"><sup>Comment</sup></a></p>

<p class=MsoNormal>Note the similarity between the second form of <b>transform(&nbsp;)</b>
and the second form of <b>accumulate(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0954"
title="Add Comment A0954"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;numeric&gt;<br>
T <b>inner_product</b>(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init);<br>
T <b>inner_product</b>(InputIterator1 first1, InputIterator1 last1, InputIterator2
first2, T init, BinaryFunction1 op1, BinaryFunction2 op2);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0955"
title="Add Comment A0955"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Calculates a generalized inner product of the two ranges <b>[first1,
last1)</b> and <b>[first2, first2 + (last1 - first1))</b>. The return value is
produced by multiplying the element from the first sequence by the “parallel”
element in the second sequence and then adding it to the sum. Thus, if you have
two sequences {1, 1, 2, 2} and {1, 2, 3, 4}, the inner product becomes<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0956"
title="Add Comment A0956"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>(1*1) + (1*2) + (2*3) +
(2*4)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which is 17. The <b>init</b> argument is the initial value
for the inner product; this is probably zero but may be anything and is
especially important for an empty first sequence, because then it becomes the
default return value. The second sequence must have at least as many elements
as the first.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0957"
title="Add Comment A0957"><sup>Comment</sup></a></p>

<p class=MsoNormal>The second form simply applies a pair of functions to its
sequence. The <b>op1</b> function is used in place of addition, and <b>op2</b>
is used instead of multiplication. Thus, if you applied the second version of <b>inner_product(&nbsp;)</b>
to the sequence, the result would be the following operations:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0958"
title="Add Comment A0958"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>init = op1(init, op2(1,1));</p>

<p class=CodeChar style='margin-left:0in'>init = op1(init, op2(1,2));</p>

<p class=CodeChar style='margin-left:0in'>init = op1(init, op2(2,3));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>init = op1(init, op2(2,4));</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Thus, it’s similar to <b>transform(&nbsp;),</b> but two
operations are performed instead of one.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0959"
title="Add Comment A0959"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;numeric&gt;<br>
OutputIterator <b>partial_sum</b>(InputIterator first, InputIterator last,
OutputIterator result);<br>
OutputIterator <b>partial_sum</b>(InputIterator first, InputIterator last,
OutputIterator result, BinaryFunction op);</p>

</div>

<p class=MsoNormal>Calculates a generalized partial sum. This means that a new
sequence is created, beginning at <b>result</b>; each element is the sum of all
the elements up to the currently selected element in <b>[first, last)</b>. For
example, if the original sequence is <b>{1, 1, 2, 2, 3},</b> the generated
sequence is <b>{1, 1 + 1, 1 + 1 + 2, 1 + 1  + 2 + 2, 1 + 1 + 2 + 2 + 3}</b>,
that is, <b>{1, 2, 4, 6, 9}</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0960"
title="Add Comment A0960"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the second version, the binary function <b>op</b> is used
instead of the <b>+</b> operator to take all the “summation” up to that point
and combine it with the new value. For example, if you use <b>multiplies&lt;int&gt;(&nbsp;)</b>
as the object for the sequence, the output is <b>{1, 1, 2, 4, 12}</b>. Note
that the first output value is always the same as the first input value.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0961"
title="Add Comment A0961"><sup>Comment</sup></a></p>

<p class=MsoNormal>The return value is the end of the output range <b>[result,
result + (last - first) )</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0962"
title="Add Comment A0962"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;numeric&gt;<br>
OutputIterator <b>adjacent_difference</b>(InputIterator first, InputIterator
last, OutputIterator result);<br>
OutputIterator <b>adjacent_difference</b>(InputIterator first, InputIterator
last, OutputIterator result, BinaryFunction op);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0963"
title="Add Comment A0963"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Calculates the differences of adjacent elements throughout
the range <b>[first, last)</b>. This means that in the new sequence, the value
is the value of the difference of the current element and the previous element
in the original sequence (the first value is unchanged). For example, if the
original sequence is <b>{1, 1, 2, 2, 3}</b>, the resulting sequence is <b>{1, 1
– 1, 2 – 1, 2 – 2, 3 – 2}</b>, that is: <b>{1, 0, 1, 0, 1}</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0964"
title="Add Comment A0964"><sup>Comment</sup></a></p>

<p class=MsoNormal>The second form uses the binary function <b>op</b> instead
of the <b>–</b> operator to perform the “differencing.” For example, if you use
<b>multiplies&lt;int&gt;(&nbsp;)</b> as the function object for the sequence,
the output is <b>{1, 1, 2, 4, 6}</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0965"
title="Add Comment A0965"><sup>Comment</sup></a></p>

<p class=MsoNormal>The return value is the end of the output range <b>[result,
result + (last - first) )</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0966"
title="Add Comment A0966"><sup>Comment</sup></a></p>

<h4>Example</h4>

<p class=MsoNormal>This program tests all the algorithms in <b>&lt;numeric&gt;</b>
in both forms, on integer arrays. You’ll notice that in the test of the form
where you supply the function or functions, the function objects used are the
ones that produce the same result as form one, so the results will be exactly
the same. This should also demonstrate a bit more clearly the operations that
are going on and how to substitute your own operations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0967"
title="Add Comment A0967"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C06:NumericTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;PrintSequence.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;numeric&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int a[] = { 1, 1, 2, 2, 3, 5, 7, 9,
11, 13 };</p>

<p class=CodeChar style='margin-left:0in'>  const int asz = sizeof a / sizeof
a[0];</p>

<p class=CodeChar style='margin-left:0in'>  print(a, a + asz, &quot;a&quot;,
&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int r = accumulate(a, a + asz, 0);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;accumulate 1:
&quot; &lt;&lt; r &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Should produce the same result:</p>

<p class=CodeChar style='margin-left:0in'>  r = accumulate(a, a + asz, 0,
plus&lt;int&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;accumulate 2:
&quot; &lt;&lt; r &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  int b[] = { 1, 2, 3, 4, 1, 2, 3, 4,
1, 2 };</p>

<p class=CodeChar style='margin-left:0in'>  print(b, b + sizeof b / sizeof
b[0], &quot;b&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  r = inner_product(a, a + asz, b,
0);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;inner_product
1: &quot; &lt;&lt; r &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Should produce the same result:</p>

<p class=CodeChar style='margin-left:0in'>  r = inner_product(a, a + asz, b, 0,
</p>

<p class=CodeChar style='margin-left:0in'>    plus&lt;int&gt;(),
multiplies&lt;int&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;inner_product
2: &quot; &lt;&lt; r &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  int* it = partial_sum(a, a + asz,
b);</p>

<p class=CodeChar style='margin-left:0in'>  print(b, it, &quot;partial_sum
1&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Should produce the same result:</p>

<p class=CodeChar style='margin-left:0in'>  it = partial_sum(a, a + asz, b,
plus&lt;int&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  print(b, it, &quot;partial_sum
2&quot;, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = adjacent_difference(a, a +
asz, b);</p>

<p class=CodeChar style='margin-left:0in'>  print(b, it,
&quot;adjacent_difference 1&quot;,&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Should produce the same result:</p>

<p class=CodeChar style='margin-left:0in'>  it = adjacent_difference(a, a +
asz, b, </p>

<p class=CodeChar style='margin-left:0in'>    minus&lt;int&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  print(b, it,
&quot;adjacent_difference 2&quot;,&quot; &quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note that the return value of <b>inner_product(&nbsp;)</b>
and <b>partial_sum(&nbsp;)</b> is the past-the-end iterator for the resulting
sequence, so it is used as the second iterator in the <b>print(&nbsp;)</b>
function.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0968"
title="Add Comment A0968"><sup>Comment</sup></a></p>

<p class=MsoNormal>Since the second form of each function allows you to provide
your own function object, only the first form of the functions is purely
“numeric.” You could conceivably do some things that are not intuitively
numeric with something like <b>inner_product(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0969"
title="Add Comment A0969"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440100"></a><a name="_Toc22433890">General utilities</a></h3>

<p class=MsoNormal>Finally, here are some basic tools that are used with the
other algorithms; you may or may not use them directly yourself.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0970"
title="Add Comment A0970"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;utility&gt;<br>
struct <b>pair</b>;<br>
<b>make_pair</b>(&nbsp;);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0971"
title="Add Comment A0971"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>This was described and used earlier in this chapter. A <b>pair</b>
is simply a way to package two objects (which may be of different types)
together into a single object. This is typically used when you need to return
more than one object from a function, but it can also be used to create a
container that holds <b>pair </b>objects or to pass more than one object as a
single argument. You access the elements by saying <b>p.first</b> and <b>p.second</b>,
in which <b>p</b> is the <b>pair</b> object. The function <b>equal_range(&nbsp;)</b>,
described in the last chapter and in this one, returns its result as a <b>pair</b>
of iterators. You can <b>insert(&nbsp;)</b> a <b>pair</b> directly into a <b>map</b>
or <b>multimap</b>; a <b>pair</b> is the <b>value_type</b> for those
containers.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0972"
title="Add Comment A0972"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you want to create a <b>pair </b>“on the fly,”, you
typically use the template function <b>make_pair(&nbsp;)</b> rather than
explicitly constructing a <b>pair</b> object.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0973"
title="Add Comment A0973"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;iterator&gt;<br>
<b>distance</b>(InputIterator first, InputIterator last);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0974"
title="Add Comment A0974"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Tells you the number of elements between <b>first</b> and <b>last</b>.
More precisely, it returns an integral value that tells you the number of times
<b>first</b> must be incremented before it is equal to <b>last</b>. No
dereferencing of the iterators occurs during this process.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0975"
title="Add Comment A0975"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;iterator&gt;<br>
void <b>advance</b>(InputIterator&amp; i, Distance n);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0976"
title="Add Comment A0976"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Moves the iterator <b>i</b> forward by the value of <b>n.</b>
(The iterator can also be moved backward for negative values of <b>n</b> if the
iterator is also a bidirectional iterator.) This algorithm is aware of
bidirectional iterators and will use the most efficient approach.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0977"
title="Add Comment A0977"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>&lt;iterator&gt;<br>
back_insert_iterator&lt;Container&gt; <b>back_inserter</b>(Container&amp; x);<br>
front_insert_iterator&lt;Container&gt; <b>front_inserter</b>(Container&amp; x);<br>
insert_iterator&lt;Container&gt; <b>inserter</b>(Container&amp; x, Iterator i);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0978"
title="Add Comment A0978"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>These functions are used to create iterators for the given
containers that will insert elements into the container, rather than overwrite
the existing elements in the container using <b>operator= </b>(which is the
default behavior). Each type of iterator uses a different operation for
insertion: <b>back_insert_iterator</b> uses <b>push_back(&nbsp;)</b>, <b>front_insert_iterator</b>
uses <b>push_front(&nbsp;),</b> and <b>insert_iterator</b> uses <b>insert(&nbsp;)</b>
(and thus it can be used with the associative containers, while the other two
can be used with sequence containers). These will be shown in some detail in
the next chapter.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0979"
title="Add Comment A0979"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>const
LessThanComparable&amp; <b>min</b>(const LessThanComparable&amp; a, const
LessThanComparable&amp; b);<br>
const T&amp; <b>min</b>(const T&amp; a, const T&amp; b, BinaryPredicate binary_pred);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0980"
title="Add Comment A0980"><sup>Comment</sup></a></p>

</div>

<p class=MsoNormal>Returns the lesser of its two arguments, or returns the
first argument if the two are equivalent. The first version performs comparisons
using <b>operator&lt;,</b> and the second passes both arguments to <b>binary_pred</b>
to perform the comparison.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0981"
title="Add Comment A0981"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>const
LessThanComparable&amp; <b>max</b>(const LessThanComparable&amp; a, <br>
  const LessThanComparable&amp; b);<br>
const T&amp; <b>max</b>(const T&amp; a, const T&amp; b, <br>
  BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Exactly like <b>min(&nbsp;)</b>, but returns the greater of
its two arguments.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0982"
title="Add Comment A0982"><sup>Comment</sup></a></p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>swap</b>(Assignable&amp;
a, Assignable&amp; b);<br>
void <b>iter_swap</b>(ForwardIterator1 a, ForwardIterator2 b);<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0983"
title="Add Comment A0983"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>Exchanges
the values of <b>a</b> and <b>b</b> using assignment. Note that all container
classes use specialized versions of <b>swap(&nbsp;)</b> that are typically more
efficient than this general version.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0984"
title="Add Comment A0984"><sup>Comment</sup></a></p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>The<b>
iter_swap(&nbsp;)</b> function swaps the values that its two arguments
reference.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0985"
title="Add Comment A0985"><sup>Comment</sup></a></p>

</div>

<h2 style='margin-left:0in'><a name="_Toc45440101"></a><a name="_Toc22433891">Creating
your own STL-style algorithms</a></h2>

<p class=MsoNormal>Once you become comfortable with the STL algorithm style,
you can begin to create your own generic algorithms. Because these will conform
to the conventions of all the other algorithms in the STL, they’re easy to use
for programmers who are familiar with the STL, and thus they become a way to
“extend the STL vocabulary.” <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0986"
title="Add Comment A0986"><sup>Comment</sup></a></p>

<p class=MsoNormal>The easiest way to approach the problem is to go to the <b>&lt;algorithm&gt;</b>
header file, find something similar to what you need, and pattern your code
after that<a href="#_ftn77" name="_ftnref77" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[77]</span></sup></span></span></sup></span></a>.
(Virtually all STL implementations provide the code for the templates directly
in the header files.) </p>

<p class=MsoNormal>Now that you’re comfortable with the ideas of the various
iterator types, the actual implementation is quite straightforward. You can
imagine creating an entire additional library of your own useful algorithms
that follow the format of the STL. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0989"
title="Add Comment A0989"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you take a close look at the list of algorithms in the
standard C++ library, you might notice a glaring omission: there is no <b>copy_if(&nbsp;)</b>
algorithm. Although it’s true that you can accomplish the same thing with <b>remove_copy_if(&nbsp;)</b>,
this is not quite as convenient because you have to invert the condition.
(Remember, <b>remove_copy_if(&nbsp;)</b> only copies those elements that <i>don’t</i>
match its predicate, in effect <i>removing</i> those that do.) You might be
tempted to write a function object adapter that negates its predicate before
passing it to <b>remove_copy_if(&nbsp;)</b>, by including a statement something
like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Assumes pred is the incoming
condition</p>

<p class=CodeInlineCharChar style='margin-left:0in'>replace_copy_if(begin, end,
not1(pred));</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This seems reasonable, but when you remember that you want
to be able to use predicates that are pointers to raw functions, you see why
this won’t work—<b>not1</b> expects an adaptable function object. The only
solution is to write a <b>copy_if(&nbsp;)</b> algorithm from scratch. Since you
know from inspecting the other copy algorithms that conceptually you need
separate iterators for input and output, the following example will do the job.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1679"
title="Add Comment A1679"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>//:
C06:copy_if.h</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>// Roll your
own STL-style algorithm</p>

<p class=CodeChar style='margin-left:0in'>#ifndef COPY_IF_H</p>

<p class=CodeChar style='margin-left:0in'>#define COPY_IF_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename ForwardIter,</p>

<p class=CodeChar style='margin-left:0in'>  typename OutputIter, typename
UnaryPred&gt;</p>

<p class=CodeChar style='margin-left:0in'>OutputIter copy_if(ForwardIter begin,
ForwardIter end,</p>

<p class=CodeChar style='margin-left:0in'>  OutputIter dest, UnaryPred f) {</p>

<p class=CodeChar style='margin-left:0in'>  while(begin != end) {</p>

<p class=CodeChar style='margin-left:0in'>    if(f(*begin))</p>

<p class=CodeChar style='margin-left:0in'>      *dest++ = *begin;</p>

<p class=CodeChar style='margin-left:0in'>    ++begin;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return dest;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // COPY_IF_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45440102"></a><a name="_Toc22433892">Summary</a></h2>

<p class=MsoNormal>The goal of this chapter was to give you a practial
understanding of the algorithms in the Standard Template Library. That is, to
make you aware of and comfortable enough with the STL that you begin to use it
on a regular basis (or, at least, to think of using it so you can come back
here and hunt for the appropriate solution). It is powerful not only because
it’s a reasonably complete library of tools, but also because it provides a
vocabulary for thinking about problem solutions and because it is a framework
for creating additional tools. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0990"
title="Add Comment A0990"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although this chapter did show some examples of creating
your own tools, we did not go into the full depth of the theory of the STL that
is necessary to completely understand all the STL nooks and crannies to allow
you to create tools more sophisticated than those shown here. This was in part
because of space limitations, but mostly because it is beyond the charter of
this book; our goal here is to give you practical understanding that will
affect your day-to-day programming skills. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0991"
title="Add Comment A0991"><sup>Comment</sup></a></p>

<p class=MsoNormal>A number of books are dedicated solely to the STL (these are
listed in the appendices), but we especially recommend Matthew H. Austern’s <i>Generic
Programming and the STL</i>  (Addison-Wesley, 1999) and Scott Meyers’s<i>
Effective STL</i> (Addison-Wesley, 2002). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0992"
title="Add Comment A0992"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440103"></a><a name="_Toc22433893">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a generator that returns the current value of <b>clock(&nbsp;)</b>
(in <b>&lt;ctime&gt;</b>). Create a <b>list&lt;clock_t&gt;,</b> and fill it
with your generator using <b>generate_n(&nbsp;)</b>. Remove any duplicates in
the list and print it to <b>cout</b> using <b>copy(&nbsp;)</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using <b>transform(&nbsp;)</b> and <b>toupper(&nbsp;)</b> (in <b>&lt;cctype&gt;</b>),
write a single function call that will convert a string to all uppercase
letters.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a <b>Sum</b> function object template that will accumulate
all the values in a range when used with <b>for_each(&nbsp;)</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write an anagram generator that takes a word as a command-line
argument and produces all possible permutations of the letters.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a “sentence anagram generator” that takes a sentence as a
command-line argument and produces all possible permutations of the words in
the sentence. (It leaves the words alone and just moves them around.)</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a class hierarchy with a base class <b>B</b> and a derived
class <b>D</b>. Put a <b>virtual</b> member function <b>void f(&nbsp;)</b> in <b>B</b>
such that it will print a message indicating that <b>B</b>’s <b>f(&nbsp;)</b>
has been called, and redefine this function for <b>D</b> to print a different
message. Create a <b>vector&lt;B*&gt;,</b> and fill it with <b>B</b> and <b>D</b>
objects. Use <b>for_each(&nbsp;)</b> to call <b>f(&nbsp;)</b> for each of the
objects in your vector.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>FunctionObjects.cpp</b> so that it uses <b>float</b>
instead of <b>int</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>8. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>FunctionObjects.cpp</b> so that it templatizes the main
body of tests so you can choose which type you’re going to test. (You’ll have
to pull most of <b>main(&nbsp;)</b> out into a separate template function.)</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>9. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that takes an integer as a command lineargument
and finds all of its factors.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>10. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that takes as a command-line argument the name of
a text file. Open this file and read it a word at a time (hint: use <b>&gt;&gt;</b>).
Store each word into a <b>vector&lt;string&gt;</b>. Force all the words to
lowercase, sort them, remove all the duplicates, and print the results.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>11. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that finds all the words that are in common
between two input files, using <b>set_intersection(&nbsp;)</b>. Change it to
show the words that are not in common, using <b>set_symmetric_difference(&nbsp;)</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>12. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a program that, given an integer on the command line,
creates a “factorial table” of all the factorials up to and including the
number on the command line. To do this, write a generator to fill a <b>vector&lt;int&gt;</b>,
and then use <b>partial_sum(&nbsp;)</b> with a standard function object.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>13. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>CalcInventory.cpp</b> so that it will find all the
objects that have a quantity that’s less than a certain amount. Provide this
amount as a command-line argument, and use <b>copy_if(&nbsp;)</b> and <b>bind2nd(&nbsp;)</b>
to create the collection of values less than the target value.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>14. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use <b>UrandGen( )</b> to generate 100 numbers. (The size of the
numbers does not matter.)  Find which numbers in your range are congruent mod
23 (meaning they have the same remainder when divided by 23). Manually pick a
random number yourself, and find if that number is in your range by dividing
each number in the list by your number and checking if the result is 1 instead
of just using <b>find( )</b> with your value.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>15. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Fill a <b>vector&lt;double&gt;</b> with numbers representing
angles in radians. Using function object composition, take the sine of all the
elements in your vector (see <b>&lt;cmath&gt;</b>).</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>16. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Test the speed of your computer.  Call <b>srand(time(0))</b>,
then make an array of random numbers. Call <b>srand(time(0))</b> again and
generate the same number of random numbers in a second array. Use <b>equal( )</b>
to see if the arrays are the same.  (If your computer is fast enough, <b>time(0)</b>
will return the same value both times it is called.) If the arrays are not the
same, sort them and use <b>mismatch( )</b> to see where they differ. If they
are the same, increase the length of your array and try again.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>17. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create an STL-style algorithm <b>transform_if(&nbsp;)</b>
following the first form of <b>transform(&nbsp;)</b> that performs
transformations only on objects that satisfy a unary predicate. Objects that
don’t satisfy the predicate are omitted from the result. It needs to return a
new “end” iterator.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>18. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create an STL-style algorithm that is an overloaded version of <b>for_each(&nbsp;)</b>
which follows the second form of <b>transform(&nbsp;)</b> and takes two input
ranges so it can pass the objects of the second input range a to a binary
function that it applies to each object of the first range.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>19. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a <b>Matrix</b> class that is made from a <b>vector&lt;vector&lt;int&gt;
&gt;</b>. Provide it with a friend <b>ostream&amp;
operator&lt;&lt;(ostream&amp;, const Matrix&amp;)</b> to display the matrix.
Create the following binary operations using the STL function objects where
possible: <b>operator+(const Matrix&amp;, const Matrix&amp;)</b> for matrix
addition, <b>operator*(const Matrix&amp;, const vector&lt;int&gt;&amp;)</b> for
multiplying a matrix by a vector, and <b>operator*(const Matrix&amp;, const
Matrix&amp;)</b> for matrix multiplication. (You might need to look up the
mathematical meanings of the matrix operations if you don’t remember them.)
Demonstrate each.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>20. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using the characters<br>
<span class=CodeCharChar>&quot;~`!@#$%^&amp;*()_-+=}{[]|\:;&quot;'&lt;.&gt;,?/&quot;</span>,<br>
generate a codebook using an input file given on the command line as a
dictionary of words. Don't worry about stripping off the non-alphabetic
characters nor worry about case of the words in the dictionary file. Map each
permutation of the character string to a word such as the following:<br>
<br>
<span class=CodeCharChar><span style='font-size:11.0pt'>&quot;=')/%[}]|{*@?!&quot;`,;&gt;&amp;^-~_:$+.#(&lt;\&quot;  
apple<br>
&quot;|]\~&gt;#.+%(/-_[`':;=}{*&quot;$^!&amp;?),@&lt;&quot;   carrot<br>
&quot;@=~['].\/&lt;-`&gt;#*)^%+,&quot;;&amp;?!_{:|$}(&quot;   Carrot<br>
etc.<br>
</span></span><br>
Make sure that no duplicate codes or words exist in your code book. Use <b>lexicographical_compare(
)</b> to perform a sort on the codes. Use your code book to encode the
dictionary file. Decode your encoding of the dictionary file, and make sure you
get the same contents back.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>21. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using the following names:</p>

<p class=Exercises style='text-indent:0in'>&nbsp;</p>

<p class=Exercises style='text-indent:0in'>Jon Brittle</p>

<p class=Exercises style='text-indent:0in'>Jane Brittle</p>

<p class=Exercises style='text-indent:0in'>Mike Brittle</p>

<p class=Exercises style='text-indent:0in'>Sharon Brittle</p>

<p class=Exercises style='text-indent:0in'>George Jensen</p>

<p class=Exercises style='text-indent:0in'>Evelyn Jensen</p>

<p class=Exercises style='text-indent:0in'>&nbsp;</p>

<p class=Exercises style='text-indent:0in'>Find all the possible ways to
arrange them for a wedding picture.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>22. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>After being separated for one picture, the bride and groom
decided they wanted to be together for all of them.  Find all the possible ways
to arrange the people for the picture if the bride and groom (Jon Brittle and
Jane Brittle) are to be next to each other. <b><span style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I350&gt;</span></b></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>23. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A travel company wants to find out the average number of days
people take to travel from one end of the continent to another.  The problem is
that in the survey, some people did not take a direct route and took much
longer than is needed (such unusual data points are called “outliers”). Using
the following generator following, generate travel days into a vector.  Use <b>remove_if()</b>
to remove all the outliers in your vector.  Take the average of the data in the
vector to find out how long people generally take to travel.</p>

<p class=Exercises style='margin-left:.5in;text-indent:.5in'>&nbsp;</p>

<p class=Exercises style='margin-left:.5in;text-indent:.5in'><span
style='font-family:"Courier New"'>int travelTime() {</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:0in'><span
style='font-family:"Courier New"'>        // The &quot;outlier&quot;</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:0in'><span
style='font-family:"Courier New"'>        if(rand() % 10 == 0)</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:0in'><span
style='font-family:"Courier New"'>          return rand() % 100;</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:0in'><span
style='font-family:"Courier New"'>        // Regular route</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:0in'><span
style='font-family:"Courier New"'>        return rand() % 10 + 10;</span></p>

<p class=Exercises style='margin-left:.5in;text-indent:.5in'><span
style='font-family:"Courier New"'>}</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:0in'><b><span
style='display:none'> &lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I353&gt;</span></b></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>24. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Determine how much faster <b>binary_search()</b> is to <b>find()</b>
when it comes to searching <i>sorted</i> ranges.<span style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I354&gt;</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>25. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The army wants to recruit people from its selective service
list.  They have decided to recruit those that signed up for the service in
1997 starting from the oldest down to the youngest.  Generate an arbitrary
amount of people (give them data members such as <b>age</b> and <b>yearEnrolled</b>)
into a vector.  Partition the vector so that those who enrolled in 1997 are
ordered at the beginning of the list, starting from the youngest to the oldest,
and leave the remaining part of the list sorted according to age.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>26. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make a <b>class</b> called Town with population, altitude, and
weather data members.  Make the weather an <b>enum</b> with <b>{ RAINY, SNOWY,
CLOUDY, CLEAR }</b>.  Make a class that generates Town objects. Generate town
names (whether they make sense or not it doesn’t matter) or pull them off the
internet.  Ensure that the whole town name is lower case and there are no
duplicate names.  For simplicity, we recommend keeping your town names to one
word.  For the population, altitudes, and weather fields, make a generator that
will randomly generate weather conditions, populations within the range [100 to
1,000,000) and altitudes between [0, 8000) feet.  Fill a vector with your Town objects. 
Rewrite the vector out to a new file called Towns.txt.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>27. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>There was a baby boom, resulting in a 10% population increase in
every town.  Update your town data using <b>transform()</b>, rewrite your data
back out to file.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>28. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Find the towns with the highest and lowest population. 
Temporarily implement <b>operator&lt;</b> for your town object for this
exercise.  Also try implementing a function that returns true if its first
parameter is less than its second.  Use it as a predicate to call the algorithm
you use.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>29. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Find all the towns within the altitudes 2500-3500 feet
inclusive.  Implement equality operators for the <b>Town</b> class as needed.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>30. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>We need to place an airport in a certain altitude, but location
is not a problem. Organize your list of towns so that there are no duplicate (duplicate
meaning that no two altitudes are within the same 100 ft range.  Such classes
would include [100, 199), [200, 199), etc. altitudes. Sort this list in
ascending order in at least two different ways using the function objects in <b>&lt;functional&gt;</b>. 
Do the same for descending order.  Implement relational operators for <b>Town</b>
as needed.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>31. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Generate an arbitrary number of random numbers in a stack-based
array.  Use <b>max_element()</b> to find the largest number in array.  Swap it
with the number at the end of your array.  Find the next largest number and
place it in the array in the position before the previous number.  Continue
doing this until all elements have been moved.  When the algorithm is complete,
you will have a sorted array.  (This is a “selection sort”.)</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>32. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that will take phone numbers from a file (that
also contains names and other suitable information) and change the numbers that
begin with 222 to 863.  Be sure to save the old numbers.  The file format is be
as follows:</p>

<p class=Exercises style='margin-left:1.25in'>222 8945</p>

<p class=Exercises style='margin-left:1.25in'>756 3920</p>

<p class=Exercises style='margin-left:1.25in'>222 8432</p>

<p class=Exercises style='margin-left:1.25in'>etc.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>33. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program that given a last name will find everyone with
that last name with his or her corresponding phone number. Use the algorithms
that deal with ranges (<b>lower_bound</b>, <b>upper_bound</b>, <b>equal_range</b>,
etc.). Sort with the last name acting as a primary key and the first name
acting as a secondary key. Assume that you will read the names and numbers from
a file where the format will be as follows. (Be sure to order them so that the
last names are ordered, and the first names are ordered within the last
names.):</p>

<p class=Exercises style='text-indent:0in'><b>&nbsp;</b></p>

<p class=Exercises style='text-indent:0in'>John Doe                            345
9483</p>

<p class=Exercises style='text-indent:0in'>Nick Bonham    349 2930</p>

<p class=Exercises style='text-indent:0in'>Jane Doe                             283
2819</p>

<p class=Exercises style='text-indent:0in'>&nbsp;</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>34. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Given a file with data similar to the following, pull all the
state acronyms from the file and put them in a separate file. (Note that you
can’t depend on the line number for the type of data.  The data is on random
lines.)</p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'>&nbsp;</p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>ALABAMA</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>AL</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
style='font-size:10.0pt;font-family:Arial'>AK</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>ALASKA</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>ARIZONA</span><span
style='font-size:10.0pt;font-family:Arial'> </span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
style='font-size:10.0pt;font-family:Arial'>AZ</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>ARKANSAS</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
style='font-size:10.0pt;font-family:Arial'>AR</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
style='font-size:10.0pt;font-family:Arial'>CA</span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
  style='font-size:10.0pt;font-family:Arial'>CALIFORNIA</span><span
style='font-size:10.0pt;font-family:Arial'> </span></p>

<p class=Exercises style='margin-left:.75in;text-indent:.25in'><span
style='font-size:10.0pt;font-family:Arial'>CO</span></p>

<p class=Exercises style='text-indent:0in'><span style='font-size:10.0pt;
  font-family:Arial'>COLORADO</span></p>

<p class=Exercises style='text-indent:0in'><span style='font-size:10.0pt;
font-family:Arial'>etc.</span></p>

<p class=Exercises style='text-indent:0in'>&nbsp;</p>

<p class=Exercises style='text-indent:0in'>When complete, you should have a
file with all the state acronyms which are:</p>

<p class=Exercises style='margin-left:.75in;text-indent:0in'>AL AK AZ AR CA CO
  CT DE FL GA HI ID IL IN IA KS KY LA ME MD MA MI MN MS MO MT NE NV NH NJ NM NY
NC ND OH OK OR PA RI SC SD TN TX UT VT VA WA WV WI WY</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>35. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Make an <b>Employee </b>class with two data members:  <b>hours </b>and
<b>hourlyPay</b>. Employee shall also have a <b>calcSalary()</b> function which
returns the pay for that employee. Generate random hourly pay and hours for an
arbitrary amount of employees. Keep a <b>vector&lt;Employee*&gt;</b>. Find out
how much money the company is going to spend for this pay period.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>36. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Race <b>sort(), partial_sort(), </b>and <b>nth_element()</b>
against each other and find out if it’s really worth the time saved to use one
of the weaker sorts if they’re all that’s needed.</p>

</div>

<span style='font-size:13.0pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span>

<div class=Section13>

<h1 style='margin-left:-81.35pt'><a name="_Toc45440104">7: Generic containers</a></h1>

<p class=Intro style='margin-left:.25in'><a name=STLContainersChapter></a><i>Container
classes </i>are the solution to a specific kind of code reuse problem. They are
building blocks used to create object-oriented programs—they make the internals
of a program much easier to construct.</p>

<p class=MsoNormal>A container class describes an object that holds other
objects. Container classes are so important that they were considered
fundamental to early object-oriented languages. In Smalltalk, for example,
programmers think of the language as the program translator together with the
class library, and a critical part of that library is the container classes. So
it became natural that C++ compiler vendors also include a container class
library. You’ll note that the <b>vector</b> was so useful that it was
introduced in its simplest form very early in this book.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0993"
title="Add Comment A0993"><sup>Comment</sup></a></p>

<p class=MsoNormal>Like many other early C++ libraries, early container class
libraries followed Smalltalk’s <i>object-based hierarchy</i>, which worked well
for Smalltalk, but turned out to be awkward and difficult to use in C++.
Another approach was required.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0994"
title="Add Comment A0994"><sup>Comment</sup></a></p>

<p class=MsoNormal>The C++ approach to containers is based, of course, on
templates. The containers in the standard C++ library represent a broad range
of data structures designed to work well with the standard algorithms and to
meet common software development needs. </p>

<h2 style='margin-left:0in'><a name="_Toc312374088"></a><a name="_Toc305628753"></a><a
name="_Toc305593281"></a><a name="_Toc312374160"></a><a name="_Toc45440105"></a><a
name="_Toc408018396"></a><a name="_Toc375545199">Containers and iterators</a></h2>

<p class=MsoNormal>If you don’t know how many objects you’re going to need to
solve a particular problem, or how long they will last, you also don’t know
ahead of time how to store those objects. How can you know how much space to
create? You don’t until run time. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0996"
title="Add Comment A0996"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution to most problems in object-oriented design
seems simple: you create another type of object. For the storage problem, the
new type of object holds other objects or pointers to objects. This new type of
object, which is typically referred to in C++ as a <i>container</i> (also
called a <i>collection</i> in some languages), expands itself whenever
necessary to accommodate everything you place inside it. You don’t need to know
ahead of time how many objects you’re going to place in a container; you just
create a container object and let it take care of the details. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0997"
title="Add Comment A0997"><sup>Comment</sup></a></p>

<p class=MsoNormal>Fortunately, a good object-oriented programming language
comes with a set of containers. In C++, it’s the Standard Template Library. In
some libraries, a generic container is considered good enough for all needs,
and in others (C++ in particular) the library has different types of containers
for different needs: a vector for consistent access to all elements, and a
linked list for consistent insertion at all positions, and many more, so you
can choose the particular type that fits your needs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0998"
title="Add Comment A0998"><sup>Comment</sup></a></p>

<p class=MsoNormal>All containers have some way to put things in and get things
out. The way you place something into a container is fairly obvious. There’s a
function called “push” or “add” or a similar name. Fetching things out of a
container is not always as apparent; if an entity is array-like, such as a vector,
you might be able to use an indexing operator or function. But in many
situations this doesn’t make sense. Also, a single-selection function is
restrictive. What if you want to manipulate or compare a group of elements in
the container? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA0999"
title="Add Comment A0999"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution for flexible element access is an <i>iterator</i>,
an object whose job is to select the elements within a container and present
them to the user of the iterator. As a class, an iterator also provides a level
of abstraction, which you can use to separate the details of the container from
the code that’s accessing that container. The container, via the iterator, is
seen as a sequence. The iterator lets you traverse that sequence without
worrying about the underlying structure—that is, whether it’s a vector, a
linked list, a set, or something else. This gives you the flexibility to easily
change the underlying data structure without disturbing the code in your
program that traverses the container. Separating iteration from the control of
the container traversed also allows having multiple iterators simultaneously. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1000"
title="Add Comment A1000"><sup>Comment</sup></a></p>

<p class=MsoNormal>From a design standpoint, all you really want is a sequence
that can be manipulated to solve your problem. If a single type of sequence
satisfied all your needs, there’d be no reason to have different kinds. You
need a choice of containers for two reasons. First, containers provide
different types of interfaces and external behavior. A stack has an interface
and a behavior that is different from that of a queue, which is different from
that of a set or a list. One of these might provide a more flexible solution to
your problem than the other. Second, different containers have different
efficiencies for certain operations. Compare a vector to a list, as an example.
Both are simple sequences that can have nearly identical interfaces and
external behaviors. But certain operations can have radically different costs.
Randomly accessing elements in a vector is a constant-time operation; it takes
the same amount of time regardless of the element you select. However, it is
expensive to move through a linked list to randomly access an element, and it
takes longer to find an element if it is farther down the list. On the other
hand, if you want to insert an element in the middle of a sequence, it’s much
cheaper in a list than in a vector. The efficiencies of these and other operations
depend on the underlying structure of the sequence. In the design phase, you
might start with a list and, when tuning for performance, change to a vector,
or vice-versa. Because of iterators, code that merely traverses sequences is
insulated from changes in the underlying sequence implementation. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1001"
title="Add Comment A1001"><sup>Comment</sup></a></p>

<p class=MsoNormal>Remember that a container is only a storage cabinet in which
to put objects. If that cabinet solves all your needs, it probably doesn’t
really matter <i>how</i> it is implemented. If you’re working in a programming
environment that has built-in overhead due to other factors, the cost
difference between a vector and a linked list might not matter. You might need
only one type of sequence. You can even imagine the “perfect” container
abstraction, which can automatically change its underlying implementation
according to the way it is used. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1002"
title="Add Comment A1002"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440106">STL reference documentation</a></h3>

<p class=MsoNormal>As in the previous chapter, you will notice that this
chapter does not contain exhaustive documentation describing each of the member
functions in each STL container. Although we describe the member functions we
use, we’ve left the full descriptions to others. We recommend the online
resources available for the Dinkumware, Silicon Graphics, and STLPort STL
implementations.<a href="#_ftn78" name="_ftnref78" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[78]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1003"
title="Add Comment A1003"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440107">A first look</a></h2>

<p class=MsoNormal>Here’s an example using the <b>set</b> class template, a container modeled after a traditional mathematical set and which does not accept
duplicate values. This simple <b>set</b> was created to work with <b>int</b>s: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1007"
title="Add Comment A1007"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Intset.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Simple use of STL set</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;int&gt; intset;</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; 25; i++)</p>

<p class=CodeChar style='margin-left:0in'>      for(int j = 0; j &lt; 10; j++)</p>

<p class=CodeChar style='margin-left:0in'>        // Try to insert duplicates:</p>

<p class=CodeChar style='margin-left:0in'>        intset.insert(j);</p>

<p class=CodeChar style='margin-left:0in'>  assert(intset.size() == 10);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>insert(&nbsp;)</b> member does all the work: it
attempts to insert an element and ignores it if it’s already there. Often the
only activities involved in using a set are simply insertion and testing to see
whether it contains the element. You can also form a union, an intersection, or
a difference of sets and test to see if one set is a subset of another. In this
example, the values 0–9 are inserted into the set 25 times, but only the 10
unique instances are accepted. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1009"
title="Add Comment A1009"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now consider taking the form of <b>Intset.cpp</b> and
modifying it to display a list of the words used in a document. The solution
becomes remarkably simple. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1012"
title="Add Comment A1012"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:WordSet.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void wordSet(char* fileName) {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream source(fileName);</p>

<p class=CodeChar style='margin-left:0in'>  assure(source, fileName);</p>

<p class=CodeChar style='margin-left:0in'>  string word;</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;string&gt; words;</p>

<p class=CodeChar style='margin-left:0in'>  while(source &gt;&gt; word)</p>

<p class=CodeChar style='margin-left:0in'>    words.insert(word);</p>

<p class=CodeChar style='margin-left:0in'>  copy(words.begin(), words.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(cout, &quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Number of
unique words:&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; words.size() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>}  </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1)</p>

<p class=CodeChar style='margin-left:0in'>    wordSet(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  else</p>

<p class=CodeChar style='margin-left:0in'>    wordSet(&quot;WordSet.cpp&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The only substantive difference here is that <b>string</b>
is used instead of <b>int</b>. The words are pulled from a file, but the other
operations are similar to those in <b>Intset.cpp</b>. Not only does the output
reveal that duplicates have been ignored, but because of the way <b>set</b> is
implemented, the words are automatically sorted. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1013"
title="Add Comment A1013"><sup>Comment</sup></a></p>

<p class=MsoNormal>A set is an example of an <i>associative container</i>, one
of the three categories of containers provided by the standard C++ library. The
containers and their categories are summarized in the following table.</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.25in;border-collapse:collapse;border:none'>
 <tr>
  <td valign=top style='border-top:solid windowtext 1.0pt;border-left:none;
  border-bottom:solid windowtext 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Category</p>
  </td>
  <td valign=top style='border-top:solid windowtext 1.0pt;border-left:none;
  border-bottom:solid windowtext 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Containers</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Simple Sequence Containers</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>vector, list, deque</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Container Adapters</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>queue, stack, priority_queue</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Associative Containers</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>set, map, multiset, multimap</p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>All the containers in the standard library hold objects and
expand their resources as needed. The key difference between one container and
another is the way the objects are stored in memory and what operations are
available to the user. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1016"
title="Add Comment A1016"><sup>Comment</sup></a></p>

<p class=MsoNormal>A <b>vector</b>, as you already know, is a linear sequence
that allows rapid random access to its elements. However, it’s expensive to
insert an element in the middle of a co-located sequence like a vector, just as
it is with an array. A <b>deque</b> (double-ended-queue, pronounced “deck”)
also allows random access that’s nearly as fast as<b> vector</b>, but it’s
significantly faster when it needs to allocate new storage, and you can easily
add new elements at the front as well as the back of the sequence. A <b>list</b>
is a doubly linked list, so it’s expensive to move around randomly but cheap to
insert an element anywhere. Thus <b>list</b>, <b>deque</b> and <b>vector</b>
are similar in their basic functionality (they all hold linear sequences), but
different in the cost of their activities. So for your first shot at a program,
you could choose any one and experiment with the others only if you’re tuning
for efficiency. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1017"
title="Add Comment A1017"><sup>Comment</sup></a></p>

<p class=MsoNormal>Many of the problems you set out to solve will only require
a simple linear sequence such as a <b>vector</b>, <b>deque,</b> or <b>list</b>.
All three have a member function <b>push_back(&nbsp;)</b> that you use to
insert a new element at the back of the sequence (<b>deque</b> and <b>list</b>
also have <b>push_front(&nbsp;)</b>).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1018"
title="Add Comment A1018"><sup>Comment</sup></a></p>

<p class=MsoNormal>But now how do you retrieve those elements? With a <b>vector</b>
or <b>deque</b>, it is possible to use the indexing <b>operator[ ]</b>, but
that doesn’t work with <b>list</b>. You can use iterators on all three
sequences to access elements. Each container provides the appropriate type of
iterator for accessing its elements. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1019"
title="Add Comment A1019"><sup>Comment</sup></a></p>

<p class=MsoNormal>One more observation and then we’ll be ready for another
example. Even though the containers hold objects by value (that is, they hold
copies of whole objects), sometimes you’ll want to store pointers so that you
can refer to objects from a hierarchy and therefore take advantage of the
polymorphic behavior of the classes represented. Consider the classic “shape”
example in which shapes have a set of common operations, and you have different
types of shapes. Here’s what it looks like using the STL <b>vector</b> to hold
pointers to various <b>Shape</b> types created on the heap: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1022"
title="Add Comment A1022"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Stlshape.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Simple shapes w/ STL</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Circle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() { cout &lt;&lt;
&quot;~Circle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Triangle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Triangle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Triangle() { cout &lt;&lt;
&quot;~Triangle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Square::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() { cout &lt;&lt;
&quot;~Square\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef std::vector&lt;Shape*&gt;
Container;</p>

<p class=CodeChar style='margin-left:0in'>typedef Container::iterator Iter;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Container shapes;</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Circle);</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Square);</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Triangle);</p>

<p class=CodeChar style='margin-left:0in'>  for(Iter i = shapes.begin();</p>

<p class=CodeChar style='margin-left:0in'>      i != shapes.end(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    (*i)-&gt;draw();</p>

<p class=CodeChar style='margin-left:0in'>  // ... Sometime later:</p>

<p class=CodeChar style='margin-left:0in'>  for(Iter j = shapes.begin();</p>

<p class=CodeChar style='margin-left:0in'>      j != shapes.end(); j++)</p>

<p class=CodeChar style='margin-left:0in'>    delete *j;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The creation of <b>Shape</b>, <b>Circle</b>, <b>Square,</b>
and <b>Triangle</b> should be fairly familiar. <b>Shape</b> is a pure abstract
base class (because of the <i>pure specifier</i> <b>=0</b>) that defines the
interface for all types of <b>shapes</b>. The derived classes redefine the <b>virtual</b>
function <b>draw(&nbsp;)</b> to perform the appropriate operation. Now we’d
like to create a bunch of different types of <b>Shape</b> objects, but where to
put them? In an STL container, of course. For convenience, this <b>typedef</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1023"
title="Add Comment A1023"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
std::vector&lt;Shape*&gt; Container;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>creates an alias for a <b>vector</b> of <b>Shape*</b>, and
this <b>typedef</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1024"
title="Add Comment A1024"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef Container::iterator
Iter;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>uses that alias to create another one, for <b>vector&lt;Shape*&gt;::iterator</b>.
Notice that the <b>container</b> type name must be used to produce the
appropriate iterator, which is defined as a nested class. Although there are
different types of iterators (forward, bidirectional, reverse, and so on), they
all have the same basic interface: you can increment them with <b>++</b>, you
can dereference them to produce the object they’re currently selecting, and you
can test them to see if they’re at the end of the sequence. That’s what you’ll
want to do 90 percent of the time. And that’s what is done in the previous
example: after a container is created, it’s filled with different types of <b>Shape</b>
pointers. Notice that the upcast happens as the <b>Circle</b>, <b>Square,</b>
or <b>Rectangle</b> pointer is added to the <b>shapes</b> container, which
doesn’t know about those specific types but instead holds only <b>Shape*</b>.
As soon as the pointer is added to the container, it loses its specific
identity and becomes an anonymous <b>Shape*</b>. This is exactly what we want:
toss them all in and let polymorphism sort it out. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1025"
title="Add Comment A1025"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first <b>for</b> loop creates an iterator and sets it to
the beginning of the sequence by calling the <b>begin(&nbsp;)</b> member
function for the container. All containers have <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
member functions that produce an iterator selecting, respectively, the
beginning of the sequence and one past the end of the sequence. To test to see
if you’re done, you make sure you’re <b>!=</b> to the iterator produced by <b>end(&nbsp;)</b>.
Not <b>&lt;</b> or <b>&lt;=</b>. The only test that works is <b>!=</b>. So it’s
common to write a loop like: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1026"
title="Add Comment A1026"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>for(Iter i =
shapes.begin(); i != shapes.end(); i++)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This says “take me through every element in the sequence.” <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1027"
title="Add Comment A1027"><sup>Comment</sup></a></p>

<p class=MsoNormal>What do you do with the iterator to produce the element it’s
selecting? You dereference it using (what else?) the ‘<b>*</b>’ (which is
actually an overloaded operator). What you get back is whatever the container
is holding. This container holds <b>Shape*</b>, so that’s what <b>*i</b>
produces. If you want to call a <b>Shape</b> member function, you must do so
with the <b>-&gt;</b> operator, so you write the line: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1028"
title="Add Comment A1028"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>(*i)-&gt;draw();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This calls the <b>draw(&nbsp;)</b> function for the <b>Shape*</b>
the iterator is currently selecting. The parentheses are ugly but necessary to
produce the desired operator precedence. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1029"
title="Add Comment A1029"><sup>Comment</sup></a></p>

<p class=MsoNormal>As they are destroyed or in other cases where the pointers
are removed, the STL containers <i>do not</i> automatically call <b>delete</b>
for the pointers they contain. If you create an object on the heap with <b>new</b>
and place its pointer in a container, the container can’t tell if that pointer
is also placed inside another container, nor if it refers to heap memory in the
first place. As always, you are responsible for managing your own heap
allocations. The last lines in the program move through and delete every object
in the container so that proper cleanup occurs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1030"
title="Add Comment A1030"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can change the type of container that this program uses
with two lines. Instead of including <b>&lt;vector&gt;</b>, you include <b>&lt;list&gt;</b>,
and in the first <b>typedef</b> you say: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1031"
title="Add Comment A1031"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef
std::list&lt;Shape*&gt; Container;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>instead of using a <b>vector</b>. Everything else goes
untouched. This is possible not because of an interface enforced by inheritance
(there is little inheritance in the STL, which may come as a surprise), but
because the interface is enforced by a convention adopted by the designers of
the STL, precisely so you could perform this kind of interchange. Now you can
easily switch between <b>vector</b> and <b>list</b> or any other container that
supports the same interface and see which one works fastest for your needs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1032"
title="Add Comment A1032"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440108">Containers of strings</a></h3>

<p class=MsoNormal>In the previous example, at the end of <b>main(&nbsp;)</b>
it was necessary to move through the whole list and <b>delete</b> all the <b>Shape</b>
pointers: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1033"
title="Add Comment A1033"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>for(Iter j = shapes.begin();</p>

<p class=CodeChar style='margin-left:0in'>      j != shapes.end(); j++)</p>

<p class=CodeInlineCharChar style='margin-left:0in'>    delete *j;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This highlights what could be seen as an oversight in the
STL: there’s no facility in any of the STL containers to automatically <b>delete</b>
the pointers they contain, so you must do it by hand. It’s as if the assumption
of the STL designers was that containers of pointers weren’t an interesting
problem. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1034"
title="Add Comment A1034"><sup>Comment</sup></a></p>

<p class=MsoNormal>Automatically deleting a pointer turns out to be a rather
aggressive thing to do because of the <i>multiple membership</i> problem. If a
container holds a pointer to an object, it’s not unlikely that pointer could
also be in another container. A pointer to an <b>Aluminum</b> object in a list
of <b>Trash</b> pointers could also reside in a list of <b>Aluminum</b>
pointers. If that happens, which list is responsible for cleaning up that
object—that is, which list “owns” the object? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1035"
title="Add Comment A1035"><sup>Comment</sup></a></p>

<p class=MsoNormal>This question is virtually eliminated if the object rather
than a pointer resides in the list. Then it seems clear that when the list is
destroyed, the objects it contains must also be destroyed. Here, the STL
shines, as you can see when creating a container of <b>string</b> objects. The
following example stores each incoming line as a <b>string</b> in a <b>vector&lt;string&gt;</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1036"
title="Add Comment A1036"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:StringVector.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A vector of strings</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname = &quot;StringVector.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; strings;</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line))</p>

<p class=CodeChar style='margin-left:0in'>    strings.push_back(line);</p>

<p class=CodeChar style='margin-left:0in'>  // Do something to the strings...</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>int i = 1;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV> 
vector&lt;string&gt;::iterator w;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>for(w =
strings.begin();</p>

<p class=CodeChar style='margin-left:0in'>      w != strings.end(); w++) {</p>

<p class=CodeChar style='margin-left:0in'>    ostringstream ss;</p>

<p class=CodeChar style='margin-left:0in'>    ss &lt;&lt; i++;</p>

<p class=CodeChar style='margin-left:0in'>    *w = ss.str() + &quot;: &quot; +
*w;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Now send them out:</p>

<p class=CodeChar style='margin-left:0in'>  copy(strings.begin(),
strings.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(cout, &quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  // Since they aren't pointers,
string </p>

<p class=CodeChar style='margin-left:0in'>  // objects clean themselves up! </p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Once the <b>vector&lt;string&gt; </b>called <b>strings</b>
is created, each line in the file is read into a <b>string</b> and put in the <b>vector</b>:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1037"
title="Add Comment A1037"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line))</p>

<p class=CodeInlineCharChar style='margin-left:0in'>   
strings.push_back(line);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The operation that’s being performed on this file is to add
line numbers. A <b>stringstream</b> provides easy conversion from an <b>int</b>
to a <b>string</b> of characters representing that <b>int</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1038"
title="Add Comment A1038"><sup>Comment</sup></a></p>

<p class=MsoNormal>Assembling <b>string</b> objects is quite easy, since <b>operator+</b>
is overloaded. Sensibly enough, the iterator <b>w</b> can be dereferenced to
produce a string that can be used as both an rvalue <i>and</i> an lvalue: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1039"
title="Add Comment A1039"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>*w = ss.str() + &quot;:
&quot; + *w;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You may be surprised that you can assign back into the
container via the iterator , but it’s a tribute to the careful design of the
STL. <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1040"
title="Add Comment A1040"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because the <b>vector&lt;string&gt;</b> contains the objects
themselves, a number of interesting things take place. First, no explicit
cleanup of the <b>string</b> objects on your part is necessary. Even if you
were to put addresses of the <b>string</b> objects as pointers into <i>other</i>
containers, it’s clear that <b>strings</b> is the “master list” and maintains
ownership of the objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1041"
title="Add Comment A1041"><sup>Comment</sup></a></p>

<p class=MsoNormal>Second, you are effectively using dynamic object creation,
and yet you never use <b>new</b> or <b>delete</b>! That’s because, somehow,
it’s all taken care of for you by the <b>vector</b> because it stores <i>copies</i>
of the objects you give it. Thus your coding is significantly cleaned up. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1042"
title="Add Comment A1042"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440109">Inheriting from STL containers</a></h3>

<p class=MsoNormal>The power of instantly creating a sequence of elements is
amazing, and it makes you realize how much time you may have spent (or rather
wasted) in the past solving this particular problem. For example, many utility
programs involve reading a file into memory, modifying the file, and writing it
back out to disk. You might as well take the functionality in <b>StringVector.cpp</b>
and package it into a class for later reuse. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1044"
title="Add Comment A1044"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now the question is: do you create a member object of type <b>vector</b>,
or do you inherit? A general object-oriented design guideline is to prefer
composition (member objects) over inheritance, but the standard algorithms
expect sequences that implement a specified interface, so inheritance is often
called for. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1045"
title="Add Comment A1045"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:FileEditor.h</p>

<p class=CodeChar style='margin-left:0in'>// File editor tool</p>

<p class=CodeChar style='margin-left:0in'>#ifndef FILEEDITOR_H</p>

<p class=CodeChar style='margin-left:0in'>#define FILEEDITOR_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class FileEditor : </p>

<p class=CodeChar style='margin-left:0in'>  public
std::vector&lt;std::string&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void open(const char* filename);</p>

<p class=CodeChar style='margin-left:0in'>  FileEditor(const char* filename) {</p>

<p class=CodeChar style='margin-left:0in'>    open(filename);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  FileEditor() {};</p>

<p class=CodeChar style='margin-left:0in'>  void write(std::ostream&amp; out =
std::cout);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // FILEEDITOR_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Note the careful avoidance of a global <b>using namespace
std</b> statement here, to prevent the opening of the <b>std</b> namespace in
every file that includes this header. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1046"
title="Add Comment A1046"><sup>Comment</sup></a></p>

<p class=MsoNormal>The constructor opens the file and reads it into the <b>FileEditor</b>,
and <b>write(&nbsp;)</b> puts the <b>vector</b> of <b>string</b> onto any <b>ostream</b>.
Notice in <b>write(&nbsp;) </b>that you can have a default argument for the
reference. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1047"
title="Add Comment A1047"><sup>Comment</sup></a></p>

<p class=MsoNormal>The implementation is quite simple: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1048"
title="Add Comment A1048"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:FileEditor.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;FileEditor.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void FileEditor::open(const char*
filename) {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(filename);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, filename);</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line))</p>

<p class=CodeChar style='margin-left:0in'>    push_back(line);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Could also use copy() here:</p>

<p class=CodeChar style='margin-left:0in'>void FileEditor::write(ostream&amp;
out) {</p>

<p class=CodeChar style='margin-left:0in'>  for(iterator w = begin();  w !=
end(); w++)</p>

<p class=CodeChar style='margin-left:0in'>    out &lt;&lt; *w &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The functions from <b>StringVector.cpp</b> are simply
repackaged. Often this is the way classes evolve—you start by creating a
program to solve a particular application and then discover some commonly used
functionality within the program that can be turned into a class. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1049"
title="Add Comment A1049"><sup>Comment</sup></a></p>

<p class=MsoNormal>The line-numbering program can now be rewritten using <b>FileEditor</b>:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1050"
title="Add Comment A1050"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:FEditTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} FileEditor</p>

<p class=CodeChar style='margin-left:0in'>// Test the FileEditor tool</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;FileEditor.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  FileEditor file;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) {</p>

<p class=CodeChar style='margin-left:0in'>    file.open(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  } else {</p>

<p class=CodeChar style='margin-left:0in'>   
file.open(&quot;FEditTest.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Do something to the lines...</p>

<p class=CodeChar style='margin-left:0in'>  int i = 1;</p>

<p class=CodeChar style='margin-left:0in'>  FileEditor::iterator w =
file.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(w != file.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    ostringstream ss;</p>

<p class=CodeChar style='margin-left:0in'>    ss &lt;&lt; i++;</p>

<p class=CodeChar style='margin-left:0in'>    *w = ss.str() + &quot;: &quot; +
*w;</p>

<p class=CodeChar style='margin-left:0in'>    w++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Now send them to cout:</p>

<p class=CodeChar style='margin-left:0in'>  file.write();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=MsoNormal>Now the operation of reading the file is in the constructor:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1051"
title="Add Comment A1051"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>FileEditor file(argv[1]);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>(or in the <b>open( ) </b>member function), and writing
happens in the single line (which defaults to sending the output to <b>cout</b>):<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1052"
title="Add Comment A1052"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>file.write();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The bulk of the program is involved with actually modifying
the file in memory.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1053"
title="Add Comment A1053"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440110">A plethora of iterators</a></h2>

<p class=MsoNormal>As mentioned earlier in this and the previous chapter, an
iterator is an abstraction that allows code to be generic, that is, to work
with different types of containers without knowing the underlying structure of
those containers.<i> </i>Most containers support iterators<a href="#_ftn79"
name="_ftnref79" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[79]</span></sup></span></span></sup></span></a>. You can always say: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1054"
title="Add Comment A1054"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>&lt;ContainerType&gt;::iterator</p>

<p class=CodeInlineCharChar style='margin-left:0in'>&lt;ContainerType&gt;::const_iterator</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>to produce the types of the iterators produced by that
container. Every container has a <b>begin(&nbsp;)</b> member function that
produces an iterator indicating the beginning of the elements in the container,
and an <b>end(&nbsp;)</b> member function that produces an iterator which is
the as the <i>past-the-end </i>marker of the container. If the container is <b>const</b>¸
<b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> produce <b>const</b> iterators,
which disallow changing the elements pointed to (because the appropriate
operators are <b>const</b>). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1055"
title="Add Comment A1055"><sup>Comment</sup></a></p>

<p class=MsoNormal>All iterators can advance within their sequence (via <b>operator++</b>)
and allow <b>==</b> and <b>!=</b> comparisons. Thus, to move an iterator <b>it</b>
forward without running it off the end, you say something like: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1057"
title="Add Comment A1057"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>while(it != pastEnd) {</p>

<p class=CodeChar style='margin-left:0in'>  // Do something</p>

<p class=CodeChar style='margin-left:0in'>  it++;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>in which <b>pastEnd</b> is the past-the-end marker produced
by the container’s <b>end(&nbsp;)</b> member function. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1058"
title="Add Comment A1058"><sup>Comment</sup></a></p>

<p class=MsoNormal>An iterator can be used to produce the element that it is
currently selecting within a container through the dereferencing operator (<b>operator*</b>).
This can take two forms. If <b>it </b>is an iterator and <b>f(&nbsp;) </b>is a
member function of the objects held in the container that the iterator is
pointing within, you can say either: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1059"
title="Add Comment A1059"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>(*it).f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>or <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1060"
title="Add Comment A1060"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>it-&gt;f();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Knowing this, you can create a template that works with any
container. Here, the <b>apply(&nbsp;)</b> function template calls a member
function for every object in the container, using a pointer to member that is
passed as an argument: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1061"
title="Add Comment A1061"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Apply.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using simple iteration</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont, class
PtrMemFun&gt;</p>

<p class=CodeChar style='margin-left:0in'>void apply(Cont&amp; c, PtrMemFun f)
{</p>

<p class=CodeChar style='margin-left:0in'>  typename Cont::iterator it =
c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(it != c.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    ((*it).*f)(); // Alternate form</p>

<p class=CodeChar style='margin-left:0in'>    it++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Z {</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Z(int ii) : i(ii) {}</p>

<p class=CodeChar style='margin-left:0in'>  void g() { i++; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Z&amp; z) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; z.i;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;Z&gt; out(cout,
&quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Z&gt; vz;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 10; i++)</p>

<p class=CodeChar style='margin-left:0in'>    vz.push_back(Z(i));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vz.begin(), vz.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  apply(vz, &amp;Z::g);</p>

<p class=CodeChar style='margin-left:0in'>  copy(vz.begin(), vz.end(), out);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can’t use <b>operator-&gt;</b> in this case, because the
resulting statement would be</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>(it-&gt;*f)();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>which attempts to use the iterator’s <b>operator-&gt;*</b>,
which is not provided by the iterator classes<a href="#_ftn80" name="_ftnref80"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[80]</span></sup></span></span></sup></span></a>.</p>

<p class=MsoNormal>It is much easier to use either <b>for_each(&nbsp;)</b> or <b>transform(&nbsp;)</b>
to apply functions to sequences anyway, as you saw in the previous chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1062"
title="Add Comment A1062"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440111">Iterators in reversible containers</a></h3>

<p class=MsoNormal>A container may also be <i>reversible</i>, which means that
it can produce iterators that move backward from the end, as well as the
iterators that move forward from the beginning. All standard containers support
such bidirectional iteration. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1064"
title="Add Comment A1064"><sup>Comment</sup></a></p>

<p class=MsoNormal>A reversible container has the member functions <b>rbegin(&nbsp;)</b>
(to produce a <b>reverse_iterator</b> selecting the end) and <b>rend(&nbsp;)</b>
(to produce a <b>reverse_iterator</b> indicating “one past the beginning”). If
the container is <b>const,</b> <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b>
will produce <b>const_reverse_iterator</b>s.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1065"
title="Add Comment A1065"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example uses <b>vector</b>, but will work with
all containers that support iteration:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1066"
title="Add Comment A1066"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Reversible.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using reversible containers</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Reversible.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in,
&quot;Reversible.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; lines;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line))</p>

<p class=CodeChar style='margin-left:0in'>    lines.push_back(line);</p>

<p class=CodeChar style='margin-left:0in'> 
for(vector&lt;string&gt;::reverse_iterator r = lines.rbegin(); </p>

<p class=CodeChar style='margin-left:0in'>      r != lines.rend(); r++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *r &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You move backward through the container using the same
syntax as moving forward through a container with an ordinary iterator.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1067"
title="Add Comment A1067"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440112">Iterator categories</a></h3>

<p class=MsoNormal>The iterators are classified into “categories” that describe
their capabilities. The order in which they are generally described moves from
the categories with the most restricted behavior to those with the most
powerful behavior.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1069"
title="Add Comment A1069"><sup>Comment</sup></a></p>

<h4>Input: read-only, one pass</h4>

<p class=MsoNormal>The only predefined implementations of input iterators are <b>istream_iterator</b>
and <b>istreambuf_iterator</b>, to read from an <b>istream</b>. As you can
imagine, an input iterator can only be dereferenced once for each element
that’s selected, just as you can only read a particular portion of an input
stream once. They can only move forward. A special constructor defines the
past-the-end value. In summary, you can dereference it for reading (once only
for each value) and move it forward.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1070"
title="Add Comment A1070"><sup>Comment</sup></a></p>

<h4>Output: write-only, one pass</h4>

<p class=MsoNormal>This is the complement of an input iterator, but for writing
rather than reading. The only predefined implementations of output iterators
are <b>ostream_iterator</b> and <b>ostreambuf_iterator</b>, to write to an <b>ostream</b>,
and the less commonly used <b>raw_storage_iterator</b>. Again, these can only
be dereferenced once for each written value, and they can only move forward.
There is no concept of a terminal past-the-end value for an output iterator.
Summarizing, you can dereference it for writing (once only for each value) and
move it forward.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1071"
title="Add Comment A1071"><sup>Comment</sup></a></p>

<h4>Forward: multiple read/write</h4>

<p class=MsoNormal>The forward iterator contains all the functionality of both
the input iterator and the output iterator, plus you can dereference an
iterator location multiple times, so you can read and write to a value multiple
times. As the name implies, you can only move forward. There are no predefined
iterators that are only forward iterators.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1072"
title="Add Comment A1072"><sup>Comment</sup></a></p>

<h4>Bidirectional: operator--</h4>

<p class=MsoNormal>The bidirectional iterator has all the functionality of the
forward iterator, and in addition it can be moved backward one location at a
time using <b>operator--</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1073"
title="Add Comment A1073"><sup>Comment</sup></a></p>

<h4>Random-access: like a pointer</h4>

<p class=MsoNormal>Finally, the random-access iterator has all the
functionality of the bidirectional iterator plus all the functionality of a
pointer (a pointer <i>is</i> a random-access iterator), except that there is no
“null” iterator analogue to a null pointer. Basically, anything you can do with
a pointer you can do with a random-access iterator, including indexing with <b>operator[
]</b>, adding integral values to a pointer to move it forward or backward by a
number of locations, and comparing one iterator to another with <b>&lt;</b>, <b>&gt;=</b>,<b>
</b>and so on.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1074"
title="Add Comment A1074"><sup>Comment</sup></a></p>

<h4>Is this really important?</h4>

<p class=MsoNormal>Why do you care about this categorization? When you’re just
using containers in a straightforward way (for example, just hand-coding all
the operations you want to perform on the objects in the container), it usually
doesn’t impact you too much. Things either work or they don’t. The iterator
categories become important when:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1075"
title="Add Comment A1075"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You use some of the fancier built-in iterator types that will be
demonstrated shortly. Or you graduate to creating your own iterators (this will
also be demonstrated later in this chapter).</p>

<p class=Numbered><span style='font-family:Verdana'>7.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You use the STL algorithms (the subject of the previous chapter).
Each of the algorithms has requirements that it places on the iterators with
which it works. Knowledge of the iterator categories is even more important
when you create your own reusable algorithm templates, because the iterator
category that your algorithm requires determines how flexible the algorithm
will be. If you require only the most primitive iterator category (input or
output), your algorithm will work with <i>everything</i> (<b>copy(&nbsp;)</b>
is an example of this).</p>

<p class=MsoNormal>A hierarchy of iterator tag classes identify the category of
an iterator. The class names correspond to the iterator categories, as you
would expect, and their derivation reflects the relationship between them:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>struct input_iterator_tag {};</p>

<p class=CodeChar style='margin-left:0in'>struct output_iterator_tag {};</p>

<p class=CodeChar style='margin-left:0in'>struct forward_iterator_tag: public
input_iterator_tag {};</p>

<p class=CodeChar style='margin-left:0in'>struct bidirectional_iterator_tag :
public  </p>

<p class=CodeChar style='margin-left:0in'>  forward_iterator_tag {};</p>

<p class=CodeChar style='margin-left:0in'>struct random_access_iterator_tag :
public </p>

<p class=CodeChar style='margin-left:0in'>  bidirectional_iterator_tag {};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The class <b>forward_iterator_tag</b> derives only from <b>input_iterator_tag</b>,
not from <b>output_iterator_tag</b>, because we need to have past-the-end
iterator values in algorithms that use forward iterators, but algorithms that
use output iterators always assume that <b>operator*</b> can be dereferenced.
For this reason, it is important to make sure that a past-the-end value is never
passed to an algorithm that expects an output iterator.</p>

<p class=MsoNormal>For efficiency, certain algorithms provide different
implementations for different iterator types, which they infer from the
iterator tag defined by the iterator. We will use some of these tag classes
later in this chapter when we define our own iterator types. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1683"
title="Add Comment A1683"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440113">Predefined iterators</a></h3>

<p class=MsoNormal>The STL has a predefined set of iterators that can be quite
handy. For example, you’ve already seen the <b>reverse_iterator</b> objects
produced by calling <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b> for all the
basic containers.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1076"
title="Add Comment A1076"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <i>insertion iterators</i> are necessary because some of
the STL algorithms—<b>copy(&nbsp;),</b> for example—use the assignment <b>operator=</b>
to place objects in the destination container. This is a problem when you’re
using the algorithm to <i>fill</i> the container rather than to overwrite items
that are already in the destination container—that is, when the space isn’t
already there. What the insert iterators do is change the implementation of <b>operator=</b>
so that instead of doing an assignment, it calls a “push” or “insert” function
for that container, thus causing it to allocate new space. The constructors for
both <b>back_insert_iterator</b> and <b>front_insert_iterator</b> take a basic
sequence container object (<b>vector</b>,<b> deque</b> or <b>list</b>) as their
argument and produce an iterator that calls <b>push_back(&nbsp;)</b> or <b>push_front(&nbsp;)</b>,
respectively, to perform assignment. The helper functions <b>back_inserter(&nbsp;)</b>
and <b>front_inserter(&nbsp;)</b> produce the same objects with a little less
typing. Since all the basic sequence containers support <b>push_back(&nbsp;)</b>,
you will probably find yourself using <b>back_inserter(&nbsp;)</b> with some
regularity.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1077"
title="Add Comment A1077"><sup>Comment</sup></a></p>

<p class=MsoNormal>An <b>insert_iterator</b> lets you insert elements in the
middle of the sequence, again replacing the meaning of <b>operator=</b>, but
this time by automatically calling <b>insert(&nbsp;)</b> instead of one of the
“push” functions. The <b>insert(&nbsp;)</b> member function requires an
iterator indicating the place to insert before, so the <b>insert_iterator</b>
requires this iterator in addition to the container object. The shorthand
function <b>inserter(&nbsp;)</b> produces the same object.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1078"
title="Add Comment A1078"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example shows the use of the different types
of inserters:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1079"
title="Add Comment A1079"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Inserters.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Different types of iterator
inserters</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int a[] = { 1, 3, 5, 7, 11, 13, 17,
19, 23 };</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont&gt;</p>

<p class=CodeChar style='margin-left:0in'>void frontInsertion(Cont&amp; ci) {</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a +
sizeof(a)/sizeof(Cont::value_type), </p>

<p class=CodeChar style='margin-left:0in'>    front_inserter(ci));</p>

<p class=CodeChar style='margin-left:0in'>  copy(ci.begin(), ci.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;typename
Cont::value_type&gt;(</p>

<p class=CodeChar style='margin-left:0in'>    cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont&gt;</p>

<p class=CodeChar style='margin-left:0in'>void backInsertion(Cont&amp; ci) {</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a +
sizeof(a)/sizeof(Cont::value_type), </p>

<p class=CodeChar style='margin-left:0in'>    back_inserter(ci));</p>

<p class=CodeChar style='margin-left:0in'>  copy(ci.begin(), ci.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;typename
Cont::value_type&gt;(</p>

<p class=CodeChar style='margin-left:0in'>    cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont&gt;</p>

<p class=CodeChar style='margin-left:0in'>void midInsertion(Cont&amp; ci) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Cont::iterator it =
ci.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++; it++; it++;</p>

<p class=CodeChar style='margin-left:0in'>  copy(a, a +
sizeof(a)/(sizeof(Cont::value_type) * 2),</p>

<p class=CodeChar style='margin-left:0in'>    inserter(ci, it));</p>

<p class=CodeChar style='margin-left:0in'>  copy(ci.begin(), ci.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;typename
Cont::value_type&gt;(</p>

<p class=CodeChar style='margin-left:0in'>    cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>deque&lt;int&gt; di;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  list&lt;int&gt;  li;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>vector&lt;int&gt;
vi;</p>

<p class=CodeChar style='margin-left:0in'>  // Can't use a front_inserter()
with vector</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>frontInsertion(di);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  frontInsertion(li);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  di.clear();</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>li.clear();</p>

<p class=CodeChar style='margin-left:0in'>  backInsertion(vi);</p>

<p class=CodeChar style='margin-left:0in'>  backInsertion(di);</p>

<p class=CodeChar style='margin-left:0in'>  backInsertion(li);</p>

<p class=CodeChar style='margin-left:0in'>  midInsertion(vi);</p>

<p class=CodeChar style='margin-left:0in'>  midInsertion(di);</p>

<p class=CodeChar style='margin-left:0in'>  midInsertion(li);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>vector</b> does not support <b>push_front(&nbsp;)</b>,
it cannot produce a <b>front_insertion_iterator</b>. However, you can see that <b>vector</b>
does support the other two types of insertions (even though, as you shall see
later, <b>insert(&nbsp;)</b> is not an efficient operation for <b>vector</b>).
Note the use of the nested type <b>Cont::value_type</b> instead of hard-coding <b>int</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1080"
title="Add Comment A1080"><sup>Comment</sup></a></p>

<h4>More on stream iterators</h4>

<p class=MsoNormal>We introduced the use of the stream iterators <b>ostream_iterator</b>
(an output iterator) and <b>istream_iterator</b> (an input iterator) in
conjunction with <b>copy(&nbsp;)</b> in the previous chapter. Remember that an
output stream doesn’t have any concept of an “end,” since you can always just
keep writing more elements. However, an input stream eventually terminates (for
example, when you reach the end of a file), so you need a way to represent
that. An <b>istream_iterator</b> has two constructors, one that takes an <b>istream</b>
and produces the iterator you actually read from, and the other which is the
default constructor and produces an object that is the past-the-end sentinel.
In the following program this object is named <b>end</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1081"
title="Add Comment A1081"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:StreamIt.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Iterators for istreams and
ostreams</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;StreamIt.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in,
&quot;StreamIt.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  istream_iterator&lt;string&gt; begin(in),
end;</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;string&gt;
out(cout, &quot;\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; vs;</p>

<p class=CodeChar style='margin-left:0in'>  copy(begin, end,
back_inserter(vs));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vs.begin(), vs.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  *out++ = vs[0];</p>

<p class=CodeChar style='margin-left:0in'>  *out++ = &quot;That's all,
folks!&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When <b>in</b> runs out of input (in this case when the end
of the file is reached), <b>init</b> becomes equivalent to <b>end,</b> and the <b>copy(&nbsp;)</b>
terminates.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1082"
title="Add Comment A1082"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because <b>out</b> is an <b>ostream_iterator&lt;string&gt;</b>,
you can simply assign any <b>string</b> object to the dereferenced iterator
using <b>operator=,</b> and that <b>string</b> will be placed on the output
stream, as seen in the two assignments to <b>out</b>. Because <b>out</b> is
defined with a newline as its second argument, these assignments also insert a
newline along with each assignment.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1083"
title="Add Comment A1083"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although it is possible to create an <b>istream_iterator&lt;char&gt;</b>
and <b>ostream_iterator&lt;char&gt;</b>, these actually <i>parse </i>the input
and thus will, for example, automatically eat whitespace (spaces, tabs, and
newlines), which is not desirable if you want to manipulate an exact
representation of an <b>istream</b>. Instead, you can use the special iterators
<b>istreambuf_iterator</b> and <b>ostreambuf_iterator</b>, which are designed
strictly to move characters<a href="#_ftn81" name="_ftnref81" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[81]</span></sup></span></span></sup></span></a>.
Although these are templates, they are meant to be used with template arguments
of either <b>char</b> or <b>wchar_t</b><a href="#_ftn82" name="_ftnref82"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[82]</span></sup></span></span></sup></span></a>.
The following example lets you compare the behavior of the stream iterators
with the streambuf iterators: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1084"
title="Add Comment A1084"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:StreambufIterator.cpp</p>

<p class=CodeChar style='margin-left:0in'>// istreambuf_iterator &amp;
ostreambuf_iterator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;StreambufIterator.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in,
&quot;StreambufIterator.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Exact representation of stream:</p>

<p class=CodeChar style='margin-left:0in'>  istreambuf_iterator&lt;char&gt; isb(in),
end;</p>

<p class=CodeChar style='margin-left:0in'>  ostreambuf_iterator&lt;char&gt;
osb(cout);</p>

<p class=CodeChar style='margin-left:0in'>  while(isb != end)</p>

<p class=CodeChar style='margin-left:0in'>    *osb++ = *isb++; // Copy 'in' to
cout</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in2(&quot;StreambufIterator.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Strips white space:</p>

<p class=CodeChar style='margin-left:0in'>  istream_iterator&lt;char&gt;
is(in2), end2;</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;char&gt;
os(cout);</p>

<p class=CodeChar style='margin-left:0in'>  while(is != end2)</p>

<p class=CodeChar style='margin-left:0in'>    *os++ = *is++;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The stream iterators use the parsing defined by <b>istream::operator&gt;&gt;</b>,
which is probably not what you want if you are parsing characters directly—it’s
fairly rare that you want all the whitespace stripped out of your character
stream. You’ll virtually always want to use a streambuf iterator when using
characters and streams, rather than a stream iterator. In addition, <b>istream::operator&gt;&gt;</b>
adds significant overhead for each operation, so it is only appropriate for
higher-level operations such as parsing numbers.<a href="#_ftn83"
name="_ftnref83" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[83]</span></sup></span></span></sup></span></a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1085"
title="Add Comment A1085"><sup>Comment</sup></a></p>

<h4>Manipulating raw storage</h4>

<p class=MsoNormal>The <b>raw_storage_iterator</b> is defined in <b>&lt;memory&gt;</b>
and is an output iterator. It is provided to enable algorithms to store their
results in uninitialized memory. The interface is quite simple: the constructor
takes an output iterator that is pointing to the raw memory (thus it is
typically a pointer), and the <b>operator=</b> assigns an object into that raw
memory. The template parameters are the type of the output iterator pointing to
the raw storage and the type of object that will be stored. Here’s an example
that creates <b>Noisy</b> objects, which print trace statements for their
construction, assignment, and destruction (we’ll show the class definition
later):<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1086"
title="Add Comment A1086"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:RawStorageIterator.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrate the
raw_storage_iterator</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int quantity = 10;</p>

<p class=CodeChar style='margin-left:0in'>  // Create raw storage and cast to
desired type:</p>

<p class=CodeChar style='margin-left:0in'>  Noisy* np = </p>

<p class=CodeChar style='margin-left:0in'>    reinterpret_cast&lt;Noisy*&gt;(</p>

<p class=CodeChar style='margin-left:0in'>      new char[quantity *
sizeof(Noisy)]);</p>

<p class=CodeChar style='margin-left:0in'>  raw_storage_iterator&lt;Noisy*,
Noisy&gt; rsi(np);</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; quantity;
i++)</p>

<p class=CodeChar style='margin-left:0in'>    *rsi++ = Noisy(); // Place
objects in storage</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(np, np + quantity,</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;Noisy&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Explicit destructor call for
cleanup:</p>

<p class=CodeChar style='margin-left:0in'>  for(int j = 0; j &lt; quantity;
j++)</p>

<p class=CodeChar style='margin-left:0in'>    (&amp;np[j])-&gt;~Noisy();</p>

<p class=CodeChar style='margin-left:0in'>  // Release raw storage:</p>

<p class=CodeChar style='margin-left:0in'>  delete
reinterpret_cast&lt;char*&gt;(np);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>To make the <b>raw_storage_iterator </b>template happy, the
raw storage must be of the same type as the objects you’re creating. That’s why
the pointer from the new array of <b>char</b> is cast to a <b>Noisy*</b>. The
assignment operator forces the objects into the raw storage using the
copy-constructor. Note that the explicit destructor call must be made for
proper cleanup, and this also allows the objects to be deleted one at a time
during container manipulation. In addition, the expression <b>delete np;</b>
would be invalid anyway since the static type of a pointer in a <b>delete</b>
expression must be the same as the type assigned to in the <b>new</b>
expression. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1087"
title="Add Comment A1087"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440114">The basic sequences: <br>
vector, list, deque</a></h2>

<p class=MsoNormal>Sequences keep objects in whatever order you store them.
They differ in the efficiency of their operations, however, so if you are going
to manipulate a sequence in a particular fashion, choose the appropriate
container for those types of manipulations. So far in this book we’ve been
using <b>vector</b> as the container of choice. This is quite often the case in
applications. However, when you start making more sophisticated uses of
containers, it becomes important to know more about their underlying
implementations and behavior so that you can make the right choices.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1090"
title="Add Comment A1090"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440115">Basic sequence operations</a></h3>

<p class=MsoNormal>Using a template, the following example shows the operations
that all the basic sequences, <b>vector</b>, <b>deque,</b> and <b>list</b>,
support. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1091"
title="Add Comment A1091"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:BasicSequenceOperations.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The operations available for all
the </p>

<p class=CodeChar style='margin-left:0in'>// basic sequence Containers.</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename Container&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(Container&amp; c, char*
title = &quot;&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; title &lt;&lt; ':'
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  if(c.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;(empty)&quot;
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    return;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  typename Container::iterator it;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = c.begin(); it != c.end();
it++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it &lt;&lt; &quot;
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;size() &quot;
&lt;&lt; c.size() </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; max_size()
&quot;&lt;&lt; c.max_size() </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; front() &quot;
&lt;&lt; c.front()</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; back() &quot;
&lt;&lt; c.back() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>  </p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename
ContainerOfInt&gt;</p>

<p class=CodeChar style='margin-left:0in'>void basicOps(char* s) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;------- &quot;
&lt;&lt; s &lt;&lt; &quot; -------&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  typedef ContainerOfInt Ci;</p>

<p class=CodeChar style='margin-left:0in'>  Ci c;</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after default
constructor&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Ci c2(10, 1); // 10 elements, values
all 1</p>

<p class=CodeChar style='margin-left:0in'>  print(c2, &quot;c2 after
constructor(10,1)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  int ia[] = { 1, 3, 5, 7, 9 };</p>

<p class=CodeChar style='margin-left:0in'>  const int iasz =
sizeof(ia)/sizeof(*ia);</p>

<p class=CodeChar style='margin-left:0in'>  // Initialize with begin &amp; end
iterators:</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>Ci c3(ia, ia + iasz);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>print(c3,
&quot;c3 after constructor(iter,iter)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Ci c4(c2); // Copy-constructor</p>

<p class=CodeChar style='margin-left:0in'>  print(c4, &quot;c4 after
copy-constructor(c2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c = c2; // Assignment operator</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
operator=c2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c.assign(10, 2); // 10 elements,
values all 2</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after assign(10,
2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Assign with begin &amp; end
iterators:</p>

<p class=CodeChar style='margin-left:0in'>  c.assign(ia, ia + iasz);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after assign(iter,
iter)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c using reverse
iterators:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  typename Ci::reverse_iterator rit =
c.rbegin();</p>

<p class=CodeChar style='margin-left:0in'>  while(rit != c.rend())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *rit++ &lt;&lt;
&quot; &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  c.resize(4);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
resize(4)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c.push_back(47);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
push_back(47)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c.pop_back();</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
pop_back()&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  typename Ci::iterator it =
c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++; it++;</p>

<p class=CodeChar style='margin-left:0in'>  c.insert(it, 74);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after insert(it,
74)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++;</p>

<p class=CodeChar style='margin-left:0in'>  c.insert(it, 3, 96);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after insert(it,
3, 96)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++;</p>

<p class=CodeChar style='margin-left:0in'>  c.insert(it, c3.begin(), c3.end());</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
insert(&quot;</p>

<p class=CodeChar style='margin-left:0in'>    &quot;it, c3.begin(),
c3.end())&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++;</p>

<p class=CodeChar style='margin-left:0in'>  c.erase(it);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
erase(it)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  typename Ci::iterator it2 = it =
c.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++;</p>

<p class=CodeChar style='margin-left:0in'>  it2++; it2++; it2++; it2++; it2++;</p>

<p class=CodeChar style='margin-left:0in'>  c.erase(it, it2);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after erase(it,
it2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c.swap(c2);</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
swap(c2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  c.clear();</p>

<p class=CodeChar style='margin-left:0in'>  print(c, &quot;c after
clear()&quot;);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  basicOps&lt;vector&lt;int&gt;
&gt;(&quot;vector&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  basicOps&lt;deque&lt;int&gt;
&gt;(&quot;deque&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  basicOps&lt;list&lt;int&gt;
&gt;(&quot;list&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first function template, <b>print(&nbsp;)</b>,
demonstrates the basic information you can get from any sequence container: whether
it’s empty, its current size, the size of the largest possible container, the
element at the beginning, and the element at the end. You can also see that
every container has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> member
functions that return iterators.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1092"
title="Add Comment A1092"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>basicOps(&nbsp;)</b> function tests everything else
(and in turn calls <b>print(&nbsp;)</b>), including a variety of constructors:
default, copy-constructor, quantity and initial value, and beginning and ending
iterators. There are an assignment <b>operator=</b> and two kinds of <b>assign(&nbsp;)</b>
member functions. One takes a quantity and an initial value, and the other
takes a beginning and ending iterator.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1093"
title="Add Comment A1093"><sup>Comment</sup></a></p>

<p class=MsoNormal>All the basic sequence containers are reversible containers,
as shown by the use of the <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b> member
functions. A sequence container can be resized, and the entire contents of the
container can be removed with <b>clear(&nbsp;)</b>. When you call
resize(&nbsp;) to expand a sequence, the new elements use the default
constructor of the type of element in the sequence, or if they are built-in
types, they are zero-initialized. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1094"
title="Add Comment A1094"><sup>Comment</sup></a></p>

<p class=MsoNormal>Using an iterator to indicate where you want to start
inserting into any sequence container, you can <b>insert(&nbsp;)</b> a single
element, a number of elements that all have the same value, and a group of
elements from another container using the beginning and ending iterators of
that group. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1095"
title="Add Comment A1095"><sup>Comment</sup></a></p>

<p class=MsoNormal>To <b>erase(&nbsp;)</b> a single element from the middle,
use an iterator; to <b>erase(&nbsp;)</b> a range of elements, use a pair of
iterators. Notice that since a <b>list</b> supports only bidirectional
iterators, all the iterator motion must be performed with increments and
decrements. (If the containers were limited to <b>vector </b>and <b>deque</b>,
which produce random-access iterators, <b>operator+</b> and <b>operator-</b>
could have been used to move the iterators in big jumps.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1096"
title="Add Comment A1096"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although both <b>list</b> and <b>deque</b> support <b>push_front(&nbsp;)</b>
and <b>pop_front(&nbsp;)</b>, <b>vector</b> does not, so the only member
functions that work with all three are <b>push_back(&nbsp;)</b> and <b>pop_back(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1097"
title="Add Comment A1097"><sup>Comment</sup></a></p>

<p class=MsoNormal>The naming of the member function <b>swap(&nbsp;)</b> is a
little confusing, since there’s also a nonmember <b>swap(&nbsp;)</b> algorithm
that interchanges the values of any two objects of same type. The member <b>swap(&nbsp;)</b>
swaps everything in one container for another (if the containers hold the same
type), effectively swapping the containers themselves. It does this efficiently
by swapping the contents of each container, which consists mostly of just
pointers. The nonmember <b>swap(&nbsp;)</b> algorithm normally uses assignment
to interchange its arguments (an expensive operation for an entire container),
but is customized through template specialization to call the member <b>swap(&nbsp;)</b>
for the standard containers. There is also an <b>iter_swap</b> algorithm that
interchanges two elements in the same container pointed to by iterators. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1098"
title="Add Comment A1098"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following sections discuss the particulars of each type
of sequence container.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1099"
title="Add Comment A1099"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440116">vector</a></h3>

<p class=MsoNormal>The <b>vector</b> class template is intentionally made to
look like a souped-up array, since it has array-style indexing, but also can
expand dynamically. The <b>vector</b> class template is so fundamentally useful
that it was introduced in a primitive way early in this book and was used
regularly in previous examples. This section will give a more in-depth look at <b>vector</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1100"
title="Add Comment A1100"><sup>Comment</sup></a></p>

<p class=MsoNormal>To achieve maximally fast indexing and iteration, the <b>vector</b>
maintains its storage as a single contiguous array of objects. This is a
critical point to observe in understanding the behavior of <b>vector</b>. It
means that indexing and iteration are lightning-fast, being basically the same
as indexing and iterating over an array of objects. But it also means that
inserting an object anywhere but at the end (that is, appending) is not really
an acceptable operation for a <b>vector</b>. In addition, when a <b>vector</b>
runs out of preallocated storage, to maintain its contiguous array it must
allocate a whole new (larger) chunk of storage elsewhere and copy the objects
to the new storage. This approach produces a number of unpleasant side-effects.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1101"
title="Add Comment A1101"><sup>Comment</sup></a></p>

<h4>Cost of overflowing allocated storage</h4>

<p class=MsoNormal>A <b>vector </b>starts by grabbing a block of storage, as if
it’s taking a guess at how many objects you plan to put in it. As long as you
don’t try to put in more objects than can be held in the initial block of
storage, everything is rapid and efficient. (If you <i>do </i>know how many
objects to expect, you can preallocate storage using <b>reserve(&nbsp;).</b>)
But eventually you will put in one too many objects, and the <b>vector </b>responds
by:<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1102"
title="Add Comment A1102"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Allocating a new, bigger piece of storage</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Copying all the objects from the old storage to the new (using
the copy-constructor)</p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Destroying all the old objects (the destructor is called for each
one)</p>

<p class=Numbered><span style='font-family:Verdana'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Releasing the old memory</p>

<p class=MsoNormal>For complex objects, this copy-construction and destruction
can end up being expensive if you overfill your vector a lot, which is why
vectors (and STL containers in general) are designed for value types (i.e.
types that are cheap to copy). Of course, that includes pointers. </p>

<p class=MsoNormal>To see what happens when you’re filling a <b>vector</b>,
here is the <b>Noisy</b> class mentioned earlier that prints out information
about its creations, destructions, assignments, and copy-constructions:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1103"
title="Add Comment A1103"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Noisy.h</p>

<p class=CodeChar style='margin-left:0in'>// A class to track various object
activities</p>

<p class=CodeChar style='margin-left:0in'>#ifndef NOISY_H</p>

<p class=CodeChar style='margin-left:0in'>#define NOISY_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::endl;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Noisy {</p>

<p class=CodeChar style='margin-left:0in'>  static long create, assign,
copycons, destroy;</p>

<p class=CodeChar style='margin-left:0in'>  long id;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Noisy() : id(create++) { </p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;d[&quot;
&lt;&lt; id &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Noisy(const Noisy&amp; rv) :
id(rv.id) {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;c[&quot;
&lt;&lt; id &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>    copycons++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Noisy&amp; operator=(const
Noisy&amp; rv) {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;(&quot;
&lt;&lt; id &lt;&lt; &quot;)=[&quot; &lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>      rv.id &lt;&lt; &quot;]&quot;
&lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>    id = rv.id;</p>

<p class=CodeChar style='margin-left:0in'>    assign++;</p>

<p class=CodeChar style='margin-left:0in'>    return *this;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend bool </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;(const Noisy&amp; lv,
const Noisy&amp; rv) {</p>

<p class=CodeChar style='margin-left:0in'>    return lv.id &lt; rv.id;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend bool </p>

<p class=CodeChar style='margin-left:0in'>  operator==(const Noisy&amp; lv,
const Noisy&amp; rv) {</p>

<p class=CodeChar style='margin-left:0in'>    return lv.id == rv.id;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Noisy() {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;~[&quot;
&lt;&lt; id &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>    destroy++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(std::ostream&amp;
os, const Noisy&amp; n) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; n.id;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend class NoisyReport;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct NoisyGen {</p>

<p class=CodeChar style='margin-left:0in'>  Noisy operator()() { return
Noisy(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A singleton. Will automatically
report the</p>

<p class=CodeChar style='margin-left:0in'>// statistics as the program
terminates:</p>

<p class=CodeChar style='margin-left:0in'>class NoisyReport {</p>

<p class=CodeChar style='margin-left:0in'>  static NoisyReport nr;</p>

<p class=CodeChar style='margin-left:0in'>  NoisyReport() {} // Private
constructor</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  ~NoisyReport() {</p>

<p class=CodeChar style='margin-left:0in'>    std::cout &lt;&lt; &quot;\n-------------------\n&quot;</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;Noisy creations:
&quot; &lt;&lt; Noisy::create</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt;
&quot;\nCopy-Constructions: &quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; Noisy::copycons</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;\nAssignments:
&quot; &lt;&lt; Noisy::assign</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;\nDestructions:
&quot; &lt;&lt; Noisy::destroy</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; std::endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Because of the following
definitions, this file</p>

<p class=CodeChar style='margin-left:0in'>// can only be used in simple test
situations. Move</p>

<p class=CodeChar style='margin-left:0in'>// them to a .cpp file for more
complex programs:</p>

<p class=CodeChar style='margin-left:0in'>long Noisy::create = 0, Noisy::assign
= 0,</p>

<p class=CodeChar style='margin-left:0in'>  Noisy::copycons = 0, Noisy::destroy
= 0;</p>

<p class=CodeChar style='margin-left:0in'>NoisyReport NoisyReport::nr;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // NOISY_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each <b>Noisy</b> object has its own identifier, and <b>static</b>
variables keep track of all the creations, assignments (using <b>operator=</b>),
copy-constructions, and destructions. The <b>id</b> is initialized using the <b>create</b>
counter inside the default constructor; the copy-constructor and assignment
operator take their <b>id</b> values from the rvalue. Of course, with <b>operator=</b>
the lvalue is already an initialized object, so the old value of <b>id</b> is
printed before it is overwritten with the <b>id</b> from the rvalue.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1104"
title="Add Comment A1104"><sup>Comment</sup></a></p>

<p class=MsoNormal>To support certain operations such as sorting and searching
(which are used implicitly by some of the containers), <b>Noisy</b> must have
an <b>operator&lt;</b> and <b>operator==</b>. These simply compare the <b>id</b>
values. The <b>ostream</b> inserter follows the standard form and simply prints
the <b>id</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1105"
title="Add Comment A1105"><sup>Comment</sup></a></p>

<p class=MsoNormal>Objects of type <b>NoisyGen</b> are function objects (since
there is an <b>operator(&nbsp;)</b>) that produce <b>Noisy</b> objects during
testing. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1106"
title="Add Comment A1106"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>NoisyReport</b> is a singleton object, because we only
want one report printed at program termination. It has a <b>private</b>
constructor, therefore, so no additional <b>NoisyReport</b> objects can be
created, and it has a single static instance of <b>NoisyReport</b> called <b>nr</b>.
The only executable statements are in the destructor, which is called as the
program exits and the static destructors are called; this destructor prints out
the statistics captured by the <b>static</b> variables in <b>Noisy</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1107"
title="Add Comment A1107"><sup>Comment</sup></a></p>

<p class=MsoNormal>The one snag to this header file is the inclusion of the
definitions for the <b>static</b>s at the end. If you include this header in
more than one place in your project, you’ll get multiple-definition errors at
link time. Of course, you can put the <b>static</b> definitions in a separate<b>
cpp</b> file and link it in, but that is less convenient, and since <b>Noisy</b>
is just intended for quick-and-dirty experiments, the header file should be
reasonable for most situations.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1108"
title="Add Comment A1108"><sup>Comment</sup></a></p>

<p class=MsoNormal>Using <b>Noisy.h</b>, the following program will show the
behaviors that occur when a <b>vector</b> overflows its currently allocated
storage:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1109"
title="Add Comment A1109"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:VectorOverflow.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Shows the copy-construction and
destruction</p>

<p class=CodeChar style='margin-left:0in'>// That occurs when a vector must
reallocate</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  int size = 1000;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt;= 2) size =
atoi(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Noisy&gt; vn;</p>

<p class=CodeChar style='margin-left:0in'>  Noisy n;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; size; i++)</p>

<p class=CodeChar style='margin-left:0in'>    vn.push_back(n);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n cleaning up
\n&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can use the default value of 1000, or you can use your
own value by putting it on the command line.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1110"
title="Add Comment A1110"><sup>Comment</sup></a></p>

<p class=MsoNormal>When you run this program, you’ll see a single default
constructor call (for <b>n</b>), then a lot of copy-constructor calls, then
some destructor calls, then some more copy-constructor calls, and so on. When
the vector runs out of space in the linear array of bytes it has allocated, it
must (to maintain all the objects in a linear array, which is an essential part
of its job) get a bigger piece of storage and move everything over, copying
first and then destroying the old objects. You can imagine that if you store a
lot of large and complex objects, this process could rapidly become
prohibitive.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1111"
title="Add Comment A1111"><sup>Comment</sup></a></p>

<p class=MsoNormal>There are two solutions to this problem. The nicest one
requires that you know beforehand how many objects you’re going to make. In
that case, you can use <b>reserve(&nbsp;)</b> to tell the vector how much
storage to preallocate, thus eliminating all the copies and destructions and
making everything very fast (especially random access to the objects with <b>operator[&nbsp;]</b>).
Note that the use of <b>reserve(&nbsp;)</b> is different from using the <b>vector</b>
constructor with an integral first argument; the latter initializes each
element using the default copy-constructor.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1112"
title="Add Comment A1112"><sup>Comment</sup></a></p>

<p class=MsoNormal>However, in the more general case you won’t know how many
objects you’ll need. If <b>vector</b> reallocations are slowing things down,
you can change sequence containers. You could use a <b>list</b>, but<b> </b>as
you’ll see, the <b>deque</b> allows speedy insertions at either end of the
sequence and never needs to copy or destroy objects as it expands its storage.
The <b>deque</b> also allows random access with <b>operator[&nbsp;]</b>, but
it’s not quite as fast as <b>vector</b>’s <b>operator[</b>&nbsp;<b>]</b>. So if
you’re creating all your objects in one part of the program and randomly
accessing them in another, you may find yourself filling a <b>deque</b> and
then creating a <b>vector</b> from the <b>deque</b> and using the <b>vector</b>
for rapid indexing. Of course, you don’t want to program this way habitually;
just be aware of these issues (avoid premature optimization).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1113"
title="Add Comment A1113"><sup>Comment</sup></a></p>

<p class=MsoNormal>There is a darker side to <b>vector</b>’s reallocation of
memory, however. Because <b>vector</b> keeps its objects in a nice, neat array
(allowing, for one thing, maximally fast random access), the iterators used by <b>vector</b>
can be simple pointers. This is a good thing—of all the sequence containers,
these pointers allow the fastest selection and manipulation. Whether they are
simple pointers, or whether they are iterator objects that hold an internal
pointer into their container, consider what happens when you add the one
additional object that causes the <b>vector</b> to reallocate storage and move
it elsewhere. The iterator’s pointer is now pointing off into nowhere: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1114"
title="Add Comment A1114"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:VectorCoreDump.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Invalidating an iterator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; vi(10, 0);</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;int&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt;::iterator i =
vi.begin();</p>

<p class=CodeChar style='margin-left:0in'>  *i = 47;</p>

<p class=CodeChar style='margin-left:0in'>  copy(vi.begin(), vi.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Force it to move memory (could
also just add</p>

<p class=CodeChar style='margin-left:0in'>  // enough objects):</p>

<p class=CodeChar style='margin-left:0in'>  vi.resize(vi.capacity() + 1);</p>

<p class=CodeChar style='margin-left:0in'>  // Now i points to wrong memory:</p>

<p class=CodeChar style='margin-left:0in'>  *i = 48;  // Access violation</p>

<p class=CodeChar style='margin-left:0in'>  copy(vi.begin(), vi.end(), out); //
No change to vi[0]</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This illustrates the concept of <i>iterator invalidation</i>.
Certain operations cause internal changes to a container’s underlying data, so
any iterators in effect before such changes may no longer be valid afterward.
If your program is breaking mysteriously, look for places where you hold onto
an iterator while adding more objects to a <b>vector</b>. You’ll need to get a
new iterator after adding elements or use <b>operator[&nbsp;] </b>instead for
element selections. If you combine this observation with the awareness of the
potential expense for adding new objects to a <b>vector</b>, you may conclude
that the safest way to use one is to fill it up all at once (ideally, knowing
first how many objects you’ll need) and then just use it (without adding more
objects) elsewhere in the program. This is the way <b>vector</b> has been used
in the book up to this point. The standard C++ library documents which
container operations invalidate iterators.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1115"
title="Add Comment A1115"><sup>Comment</sup></a></p>

<p class=MsoNormal>You may observe that using <b>vector </b>as the “basic”
container in the earlier chapters of this book might not be the best choice in
all cases. This is a fundamental issue in containers and in data structures in
general: the “best” choice varies according to the way the container is used.
The reason <b>vector</b> has been the “best” choice up until now is that it
looks a lot like an array and was thus familiar and easy for you to adopt. But
from now on it’s also worth thinking about other issues when choosing containers.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1116"
title="Add Comment A1116"><sup>Comment</sup></a></p>

<h4>Inserting and erasing elements</h4>

<p class=MsoNormal>The <b>vector</b> is most efficient if:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1117"
title="Add Comment A1117"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You <b>reserve(&nbsp;)</b> the correct amount of storage at the
beginning so the <b>vector</b> never has to reallocate.</p>

<p class=Numbered><span style='font-family:Verdana'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You only add and remove elements from the back end.</p>

<p class=MsoNormal>It is possible to insert and erase elements from the middle
of a <b>vector</b> using an iterator, but the following program demonstrates
what a bad idea this is:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1118"
title="Add Comment A1118"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:VectorInsertAndErase.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Erasing an element from a vector</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Noisy&gt; v;</p>

<p class=CodeChar style='margin-left:0in'>  v.reserve(11);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;11 spaces have
been reserved&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(v), 10,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;Noisy&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Inserting an
element:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Noisy&gt;::iterator it = </p>

<p class=CodeChar style='margin-left:0in'>    v.begin() + v.size() / 2; //
Middle</p>

<p class=CodeChar style='margin-left:0in'>  v.insert(it, Noisy());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\nErasing an
element:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Cannot use the previous value of
it:</p>

<p class=CodeChar style='margin-left:0in'>  it = v.begin() + v.size() / 2;</p>

<p class=CodeChar style='margin-left:0in'>  v.erase(it);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When you run the program, you’ll see that the call to <b>reserve(&nbsp;)</b>
really does only allocate storage—no constructors are called. The <b>generate_n(&nbsp;)</b>
call is busy: each call to <b>NoisyGen::operator(&nbsp;)</b> results in a
construction, a copy-construction (into the <b>vector</b>), and a destruction
of the temporary. But when an object is inserted into the <b>vector</b> in the
middle, it must shove everything down to maintain the linear array, and, since
there is enough space, it does this with the assignment operator. (If the
argument of <b>reserve(&nbsp;)</b> is 10 instead of 11, it would have to
reallocate storage.) When an object is erased from the <b>vector</b>, the
assignment operator is once again used to move everything up to cover the place
that is being erased. (Notice that this requires that the assignment operator
properly clean up the lvalue.) Last, the object on the end of the array is
deleted.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1119"
title="Add Comment A1119"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440117">deque</a></h3>

<p class=MsoNormal>The <b>deque</b> container is a basic sequence optimized for
adding and removing elements from either end. It also allows for reasonably
fast random access—it has an <b>operator[ ]</b> like <b>vector</b>. However, it
does not have <b>vector</b>’s constraint of keeping everything in a single
sequential block of memory. Instead, a typical implementation of <b>deque</b>
uses multiple blocks of sequential storage (keeping track of all the blocks and
their order in a mapping structure). For this reason, the overhead for a <b>deque</b>
to add or remove elements at either end is low. In addition, it never needs to
copy and destroy contained objects during a new storage allocation (like <b>vector</b>
does), so it is far more efficient than <b>vector</b> if you are adding an
unknown quantity of objects at either end. This means that <b>vector</b> is the
best choice only if you have a good idea of how many objects you need. In
addition, many of the programs shown earlier in this book that use <b>vector</b>
and <b>push_back(&nbsp;)</b> might be more efficient with a <b>deque</b>. The
interface to <b>deque</b> is only slightly different from a <b>vector</b> (<b>deque</b>
has a <b>push_front(&nbsp;)</b> and <b>pop_front(&nbsp;)</b> while <b>vector</b>
does not, for example), so converting code from using <b>vector</b> to using <b>deque</b>
is almost trivial. Consider <b>StringVector.cpp</b>, which can be changed to
use <b>deque</b> by replacing the word “vector” with “deque” everywhere. The
following program adds parallel <b>deque</b> operations to the <b>vector</b>
operations in <b>StringVector.cpp</b> and performs timing comparisons:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1121"
title="Add Comment A1121"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:StringDeque.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Converted from StringVector.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;StringDeque.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>vector&lt;string&gt;
vstrings;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  deque&lt;string&gt;
dstrings;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>string line;</p>

<p class=CodeChar style='margin-left:0in'>  // Time reading into vector:</p>

<p class=CodeChar style='margin-left:0in'>  clock_t ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line))</p>

<p class=CodeChar style='margin-left:0in'>    vstrings.push_back(line);</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Read into
vector: &quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Repeat for deque:</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in2(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in2, fname);</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in2, line))</p>

<p class=CodeChar style='margin-left:0in'>    dstrings.push_back(line);</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Read into
deque: &quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Now compare indexing:</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
vstrings.size(); i++) {</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>ostringstream ss;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    ss &lt;&lt; i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    vstrings[i] =
ss.str() + &quot;: &quot; + vstrings[i];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>}</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Indexing
vector: &quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t j = 0; j &lt;
dstrings.size(); j++) {</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>ostringstream ss;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    ss &lt;&lt; j;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    dstrings[j] =
ss.str() + &quot;: &quot; + dstrings[j];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>}</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Indexing deque:
&quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Compare iteration</p>

<p class=CodeChar style='margin-left:0in'>  ofstream
tmp1(&quot;tmp1.tmp&quot;), tmp2(&quot;tmp2.tmp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  copy(vstrings.begin(),
vstrings.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;string&gt;(tmp1,
&quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Iterating
vector: &quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  copy(dstrings.begin(),
dstrings.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(tmp2, &quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock() - ticks;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Iterating
deque: &quot; &lt;&lt; ticks &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Knowing now what you do about the inefficiency of adding
things to <b>vector</b> because of storage reallocation, you might expect
dramatic differences between the two. However, on a 1.7MB text file, one
compiler’s program produced the following (measured in platform/compiler
specific clock ticks, not seconds):<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1122"
title="Add Comment A1122"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Read into vector: 8350</p>

<p class=CodeChar style='margin-left:0in'>Read into deque: 7690</p>

<p class=CodeChar style='margin-left:0in'>Indexing vector: 2360</p>

<p class=CodeChar style='margin-left:0in'>Indexing deque: 2480</p>

<p class=CodeChar style='margin-left:0in'>Iterating vector: 2470</p>

<p class=CodeInlineCharChar style='margin-left:0in'>Iterating deque: 2410</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A different compiler and platform roughly agreed with this.
It’s not so dramatic, is it? This points out some important issues:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1123"
title="Add Comment A1123"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>We (programmers and authors) are typically bad at guessing where
inefficiencies occur in our programs.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Efficiency comes from a combination of effects. Here, reading the
lines in and converting them to strings may dominate over the cost of the <b>vector</b>
vs. <b>deque</b>.</p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <b>string</b> class is probably fairly well designed in terms
of efficiency.</p>

<p class=MsoNormal>Of course, this doesn’t mean you shouldn’t use a <b>deque</b>
rather than a <b>vector</b> when you know that an uncertain number of objects
will be pushed onto the end of the container. On the contrary, you should—when
you’re tuning for performance. But you should also be aware that performance
issues are usually not where you think they are, and the only way to know for sure
where your bottlenecks are is by testing. Later in this chapter, you’ll see a
more “pure” comparison of performance between <b>vector</b>, <b>deque,</b> and <b>list</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1124"
title="Add Comment A1124"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440118">Converting between sequences</a></h3>

<p class=MsoNormal>Sometimes you need the behavior or efficiency of one kind of
container for one part of your program, and you need a different container’s
behavior or efficiency in another part of the program. For example, you may
need the efficiency of a <b>deque</b> when adding objects to the container but
the efficiency of a <b>vector</b> when indexing them. Each of the basic
sequence containers (<b>vector</b>, <b>deque,</b> and <b>list</b>) has a
two-iterator constructor (indicating the beginning and ending of the sequence
to read from when creating a new object) and an <b>assign(&nbsp;)</b> member
function to read into an existing container, so you can easily move objects
from one sequence container to another.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1125"
title="Add Comment A1125"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example reads objects into a <b>deque</b> and
then converts to a <b>vector</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1126"
title="Add Comment A1126"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:DequeConversion.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Reading into a Deque, converting
to a vector</p>

<p class=CodeChar style='margin-left:0in'>//{-bor<span style='font-size:11.0pt'>}</span></p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  int size = 25;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt;= 2) size =
atoi(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  deque&lt;Noisy&gt; d;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(d), size,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Converting
to a vector(1)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Noisy&gt; v1(d.begin(),
d.end());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Converting
to a vector(2)&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Noisy&gt; v2;</p>

<p class=CodeChar style='margin-left:0in'>  v2.reserve(d.size());</p>

<p class=CodeChar style='margin-left:0in'>  v2.assign(d.begin(), d.end());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n
Cleanup&quot; &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can try various sizes, but you should see that it makes
no difference—the objects are simply copy-constructed into the new <b>vector</b>s.
What’s interesting is that <b>v1</b> does not cause multiple allocations while
building the <b>vector</b>, no matter how many elements you use. You might
initially think that you must follow the process used for <b>v2</b> and
preallocate the storage to prevent messy reallocations, but this is
unneccessary because the constructor used for <b>v1</b> determines the memory
need ahead of time.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1127"
title="Add Comment A1127"><sup>Comment</sup></a></p>

<h4>Cost of overflowing allocated storage</h4>

<p class=MsoNormal>It’s illuminating to see what happens with a <b>deque</b>
when it overflows a block of storage, in contrast with <b>VectorOverflow.cpp</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1128"
title="Add Comment A1128"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:DequeOverflow.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// A deque is much more efficient
than a vector</p>

<p class=CodeChar style='margin-left:0in'>// when pushing back a lot of
elements, since it</p>

<p class=CodeChar style='margin-left:0in'>// doesn't require copying and
destroying.</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  int size = 1000;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt;= 2) size =
atoi(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  deque&lt;Noisy&gt; dn;</p>

<p class=CodeChar style='margin-left:0in'>  Noisy n;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; size; i++)</p>

<p class=CodeChar style='margin-left:0in'>    dn.push_back(n);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n cleaning up
\n&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here you will have relatively few (if any) destructors
called before the words “cleaning up” appear. Since the <b>deque</b> allocates
all its storage in blocks instead of a contiguous array like <b>vector</b>, it
never needs to move existing storage of each of its data blocks. (Thus, no
additional copy-constructions and destructions occur.) The <b>deque</b> simply
allocates a new block. For the same reason, the <b>deque</b> can just as
efficiently add elements to the <i>beginning</i> of the sequence, since if it
runs out of storage, it (again) just allocates a new block for the beginning.
(The index block that holds the data blocks together may need to be
reallocated, however.) Insertions in the middle of a <b>deque</b>, however,
could be even messier than for <b>vector</b> (but not as costly).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1129"
title="Add Comment A1129"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because of <b>deque</b>’s<b> </b>clever storage management,
an existing iterator is not invalidated after you add new things to either end
of a deque, as it was demonstrated to do with <b>vector</b> (in <b>VectorCoreDump.cpp</b>).
If you stick to what <b>deque</b> is best at—insertions and removals from
either end, reasonably rapid traversals and fairly fast random-access using <b>operator[
]</b>—you’ll be in good shape.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1132"
title="Add Comment A1132"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440119">Checked random-access</a></h3>

<p class=MsoNormal>Both <b>vector </b>and <b>deque</b> provide two ways to
perform random access of their elements: the <b>operator[ ]</b>, which you’ve
seen already, and <b>at(&nbsp;)</b>, which checks the boundaries of the
container that’s being indexed and throws an exception if you go out of bounds.
It does cost more to use <b>at(&nbsp;)</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1133"
title="Add Comment A1133"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:IndexingVsAt.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Comparing &quot;at()&quot; to
operator[]</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  long count = 1000;</p>

<p class=CodeChar style='margin-left:0in'>  int sz = 1000;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt;= 2) count =
atoi(argv[1]);</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt;= 3) sz =
atoi(argv[2]);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt; vi(sz);</p>

<p class=CodeChar style='margin-left:0in'>  clock_t ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i1 = 0; i1 &lt; count;
i1++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; sz; j++)</p>

<p class=CodeChar style='margin-left:0in'>      <span lang=SV>vi[j];</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  cout &lt;&lt;
&quot;vector[] &quot; &lt;&lt; clock() - ticks &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>ticks =
clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i2 = 0; i2 &lt; count;
i2++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; sz; j++)</p>

<p class=CodeChar style='margin-left:0in'>      vi.at(j);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;vector::at()
&quot; &lt;&lt; clock()-ticks &lt;&lt;endl;</p>

<p class=CodeChar style='margin-left:0in'>  deque&lt;int&gt; di(sz);</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i3 = 0; i3 &lt; count;
i3++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; sz; j++)</p>

<p class=CodeChar style='margin-left:0in'>      di[j];</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;deque[] &quot;
&lt;&lt; clock() - ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i4 = 0; i4 &lt; count;
i4++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; sz; j++)</p>

<p class=CodeChar style='margin-left:0in'>      di.at(j);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;deque::at()
&quot; &lt;&lt; clock()-ticks &lt;&lt;endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Demonstrate at() when you go out
of bounds:</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    di.at(vi.size() + 1);</p>

<p class=CodeChar style='margin-left:0in'>  } catch(...) {</p>

<p class=CodeChar style='margin-left:0in'>    cerr &lt;&lt; &quot;Exception
thrown&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As you saw in Chapter 1, different systems may handle the
uncaught exception in different ways, but you’ll know one way or another that
something went wrong with the program when using <b>at(&nbsp;)</b>, whereas
it’s possible to go blundering ahead using <b>operator[ ]</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1134"
title="Add Comment A1134"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440120">list</a></h3>

<p class=MsoNormal>A <b>list</b> is implemented as a doubly linked list data
structure and is thus designed for rapid insertion and removal of elements <i>anywhere</i>
in the sequence, whereas for <b>vector</b> and <b>deque </b>this is a much more
costly operation. A list is so slow when randomly accessing elements that it
does not have an <b>operator[ ]</b>. It’s best used when you’re traversing a
sequence, in order, from beginning to end (or vice-versa), rather than choosing
elements randomly from the middle. Even then the traversal can be slower than
with a <b>vector</b>, but if you aren’t doing a lot of traversals, that won’t
be your bottleneck.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1135"
title="Add Comment A1135"><sup>Comment</sup></a></p>

<p class=MsoNormal>Another thing to be aware of with a <b>list</b> is the
memory overhead of each link, which requires a forward and backward pointer on
top of the storage for the actual object. Thus, a <b>list</b> is a better
choice when you have larger objects that you’ll be inserting and removing from
the middle of the <b>list</b>.</p>

<p class=MsoNormal>It’s better not to use a <b>list </b>if you think you might
be traversing it a lot, looking for objects, since the amount of time it takes
to get from the beginning of the <b>list</b>—which is the only place you can
start unless you’ve already got an iterator to somewhere you know is closer to
your destination—to the object of interest is proportional to the number of
objects between the beginning and that object.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1136"
title="Add Comment A1136"><sup>Comment</sup></a></p>

<p class=MsoNormal>The objects in a <b>list </b>never move after they are
created; “moving” a list element means changing the links, but never copying or
assigning the actual objects. This means that iterators aren't invalidated when
items are added to the list as it was demonstrated earlier to be the case <b>vector</b>.
Here’s an example using the <b>Noisy</b> class:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1137"
title="Add Comment A1137"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:ListStability.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Things don't move around in lists</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;Noisy&gt; l;</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;Noisy&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l), 25,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Printing the
list:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(l.begin(), l.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Reversing
the list:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  l.reverse();</p>

<p class=CodeChar style='margin-left:0in'>  copy(l.begin(), l.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Sorting the
list:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  l.sort();</p>

<p class=CodeChar style='margin-left:0in'>  copy(l.begin(), l.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Swapping two
elements:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;Noisy&gt;::iterator it1,
it2;</p>

<p class=CodeChar style='margin-left:0in'>  it1 = it2 = l.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it2++;</p>

<p class=CodeChar style='margin-left:0in'>  swap(*it1, *it2);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(l.begin(), l.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Using
generic reverse(): &quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  reverse(l.begin(), l.end());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  copy(l.begin(), l.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n
Cleanup&quot; &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Operations as seemingly radical as reversing and sorting the
list require no copying of objects, because instead of moving the objects, the
links are simply changed. However, notice that <b>sort(&nbsp;)</b> and <b>reverse(&nbsp;)</b>
are member functions of <b>list</b>, so they have special knowledge of the
internals of <b>list</b> and can rearrange the elements instead of copying
them. On the other hand, the <b>swap(&nbsp;)</b> function is a generic
algorithm and doesn’t know about <b>list</b> in particular, so it uses the
copying approach for swapping two elements. In general you should use the
member version of an algorithm if it is supplied instead of its generic
algorithm equivalent. In particular, use the generic <b>sort(&nbsp;)</b> and <b>reverse(&nbsp;)</b>
algorithms only with arrays, <b>vector</b>s, and <b>deque</b>s.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1138"
title="Add Comment A1138"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you have large, complex objects, you might want to choose
a <b>list</b> first, especially if construction, destruction,
copy-construction, and assignment are expensive and if you are doing things
like sorting the objects or otherwise reordering them a lot.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1139"
title="Add Comment A1139"><sup>Comment</sup></a></p>

<h4>Special list operations</h4>

<p class=MsoNormal>The <b>list</b> has some special built-in operations to make
the best use of the structure of the <b>list</b>. You’ve already seen <b>reverse(&nbsp;)</b>
and <b>sort(&nbsp;)</b>, and here are some of the others in use:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1140"
title="Add Comment A1140"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:ListSpecialFunctions.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>ostream_iterator&lt;Noisy&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void print(list&lt;Noisy&gt;&amp; ln,
char* comment = &quot;&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;
&lt;&lt; comment &lt;&lt; &quot;:\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  copy(ln.begin(), ln.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  typedef list&lt;Noisy&gt; LN;</p>

<p class=CodeChar style='margin-left:0in'>  LN l1, l2, l3, l4;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l1), 6,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l2), 6,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l3), 6,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l4), 6,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  print(l1, &quot;l1&quot;);
print(l2, &quot;l2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(l3, &quot;l3&quot;);
print(l4, &quot;l4&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  LN::iterator it1 = l1.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it1++; it1++; it1++;</p>

<p class=CodeChar style='margin-left:0in'>  l1.splice(it1, l2);</p>

<p class=CodeChar style='margin-left:0in'>  print(l1, &quot;l1 after
splice(it1, l2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  print(l2, &quot;l2 after
splice(it1, l2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  LN::iterator it2 = l3.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it2++; it2++; it2++;</p>

<p class=CodeChar style='margin-left:0in'>  l1.splice(it1, l3, it2);</p>

<p class=CodeChar style='margin-left:0in'>  print(l1, &quot;l1 after
splice(it1, l3, it2)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  LN::iterator it3 = l4.begin(), it4
= l4.end();</p>

<p class=CodeChar style='margin-left:0in'>  it3++; it4--;</p>

<p class=CodeChar style='margin-left:0in'>  l1.splice(it1, l4, it3, it4);</p>

<p class=CodeChar style='margin-left:0in'>  print(l1, &quot;l1 after
splice(it1,l4,it3,it4)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Noisy n;</p>

<p class=CodeChar style='margin-left:0in'>  LN l5(3, n);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(l5), 4,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  l5.push_back(n);</p>

<p class=CodeChar style='margin-left:0in'>  print(l5, &quot;l5 before
remove()&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  l5.remove(l5.front());</p>

<p class=CodeChar style='margin-left:0in'>  print(l5, &quot;l5 after
remove()&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>l1.sort(); l5.sort();</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  l5.merge(l1);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>print(l5,
&quot;l5 after l5.merge(l1)&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n
Cleanup&quot; &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>print(&nbsp;)</b> function displays results. After
filling four <b>list</b>s with <b>Noisy</b> objects, one list is spliced into
another in three ways. In the first, the entire list <b>l2</b> is spliced into <b>l1</b>
at the iterator <b>it1</b>. Notice that after the splice, <b>l2</b> is
empty—splicing means removing the elements from the source list. The second
splice inserts elements from <b>l3 </b>starting at <b>it2</b> into <b>l1 </b>starting
at <b>it1</b>. The third splice starts at <b>it1</b> and uses elements from <b>l4</b>
starting at <b>it3</b> and ending at <b>it4</b> (the seemingly redundant
mention of the source list is because the elements must be erased from the
source list as part of the transfer to the destination list)<b>.</b><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1141"
title="Add Comment A1141"><sup>Comment</sup></a></p>

<p class=MsoNormal>The output from the code that demonstrates <b>remove(&nbsp;)</b>
shows that the list does not have to be sorted in order for all the elements of
a particular value to be removed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1142"
title="Add Comment A1142"><sup>Comment</sup></a></p>

<p class=MsoNormal>Finally, if you <b>merge(&nbsp;)</b> one list with another,
the merge only works sensibly if the lists have been sorted. What you end up
with in that case is a sorted list containing all the elements from both lists
(the source list is erased—that is, the elements are <i>moved</i> to the
destination list).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1143"
title="Add Comment A1143"><sup>Comment</sup></a></p>

<p class=MsoNormal>A <b>unique(&nbsp;)</b> member function removes all
duplicates, but only if the <b>list</b> has been sorted first:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1144"
title="Add Comment A1144"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:UniqueList.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Testing list's unique() function</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int a[] = { 1, 3, 1, 4, 1, 5, 1, 6, 1
};</p>

<p class=CodeChar style='margin-left:0in'>const int asz = sizeof a / sizeof *a;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // For output:</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;int&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;int&gt; li(a, a + asz);</p>

<p class=CodeChar style='margin-left:0in'>  li.unique();</p>

<p class=CodeChar style='margin-left:0in'>  // Oops! No duplicates removed:</p>

<p class=CodeChar style='margin-left:0in'>  copy(li.begin(), li.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Must sort it first:</p>

<p class=CodeChar style='margin-left:0in'>  li.sort();</p>

<p class=CodeChar style='margin-left:0in'>  copy(li.begin(), li.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Now unique() will have an
effect:</p>

<p class=CodeChar style='margin-left:0in'>  li.unique();</p>

<p class=CodeChar style='margin-left:0in'>  copy(li.begin(), li.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>list</b> constructor used here takes the starting and
past-the-end iterator from another container and copies all the elements from
that container into itself. (A similar constructor is available for all the
containers.) Here, the “container” is just an array, and the “iterators” are
pointers into that array, but because of the design of the STL, it works with
arrays just as easily as any other container.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1145"
title="Add Comment A1145"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>unique(&nbsp;)</b> function will remove only <i>adjacent</i>
duplicate elements, and thus sorting is necessary before calling <b>unique(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1146"
title="Add Comment A1146"><sup>Comment</sup></a></p>

<p class=MsoNormal>Four additional <b>list </b>member functions are not
demonstrated here: a <b>remove_if(&nbsp;)</b> that takes a predicate, which is
used to decide whether an object should be removed; a <b>unique(&nbsp;)</b>
that takes a binary predicate to perform uniqueness comparisons; a <b>merge(&nbsp;)</b>
that takes an additional argument which performs comparisons; and a <b>sort(&nbsp;)</b>
that takes a comparator (to provide a comparison or override the existing one).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1147"
title="Add Comment A1147"><sup>Comment</sup></a></p>

<h4><span style='font-weight:normal'>list</span> vs. <span style='font-weight:
normal'>set</span></h4>

<p class=MsoNormal>Looking at the previous example, you might note that if you
want a sorted list with no duplicates, a <b>set</b> can give you that, right? <b> </b>It’s
interesting to compare the performance of the two containers:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1148"
title="Add Comment A1148"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:ListVsSet.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Comparing list and set performance</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Obj {</p>

<p class=CodeChar style='margin-left:0in'>  int a[20]; // To take up extra
space</p>

<p class=CodeChar style='margin-left:0in'>  int val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Obj() : val(rand() % 500) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend bool </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;(const Obj&amp; a,
const Obj&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    return a.val &lt; b.val;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend bool </p>

<p class=CodeChar style='margin-left:0in'>  operator==(const Obj&amp; a, const
Obj&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    return a.val == b.val;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Obj&amp; a) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; a.val;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Container&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(Container&amp; c) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Container::iterator it;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = c.begin(); it != c.end();
it++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it &lt;&lt; &quot;
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct ObjGen {</p>

<p class=CodeChar style='margin-left:0in'>  Obj operator()() { return Obj(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 5000;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;Obj&gt; lo;</p>

<p class=CodeChar style='margin-left:0in'>  clock_t ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(lo), sz,
ObjGen());</p>

<p class=CodeChar style='margin-left:0in'>  lo.sort();</p>

<p class=CodeChar style='margin-left:0in'>  lo.unique();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;list:&quot;
&lt;&lt; clock() - ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;Obj&gt; so;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(inserter(so,
so.begin()), </p>

<p class=CodeChar style='margin-left:0in'>    sz, ObjGen());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;set:&quot;
&lt;&lt; clock() - ticks &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(lo);</p>

<p class=CodeChar style='margin-left:0in'>  print(so);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When you run the program, you should discover that <b>set</b>
is much faster than <b>list</b>. This is reassuring—after all, it <i>is</i> <b>set</b>’s
primary job description!<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1149"
title="Add Comment A1149"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440121">Swapping basic sequences</a></h3>

<p class=MsoNormal>We mentioned earlier that all basic sequences have a member
function <b>swap(&nbsp;)</b> that’s designed to switch one sequence with
another (but only for sequences of the same type). The member <b>swap(&nbsp;)</b>
makes use of its knowledge of the internal structure of the particular
container in order to be efficient:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1150"
title="Add Comment A1150"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Swapping.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// All basic sequence containers can
be swapped</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>ostream_iterator&lt;Noisy&gt;
out(cout, &quot; &quot;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(Cont&amp; c, char* comment
= &quot;&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;
&lt;&lt; comment &lt;&lt; &quot;: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  copy(c.begin(), c.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Cont&gt;</p>

<p class=CodeChar style='margin-left:0in'>void testSwap(char* cname) {</p>

<p class=CodeChar style='margin-left:0in'>  Cont c1, c2;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(c1), 10,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(back_inserter(c2), 5,
NoisyGen());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n&quot;
&lt;&lt; cname &lt;&lt; &quot;:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  print(c1, &quot;c1&quot;);
print(c2, &quot;c2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n Swapping the
&quot; &lt;&lt; cname </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot;:&quot; &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  c1.swap(c2);</p>

<p class=CodeChar style='margin-left:0in'>  print(c1, &quot;c1&quot;);
print(c2, &quot;c2&quot;);</p>

<p class=CodeChar style='margin-left:0in'>}  </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  testSwap&lt;vector&lt;Noisy&gt;
&gt;(&quot;vector&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testSwap&lt;deque&lt;Noisy&gt;
&gt;(&quot;deque&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  testSwap&lt;list&lt;Noisy&gt;
&gt;(&quot;list&quot;);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When you run this, you’ll discover that each type of
sequence container can swap one sequence for another without any copying or
assignments, even if the sequences are of different sizes. In effect, you’re
completely swapping the resources of one object for another.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1151"
title="Add Comment A1151"><sup>Comment</sup></a></p>

<p class=MsoNormal>The STL algorithms also contain a <b>swap(&nbsp;)</b>, and
when this function is applied to two containers of the same type, it uses the
member <b>swap(&nbsp;)</b> to achieve fast performance. Consequently, if you
apply the <b>sort(&nbsp;)</b> algorithm to a container of containers, you will
find that the performance is very fas—it turns out that fast sorting of a
container of containers was a design goal of the STL.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1152"
title="Add Comment A1152"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440122">set</a></h2>

<p class=MsoNormal>The <b>set</b> produces a container that will accept only
one of each thing you place in it; it also sorts the elements. (Sorting isn’t
intrinsic to the conceptual definition of a set, but the STL <b>set</b> stores
its elements in a balanced tree data structure to provide rapid lookups, thus
producing sorted results when you traverse it.) The first two examples in this
chapter used <b>set</b>s.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1163"
title="Add Comment A1163"><sup>Comment</sup></a></p>

<p class=MsoNormal>Consider the problem of creating an index for a book. You
might like to start with all the words in the book, but you only want one
instance of each word, and you want them sorted. Of course, a <b>set</b> is
perfect for this and solves the problem effortlessly. However, there’s also the
problem of punctuation and any other nonalpha characters, which must be
stripped off to generate proper words. One solution to this problem is to use
the Standard C library functions <b>isalpha(&nbsp;)</b> and <b>isspace(&nbsp;)</b>
to extract only the characters you want. You can replace all unwanted
characters with spaces so that you can easily extract valid words from each
line you read:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1164"
title="Add Comment A1164"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:WordList.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Display a list of words used in a
document</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>char replaceJunk(char c) {</p>

<p class=CodeChar style='margin-left:0in'>   // Only keep alphas, space (as a
delimiter), and '</p>

<p class=CodeChar style='margin-left:0in'>   return (isalpha(c) || c == '\'') ?
c : ' ';</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;WordList.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;string&gt; wordlist;</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line)) {</p>

<p class=CodeChar style='margin-left:0in'>    transform(line.begin(),
line.end(), line.begin(), </p>

<p class=CodeChar style='margin-left:0in'>              replaceJunk);</p>

<p class=CodeChar style='margin-left:0in'>    istringstream is(line);</p>

<p class=CodeChar style='margin-left:0in'>    string word;</p>

<p class=CodeChar style='margin-left:0in'>    while (is &gt;&gt; word)</p>

<p class=CodeChar style='margin-left:0in'>      wordlist.insert(word);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  // Output results:</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist.begin(),
wordlist.end(),</p>

<p class=CodeChar style='margin-left:0in'>      
ostream_iterator&lt;string&gt;(cout, &quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The call to <b>transform(&nbsp;)</b> replaces each character
to be ignored with a space. The set container not only ignores duplicate words,
but compares the words it keeps according to the function object <b>less&lt;string&gt;</b>
(the default second template argument for the <b>set</b> container), which in
turn uses <b>string::operator&lt;(&nbsp;)</b>, so the words emerge in
alphabetical order. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1165"
title="Add Comment A1165"><sup>Comment</sup></a></p>

<p class=MsoNormal>You don’t have to use a <b>set</b> just to get a sorted
sequence. You can use the <b>sort(&nbsp;)</b> function (along with a multitude
of other functions in the STL) on different STL containers. However, it’s
likely that <b>set</b> will be faster. Using a set is particularly handy when
you just want to do lookup, since its <b>find(&nbsp;)</b> member function has
logarithmic complexity and therefore is much faster than the generic <b>find(&nbsp;)</b>
algorithm. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1166"
title="Add Comment A1166"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following version shows how to build the list of words
with an <b>istreambuf_iterator</b> that moves the characters from one place
(the input stream) to another (a <b>string </b>object), depending on whether
the Standard C library function <b>isalpha(&nbsp;)</b> returns true:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1168"
title="Add Comment A1168"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:WordList2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates istreambuf_iterator
and insert iterators</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstring&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;WordList2.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  istreambuf_iterator&lt;char&gt;
p(in), end;</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;string&gt; wordlist;</p>

<p class=CodeChar style='margin-left:0in'>  while (p != end) {</p>

<p class=CodeChar style='margin-left:0in'>    string word;</p>

<p class=CodeChar style='margin-left:0in'>    insert_iterator&lt;string&gt; </p>

<p class=CodeChar style='margin-left:0in'>      ii(word, word.begin());</p>

<p class=CodeChar style='margin-left:0in'>    // Find the first alpha
character:</p>

<p class=CodeChar style='margin-left:0in'>    while(!isalpha(*p) &amp;&amp; p
!= end)</p>

<p class=CodeChar style='margin-left:0in'>      p++;</p>

<p class=CodeChar style='margin-left:0in'>    // Copy until the first non-alpha
character:</p>

<p class=CodeChar style='margin-left:0in'>    while (isalpha(*p) &amp;&amp; p
!= end)</p>

<p class=CodeChar style='margin-left:0in'>      *ii++ = *p++;</p>

<p class=CodeChar style='margin-left:0in'>    if (word.size() != 0)</p>

<p class=CodeChar style='margin-left:0in'>      wordlist.insert(word);</p>

<p class=CodeChar style='margin-left:0in'>  } </p>

<p class=CodeChar style='margin-left:0in'>  // Output results:</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist.begin(),
wordlist.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;string&gt;(cout,
&quot;\n&quot;));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example was suggested by Nathan Myers, who invented the
<b>istreambuf_iterator</b> and its relatives. This iterator extracts
information character by character from a stream. Although the <b>istreambuf_iterator
</b>template argument might suggest that you could extract, for example, <b>int</b>s
instead of <b>char</b>, that’s not the case. The argument must be of some
character type—a regular <b>char</b> or a wide character.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1169"
title="Add Comment A1169"><sup>Comment</sup></a></p>

<p class=MsoNormal>After the file is open, an <b>istreambuf_iterator</b> called
<b>p</b> is attached to the <b>istream</b> so characters can be extracted from
it. The <b>set&lt;string&gt;</b> called <b>wordlist</b> will hold the resulting
words.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1170"
title="Add Comment A1170"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>while</b> loop reads words until the end of the input
stream is found. This is detected using the default constructor for <b>istreambuf_iterator,</b>
which produces the past-the-end iterator object <b>end</b>. Thus, if you want
to test to make sure you’re not at the end of the stream, you simply say <b>p
!= end</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1171"
title="Add Comment A1171"><sup>Comment</sup></a></p>

<p class=MsoNormal>The second type of iterator that’s used here is the <b>insert_iterator</b>,
which creates an iterator that knows how to insert objects into a container.
Here, the “container” is the <b>string</b> called <b>word,</b> which, for the
purposes of <b>insert_iterator</b>, behaves like a container. The constructor
for <b>insert_iterator</b> requires the container and an iterator indicating
where it should start inserting the characters. You could also use a <b>back_insert_iterator</b>,
which requires that the container have a <b>push_back(&nbsp;)</b> (<b>string</b>
does).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1172"
title="Add Comment A1172"><sup>Comment</sup></a></p>

<p class=MsoNormal>After the <b>while</b> loop sets everything up, it begins by
looking for the first alpha character, incrementing <b>start</b> until that
character is found. It then copies characters from one iterator to the other,
stopping when a nonalpha character is found. Each <b>word</b>, assuming it is
nonempty, is added to <b>wordlist</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1173"
title="Add Comment A1173"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440123">A completely reusable tokenizer</a></h3>

<p class=MsoNormal>The word list examples use different approaches to extract
tokens from a stream, neither of which are very flexible. Since the STL
containers and algorithms all revolve around iterators, the most flexible
solution will itself use an iterator. You could think of the <b>TokenIterator</b>
as an iterator that wraps itself around any other iterator that can produce
characters. Because it is certainly a type of input iterator (the most
primitive type of iterator), it can provide input to any STL algorithm. Not
only is it a useful tool in itself, the following <b>TokenIterator</b> is also
a good example of how you can design your own iterators.<a href="#_ftn84"
name="_ftnref84" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[84]</span></sup></span></span></sup></span></a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1178"
title="Add Comment A1178"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>TokenIterator</b> class is doubly flexible. First,
you can choose the type of iterator that will produce the <b>char</b> input.
Second, instead of just saying what characters represent the delimiters, <b>TokenIterator</b>
will use a predicate that is a function object whose <b>operator(&nbsp;)</b>
takes a <b>char</b> and decides whether it should be in the token. Although the
two examples given here have a static concept of what characters belong in a
token, you could easily design your own function object to change its state as
the characters are read, producing a more sophisticated parser.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1179"
title="Add Comment A1179"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following header file contains two basic predicates, <b>Isalpha</b>
and <b>Delimiters</b>, along with the template for <b>TokenIterator</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1180"
title="Add Comment A1180"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:TokenIterator.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef TOKENITERATOR_H</p>

<p class=CodeChar style='margin-left:0in'>#define TOKENITERATOR_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cctype&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct Isalpha :
std::unary_function&lt;char, bool&gt; { </p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(char c) { </p>

<p class=CodeChar style='margin-left:0in'>    return std::isalpha(c); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Delimiters :
std::unary_function&lt;char, bool&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  std::string exclude;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Delimiters() {}</p>

<p class=CodeChar style='margin-left:0in'>  Delimiters(const std::string&amp;
excl) </p>

<p class=CodeChar style='margin-left:0in'>    : exclude(excl) {}</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(char c) {</p>

<p class=CodeChar style='margin-left:0in'>    return exclude.find(c) ==
std::string::npos;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template &lt;class InputIter, class
Pred = Isalpha&gt;</p>

<p class=CodeChar style='margin-left:0in'>class TokenIterator : public
std::iterator&lt;</p>

<p class=CodeChar style='margin-left:0in'>   
std::input_iterator_tag,std::string, std::ptrdiff_t&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  InputIter first;</p>

<p class=CodeChar style='margin-left:0in'>  InputIter last;</p>

<p class=CodeChar style='margin-left:0in'>  std::string word;</p>

<p class=CodeChar style='margin-left:0in'>  Pred predicate;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator(InputIter begin,
InputIter end, </p>

<p class=CodeChar style='margin-left:0in'>    Pred pred = Pred()) </p>

<p class=CodeChar style='margin-left:0in'>    : first(begin), last(end),
predicate(pred) {</p>

<p class=CodeChar style='margin-left:0in'>      ++*this; </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator() {} // End sentinel</p>

<p class=CodeChar style='margin-left:0in'>  // Prefix increment:</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator&amp; operator++() {</p>

<p class=CodeChar style='margin-left:0in'>    word.resize(0);</p>

<p class=CodeChar style='margin-left:0in'>    first = std::find_if(first, last,
predicate);</p>

<p class=CodeChar style='margin-left:0in'>    while (first != last &amp;&amp;
predicate(*first))</p>

<p class=CodeChar style='margin-left:0in'>      word += *first++;</p>

<p class=CodeChar style='margin-left:0in'>    return *this;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Postfix increment</p>

<p class=CodeChar style='margin-left:0in'>  class Proxy { </p>

<p class=CodeChar style='margin-left:0in'>    std::string word;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    Proxy(const std::string&amp; w) :
word(w) {}</p>

<p class=CodeChar style='margin-left:0in'>    std::string operator*() { return
word; } </p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  Proxy operator++(int) { </p>

<p class=CodeChar style='margin-left:0in'>    Proxy d(word);</p>

<p class=CodeChar style='margin-left:0in'>    ++*this; </p>

<p class=CodeChar style='margin-left:0in'>    return d; </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Produce the actual value:</p>

<p class=CodeChar style='margin-left:0in'>  std::string operator*() const {
return word; }</p>

<p class=CodeChar style='margin-left:0in'>  std::string* operator-&gt;() const
{</p>

<p class=CodeChar style='margin-left:0in'>    return &amp;(operator*()); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Compare iterators:</p>

<p class=CodeChar style='margin-left:0in'>  bool operator==(const
TokenIterator&amp;) { </p>

<p class=CodeChar style='margin-left:0in'>    return word.size() == 0
&amp;&amp; first == last; </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  bool operator!=(const
TokenIterator&amp; rv) { </p>

<p class=CodeChar style='margin-left:0in'>    return !(*this == rv);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>#endif // TOKENITERATOR_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>TokenIterator</b> class derives from the <b>std::iterator</b>
template. It might appear that some kind of functionality comes with <b>std::iterator</b>,
but it is purely a way of tagging an iterator so that a container that uses it
knows what it’s capable of. Here, you can see <b>input_iterator_tag</b> as the <b>iterator_category</b>
template argument—this tells anyone who asks that a <b>TokenIterator</b> only
has the capabilities of an input iterator and cannot be used with algorithms
requiring more sophisticated iterators. Apart from the tagging, <b>std::iterator</b>
doesn’t do anything beyond providing several useful type definitions, which
means you must design all the other functionality in yourself.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1181"
title="Add Comment A1181"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>TokenIterator</b> class may look a little strange at
first, because the first constructor requires both a “begin” and an “end”
iterator as arguments, along with the predicate. Remember, this is a “wrapper”
iterator that has no idea how to tell whether it’s at the end of its input
source, so the ending iterator is necessary in the first constructor. The
reason for the second (default) constructor is that the STL algorithms (and any
algorithms you write) need a <b>TokenIterator </b>sentinel to be the
past-the-end value. Since all the information necessary to see if the <b>TokenIterator</b>
has reached the end of its input is collected in the first constructor, this
second constructor creates a <b>TokenIterator</b> that is merely used as a
placeholder in algorithms.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1182"
title="Add Comment A1182"><sup>Comment</sup></a></p>

<p class=MsoNormal>The core of the behavior happens in <b>operator++</b>. This
erases the current value of <b>word</b> using <b>string::resize(&nbsp;)</b> and
then finds the first character that satisfies the predicate (thus discovering
the beginning of the new token) using <b>find_if(&nbsp;)</b> (from the STL
algorithms, discussed in the following chapter). The resulting iterator is
assigned to <b>first</b>, thus moving <b>first</b> forward to the beginning of
the token. Then, as long as the end of the input is not reached and the
predicate is satisfied, input characters are copied into <b>word</b>. Finally,
the <b>TokenIterator</b> object is returned and must be dereferenced to access
the new token.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1183"
title="Add Comment A1183"><sup>Comment</sup></a></p>

<p class=MsoNormal>The postfix increment requires a proxy object to hold the
value before the increment, so it can be returned. Producing the actual value
is a straightforward <b>operator*</b>. The only other functions that must be
defined for an output iterator are the <b>operator==</b> and <b>operator!=</b>
to indicate whether the <b>TokenIterator</b> has reached the end of its input.
You can see that the argument for <b>operator== </b>is ignored—it only cares
about whether it has reached its internal <b>last</b> iterator. Notice that <b>operator!=</b>
is defined in terms of <b>operator==</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1184"
title="Add Comment A1184"><sup>Comment</sup></a></p>

<p class=MsoNormal>A good test of <b>TokenIterator</b> includes a number of
different sources of input characters, including a <b>streambuf_iterator</b>, a
<b>char*</b>, and a <b>deque&lt;char&gt;::iterator</b>. Finally, the original
word list problem is solved:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1185"
title="Add Comment A1185"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:TokenIteratorTest.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;TokenIterator.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;deque&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;TokenIteratorTest.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;string&gt;
out(cout, &quot;\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  typedef
istreambuf_iterator&lt;char&gt; IsbIt;</p>

<p class=CodeChar style='margin-left:0in'>  IsbIt begin(in), isbEnd;</p>

<p class=CodeChar style='margin-left:0in'>  Delimiters </p>

<p class=CodeChar style='margin-left:0in'>    delimiters(&quot;
\t\n~;()\&quot;&lt;&gt;:{}[]+-=&amp;*#.,/\\&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator&lt;IsbIt,
Delimiters&gt; </p>

<p class=CodeChar style='margin-left:0in'>    wordIter(begin, isbEnd,
delimiters),</p>

<p class=CodeChar style='margin-left:0in'>    end;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; wordlist;</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordIter, end,
back_inserter(wordlist));</p>

<p class=CodeChar style='margin-left:0in'>  // Output results:</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist.begin(),
wordlist.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  *out++ =
&quot;-----------------------------------&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Use a char array as the source:</p>

<p class=CodeChar style='margin-left:0in'>  char* cp = </p>

<p class=CodeChar style='margin-left:0in'>    &quot;typedef
std::istreambuf_iterator&lt;char&gt; It&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator&lt;char*,
Delimiters&gt;</p>

<p class=CodeChar style='margin-left:0in'>    charIter(cp, cp + strlen(cp),
delimiters),</p>

<p class=CodeChar style='margin-left:0in'>    end2;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; wordlist2;</p>

<p class=CodeChar style='margin-left:0in'>  copy(charIter, end2,
back_inserter(wordlist2));</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist2.begin(),
wordlist2.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  *out++ =
&quot;-----------------------------------&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Use a deque&lt;char&gt; as the
source:</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in2(&quot;TokenIteratorTest.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  deque&lt;char&gt; dc;</p>

<p class=CodeChar style='margin-left:0in'>  copy(IsbIt(in2), IsbIt(),
back_inserter(dc));</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator&lt;deque&lt;char&gt;::iterator,Delimiters&gt;</p>

<p class=CodeChar style='margin-left:0in'>    dcIter(dc.begin(), dc.end(),
delimiters),</p>

<p class=CodeChar style='margin-left:0in'>    end3;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; wordlist3;</p>

<p class=CodeChar style='margin-left:0in'>  copy(dcIter, end3,
back_inserter(wordlist3));</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist3.begin(),
wordlist3.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  *out++ =
&quot;-----------------------------------&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Reproduce the Wordlist.cpp
example:</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in3(&quot;TokenIteratorTest.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  TokenIterator&lt;IsbIt,
Delimiters&gt;</p>

<p class=CodeChar style='margin-left:0in'>    wordIter2((IsbIt(in3)), isbEnd,
delimiters);</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;string&gt; wordlist4;</p>

<p class=CodeChar style='margin-left:0in'>  while(wordIter2 != end)</p>

<p class=CodeChar style='margin-left:0in'>    wordlist4.insert(*wordIter2++);</p>

<p class=CodeChar style='margin-left:0in'>  copy(wordlist4.begin(),
wordlist4.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When using an <b>istreambuf_iterator</b>, you create one to
attach to the <b>istream</b> object and one with the default constructor as the
past-the-end marker. Both are used to create the <b>TokenIterator</b> that will
actually produce the tokens; the default constructor produces the faux <b>TokenIterator</b>
past-the-end sentinel. (This is just a placeholder and, as mentioned
previously, is actually ignored.) The<b> TokenIterator</b> produces <b>string</b>s
that are inserted into a container which must, naturally, be a container of <b>string</b>—here
a <b>vector&lt;string&gt;</b> is used in all cases except the last. (You could
also concatenate the results onto a <b>string.</b>) Other than that, a <b>TokenIterator</b>
works like any other input iterator.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1186"
title="Add Comment A1186"><sup>Comment</sup></a></p>

<p class=MsoNormal>The strangest thing in the previous program is the
declaration of <b>wordIter2</b>. Note the extra parentheses in the first
argument to the constructor. Without these, a conforming compiler will think
that <b>wordIter2</b> is a prototype for a function that has three arguments
and returns a <b>TokenIterator&lt;IsbIt, Delimiters&gt;</b><a href="#_ftn85"
name="_ftnref85" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[85]</span></sup></span></span></sup></span></a>. (Microsoft’s Visual
C++ .NET compiler accepts it without the extra parentheses, but it shouldn’t.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1684"
title="Add Comment A1684"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440124">stack</a></h2>

<p class=MsoNormal>The <b>stack</b>, along with the <b>queue</b> and <b>priority_queue</b>,
are classified as <i>adapters</i>, which means they adapt one of the basic
sequence containers to store their data. This is an unfortunate case of
confusing what something does with the details of its underlying
implementation—the fact that these are called “adapters” is of primary value
only to the creator of the library. When you use them, you generally don’t care
that they’re adapters, but instead that they solve your problem. Admittedly at
times it’s useful to know that you can choose an alternate implementation or
build an adapter from an existing container object, but that’s generally one
level removed from the adapter’s behavior. So, while you may see it emphasized
elsewhere that a particular container is an adapter, we’ll only point out that
fact when it’s useful. Note that each type of adapter has a default container
that it’s built upon, and this default is the most sensible implementation. In
most cases you won’t need to concern yourself with the underlying
implementation.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1187"
title="Add Comment A1187"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example shows <b>stack&lt;string&gt;</b>
implemented in the three ways: the default (which uses <b>deque</b>), with a <b>vector,</b>
and with a <b>list</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1188"
title="Add Comment A1188"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Stack1.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrates the STL stack</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stack&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Rearrange comments below to use
different versions.</p>

<p class=CodeChar style='margin-left:0in'>typedef stack&lt;string&gt; Stack1;
// Default: deque&lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>// typedef stack&lt;string,
vector&lt;string&gt; &gt; Stack2;</p>

<p class=CodeChar style='margin-left:0in'>// typedef stack&lt;string,
list&lt;string&gt; &gt; Stack3;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Stack1.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Stack1 textlines; // Try the
different versions</p>

<p class=CodeChar style='margin-left:0in'>  // Read file and store lines in the
stack:</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line)) </p>

<p class=CodeChar style='margin-left:0in'>    textlines.push(line +
&quot;\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Print lines from the stack and
pop them:</p>

<p class=CodeChar style='margin-left:0in'>  while(!textlines.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; textlines.top();</p>

<p class=CodeChar style='margin-left:0in'>    textlines.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>top(&nbsp;)</b> and <b>pop(&nbsp;)</b> operations
will probably seem non-intuitive if you’ve used other <b>stack</b> classes.
When you call <b>pop(&nbsp;),</b> it returns void rather than the top element
that you might have expected. If you want the top element, you get a reference
to it with <b>top(&nbsp;)</b>. It turns out this is more efficient, since a
traditional <b>pop(&nbsp;)</b> would have to return a value rather than a
reference and thus invoke the copy-constructor. More important, it is <i>exception
safe</i>, as we discussed in Chapter 1. If <b>pop(&nbsp;)</b> both changed the
state of the stack and attempted to return the top element, an exception in the
element’s copy-constructor could cause the element to be lost. When you’re
using a <b>stack</b> (or a <b>priority_queue</b>, described later), you can
efficiently refer to <b>top(&nbsp;)</b> as many times as you want and then
discard the top element explicitly using <b>pop(&nbsp;).</b> (Perhaps if some
term other than the familiar “pop” had been used, this would have been a bit
clearer.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1189"
title="Add Comment A1189"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>stack</b> template has a simple interface—essentially
the member functions you saw earlier. Since it only makes sense to access a
stack at its top, no iterators are available for traversing it. Nor are there
sophisticated forms of initialization, but if you need that, you can use the
underlying container upon which the <b>stack</b> is implemented. For example,
suppose you have a function that expects a <b>stack</b> interface, but in the
rest of your program you need the objects stored in a <b>list</b>. The
following program stores each line of a file along with the leading number of
spaces in that line. (You might imagine it as a starting point for performing
some kind of source-code reformatting.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1190"
title="Add Comment A1190"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Stack2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Converting a list to a stack</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stack&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Expects a stack:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Stk&gt;</p>

<p class=CodeChar style='margin-left:0in'>void stackOut(Stk&amp; s, ostream&amp;
os = cout) {</p>

<p class=CodeChar style='margin-left:0in'>  while(!s.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; s.top() &lt;&lt;
&quot;\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    s.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Line {</p>

<p class=CodeChar style='margin-left:0in'>  string line; // Without leading
spaces</p>

<p class=CodeChar style='margin-left:0in'>  int lspaces; // Number of leading
spaces</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Line(string s) : line(s) {</p>

<p class=CodeChar style='margin-left:0in'>    lspaces =
line.find_first_not_of(' ');</p>

<p class=CodeChar style='margin-left:0in'>    if(lspaces == string::npos)</p>

<p class=CodeChar style='margin-left:0in'>      lspaces = 0;</p>

<p class=CodeChar style='margin-left:0in'>    line = line.substr(lspaces);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Line&amp; l) {</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; l.lspaces;
i++)</p>

<p class=CodeChar style='margin-left:0in'>      <span lang=SV>os &lt;&lt; ' ';</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    return os &lt;&lt;
l.line;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>}</p>

<p class=CodeChar style='margin-left:0in'>  // Other functions here...</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream
in(&quot;Stack2.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;Line&gt; lines;</p>

<p class=CodeChar style='margin-left:0in'>  // Read file and store lines in the
list:</p>

<p class=CodeChar style='margin-left:0in'>  string s;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, s)) </p>

<p class=CodeChar style='margin-left:0in'>    lines.push_front(s);</p>

<p class=CodeChar style='margin-left:0in'>  // Turn the list into a stack for
printing:</p>

<p class=CodeChar style='margin-left:0in'>  stack&lt;Line, list&lt;Line&gt; &gt;
stk(lines);</p>

<p class=CodeChar style='margin-left:0in'>  stackOut(stk);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The function that requires the <b>stack</b> interface just
sends each <b>top(&nbsp;)</b> object to an <b>ostream</b> and then removes it
by calling <b>pop(&nbsp;)</b>. The <b>Line</b> class determines the number of
leading spaces and then stores the contents of the line <i>without</i> the
leading spaces. The <b>ostream</b> <b>operator&lt;&lt;</b> re-inserts the
leading spaces so the line prints properly, but you can easily change the
number of spaces by changing the value of <b>lspaces.</b> (The member functions
to do this are not shown here.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1191"
title="Add Comment A1191"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, the input file is read into a <b>list&lt;Line&gt;</b>,
and then each line in the list is copied into a <b>stack</b> that is sent to <b>stackOut(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1192"
title="Add Comment A1192"><sup>Comment</sup></a></p>

<p class=MsoNormal>You cannot iterate through a <b>stack</b>; this emphasizes
that you only want to perform <b>stack</b> operations when you create a <b>stack</b>.
You can get equivalent “stack” functionality using a <b>vector</b> and its <b>back(&nbsp;)</b>,
<b>push_back(&nbsp;),</b> and <b>pop_back(&nbsp;)</b> member functions, and
then you have all the additional functionality of the <b>vector</b>. <b>Stack1.cpp</b>
can be rewritten to show this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1193"
title="Add Comment A1193"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Stack3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using a vector as a stack;
modified Stack1.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(&quot;Stack3.cpp&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt; textlines;</p>

<p class=CodeChar style='margin-left:0in'>  string line;</p>

<p class=CodeChar style='margin-left:0in'>  while(getline(in, line)) </p>

<p class=CodeChar style='margin-left:0in'>    textlines.push_back(line +
&quot;\n&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  while(!textlines.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; textlines.back();</p>

<p class=CodeChar style='margin-left:0in'>    textlines.pop_back();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This produces the same output as <b>Stack1.cpp</b>, but you
can now perform <b>vector</b> operations as well. Of course, <b>list</b> can
also push things at the front, but it’s generally less efficient than using <b>push_back(&nbsp;)</b>
with <b>vector</b>. (In addition, <b>deque</b> is usually more efficient than <b>list</b>
for pushing things at the front.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1194"
title="Add Comment A1194"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440125">queue</a></h2>

<p class=MsoNormal>The <b>queue</b> is a restricted form of a <b>deque</b>—you
can only enter elements at one end and pull them off the other end. Functionally,
you could use a <b>deque</b> anywhere you need a <b>queue</b>, and you would
then also have the additional functionality of the <b>deque</b>. The only
reason you need to use a <b>queue</b> rather than a <b>deque</b>, then, is if
you want to emphasize that you will only be performing queue-like behavior.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1195"
title="Add Comment A1195"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>queue</b> is an adapter class like <b>stack</b>, in
that it is built on top of another sequence container. As you might guess, the
ideal implementation for a <b>queue</b> is a <b>deque</b>, and that is the
default template argument for the <b>queue</b>; you’ll rarely need a different
implementation.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1196"
title="Add Comment A1196"><sup>Comment</sup></a></p>

<p class=MsoNormal>Queues are often used when modeling systems in which some
elements of the system are waiting to be served by other elements in the
system. A classic example of this is the “bank-teller problem”: customers
arrive at random intervals, gett into a line, and then are served by a set of
tellers. Since the customers arrive randomly and each takes a random amount of
time to be served, there’s no way to deterministically know how long the line
will be at any time. However, it’s possible to simulate the situation and see
what happens.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1197"
title="Add Comment A1197"><sup>Comment</sup></a></p>

<p class=MsoNormal>In a realistic simulation each customer and teller should be
run by a separate thread. What we’d like is a multithreaded environment so that
each customer or teller would have their own thread. However, Standard C++ has
no model for multithreading, so there is no standard solution to this problem.
On the other hand, with a little adjustment to the code, it’s possible to
simulate enough multithreading to provide a satisfactory solution<a
href="#_ftn86" name="_ftnref86" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[86]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1198"
title="Add Comment A1198"><sup>Comment</sup></a></p>

<p class=MsoNormal>In multithreading, multiple threads of control run
simultaneously, sharing the same address space. Quite often you have fewer CPUs
than you do threads (and often only one CPU). To give the illusion that each
thread has its own CPU, a <i>time-slicing</i> mechanism says “OK, current
thread, you’ve had enough time. I’m going to stop you and give time to some
other thread.” This automatic stopping and starting of threads is called <i>preemptive,
</i>and it means you (the programmer) don’t need to manage the threading
process at all.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1199"
title="Add Comment A1199"><sup>Comment</sup></a></p>

<p class=MsoNormal>An alternative approach has each thread voluntarily yield
the CPU to the scheduler, which then finds another thread that needs running.
Instead, we’ll build the “time-slicing” into the classes in the system. In this
case, it will be the tellers that represent the “threads,” (the customers will
be passive). Each teller will have an infinite-looping <b>run(&nbsp;)</b>
member function that will execute for a certain number of “time units” and then
simply return. By using the ordinary return mechanism, we eliminate the need
for any swapping. The resulting program, although small, provides a remarkably
reasonable simulation:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1200"
title="Add Comment A1200"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:BankTeller.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using a queue and simulated
multithreading</p>

<p class=CodeChar style='margin-left:0in'>// To model a bank teller system</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Customer {</p>

<p class=CodeChar style='margin-left:0in'>  int serviceTime;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Customer() : serviceTime(0) {}</p>

<p class=CodeChar style='margin-left:0in'>  Customer(int tm) : serviceTime(tm)
{}</p>

<p class=CodeChar style='margin-left:0in'>  int getTime() { return serviceTime;
}</p>

<p class=CodeChar style='margin-left:0in'>  void setTime(int newtime) {</p>

<p class=CodeChar style='margin-left:0in'>    serviceTime = newtime;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os, const
Customer&amp; c) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; '[' &lt;&lt;
c.serviceTime &lt;&lt; ']';</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Teller {</p>

<p class=CodeChar style='margin-left:0in'>  queue&lt;Customer&gt;&amp;
customers;</p>

<p class=CodeChar style='margin-left:0in'>  Customer current;</p>

<p class=CodeChar style='margin-left:0in'>  enum { slice = 5 };</p>

<p class=CodeChar style='margin-left:0in'>  int ttime; // Time left in slice</p>

<p class=CodeChar style='margin-left:0in'>  bool busy; // Is teller serving a
customer?</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Teller(queue&lt;Customer&gt;&amp;
cq) </p>

<p class=CodeChar style='margin-left:0in'>    : customers(cq), ttime(0),
busy(false) {}</p>

<p class=CodeChar style='margin-left:0in'>  Teller&amp; operator=(const
Teller&amp; rv) {</p>

<p class=CodeChar style='margin-left:0in'>    customers = rv.customers;</p>

<p class=CodeChar style='margin-left:0in'>    current = rv.current;</p>

<p class=CodeChar style='margin-left:0in'>    ttime = rv.ttime;</p>

<p class=CodeChar style='margin-left:0in'>    busy = rv.busy;</p>

<p class=CodeChar style='margin-left:0in'>    return *this;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  bool isBusy() { return busy; }</p>

<p class=CodeChar style='margin-left:0in'>  void run(bool recursion = false) {</p>

<p class=CodeChar style='margin-left:0in'>    if(!recursion)</p>

<p class=CodeChar style='margin-left:0in'>      ttime = slice;</p>

<p class=CodeChar style='margin-left:0in'>    int servtime = current.getTime();</p>

<p class=CodeChar style='margin-left:0in'>    if(servtime &gt; ttime) {</p>

<p class=CodeChar style='margin-left:0in'>      servtime -= ttime;</p>

<p class=CodeChar style='margin-left:0in'>      current.setTime(servtime);</p>

<p class=CodeChar style='margin-left:0in'>      busy = true; // Still working
on current</p>

<p class=CodeChar style='margin-left:0in'>      return;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    if(servtime &lt; ttime) {</p>

<p class=CodeChar style='margin-left:0in'>      ttime -= servtime;</p>

<p class=CodeChar style='margin-left:0in'>      if(!customers.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>        current = customers.front();</p>

<p class=CodeChar style='margin-left:0in'>        customers.pop(); // Remove it</p>

<p class=CodeChar style='margin-left:0in'>        busy = true;</p>

<p class=CodeChar style='margin-left:0in'>        run(true); // Recurse</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>      return;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    if(servtime == ttime) {</p>

<p class=CodeChar style='margin-left:0in'>      // Done with current, set to
empty:</p>

<p class=CodeChar style='margin-left:0in'>      current = Customer(0);</p>

<p class=CodeChar style='margin-left:0in'>      busy = false;</p>

<p class=CodeChar style='margin-left:0in'>      return; // No more time in this
slice</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Inherit to access protected
implementation:</p>

<p class=CodeChar style='margin-left:0in'>class CustomerQ : public queue&lt;Customer&gt;
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const CustomerQ&amp; cd) {</p>

<p class=CodeChar style='margin-left:0in'>    copy(cd.c.begin(), cd.c.end(), </p>

<p class=CodeChar style='margin-left:0in'>     
ostream_iterator&lt;Customer&gt;(os, &quot;&quot;));</p>

<p class=CodeChar style='margin-left:0in'>    return os;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  CustomerQ customers;</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;Teller&gt; tellers;</p>

<p class=CodeChar style='margin-left:0in'>  typedef
list&lt;Teller&gt;::iterator TellIt;</p>

<p class=CodeChar style='margin-left:0in'> 
tellers.push_back(Teller(customers));</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0)); // Seed random
number generator</p>

<p class=CodeChar style='margin-left:0in'>  clock_t ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  // Run simulation for at least 5
seconds:</p>

<p class=CodeChar style='margin-left:0in'>  while(clock() &lt; ticks + 5 *
CLK_TCK) {</p>

<p class=CodeChar style='margin-left:0in'>    // Add a random number of
customers to the</p>

<p class=CodeChar style='margin-left:0in'>    // queue, with random service
times:</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; rand() % 5;
i++)</p>

<p class=CodeChar style='margin-left:0in'>      customers.push(Customer(rand()
% 15 + 1));</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; '{' &lt;&lt;
tellers.size() &lt;&lt; '}' </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; customers &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    // Have the tellers service the
queue:</p>

<p class=CodeChar style='margin-left:0in'>    for(TellIt i = tellers.begin(); </p>

<p class=CodeChar style='margin-left:0in'>      i != tellers.end(); i++)</p>

<p class=CodeChar style='margin-left:0in'>      (*i).run();</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; '{' &lt;&lt;
tellers.size() &lt;&lt; '}' </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; customers &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    // If line is too long, add
another teller:</p>

<p class=CodeChar style='margin-left:0in'>    if(customers.size() /
tellers.size() &gt; 2)</p>

<p class=CodeChar style='margin-left:0in'>     
tellers.push_back(Teller(customers));</p>

<p class=CodeChar style='margin-left:0in'>    // If line is short enough,
remove a teller:</p>

<p class=CodeChar style='margin-left:0in'>    if(tellers.size() &gt; 1
&amp;&amp; </p>

<p class=CodeChar style='margin-left:0in'>      customers.size() /
tellers.size() &lt; 2)</p>

<p class=CodeChar style='margin-left:0in'>      for(TellIt i = tellers.begin();</p>

<p class=CodeChar style='margin-left:0in'>        i != tellers.end(); i++)</p>

<p class=CodeChar style='margin-left:0in'>        if(!(*i).isBusy()) {</p>

<p class=CodeChar style='margin-left:0in'>          tellers.erase(i);</p>

<p class=CodeChar style='margin-left:0in'>          break; // Out of for loop</p>

<p class=CodeChar style='margin-left:0in'>        }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each customer requires a certain amount of service time,
which is the number of time units that a teller must spend on the customer in
order to serve that customer’s needs. Of course, the amount of service time
will be different for each customer and will be determined randomly. In
addition, you won’t know how many customers will be arriving in each interval,
so this will also be determined randomly. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1201"
title="Add Comment A1201"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>Customer </b>objects are kept in a <b>queue&lt;Customer&gt;</b>,
and each <b>Teller</b> object keeps a reference to that queue.<b> </b>When a <b>Teller</b>
object is finished with its current <b>Customer</b> object, that <b>Teller</b>
will get another <b>Customer</b> from the queue and begin working on the new <b>Customer</b>,
reducing the <b>Customer</b>’s service time during each time slice that the <b>Teller</b>
is allotted. All this logic is in the <b>run(&nbsp;)</b> member function, which
is basically a three-way <b>if</b> statement based on whether the amount of
time necessary to serve the customer is less than, greater than, or equal to
the amount of time left in the teller’s current time slice. Notice that if the <b>Teller</b>
has more time after finishing with a <b>Customer</b>, it gets a new customer
and recurses into itself.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1202"
title="Add Comment A1202"><sup>Comment</sup></a></p>

<p class=MsoNormal>Just as with a <b>stack</b>, when you use a <b>queue</b>,
it’s only a <b>queue</b> and doesn’t have any of the other functionality of the
basic sequence containers. This includes the ability to get an iterator in
order to step through the <b>stack</b>. However, the underlying sequence
container (that the <b>queue</b> is built upon) is held as a <b>protected</b>
member inside the <b>queue</b>, and the identifier for this member is specified
in the C++ Standard as ‘<b>c</b>’, which means that you can derive from <b>queue</b>
in order to access the underlying implementation. The <b>CustomerQ</b> class
does exactly that, for the sole purpose of defining an <b>ostream</b> <b>operator&lt;&lt;</b>
that can iterate through the <b>queue</b> and print out its members.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1203"
title="Add Comment A1203"><sup>Comment</sup></a></p>

<p class=MsoNormal>The driver for the simulation is the <b>while</b> loop in <b>main(&nbsp;)</b>,
which uses processor ticks (defined in <b>&lt;ctime&gt;</b>) to determine if
the simulation has run for at least 5 seconds. At the beginning of each pass
through the loop, a random number of customers is added, with random service
times. Both the number of tellers and the queue contents are displayed so you
can see the state of the system. After running each teller, the display is
repeated. At this point, the system adapts by comparing the number of customers
and the number of tellers; if the line is too long, another teller is added,
and if it is short enough, a teller can be removed. In this adaptation section
of the program you can experiment with policies regarding the optimal addition
and removal of tellers. If this is the only section that you’re modifying, you
might want to encapsulate policies inside different objects. We’ll revisit this
problem with a multithreaded solution in Chapter 10. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1204"
title="Add Comment A1204"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440126">Priority queues</a></h2>

<p class=MsoNormal>When you <b>push(&nbsp;)</b> an object onto a <b>priority_queue</b>,
that object is sorted into the queue according to a function or function
object. (You can allow the default <b>less</b> template to supply this, or you
can provide one of your own.) The <b>priority_queue</b> ensures that when you
look at the <b>top(&nbsp;)</b> element, it will be the one with the highest
priority. When you’re done with it, you call <b>pop(&nbsp;)</b> to remove it
and bring the next one into place. Thus, the <b>priority_queue</b> has nearly
the same interface as a <b>stack</b>, but it behaves differently.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1205"
title="Add Comment A1205"><sup>Comment</sup></a></p>

<p class=MsoNormal>Like <b>stack</b> and <b>queue</b>, <b>priority_queue</b> is
an adapter that is built on top of one of the basic sequences—the default is <b>vector</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1206"
title="Add Comment A1206"><sup>Comment</sup></a></p>

<p class=MsoNormal>It’s trivial to make a <b>priority_queue</b> that works with
<b>int</b>s:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1207"
title="Add Comment A1207"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue1.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  priority_queue&lt;int&gt; pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0)); // Seed random
number generator</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This pushes into the <b>priority_queue </b>100 random values
from 0 to 24. When you run this program you’ll see that duplicates are allowed,
and the highest values appear first. To show how you can change the ordering by
providing your own function or function object, the following program gives
lower-valued numbers the highest priority:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1208"
title="Add Comment A1208"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Changing the priority</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;functional&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  priority_queue&lt;int,
vector&lt;int&gt;, greater&lt;int&gt; &gt; pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A more interesting problem is a to-do list, in which each
object contains a <b>string</b> and a primary and secondary priority value:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1212"
title="Add Comment A1212"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A more complex use of priority_queue</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class ToDoItem {</p>

<p class=CodeChar style='margin-left:0in'>  char primary;</p>

<p class=CodeChar style='margin-left:0in'>  int secondary;</p>

<p class=CodeChar style='margin-left:0in'>  string item;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  ToDoItem(string td, char pri ='A',
int sec =1)</p>

<p class=CodeChar style='margin-left:0in'>    : item(td), primary(pri),
secondary(sec) {}</p>

<p class=CodeChar style='margin-left:0in'>  friend bool operator&lt;(</p>

<p class=CodeChar style='margin-left:0in'>    const ToDoItem&amp; x, const
ToDoItem&amp; y) {</p>

<p class=CodeChar style='margin-left:0in'>    if(x.primary &gt; y.primary) </p>

<p class=CodeChar style='margin-left:0in'>      return true;</p>

<p class=CodeChar style='margin-left:0in'>    if(x.primary == y.primary)</p>

<p class=CodeChar style='margin-left:0in'>      if(x.secondary &gt;
y.secondary) </p>

<p class=CodeChar style='margin-left:0in'>        return true;</p>

<p class=CodeChar style='margin-left:0in'>    return false;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const ToDoItem&amp; td) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; td.primary
&lt;&lt; td.secondary </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot;: &quot;
&lt;&lt; td.item;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  priority_queue&lt;ToDoItem&gt;
toDoList;</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Empty
trash&quot;, 'C', 4));</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Feed
dog&quot;, 'A', 2));</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Feed
bird&quot;, 'B', 7));</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Mow
lawn&quot;, 'C', 3));</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Water
lawn&quot;, 'A', 1));</p>

<p class=CodeChar style='margin-left:0in'>  toDoList.push(ToDoItem(&quot;Feed
cat&quot;, 'B', 1));</p>

<p class=CodeChar style='margin-left:0in'>  while(!toDoList.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; toDoList.top()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    toDoList.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>ToDoItem</b>’s <b>operator&lt;</b> must be a
nonmember function for it to work with <b>less&lt; &gt;</b>. Other than that,
everything happens automatically. The output is:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1213"
title="Add Comment A1213"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>A1: Water lawn</p>

<p class=CodeChar style='margin-left:0in'>A2: Feed dog</p>

<p class=CodeChar style='margin-left:0in'>B1: Feed cat</p>

<p class=CodeChar style='margin-left:0in'>B7: Feed bird</p>

<p class=CodeChar style='margin-left:0in'>C3: Mow lawn</p>

<p class=CodeInlineCharChar style='margin-left:0in'>C4: Empty trash</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You cannot iterate through a <b>priority_queue</b>, but it’s
possible to simulate the behavior of a <b>priority_queue</b> using a <b>vector</b>,
thus allowing you access to that <b>vector</b>. You can do this by looking at
the implementation of <b>priority_queue</b>, which uses <b>make_heap(&nbsp;)</b>,
<b>push_heap(&nbsp;),</b> and <b>pop_heap(&nbsp;).</b> (They are the soul of
the <b>priority_queue</b>; in fact you could say that the heap <i>is</i> the priority
queue and that <b>priority_queue </b>is just a wrapper around it.) This turns
out to be reasonably straightforward, but you might think that a shortcut is
possible. Since the container used by <b>priority_queue</b> is <b>protected</b>
(and has the identifier, according to the Standard C++ specification, named <b>c</b>),
you can inherit a new class that provides access to the underlying
implementation:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1214"
title="Add Comment A1214"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue4.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Manipulating the underlying
implementation</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class PQI : public
priority_queue&lt;int&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;int&gt;&amp; impl() {
return c; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  PQI pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  copy(pqi.impl().begin(),
pqi.impl().end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>However, if you run this program, you’ll discover that the <b>vector</b>
doesn’t contain the items in the descending order that you get when you call <b>pop(&nbsp;)</b>,
the order that you want from the priority queue. It would seem that if you want
to create a <b>vector</b> that is a priority queue, you have to do it by hand,
like this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1215"
title="Add Comment A1215"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue5.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Building your own priority queue</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class
Compare&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PQV : public vector&lt;T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  Compare comp;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  PQV(Compare cmp = Compare()) :
comp(cmp) {</p>

<p class=CodeChar style='margin-left:0in'>    make_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  const T&amp; top() { return
front(); }</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    push_back(x);</p>

<p class=CodeChar style='margin-left:0in'>    push_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {</p>

<p class=CodeChar style='margin-left:0in'>    pop_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>    pop_back();</p>

<p class=CodeChar style='margin-left:0in'>  }  </p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  PQV&lt;int, less&lt;int&gt; &gt;
pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  copy(pqi.begin(), pqi.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>But this program behaves in the same way as the previous
one! What you are seeing in the underlying <b>vector</b> is called a <i>heap</i>.<i>
</i>This heap data structure represents the tree of the priority queue (stored
in the linear structure of the <b>vector</b>), but when you iterate through it,
you do not get a linear priority-queue order. You might think that you can
simply call <b>sort_heap(&nbsp;)</b>, but that only works once, and then you
don’t have a heap anymore, but instead a sorted list. This means that to go
back to using it as a heap, the user must remember to call <b>make_heap(&nbsp;)
</b>first. This can be encapsulated into your custom priority queue:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1216"
title="Add Comment A1216"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue6.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class
Compare&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PQV : public vector&lt;T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  Compare comp;</p>

<p class=CodeChar style='margin-left:0in'>  bool sorted;</p>

<p class=CodeChar style='margin-left:0in'>  void assureHeap() {</p>

<p class=CodeChar style='margin-left:0in'>    if(sorted) {</p>

<p class=CodeChar style='margin-left:0in'>      // Turn it back into a heap:</p>

<p class=CodeChar style='margin-left:0in'>      make_heap(begin(), end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>      sorted = false;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }    </p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  PQV(Compare cmp = Compare()) :
comp(cmp) {</p>

<p class=CodeChar style='margin-left:0in'>    make_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>    sorted = false;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  const T&amp; top() {</p>

<p class=CodeChar style='margin-left:0in'>    assureHeap();</p>

<p class=CodeChar style='margin-left:0in'>    return front(); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    assureHeap();</p>

<p class=CodeChar style='margin-left:0in'>    // Put it at the end:</p>

<p class=CodeChar style='margin-left:0in'>    push_back(x);</p>

<p class=CodeChar style='margin-left:0in'>    // Re-adjust the heap:</p>

<p class=CodeChar style='margin-left:0in'>    push_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {</p>

<p class=CodeChar style='margin-left:0in'>    assureHeap();</p>

<p class=CodeChar style='margin-left:0in'>    // Move the top element to the
last position:</p>

<p class=CodeChar style='margin-left:0in'>    pop_heap(begin(), end(), comp);</p>

<p class=CodeChar style='margin-left:0in'>    // Remove that element:</p>

<p class=CodeChar style='margin-left:0in'>    pop_back();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void sort() {</p>

<p class=CodeChar style='margin-left:0in'>    if(!sorted) {</p>

<p class=CodeChar style='margin-left:0in'>      sort_heap(begin(), end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>      reverse(begin(), end());</p>

<p class=CodeChar style='margin-left:0in'>      sorted = true;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  PQV&lt;int, less&lt;int&gt; &gt;
pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>    copy(pqi.begin(), pqi.end(),</p>

<p class=CodeChar style='margin-left:0in'>     
ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;\n-----\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  pqi.sort();</p>

<p class=CodeChar style='margin-left:0in'>  copy(pqi.begin(), pqi.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>If <b>sorted</b> is true, the <b>vector</b> is not organized
as a heap, but instead as a sorted sequence. The <b>assureHeap(&nbsp;)</b>
function guarantees that it’s put back into heap form before performing any
heap operations on it.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1217"
title="Add Comment A1217"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first <b>for</b> loop in <b>main(&nbsp;)</b> now has the
additional quality that it displays the heap as it’s being built.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1218"
title="Add Comment A1218"><sup>Comment</sup></a></p>

<p class=MsoNormal>The only drawback to this solution is that the user must
remember to call <b>sort(&nbsp;) </b>before viewing it as a sorted sequence
(although one could conceivably override all the member functions that produce
iterators so that they guarantee sorting). Another solution is to build a
priority queue that is not a <b>vector</b>, but will build you a <b>vector</b>
whenever you want one:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1219"
title="Add Comment A1219"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue7.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A priority queue that will hand
you a vector</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T, class
Compare&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PQV {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;T&gt; v;</p>

<p class=CodeChar style='margin-left:0in'>  Compare comp;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // Don't need to call make_heap();
it's empty:</p>

<p class=CodeChar style='margin-left:0in'>  PQV(Compare cmp = Compare()) :
comp(cmp) {}</p>

<p class=CodeChar style='margin-left:0in'>  void push(const T&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    // Put it at the end:</p>

<p class=CodeChar style='margin-left:0in'>    v.push_back(x);</p>

<p class=CodeChar style='margin-left:0in'>    // Re-adjust the heap:</p>

<p class=CodeChar style='margin-left:0in'>    push_heap(v.begin(), v.end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void pop() {</p>

<p class=CodeChar style='margin-left:0in'>    // Move the top element to the
last position:</p>

<p class=CodeChar style='margin-left:0in'>    pop_heap(v.begin(), v.end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>    // Remove that element:</p>

<p class=CodeChar style='margin-left:0in'>    v.pop_back();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  const T&amp; top() { return
v.front(); }</p>

<p class=CodeChar style='margin-left:0in'>  bool empty() const { return
v.empty(); }</p>

<p class=CodeChar style='margin-left:0in'>  int size() const { return v.size();
}</p>

<p class=CodeChar style='margin-left:0in'>  typedef vector&lt;T&gt; TVec;</p>

<p class=CodeChar style='margin-left:0in'>  TVec vector() {</p>

<p class=CodeChar style='margin-left:0in'>    TVec r(v.begin(), v.end());</p>

<p class=CodeChar style='margin-left:0in'>    // It’s already a heap</p>

<p class=CodeChar style='margin-left:0in'>    sort_heap(r.begin(), r.end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>    // Put it into priority-queue
order:</p>

<p class=CodeChar style='margin-left:0in'>    reverse(r.begin(), r.end());</p>

<p class=CodeChar style='margin-left:0in'>    return r;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  PQV&lt;int, less&lt;int&gt; &gt;
pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  const vector&lt;int&gt;&amp; v =
pqi.vector();</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;; </p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>PQV</b> class template follows the same form as the
STL’s <b>priority_queue</b>, but has the additional member <b>vector(&nbsp;)</b>,
which creates a new <b>vector</b> that’s a copy of the one in <b>PQV </b>(which
means that it’s already a heap). It then sorts that copy (leaveing <b>PQV</b>’s
<b>vector</b> untouched), and reverses the order so that traversing the new <b>vector</b>
produces the same effect as popping the elements from the priority queue. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1220"
title="Add Comment A1220"><sup>Comment</sup></a></p>

<p class=MsoNormal>You may observe that the approach of deriving from <b>priority_queue</b>
used in <b>PriorityQueue4.cpp</b> could be used with the above technique to
produce more succinct code:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1221"
title="Add Comment A1221"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:PriorityQueue8.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A more compact version of
PriorityQueue7.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;queue&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PQV : public
priority_queue&lt;T&gt; {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  typedef vector&lt;T&gt; TVec;</p>

<p class=CodeChar style='margin-left:0in'>  TVec vector() {</p>

<p class=CodeChar style='margin-left:0in'>    TVec r(c.begin(), c.end());</p>

<p class=CodeChar style='margin-left:0in'>    // c is already a heap</p>

<p class=CodeChar style='margin-left:0in'>    sort_heap(r.begin(), r.end(),
comp);</p>

<p class=CodeChar style='margin-left:0in'>    // Put it into priority-queue
order:</p>

<p class=CodeChar style='margin-left:0in'>    reverse(r.begin(), r.end());</p>

<p class=CodeChar style='margin-left:0in'>    return r;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  PQV&lt;int&gt; pqi;</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    pqi.push(rand() % 25);</p>

<p class=CodeChar style='margin-left:0in'>  const vector&lt;int&gt;&amp; v =
pqi.vector();</p>

<p class=CodeChar style='margin-left:0in'>  copy(v.begin(), v.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n-----------\n&quot;;
</p>

<p class=CodeChar style='margin-left:0in'>  while(!pqi.empty()) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; pqi.top() &lt;&lt;
' ';</p>

<p class=CodeChar style='margin-left:0in'>    pqi.pop();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The brevity of this solution makes it the simplest and most
desirable, plus it’s guaranteed that the user will not have a <b>vector</b> in
the unsorted state. The only potential problem is that the <b>vector(&nbsp;)</b>
member function returns the <b>vector&lt;T&gt;</b> by value, which might cause
some overhead issues with complex values of the parameter type <b>T</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1222"
title="Add Comment A1222"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440127">Holding bits</a></h2>

<p class=MsoNormal>Because C was a language that purported to be “close to the
hardware,” many have found it dismaying that there was no native binary
representation for numbers. Decimal, of course, and hexadecimal (tolerable only
because it’s easier to group the bits in your mind), but octal? Ugh. Whenever
you read specs for chips you’re trying to program, they don’t describe the chip
registers in octal or even hexadecimal—they use binary. And yet C won’t let you
say <b>0b0101101</b>, which is the obvious solution for a language close to the
hardware.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1223"
title="Add Comment A1223"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although there’s still no native binary representation in
C++, things have improved with the addition of two classes: <b>bitset</b> and <b>vector&lt;bool&gt;</b>,
both of which are designed to manipulate a group of on-off values<a
href="#_ftn87" name="_ftnref87" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[87]</span></sup></span></span></sup></span></a>. The primary
differences between these types are:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1224"
title="Add Comment A1224"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Each <b>bitset</b> holds a fixed number of bits. You establish
the quantity of bits in the <b>bitset</b> template argument. The <b>vector&lt;bool&gt;</b>
can, like a regular <b>vector</b>, expand dynamically to hold any number of <b>bool</b>
values.</p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <b>bitset</b> template is explicitly designed for performance
when manipulating bits, and is not a “regular” STL container. As such, it has
no iterators. The number of bits, being a template parameter, is known at
compile time and allows the underlying integral array to be stored on the
runtime stack. The <b>vector&lt;bool&gt;</b> container, on the other hand, is a
specialization of a <b>vector</b> and so has all the operations of a normal <b>vector</b>—the
specialization is just designed to be space efficient for <b>bool</b>.</p>

<p class=MsoNormal>There is no trivial conversion between a <b>bitset</b> and a
<b>vector&lt;bool&gt;</b>, which implies that the two are for very different
purposes. Furthermore, neither is a traditional “STL container.” The <b>bitset</b>
template class has an interface for bit-level operations and in no way
resembles the STL containers we’ve discussed up to this point. The <b>vector&lt;bool&gt;</b>
specialization of <b>vector</b> is similar to an STL-like container, but it
differs as discussed below. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1225"
title="Add Comment A1225"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440128"><span style='font-weight:normal'>bitset&lt;n&gt;</span></a></h3>

<p class=MsoNormal>The template for <b>bitset</b> accepts an unsigned integral
template argument that is the number of bits to represent. Thus, <b>bitset&lt;10&gt;</b>
is a different type than <b>bitset&lt;20&gt;</b>, and you cannot perform
comparisons, assignments, and so on between the two.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1226"
title="Add Comment A1226"><sup>Comment</sup></a></p>

<p class=MsoNormal>A <b>bitset</b> provides the most commonly used bitwise
operations in an efficient form. However, each <b>bitset</b> is implemented by
logically packing bits in an array of integral types (typically <b>unsigned</b>
<b>long</b>s, which contain at least 32 bits). In addition, the only conversion
from a <b>bitset</b> to a numerical value is to an <b>unsigned long</b> (via
the function <b>to_ulong(&nbsp;)</b>).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1227"
title="Add Comment A1227"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example tests almost all the functionality of
the <b>bitset</b> (the missing operations are redundant or trivial).<b> </b>You’ll
see the description of each of the bitset outputs to the right of the output so
that the bits all line up, and you can compare them to the source values. If
you still don’t understand bitwise operations, running this program should
help.<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1228"
title="Add Comment A1228"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:BitSet.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Exercising the bitset class</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;bitset&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;climits&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>const int sz = 32;</p>

<p class=CodeChar style='margin-left:0in'>typedef bitset&lt;sz&gt; BS;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int bits&gt;</p>

<p class=CodeChar style='margin-left:0in'>bitset&lt;bits&gt; randBitset() {</p>

<p class=CodeChar style='margin-left:0in'>  bitset&lt;bits&gt; r(rand());</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; bits/16 - 1;
i++) {</p>

<p class=CodeChar style='margin-left:0in'>    r &lt;&lt;= 16;</p>

<p class=CodeChar style='margin-left:0in'>    // &quot;OR&quot; together with a
new lower 16 bits:</p>

<p class=CodeChar style='margin-left:0in'>    r |= bitset&lt;bits&gt;(rand()); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  return r;</p>

<p class=CodeChar style='margin-left:0in'>}  </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;sizeof(bitset&lt;16&gt;) = &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; sizeof(bitset&lt;16&gt;)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;sizeof(bitset&lt;32&gt;) = &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; sizeof(bitset&lt;32&gt;)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;sizeof(bitset&lt;48&gt;) = &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; sizeof(bitset&lt;48&gt;)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;sizeof(bitset&lt;64&gt;) = &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; sizeof(bitset&lt;64&gt;)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;sizeof(bitset&lt;65&gt;) = &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; sizeof(bitset&lt;65&gt;)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  BS a(randBitset&lt;sz&gt;()),
b(randBitset&lt;sz&gt;());</p>

<p class=CodeChar style='margin-left:0in'>  // Converting from a bitset:</p>

<p class=CodeChar style='margin-left:0in'>  unsigned long ul = a.to_ulong();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Converting a string to a bitset:</p>

<p class=CodeChar style='margin-left:0in'>  string
cbits(&quot;111011010110111&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;as a string =
&quot; &lt;&lt; cbits &lt;&lt;endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(cbits) &lt;&lt;
&quot; [BS(cbits)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(cbits, 2) </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; [BS(cbits,
2)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(cbits, 2, 11)</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; [BS(cbits, 2,
11)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; &quot;
[a]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b &lt;&lt; &quot;
[b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Bitwise AND:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (a &amp; b) &lt;&lt;
&quot; [a &amp; b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (BS(a) &amp;= b)
&lt;&lt; &quot; [a &amp;= b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Bitwise OR:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (a | b) &lt;&lt;
&quot; [a | b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (BS(a) |= b) &lt;&lt;
&quot; [a |= b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Exclusive OR:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (a ^ b) &lt;&lt;
&quot; [a ^ b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (BS(a) ^= b) &lt;&lt;
&quot; [a ^= b]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; &quot;
[a]&quot; &lt;&lt; endl; // For reference</p>

<p class=CodeChar style='margin-left:0in'>  // Logical left shift (fill with
zeros):</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (BS(a) &lt;&lt;=
sz/2) </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; [a &lt;&lt;=
(sz/2)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (a &lt;&lt; sz/2)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; &quot;
[a]&quot; &lt;&lt; endl; // For reference</p>

<p class=CodeChar style='margin-left:0in'>  // Logical right shift (fill with
zeros):</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (BS(a) &gt;&gt;=
sz/2) </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot; [a &gt;&gt;=
(sz/2)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (a &gt;&gt; sz/2)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; &quot;
[a]&quot; &lt;&lt; endl; // For reference</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(a).set() &lt;&lt;
&quot; [a.set()]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>for(int i = 0; i &lt;
sz; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>if(!a.test(i))
{</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; BS(a).set(i) </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot; [a.set(&quot;
&lt;&lt; i &lt;&lt;&quot;)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>      break; // Just do one example
of this</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(a).reset()
&lt;&lt; &quot; [a.reset()]&quot;&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(int j = 0; j &lt; sz; j++)</p>

<p class=CodeChar style='margin-left:0in'>    if(a.test(j)) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; BS(a).reset(j) </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot;
[a.reset(&quot; &lt;&lt; j &lt;&lt;&quot;)]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>      break; // Just do one example
of this</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(a).flip() &lt;&lt;
&quot; [a.flip()]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; ~a &lt;&lt; &quot;
[~a]&quot; &lt;&lt; endl;  </p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; a &lt;&lt; &quot;
[a]&quot; &lt;&lt; endl; // For reference</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; BS(a).flip(1)
&lt;&lt; &quot; [a.flip(1)]&quot;&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  BS c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; c &lt;&lt; &quot;
[c]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.count() =
&quot; &lt;&lt; c.count() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.any() =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; (c.any() ?
&quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.none() =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; (c.none() ?
&quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  c[1].flip(); c[2].flip();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; c &lt;&lt; &quot;
[c]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.count() =
&quot; &lt;&lt; c.count() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.any() =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; (c.any() ?
&quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;c.none() =
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; (c.none() ?
&quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Array indexing operations:</p>

<p class=CodeChar style='margin-left:0in'>  c.reset();</p>

<p class=CodeChar style='margin-left:0in'>  for(int k = 0; k &lt; c.size();
k++)</p>

<p class=CodeChar style='margin-left:0in'>    if(k % 2 == 0)</p>

<p class=CodeChar style='margin-left:0in'>      c[k].flip();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; c &lt;&lt; &quot;
[c]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  c.reset();</p>

<p class=CodeChar style='margin-left:0in'>  // Assignment to bool:</p>

<p class=CodeChar style='margin-left:0in'>  for(int ii = 0; ii &lt; c.size();
ii++)</p>

<p class=CodeChar style='margin-left:0in'>    c[ii] = (rand() % 100) &lt; 25;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; c &lt;&lt; &quot;
[c]&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // bool test:</p>

<p class=CodeChar style='margin-left:0in'>  if(c[1]) </p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;c[1] ==
true&quot;; </p>

<p class=CodeChar style='margin-left:0in'>  else </p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;c[1] ==
false&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>To generate interesting random <b>bitset</b>s, the <b>randBitset(&nbsp;)</b>
function is created. This function demonstrates <b>operator&lt;&lt;=</b> by
shifting each 16 random bits to the left until the <b>bitset</b> (which is
templatized in this function for size) is full. The generated number and each
new 16 bits are combined using the <b>operator|=</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1229"
title="Add Comment A1229"><sup>Comment</sup></a></p>

<p class=MsoNormal>The first thing demonstrated in <b>main(&nbsp;)</b> is the
unit size of a <b>bitset</b>. If it is less than 32 bits, <b>sizeof</b>
produces 4 (4 bytes = 32 bits), which is the size of a single <b>long</b> on
most implementations. If it’s between 32 and 64, it requires two <b>long</b>s,
greater than 64 requires 3 <b>long</b>s, and so on. Thus, you make the best use
of space if you use a bit quantity that fits in an integral number of <b>long</b>s.
However, notice there’s no extra overhead for the object—it’s as if you were
hand-coding to use a <b>long</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1230"
title="Add Comment A1230"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although there are no other numerical conversions from <b>bitset</b>
besides <b>to_ulong(&nbsp;)</b>, there is a <b>stream inserter </b>that
produces a <b>string</b> containing ones and zeros, and this can be as long as
the actual <b>bitset</b>.<b> </b><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1231"
title="Add Comment A1231"><sup>Comment</sup></a></p>

<p class=MsoNormal>There’s still no primitive format for binary values, but the
next best thing is supported by <b>bitset</b>: a <b>string</b> of ones and
zeros with the least-significant bit (lsb) on the right. The three constructors
demonstrated show taking the entire <b>string</b>, the <b>string</b> starting
at character 2, and the string from character 2 through 11. You can write to an
<b>ostream</b> from a <b>bitset</b> using <b>operator&lt;&lt;, </b>and it comes
out as ones and zeros. You can also read from an <b>istream</b> using <b>operator&gt;&gt;</b>
(not shown here).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1232"
title="Add Comment A1232"><sup>Comment</sup></a></p>

<p class=MsoNormal>You’ll notice that <b>bitset</b> only has three nonmember
operators: <i>and</i> (<b>&amp;</b>), <i>or</i> (<b>|</b>), and <i>exclusive-or</i>
(<b>^</b>). Each of these creates a new <b>bitset </b>as its return value. All
the member operators opt for the more efficient <b>&amp;=</b>, <b>|=</b>, and
so on form in which a temporary is not created. However, these forms actually
change the <b>bitset</b>’s value (which is <b>a</b> in most of the tests in the
above example). To prevent this, we created a temporary to be used as the
lvalue by invoking the copy-constructor on <b>a</b>; this is why you see the
form <b>BS(a)</b>. The result of each test is printed out, and occasionally <b>a</b>
is reprinted so you can easily look at it for reference.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1233"
title="Add Comment A1233"><sup>Comment</sup></a></p>

<p class=MsoNormal>The rest of the example should be self-explanatory when you
run it; if not you can find the details in your compiler’s documentation or in
the other documentation mentioned earlier in this chapter.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1234"
title="Add Comment A1234"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440129"><span style='font-weight:normal'>vector&lt;bool&gt;</span></a></h3>

<p class=MsoNormal>The <b>vector&lt;bool&gt;</b> container is a specialization
of the <b>vector</b> template. A normal <b>bool</b> variable requires at least
one byte, but since a <b>bool</b> only has two states, the ideal implementation
of <b>vector&lt;bool&gt;</b> is such that each <b>bool</b> value only requires
one bit. This means the iterator must be specially defined and cannot be a
pointer to <b>bool</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1235"
title="Add Comment A1235"><sup>Comment</sup></a></p>

<p class=MsoNormal>The bit-manipulation functions for <b>vector&lt;bool&gt;</b>
are much more limited than those of <b>bitset</b>. The only member function
that was added to those already in <b>vector</b> is <b>flip(&nbsp;)</b>, to
invert all the bits; there is no <b>set(&nbsp;)</b> or <b>reset(&nbsp;)</b> as
in <b>bitset</b>. When you use <b>operator[ ]</b>, you get back an object of
type <b>vector&lt;bool&gt;::reference</b>, which also has a <b>flip(&nbsp;)</b>
to invert that individual bit.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1236"
title="Add Comment A1236"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:VectorOfBool.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstrate the vector&lt;bool&gt;
specialization</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;bitset&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in;text-align:justify'>#include
&lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;bool&gt; vb(10, true);</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;bool&gt;::iterator it;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = vb.begin(); it !=
vb.end(); it++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vb.push_back(false);</p>

<p class=CodeChar style='margin-left:0in'>  ostream_iterator&lt;bool&gt;
out(cout, &quot;&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  bool ab[] = { true, false, false,
true, true, </p>

<p class=CodeChar style='margin-left:0in'>    true, true, false, false, true };</p>

<p class=CodeChar style='margin-left:0in'>  // There's a similar constructor:</p>

<p class=CodeChar style='margin-left:0in'>  vb.assign(ab, ab +
sizeof(ab)/sizeof(bool));</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  vb.flip(); // Flip all bits</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; vb.size();
i++)</p>

<p class=CodeChar style='margin-left:0in'>    vb[i] = 0; // (Equivalent to
&quot;false&quot;)</p>

<p class=CodeChar style='margin-left:0in'>  vb[4] = true;</p>

<p class=CodeChar style='margin-left:0in'>  vb[5] = 1;</p>

<p class=CodeChar style='margin-left:0in'>  vb[7].flip(); // Invert one bit</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(), out);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Convert to a bitset:</p>

<p class=CodeChar style='margin-left:0in'>  ostringstream os;</p>

<p class=CodeChar style='margin-left:0in'>  copy(vb.begin(), vb.end(), </p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;bool&gt;(os,
&quot;&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  bitset&lt;10&gt; bs(os.str());</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Bitset:\n&quot;
&lt;&lt; bs &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The last part of this example takes a <b>vector&lt;bool&gt;</b>
and converts it to a <b>bitset</b> by first turning it into a <b>string</b> of
ones and zeros. Of course, you must know the size of the <b>bitset</b> at
compile time. You can see that this conversion is not the kind of operation
you’ll want to do on a regular basis.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1237"
title="Add Comment A1237"><sup>Comment</sup></a></p>

<p class=MsoNormal>The <b>vector&lt;bool&gt;</b> specialization is a “crippled”
STL container in the sense that certain guarantees that other containers
provide are missing. For example, with the other containers the following
relationships hold:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Let c be an STL container other
than vector&lt;bool&gt;:</p>

<p class=CodeChar style='margin-left:0in'>T&amp; r = c.front();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>T* p = &amp;*c.begin();</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>For all other containers, the <b>front(&nbsp;)</b> function
yields an lvalue (something you can get a non-const reference to), and <b>begin(&nbsp;)</b>
must yield something you can dereference and then take the address of. Neither
is possible because bits are not addressable. Both <b>vector&lt;bool&gt;</b>
and <b>bitset</b> use a proxy class (<b>reference</b>, mentioned earlier) to
read and set bits as necessary.</p>

<h2 style='margin-left:0in'><a name="_Toc45440130">Associative containers</a></h2>

<p class=MsoNormal>The <b>set</b>, <b>map</b>, <b>multiset,</b> and <b>multimap</b>
are called <i>associative containers</i> because they associate <i>keys</i>
with <i>values</i>. Well, at least <b>map</b>s and <b>multimap</b>s associate
keys with values, but you can look at a <b>set</b> as a <b>map</b> that has no
values, only keys (and they can in fact be implemented this way), and the same
for the relationship between <b>multiset</b> and <b>multimap</b>. So, because
of the structural similarity, <b>set</b>s and <b>multiset</b>s are lumped in
with associative containers.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1238"
title="Add Comment A1238"><sup>Comment</sup></a></p>

<p class=MsoNormal>The most important basic operations with associative
containers are putting things in and, in the case of a <b>set</b>, seeing if
something is in the set. In the case of a <b>map</b>, you want to first see if
a key is in the <b>map</b>, and if it exists, you want the associated value for
that key to be returned. Of course, there are many variations on this theme,
but that’s the fundamental concept. The following example shows these basics:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1239"
title="Add Comment A1239"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:AssociativeBasics.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Basic operations with sets and
maps</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Noisy na[7];</p>

<p class=CodeChar style='margin-left:0in'>  // Add elements via constructor:</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;Noisy&gt; ns(na, na + sizeof
na/sizeof(Noisy));</p>

<p class=CodeChar style='margin-left:0in'>  // Ordinary insertion:</p>

<p class=CodeChar style='margin-left:0in'>  Noisy n;</p>

<p class=CodeChar style='margin-left:0in'>  ns.insert(n);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Check for set membership:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;ns.count(n)=
&quot; &lt;&lt; ns.count(n) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  if(ns.find(n) != ns.end())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;n(&quot;
&lt;&lt; n &lt;&lt; &quot;) found in ns&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Print elements:</p>

<p class=CodeChar style='margin-left:0in'>  copy(ns.begin(), ns.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;Noisy&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  map&lt;int, Noisy&gt; nm;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 10; i++)</p>

<p class=CodeChar style='margin-left:0in'>    nm[i]; // Automatically makes
pairs</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t j = 0; j &lt; nm.size();
j++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;nm[&quot;
&lt;&lt; j &lt;&lt;&quot;] = &quot; &lt;&lt; nm[j] &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  nm[10] = n;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  nm.insert(make_pair(47, n));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n
nm.count(10)= &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; nm.count(10) &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;nm.count(11)=
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; nm.count(11) &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  map&lt;int, Noisy&gt;::iterator it
= nm.find(6);</p>

<p class=CodeChar style='margin-left:0in'>  if(it != nm.end())</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;value:&quot;
&lt;&lt; (*it).second</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; &quot; found in nm at
location 6&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = nm.begin(); it !=
nm.end(); it++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; (*it).first
&lt;&lt; &quot;:&quot; </p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; (*it).second &lt;&lt;
&quot;, &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n-----------\n&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>set&lt;Noisy&gt;</b> object <b>ns</b> is created
using two iterators into an array of <b>Noisy</b> objects, but there is also a
default constructor and a copy-constructor, and you can pass in an object that
provides an alternate scheme for doing comparisons. Both <b>set</b>s and <b>map</b>s
have an <b>insert(&nbsp;)</b> member function to put things in, and you can
check to see if an object is already in an associative container in a couple of
ways. The <b>count(&nbsp;) </b>member function, when given a key, will tell you
how many times that key occurs. (This can only be zero or one in a <b>set</b>
or <b>map</b>, but it can be more than one with a <b>multiset</b> or <b>multimap.</b>)
The <b>find(&nbsp;)</b> member function will produce an iterator indicating the
first occurrence (with <b>set</b> and <b>map</b>, the <i>only</i> occurrence)
of the key that you give it or will produce the past-the-end iterator if it
can’t find the key. The <b>count(&nbsp;)</b> and <b>find(&nbsp;)</b> member
functions exist for all the associative containers, which makes sense. The
associative containers also have member functions <b>lower_bound(&nbsp;)</b>, <b>upper_bound(&nbsp;),</b>
and <b>equal_range(&nbsp;)</b>, which actually only make sense for <b>multiset</b>
and <b>multimap</b>, as you will see. (But don’t try to figure out how they
would be useful for <b>set</b> and <b>map</b>, since they are designed for
dealing with a range of duplicate keys, which those containers don’t allow.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1240"
title="Add Comment A1240"><sup>Comment</sup></a></p>

<p class=MsoNormal>Designing an <b>operator[ ]</b> always presents a bit of a
dilemma. Because it’s intended to be treated as an array-indexing operation,
people don’t tend to think about performing a test before they use it. But what
happens if you decide to index out of the bounds of the array? One option, of
course, is to throw an exception, but with a <b>map</b> “indexing out of the
array” could mean that you want an entry there, and that’s the way the STL <b>map</b>
treats it. The first <b>for</b> loop after the creation of the <b>map&lt;int,
Noisy&gt; nm</b> just “looks up” objects using the <b>operator[ ]</b>, but this
is actually creating new <b>Noisy</b> objects! The <b>map</b> creates a new
key-value pair (using the default constructor for the value) if you look up a
value with <b>operator[ ]</b> and it isn’t there. This means that if you really
just want to look something up and not create a new entry, you must use the
member functions <b>count(&nbsp;)</b> (to see if it’s there) or <b>find(&nbsp;)</b>
(to get an iterator to it).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1241"
title="Add Comment A1241"><sup>Comment</sup></a></p>

<p class=MsoNormal>A number of problems are associated with the <b>for</b> loop
that prints out the values of the container using <b>operator[ ]</b>. First, it
requires integral keys (which we happen to have in this case). Next and worse,
if all the keys are not sequential, you’ll end up counting from zero to the
size of the container, and if some spots don’t have key-value pairs, you’ll
automatically create them and miss some of the higher values of the keys.
Finally, if you look at the output from the <b>for</b> loop, you’ll see that
things are <i>very</i> busy, and it’s quite puzzling at first why there are so
many constructions and destructions for what appears to be a simple lookup. The
answer only becomes clear when you look at the code in the <b>map</b> template
for <b>operator[ ]</b>, which will be something like this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1242"
title="Add Comment A1242"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>mapped_type&amp; operator[] (const
key_type&amp; k) {</p>

<p class=CodeChar style='margin-left:0in'>  value_type tmp(k,T()); </p>

<p class=CodeChar style='margin-left:0in'>  return
(*((insert(tmp)).first)).second;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>map::insert(&nbsp;)</b> function takes a key-value
pair and does nothing if there is already an entry in the map with the given
key—otherwise it inserts an entry for the key. In either case, it returns a new
key-value pair holding an iterator to the inserted pair as its first element
and holding true as the second element if an insertion actually took place. The
members <b>first</b> and <b>second</b> give the key and value, respectively,
because <b>map::value_type</b> is really just a <b>typedef</b> for a <b>std::pair</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1243"
title="Add Comment A1243"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typedef pair&lt;const Key,
T&gt; value_type;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We’ve seen the <b>std::pair</b> template before, which just
holds two values of independent types, as you can see by its definition:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1244"
title="Add Comment A1244"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template &lt;class T1, class T2&gt;</p>

<p class=CodeChar style='margin-left:0in'>struct pair { </p>

<p class=CodeChar style='margin-left:0in'>  typedef T1 first_type; </p>

<p class=CodeChar style='margin-left:0in'>  typedef T2 second_type; </p>

<p class=CodeChar style='margin-left:0in'>  T1 first; </p>

<p class=CodeChar style='margin-left:0in'>  T2 second; </p>

<p class=CodeChar style='margin-left:0in'>  pair(); </p>

<p class=CodeChar style='margin-left:0in'>  pair(const T1&amp; x, const T2&amp;
y) </p>

<p class=CodeChar style='margin-left:0in'>    : first(x), second(y) {}</p>

<p class=CodeChar style='margin-left:0in'>  // Templatized copy-constructor:</p>

<p class=CodeChar style='margin-left:0in'>  template&lt;class U, class V&gt; </p>

<p class=CodeChar style='margin-left:0in'>   pair(const pair&lt;U, V&gt;
&amp;p);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>pair</b> template class is very useful, especially
when you want to return two objects from a function (since a <b>return</b>
statement only takes one object). There’s even a shorthand for creating a pair
called <b>make_pair(&nbsp;)</b>, which is used in <b>AssociativeBasics.cpp</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1245"
title="Add Comment A1245"><sup>Comment</sup></a></p>

<p class=MsoNormal>So to retrace the steps, <b>map::value_type</b> is a <b>pair</b>
of the key and the value of the map—actually, it’s a single entry for the map.
But notice that <b>pair</b> packages its objects by value, which means that
copy-constructions are necessary to get the objects into the <b>pair</b>. Thus,
the creation of <b>tmp</b> in <b>map::operator[ ]</b> will involve at least a
copy-constructor call and destructor call for each object in the <b>pair</b>.
Here, we’re getting off easy because the key is an <b>int</b>. But if you want
to really see what kind of activity can result from <b>map::operator[ ]</b>,
try running this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1246"
title="Add Comment A1246"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:NoisyMap.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Mapping Noisy to Noisy</p>

<p class=CodeChar style='margin-left:0in'>//{L} ../TestSuite/Test</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Noisy.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  map&lt;Noisy, Noisy&gt; mnn;</p>

<p class=CodeChar style='margin-left:0in'>  Noisy n1, n2;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n--------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  mnn[n1] = n2;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n--------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; mnn[n1] &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;\n--------\n&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You’ll see that both the insertion and lookup generate a lot
of extra objects, and that’s because of the creation of the <b>tmp</b> object.
If you look back up at <b>map::operator[ ],</b> you’ll see that the second line
calls <b>insert(&nbsp;),</b> passing it <b>tmp</b>—that is, <b>operator[ ]</b>
does an insertion every time. The return value of <b>insert(&nbsp;)</b> is a
different kind of <b>pair</b>, in which <b>first</b> is an iterator pointing to
the key-value <b>pair</b> that was just inserted, and <b>second</b> is a <b>bool</b>
indicating whether the insertion took place. You can see that <b>operator[ ]</b>
grabs <b>first</b> (the iterator), dereferences it to produce the <b>pair</b>,
and then returns the <b>second,</b> which is the value at that location. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1247"
title="Add Comment A1247"><sup>Comment</sup></a></p>

<p class=MsoNormal>So on the upside, <b>map</b> has this fancy “make a new
entry if one isn’t there” behavior, but the downside is that you <i>always</i>
get a lot of extra object creations and destructions when you use <b>map::operator[
]</b>. Fortunately, <b>AssociativeBasics.cpp</b> also demonstrates how to reduce
the overhead of insertions and deletions, by not using <b>operator[ ]</b> if
you don’t have to. The <b>insert(&nbsp;)</b> member function is slightly more
efficient than <b>operator[ ]</b>. With a <b>set,</b> you hold only one object,
but with a <b>map,</b> you hold key-value pairs; so <b>insert(&nbsp;)</b>
requires a <b>pair</b> as its argument. Here’s where <b>make_pair(&nbsp;)</b>
comes in handy, as you can see.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1248"
title="Add Comment A1248"><sup>Comment</sup></a></p>

<p class=MsoNormal>For looking objects up in a <b>map</b>, you can use <b>count(&nbsp;)</b>
to see whether a key is in the map, or you can use <b>find(&nbsp;)</b> to
produce an iterator pointing directly at the key-value pair. Again, since the <b>map</b>
contains <b>pair</b>s, that’s what the iterator produces when you dereference
it; so you have to select <b>first</b> and <b>second</b>. When you run <b>AssociativeBasics.cpp,</b>
you’ll notice that the iterator approach involves no extra object creations or
destructions at all. It’s not as easy to write or read, though.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1249"
title="Add Comment A1249"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440131">Generators and fillers<br>
for associative containers</a></h3>

<p class=MsoNormal>You’ve seen how useful the <b>fill(&nbsp;)</b>, <b>fill_n(&nbsp;)</b>,
<b>generate(&nbsp;),</b> and <b>generate_n(&nbsp;)</b> function templates in <b>&lt;algorithm&gt;</b>
have been for filling the sequential containers (<b>vector</b>, <b>list,</b>
and <b>deque</b>) with data. However, these are implemented by using <b>operator=
</b>to assign values into the sequential containers, and the way that you add
objects to associative containers is with their respective <b>insert(&nbsp;)</b>
member functions. Thus, the default “assignment” behavior causes a problem when
trying to use the “fill” and “generate” functions with associative containers.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1252"
title="Add Comment A1252"><sup>Comment</sup></a></p>

<p class=MsoNormal>One solution is to duplicate the “fill” and “generate”
functions, creating new ones that can be used with associative containers. It
turns out that only the <b>fill_n(&nbsp;)</b> and <b>generate_n(&nbsp;)</b>
functions can be duplicated (<b>fill(&nbsp;) </b>and <b>generate(&nbsp;) </b>copy
in between two iterators, which doesn’t make sense with associative
containers), but the job is fairly easy, since you have the <b>&lt;algorithm&gt;</b>
header file to work from (and since it contains templates, all the source code
is there):<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1253"
title="Add Comment A1253"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:assocGen.h</p>

<p class=CodeChar style='margin-left:0in'>// The fill_n() and generate_n()
equivalents </p>

<p class=CodeChar style='margin-left:0in'>// for associative containers.</p>

<p class=CodeChar style='margin-left:0in'>#ifndef ASSOCGEN_H</p>

<p class=CodeChar style='margin-left:0in'>#define ASSOCGEN_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Assoc, class Count,
class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void </p>

<p class=CodeChar style='margin-left:0in'>assocFill_n(Assoc&amp; a, Count n,
const T&amp; val) {</p>

<p class=CodeChar style='margin-left:0in'>  while(n-- &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>    a.insert(val);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Assoc, class Count,
class Gen&gt;</p>

<p class=CodeChar style='margin-left:0in'>void assocGen_n(Assoc&amp; a, Count
n, Gen g) {</p>

<p class=CodeChar style='margin-left:0in'>  while(n-- &gt; 0)</p>

<p class=CodeChar style='margin-left:0in'>    a.insert(g());</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // ASSOCGEN_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that instead of using iterators, the container
class itself is passed (by reference, of course, since you wouldn’t want to
make a local copy, fill it, and then have it discarded at the end of the
scope).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1254"
title="Add Comment A1254"><sup>Comment</sup></a></p>

<p class=MsoNormal>This code demonstrates two valuable lessons. The first is
that if the algorithms don’t do what you want, copy the nearest thing and
modify it. You have the example at hand in the STL header, so most of the work
has already been done.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1255"
title="Add Comment A1255"><sup>Comment</sup></a></p>

<p class=MsoNormal>The second lesson is more pointed: if you look long enough,
there’s probably a way to do it in the STL <i>without</i> inventing anything
new. The present problem can instead be solved by using an <b>insert_iterator</b>
(produced by a call to <b>inserter(&nbsp;)</b>), which calls <b>insert(&nbsp;)</b>
to place items in the container instead of <b>operator=</b>. This is <i>not</i>
simply a variation of <b>front_insert_iterator</b> or <b>back_insert_iterator</b>,
because those iterators use <b>push_front(&nbsp;)</b> and <b>push_back(&nbsp;)</b>,
respectively. Each of the insert iterators is different by virtue of the member
function it uses for insertion, and <b>insert(&nbsp;)</b> is the one we need.
Here’s a demonstration that shows filling and generating both a <b>map</b> and
a <b>set.</b> (Of course, it can also be used with <b>multimap</b> and <b>multiset.</b>)
First, some templatized, simple generators are created. (This may seem like
overkill, but you never know when you’ll need them; for that reason they’re
placed in a header file.)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1256"
title="Add Comment A1256"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:SimpleGenerators.h</p>

<p class=CodeChar style='margin-left:0in'>// Generic generators, including</p>

<p class=CodeChar style='margin-left:0in'>// one that creates pairs</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;utility&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A generator that increments its
value:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class IncrGen {</p>

<p class=CodeChar style='margin-left:0in'>  T i;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  IncrGen(T ii) : i (ii) {}</p>

<p class=CodeChar style='margin-left:0in'>  T operator()() { return i++; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A generator that produces an STL
pair&lt;&gt;:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename T1, typename
T2&gt;</p>

<p class=CodeChar style='margin-left:0in'>class PairGen {</p>

<p class=CodeChar style='margin-left:0in'>  T1 i;</p>

<p class=CodeChar style='margin-left:0in'>  T2 j;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  PairGen(T1 ii, T2 jj) : i(ii),
j(jj) {}</p>

<p class=CodeChar style='margin-left:0in'>  std::pair&lt;T1,T2&gt; operator()()
{ </p>

<p class=CodeChar style='margin-left:0in'>    return
std::pair&lt;T1,T2&gt;(i++, j++); </p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>namespace std {</p>

<p class=CodeChar style='margin-left:0in'>// A generic global operator&lt;&lt; </p>

<p class=CodeChar style='margin-left:0in'>// for printing any STL pair&lt;&gt;:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;typename F, typename
S&gt; ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(ostream&amp; os,
const pair&lt;F,S&gt;&amp; p) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt; p.first &lt;&lt;
&quot;\t&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; p.second &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Both generators expect that <b>T</b> can be incremented, and
they simply use <b>operator++</b> to generate new values from whatever you used
for initialization. <b>PairGen</b> creates an STL <b>pair</b> object as its
return value, and that’s what can be placed into a <b>map</b> or <b>multimap</b>
using <b>insert(&nbsp;)</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1257"
title="Add Comment A1257"><sup>Comment</sup></a></p>

<p class=MsoNormal>The last function is a generalization of <b>operator&lt;&lt;</b>
for <b>ostream</b>s, so that any <b>pair</b> can be printed, assuming each
element of the <b>pair </b>supports a stream <b>operator&lt;&lt;</b>. (It is in
namespace <b>std</b> for the strange name lookup reasons discussed in Chapter
5.) As you can see in the following, this allows the use of <b>copy(&nbsp;)</b>
to output the <b>map</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1258"
title="Add Comment A1258"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:AssocInserter.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Using an insert_iterator so
fill_n() and</p>

<p class=CodeChar style='margin-left:0in'>// generate_n() can be used with
associative </p>

<p class=CodeChar style='margin-left:0in'>// containers</p>

<p class=CodeChar style='margin-left:0in'>#include
&quot;SimpleGenerators.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;int&gt; s;</p>

<p class=CodeChar style='margin-left:0in'>  fill_n(inserter(s, s.begin()), 10,
47);</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(inserter(s, s.begin()),
10, </p>

<p class=CodeChar style='margin-left:0in'>    IncrGen&lt;int&gt;(12));</p>

<p class=CodeChar style='margin-left:0in'>  copy(s.begin(), s.end(), </p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;int&gt;(cout,
&quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  </p>

<p class=CodeChar style='margin-left:0in'>  map&lt;int, int&gt; m;</p>

<p class=CodeChar style='margin-left:0in'>  fill_n(inserter(m, m.begin()), 10, </p>

<p class=CodeChar style='margin-left:0in'>    make_pair(90,120));</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(inserter(m, m.begin()),
10, </p>

<p class=CodeChar style='margin-left:0in'>    PairGen&lt;int, int&gt;(3, 9));</p>

<p class=CodeChar style='margin-left:0in'>  copy(m.begin(), m.end(), </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;pair&lt;int,int&gt; &gt;(cout,&quot;\n&quot;));</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The second argument to <b>inserter</b> is an iterator, which
is an optimization hint to help the insertion go faster (instead of always
starting the search at the root of the underlying tree). Since an <b>insert_iterator</b>
can be used with many different types of containers, with non-associative
containers it is more than a hint—it is required. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1259"
title="Add Comment A1259"><sup>Comment</sup></a></p>

<p class=MsoNormal>Note how the <b>ostream_iterator</b> is created to output a <b>pair</b>;
this wouldn’t have worked if the <b>operator&lt;&lt;</b> hadn’t been created,
and since it’s a template, it is automatically instantiated for <b>pair&lt;int,
int&gt;</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1260"
title="Add Comment A1260"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440132">The magic of maps</a></h3>

<p class=MsoNormal>An ordinary array uses an integral value to index into a
sequential set of elements of some type. A <b>map</b> is an <i>associative
array</i>, which means you associate one object with another in an array-like
fashion, but instead of selecting an array element with a number as you do with
an ordinary array, you look it up with an object! The example that follows
counts the words in a text file, so the index is the <b>string</b> object
representing the word, and the value being looked up is the object that keeps
count of the strings.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1261"
title="Add Comment A1261"><sup>Comment</sup></a></p>

<p class=MsoNormal>In a single-item container such as a <b>vector</b> or a <b>list</b>,
only one thing is being held. But in a <b>map</b>, you’ve got two things: the <i>key</i>
(what you look up by, as in <b>mapname[key]</b>) and the <i>value</i> that
results from the lookup with the key. If you simply want to move through the
entire <b>map</b> and list each key-value pair, you use an iterator, which when
dereferenced produces a <b>pair</b> object containing both the key and the
value. You access the members of a <b>pair</b> by selecting <b>first</b> or <b>second</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1262"
title="Add Comment A1262"><sup>Comment</sup></a></p>

<p class=MsoNormal>This same philosophy of packaging two items together is also
used to insert elements into the map, but the <b>pair</b> is created as part of
the instantiated <b>map</b> and is called <b>value_type</b>, containing the key
and the value. So one option for inserting a new element is to create a <b>value_type</b>
object, loading it with the appropriate objects and then calling the <b>insert(&nbsp;)</b>
member function for the <b>map</b>. Instead, the following example uses the
aforementioned special feature of <b>map</b>: if you’re trying to find an
object by passing in a key to <b>operator[ ]</b> and that object doesn’t exist,
<b>operator[ ]</b> will automatically insert a new key-value pair for you,
using the default constructor for the value object. With that in mind, consider
an implementation of a word-counting program:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1263"
title="Add Comment A1263"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:WordCount.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Count occurrences of words using a
map</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef map&lt;string, int&gt;
WordMap;</p>

<p class=CodeChar style='margin-left:0in'>typedef WordMap::iterator WMIter;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;WordCount.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  WordMap wordmap;</p>

<p class=CodeChar style='margin-left:0in'>  string word;</p>

<p class=CodeChar style='margin-left:0in'>  while(in &gt;&gt; word)</p>

<p class=CodeChar style='margin-left:0in'>    wordmap[word]++;</p>

<p class=CodeChar style='margin-left:0in'>  for(WMIter w = wordmap.begin(); w
!= wordmap.end(); w++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; w-&gt;first
&lt;&lt; &quot;: &quot;</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; w-&gt;second &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example shows the power of <i>zero-initialization</i>.
Consider this line of code from the program above: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1264"
title="Add Comment A1264"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>wordmap[word]++;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This increments the <b>int</b> associated with <b>word</b>.
If there isn’t such a word yet in the map, a key-value pair for the word is
automatically inserted, with the value initialized to zero by a call to the
pseudo-constructor <b>int(&nbsp;)</b>, which returns a 0. <sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1265"
title="Add Comment A1265"><sup>Comment</sup></a></p>

<p class=MsoNormal>Printing the entire list requires traversing it with an
iterator. (There’s no <b>copy(&nbsp;)</b> shortcut for a <b>map</b> unless you
want to write an <b>operator&lt;&lt; </b>for the <b>pair</b> in the map.) As
previously mentioned, dereferencing this iterator produces a <b>pair</b>
object, with the <b>first</b> member the key and the <b>second</b> member the
value. <sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1266"
title="Add Comment A1266"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you want to find the count for a particular word, you can
use the array index operator, like this:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1267"
title="Add Comment A1267"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>cout &lt;&lt; &quot;the:
&quot; &lt;&lt; wordmap[&quot;the&quot;] &lt;&lt; endl;</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that one of the great advantages of the <b>map</b>
is the clarity of the syntax; an associative array makes intuitive sense to the
reader. (Note, however, that if “the” isn’t already in the <b>wordmap,</b> a
new entry will be created!)<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1268"
title="Add Comment A1268"><sup>Comment</sup></a></p>

<h3><a name="_Toc312374082"></a><a name="_Toc45440133">Multimaps and duplicate
keys</a></h3>

<p class=MsoNormal>A <b>multimap</b> is a <b>map</b> that can contain duplicate
keys. At first this may seem like a strange idea, but it can occur surprisingly
often. A phone book, for example, can have many entries with the same name. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1277"
title="Add Comment A1277"><sup>Comment</sup></a></p>

<p class=MsoNormal>Suppose you are monitoring wildlife, and you want to keep
track of where and when each type of animal is spotted. Thus, you may see many
animals of the same kind, all in different locations and at different times. So
if the type of animal is the key, you’ll need a <b>multimap</b>. Here’s what it
looks like:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1278"
title="Add Comment A1278"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:WildLifeMonitor.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DataPoint {</p>

<p class=CodeChar style='margin-left:0in'>  int x, y; // Location coordinates</p>

<p class=CodeChar style='margin-left:0in'>  time_t time; // Time of Sighting</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  DataPoint() : x(0), y(0), time(0)
{}</p>

<p class=CodeChar style='margin-left:0in'>  DataPoint(int xx, int yy, time_t
tm) :</p>

<p class=CodeChar style='margin-left:0in'>    x(xx), y(yy), time(tm) {}</p>

<p class=CodeChar style='margin-left:0in'>  // Synthesized operator=,
copy-constructor OK</p>

<p class=CodeChar style='margin-left:0in'>  int getX() const { return x; }</p>

<p class=CodeChar style='margin-left:0in'>  int getY() const { return y; }</p>

<p class=CodeChar style='margin-left:0in'>  const time_t* getTime() const {
return &amp;time; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>string animal[] = { </p>

<p class=CodeChar style='margin-left:0in'>  &quot;chipmunk&quot;,
&quot;beaver&quot;, &quot;marmot&quot;, &quot;weasel&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;squirrel&quot;,
&quot;ptarmigan&quot;, &quot;bear&quot;, &quot;eagle&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;hawk&quot;, &quot;vole&quot;,
&quot;deer&quot;, &quot;otter&quot;, &quot;hummingbird&quot;,</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>const int asz = sizeof animal/sizeof
*animal;</p>

<p class=CodeChar style='margin-left:0in'>vector&lt;string&gt; animals(animal,
animal + asz);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// All the information is contained
in a </p>

<p class=CodeChar style='margin-left:0in'>// &quot;Sighting,&quot; which can be
sent to an ostream:</p>

<p class=CodeChar style='margin-left:0in'>typedef pair&lt;string, DataPoint&gt;
Sighting;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(ostream&amp; os,
const Sighting&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt; s.first &lt;&lt;
&quot; sighted at x= &quot; &lt;&lt; </p>

<p class=CodeChar style='margin-left:0in'>    s.second.getX() &lt;&lt; &quot;,
y= &quot; &lt;&lt; s.second.getY()</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot;, time = &quot;
&lt;&lt; ctime(s.second.getTime());</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A generator for Sightings:</p>

<p class=CodeChar style='margin-left:0in'>class SightingGen {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;string&gt;&amp; animals;</p>

<p class=CodeChar style='margin-left:0in'>  enum { d = 100 };</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'> 
SightingGen(vector&lt;string&gt;&amp; an) :</p>

<p class=CodeChar style='margin-left:0in'>    animals(an) { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  Sighting operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    Sighting result;</p>

<p class=CodeChar style='margin-left:0in'>    int select = rand() %
animals.size();</p>

<p class=CodeChar style='margin-left:0in'>    result.first = animals[select];</p>

<p class=CodeChar style='margin-left:0in'>    result.second = DataPoint(</p>

<p class=CodeChar style='margin-left:0in'>      rand() % d, rand() % d,
time(0));</p>

<p class=CodeChar style='margin-left:0in'>    return result;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Display a menu of animals, allow
the user to</p>

<p class=CodeChar style='margin-left:0in'>// select one, return the index
value:</p>

<p class=CodeChar style='margin-left:0in'>int menu() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;select an
animal or 'q' to quit: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt;
animals.size(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;'['&lt;&lt; i
&lt;&lt;']'&lt;&lt; animals[i] &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  string reply;</p>

<p class=CodeChar style='margin-left:0in'>  cin &gt;&gt; reply;</p>

<p class=CodeChar style='margin-left:0in'>  if(reply.at(0) == 'q') return 0;</p>

<p class=CodeChar style='margin-left:0in'>  istringstream r(reply);</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>  r &gt;&gt; i; // Converts to int</p>

<p class=CodeChar style='margin-left:0in'>  i %= animals.size();</p>

<p class=CodeChar style='margin-left:0in'>  return i;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef multimap&lt;string,
DataPoint&gt; DataMap;</p>

<p class=CodeChar style='margin-left:0in'>typedef DataMap::iterator DMIter;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  DataMap sightings;</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(</p>

<p class=CodeChar style='margin-left:0in'>    inserter(sightings, sightings.begin()),</p>

<p class=CodeChar style='margin-left:0in'>    50, SightingGen(animals));</p>

<p class=CodeChar style='margin-left:0in'>  // Print everything:</p>

<p class=CodeChar style='margin-left:0in'>  copy(sightings.begin(),
sightings.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;Sighting&gt;(cout, &quot;&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  // Print sightings for selected
animal:</p>

<p class=CodeChar style='margin-left:0in'>  for(int count = 1; count &lt; 10;
count++) {</p>

<p class=CodeChar style='margin-left:0in'>    // Use menu to get selection:</p>

<p class=CodeChar style='margin-left:0in'>    // int i = menu();</p>

<p class=CodeChar style='margin-left:0in'>    // Generate randomly (for
automated testing):</p>

<p class=CodeChar style='margin-left:0in'>    int i = rand() % animals.size();</p>

<p class=CodeChar style='margin-left:0in'>    // Iterators in &quot;range&quot;
denote begin, one </p>

<p class=CodeChar style='margin-left:0in'>    // past end of matching range:</p>

<p class=CodeChar style='margin-left:0in'>    pair&lt;DMIter, DMIter&gt; range
= </p>

<p class=CodeChar style='margin-left:0in'>      sightings.equal_range(animals[i]);</p>

<p class=CodeChar style='margin-left:0in'>    copy(range.first, range.second,</p>

<p class=CodeChar style='margin-left:0in'>     
ostream_iterator&lt;Sighting&gt;(cout, &quot;&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>All the data about a sighting is encapsulated into the class
<b>DataPoint</b>, which is simple enough that it can rely on the synthesized assignment
and copy-constructor. It uses the Standard C library time functions to record
the time of the sighting.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1279"
title="Add Comment A1279"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the array of <b>string</b> <b>animal</b>, notice that the
<b>char*</b> constructor is automatically used during initialization, which
makes initializing an array of <b>string</b> quite convenient. Since it’s
easier to use the animal names in a <b>vector</b>, the length of the array is
calculated, and a <b>vector&lt;string&gt;</b> is initialized using the <b>vector(iterator,
iterator)</b> constructor.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1280"
title="Add Comment A1280"><sup>Comment</sup></a></p>

<p class=MsoNormal>The key-value pairs that make up a <b>Sighting</b> are the <b>string,</b>
which names the type of animal, and the <b>DataPoint,</b> which says where and
when it was sighted. The standard <b>pair</b> template combines these two types
and is typedefed to produce the <b>Sighting</b> type. Then an <b>ostream</b> <b>operator&lt;&lt;</b>
is created for <b>Sighting</b>; this will allow you to iterate through a <b>map</b>
or <b>multimap</b> of <b>Sighting</b>s<b> </b>and print it out.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1281"
title="Add Comment A1281"><sup>Comment</sup></a></p>

<p class=MsoNormal><b>SightingGen</b> generates random sightings at random data
points to use for testing. It has the usual <b>operator(&nbsp;)</b> necessary
for a function object, but it also has a constructor to capture and store a
reference to a <b>vector&lt;string&gt;</b>, which is where the aforementioned
animal names are stored.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1282"
title="Add Comment A1282"><sup>Comment</sup></a></p>

<p class=MsoNormal>A <b>DataMap</b> is a <b>multimap</b> of <b>string</b>-<b>DataPoint</b>
pairs, which means it stores <b>Sighting</b>s. It is filled with 50 <b>Sighting</b>s
using <b>generate_n(&nbsp;)</b> and printed out. (Notice that because there is
an <b>operator&lt;&lt;</b> that takes a <b>Sighting</b>, an <b>ostream_iterator</b>
can be created.) At this point the user is asked to select the animal for which
they want to see all the sightings . If you press <b>q,</b> the program will
quit, but if you select an animal number, the <b>equal_range(&nbsp;)</b> member
function is invoked. This returns an iterator (<b>DMIter</b>) to the beginning
of the set of matching pairs and an iterator indicating past-the-end of the
set. Since only one object can be returned from a function, <b>equal_range(&nbsp;)</b>
makes use of <b>pair</b>. Since the <b>range</b> pair has the beginning and
ending iterators of the matching set, those iterators can be used in <b>copy(&nbsp;)</b>
to print out all the sightings for a particular type of animal.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1283"
title="Add Comment A1283"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440134">Multisets</a></h3>

<p class=MsoNormal>You’ve seen the <b>set</b>, which allows only one object of
each value to be inserted. The <b>multiset</b> is odd by comparison since it
allows more than one object of each value to be inserted. This seems to go
against the whole idea of “setness,” in which you can ask, “Is ‘it’ in this
set?” If there can be more than one “it,” what does that question mean?<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1284"
title="Add Comment A1284"><sup>Comment</sup></a></p>

<p class=MsoNormal>With some thought, you can see that it makes little sense to
have more than one object of the same value in a set if those duplicate objects
are <i>exactly</i> the same (with the possible exception of counting
occurrences of objects, but as seen earlier in this chapter that can be handled
in an alternative, more elegant fashion). Thus, each duplicate object will have
something that makes it “different” from the other duplicates—most likely
different state information that is not used in the calculation of the key
during the comparison. That is, to the comparison operation, the objects look
the same, but they actually contain some differing internal state.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1285"
title="Add Comment A1285"><sup>Comment</sup></a></p>

<p class=MsoNormal>Like any STL container that must order its elements, the <b>multiset</b>
template uses the <b>less</b> template by default to determine element
ordering. This uses the contained classes’ <b>operator&lt;</b>, but you can of
course substitute your own comparison function.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1286"
title="Add Comment A1286"><sup>Comment</sup></a></p>

<p class=MsoNormal>Consider a simple class that contains one element that is
used in the comparison and another that is not:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1287"
title="Add Comment A1287"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:MultiSet1.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstration of multiset behavior</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class X {</p>

<p class=CodeChar style='margin-left:0in'>  char c; // Used in comparison</p>

<p class=CodeChar style='margin-left:0in'>  int i; // Not used in comparison</p>

<p class=CodeChar style='margin-left:0in'>  // Don't need default constructor
and operator=</p>

<p class=CodeChar style='margin-left:0in'>  X();</p>

<p class=CodeChar style='margin-left:0in'>  X&amp; operator=(const X&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  // Usually need a copy-constructor
(but the</p>

<p class=CodeChar style='margin-left:0in'>  // synthesized version works here)</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>X(char cc, int ii) :
c(cc), i(ii) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>// Notice no
operator== is required</p>

<p class=CodeChar style='margin-left:0in'>  friend bool operator&lt;(const
X&amp; x, const X&amp; y) {</p>

<p class=CodeChar style='margin-left:0in'>    return x.c &lt; y.c;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;
operator&lt;&lt;(ostream&amp; os, X x) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; x.c &lt;&lt;
&quot;:&quot; &lt;&lt; x.i;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Xgen {</p>

<p class=CodeChar style='margin-left:0in'>  static int i;</p>

<p class=CodeChar style='margin-left:0in'>  // Number of characters to select
from:</p>

<p class=CodeChar style='margin-left:0in'>  enum { span = 6 };</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Xgen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  X operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    char c = 'A' + rand() % span;    </p>

<p class=CodeChar style='margin-left:0in'>    return X(c, i++);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int Xgen::i = 0;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef multiset&lt;X&gt; Xmset;</p>

<p class=CodeChar style='margin-left:0in'>typedef Xmset::const_iterator Xmit;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Xmset mset;</p>

<p class=CodeChar style='margin-left:0in'>  // Fill it with X's:</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(inserter(mset,
mset.begin()), </p>

<p class=CodeChar style='margin-left:0in'>    25, Xgen());</p>

<p class=CodeChar style='margin-left:0in'>  // Initialize a regular set from
mset:</p>

<p class=CodeChar style='margin-left:0in'>  set&lt;X&gt; unique(mset.begin(),
mset.end());</p>

<p class=CodeChar style='margin-left:0in'>  copy(unique.begin(), unique.end(), </p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;X&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;\n----\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Iterate over the unique values:</p>

<p class=CodeChar style='margin-left:0in'>  for(set&lt;X&gt;::iterator i =
unique.begin();</p>

<p class=CodeChar style='margin-left:0in'>      i != unique.end(); i++) {</p>

<p class=CodeChar style='margin-left:0in'>    pair&lt;Xmit, Xmit&gt; p =
mset.equal_range(*i);</p>

<p class=CodeChar style='margin-left:0in'>    copy(p.first, p.second, </p>

<p class=CodeChar style='margin-left:0in'>      ostream_iterator&lt;X&gt;(cout,
&quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In <b>X</b>, all the comparisons are made with the <b>char c</b>.
The comparison is performed with <b>operator&lt;</b>, which is all that is
necessary for the <b>multiset</b>, since in this example the default <b>less</b>
comparison object is used. The class <b>Xgen</b> is used to randomly generate <b>X</b>
objects, but the comparison value is restricted to the span from <b>‘A</b>’ to
‘<b>E</b>’. In <b>main(&nbsp;)</b>, a <b>multiset&lt;X&gt;</b> is created and
filled with 25 <b>X</b> objects using <b>Xgen</b>, guaranteeing that there will
be duplicate keys. So that we know what the unique values are, a regular <b>set&lt;X&gt;</b>
is created from the <b>multiset</b> (using the <b>iterator, iterator</b>
constructor). These values are displayed, and then each one is used to produce
the <b>equal_range(&nbsp;)</b> in the <b>multiset</b> (<b>equal_range(&nbsp;)</b>
has the same meaning here as it does with <b>multimap</b>: all the elements
with matching keys). Each set of matching keys is then printed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1288"
title="Add Comment A1288"><sup>Comment</sup></a></p>

<p class=MsoNormal>As a second example, a (possibly) more elegant version of <b>WordCount.cpp</b>
can be created using <b>multiset</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1289"
title="Add Comment A1289"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:MultiSetWordCount.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Count occurrences of words using a
multiset</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../require.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(int argc, char* argv[]) {</p>

<p class=CodeChar style='margin-left:0in'>  char* fname =
&quot;MultiSetWordCount.cpp&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  if(argc &gt; 1) fname = argv[1];</p>

<p class=CodeChar style='margin-left:0in'>  ifstream in(fname);</p>

<p class=CodeChar style='margin-left:0in'>  assure(in, fname);</p>

<p class=CodeChar style='margin-left:0in'>  multiset&lt;string&gt; wordmset;</p>

<p class=CodeChar style='margin-left:0in'>  string word;</p>

<p class=CodeChar style='margin-left:0in'>  while(in &gt;&gt; word)</p>

<p class=CodeChar style='margin-left:0in'>    wordmset.insert(word);</p>

<p class=CodeChar style='margin-left:0in'>  typedef
multiset&lt;string&gt;::iterator MSit;</p>

<p class=CodeChar style='margin-left:0in'>  MSit it = wordmset.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while(it != wordmset.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    pair&lt;MSit, MSit&gt;
p=wordmset.equal_range(*it);</p>

<p class=CodeChar style='margin-left:0in'>    int count = distance(p.first,
p.second);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it &lt;&lt;
&quot;: &quot; &lt;&lt; count &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    it = p.second; // Move to the
next word</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The setup in <b>main(&nbsp;)</b> is identical to <b>WordCount.cpp</b>,
but then each word is simply inserted into the <b>multiset&lt;string&gt;</b>.
An iterator is created and initialized to the beginning of the <b>multiset</b>;
dereferencing this iterator produces the current word. The <b>equal_range(&nbsp;)</b>
member function (not generic algorithm) produces the starting and ending
iterators of the word that’s currently selected, and the algorithm <b>distance(&nbsp;)</b>
(defined in <b>&lt;iterator&gt;</b>) is used to count the number of elements in
that range. The iterator <b>it </b>is then moved forward to the end of the
range, which puts it at the next word. If you’re unfamiliar with the <b>multiset,</b>
this code can seem more complex. The density of it and the lack of need for
supporting classes such as <b>Count</b> has a lot of appeal.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1290"
title="Add Comment A1290"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the end, is this really a “set,” or should it be called
something else? An alternative is the generic “bag” that has been defined in
some container libraries, since a bag holds anything at all without
discrimination—including duplicate objects. This is close, but it doesn’t quite
fit since a bag has no specification about how elements should be ordered. A <b>multiset</b>
(which requires that all duplicate elements be adjacent to each other) is even
more restrictive than the concept of a set, which could use a hashing function
to order its elements, in which case they would not be in sorted order.
Besides, if you wanted to store a bunch of objects without any special
criteria, you’d probably just use a <b>vector</b>, <b>deque,</b> or <b>list</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1291"
title="Add Comment A1291"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440135">Combining STL containers</a></h2>

<p class=MsoNormal>When using a thesaurus, you want to know all the words that
are similar to a particular word. When you look up a word, then, you want a
list of words as the result. Here, the “multi” containers (<b>multimap</b> or <b>multiset</b>)
are not appropriate. The solution is to combine containers, which is easily
done using the STL. Here, we need a tool that turns out to be a powerful
general concept, which is a <b>map</b> of <b>vector</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1292"
title="Add Comment A1292"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Thesaurus.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A map of vectors</p>

<p class=CodeChar style='margin-left:0in'>//{-msc}</p>

<p class=CodeChar style='margin-left:0in'>//{-g++}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef map&lt;string,
vector&lt;string&gt; &gt; Thesaurus;</p>

<p class=CodeChar style='margin-left:0in'>typedef pair&lt;string,
vector&lt;string&gt; &gt; TEntry;</p>

<p class=CodeChar style='margin-left:0in'>typedef Thesaurus::iterator TIter;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp; operator&lt;&lt;(ostream&amp;
os,const TEntry&amp; t){</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; t.first &lt;&lt;
&quot;: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  copy(t.second.begin(),
t.second.end(),</p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;string&gt;(os, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>  return os;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// A generator for thesaurus test
entries:</p>

<p class=CodeChar style='margin-left:0in'>class ThesaurusGen {</p>

<p class=CodeChar style='margin-left:0in'>  static const string letters;</p>

<p class=CodeChar style='margin-left:0in'>  static int count;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  int maxSize() { return
letters.size(); }</p>

<p class=CodeChar style='margin-left:0in'>  ThesaurusGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  TEntry operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    TEntry result;</p>

<p class=CodeChar style='margin-left:0in'>    if(count &gt;= maxSize()) count =
0;</p>

<p class=CodeChar style='margin-left:0in'>    result.first = letters[count++];</p>

<p class=CodeChar style='margin-left:0in'>    int entries = (rand() % 5) + 2;</p>

<p class=CodeChar style='margin-left:0in'>    for(int i = 0; i &lt; entries;
i++) {</p>

<p class=CodeChar style='margin-left:0in'>      int choice = rand() %
maxSize();</p>

<p class=CodeChar style='margin-left:0in'>      char cbuf[2] = { 0 };</p>

<p class=CodeChar style='margin-left:0in'>      cbuf[0] = letters[choice];</p>

<p class=CodeChar style='margin-left:0in'>      result.second.push_back(cbuf);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    return result;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int ThesaurusGen::count = 0;</p>

<p class=CodeChar style='margin-left:0in'>const string ThesaurusGen::letters(&quot;ABCDEFGHIJKL&quot;</p>

<p class=CodeChar style='margin-left:0in'> 
&quot;MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Ask for a &quot;word&quot; to look
up:</p>

<p class=CodeChar style='margin-left:0in'>string menu(Thesaurus&amp; thesaurus)
{</p>

<p class=CodeChar style='margin-left:0in'>  while(true) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Select a
\&quot;word\&quot;, 0 to quit: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    for(TIter it = thesaurus.begin();
</p>

<p class=CodeChar style='margin-left:0in'>      it != thesaurus.end(); it++)</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; (*it).first
&lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    string reply;</p>

<p class=CodeChar style='margin-left:0in'>    cin &gt;&gt; reply;</p>

<p class=CodeChar style='margin-left:0in'>    if(reply.at(0) == '0') exit(0);
// Quit</p>

<p class=CodeChar style='margin-left:0in'>    if(thesaurus.find(reply) ==
thesaurus.end())</p>

<p class=CodeChar style='margin-left:0in'>      continue; // Not in list, try
again</p>

<p class=CodeChar style='margin-left:0in'>    return reply;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Thesaurus thesaurus;</p>

<p class=CodeChar style='margin-left:0in'>  // Fill with 10 entries:</p>

<p class=CodeChar style='margin-left:0in'>  generate_n(</p>

<p class=CodeChar style='margin-left:0in'>    inserter(thesaurus,
thesaurus.begin()), </p>

<p class=CodeChar style='margin-left:0in'>    10, ThesaurusGen());</p>

<p class=CodeChar style='margin-left:0in'>  // Print everything:</p>

<p class=CodeChar style='margin-left:0in'>  copy(thesaurus.begin(),
thesaurus.end(),</p>

<p class=CodeChar style='margin-left:0in'>    ostream_iterator&lt;TEntry&gt;(cout,
&quot;\n&quot;));</p>

<p class=CodeChar style='margin-left:0in'>  // Create a list of the keys:</p>

<p class=CodeChar style='margin-left:0in'>  string keys[10];</p>

<p class=CodeChar style='margin-left:0in'>  int i = 0;</p>

<p class=CodeChar style='margin-left:0in'>  for(TIter it = thesaurus.begin(); </p>

<p class=CodeChar style='margin-left:0in'>    it != thesaurus.end(); it++)</p>

<p class=CodeChar style='margin-left:0in'>    keys[i++] = (*it).first;</p>

<p class=CodeChar style='margin-left:0in'>  for(int count = 0; count &lt; 10;
count++) {</p>

<p class=CodeChar style='margin-left:0in'>    // Enter from the console:</p>

<p class=CodeChar style='margin-left:0in'>    // string reply =
menu(thesaurus);</p>

<p class=CodeChar style='margin-left:0in'>    // Generate randomly</p>

<p class=CodeChar style='margin-left:0in'>    string reply = keys[rand() % 10];</p>

<p class=CodeChar style='margin-left:0in'>    vector&lt;string&gt;&amp; v =
thesaurus[reply];</p>

<p class=CodeChar style='margin-left:0in'>    copy(v.begin(), v.end(), </p>

<p class=CodeChar style='margin-left:0in'>     
ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>Thesaurus</b> maps a <b>string</b> (the word) to a <b>vector&lt;string&gt;</b>
(the synonyms). A <b>TEntry </b>is a single entry in a <b>Thesaurus</b>. By
creating an <b>ostream operator&lt;&lt;</b> for a <b>TEntry</b>, a single entry
from the <b>Thesaurus</b> can easily be printed (and the whole <b>Thesaurus</b>
can easily be printed with <b>copy(&nbsp;)</b>). The <b>ThesaurusGen</b>
creates “words” (which are just single letters) and “synonyms” for those words
(which are just other randomly chosen single letters) to be used as thesaurus
entries. It randomly chooses the number of synonym entries to make, but there
must be at least two. All the letters are chosen by indexing into a <b>static
string</b> that is part of <b>ThesaurusGen</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1293"
title="Add Comment A1293"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, a <b>Thesaurus</b> is created,
filled with 10 entries and printed using the <b>copy(&nbsp;)</b> algorithm. The
<b>menu( )</b> function asks the user to choose a “word” to look up by typing
the letter of that word. The <b>find(&nbsp;)</b> member function is used to
find whether the entry exists in the <b>map.</b> (Remember, you don’t want to
use <b>operator[ ],</b> which will automatically make a new entry if it doesn’t
find a match!) If so, <b>operator[ ]</b> is used to fetch out the <b>vector&lt;string&gt;</b>
that is displayed.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1294"
title="Add Comment A1294"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the previous code, the selection of the <b>reply</b>
string is generated randomly, to allow automated testing.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1295"
title="Add Comment A1295"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because templates make the expression of powerful concepts
easy, you can take this concept much further, creating a <b>map</b> of <b>vector</b>s
containing <b>map</b>s, and so on. For that matter, you can combine any of the
STL containers this way.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1296"
title="Add Comment A1296"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440136">Cleaning up <br>
containers of pointers</a></h2>

<p class=MsoNormal>In <b>Stlshape.cpp</b>, the pointers did not clean
themselves up automatically. It would be convenient to be able to do this
easily, rather than writing out the code each time. Here is a function template
that will clean up the pointers in any sequence container; note that it is
placed in the book’s root directory for easy access:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1297"
title="Add Comment A1297"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: :purge.h</p>

<p class=CodeChar style='margin-left:0in'>// Delete pointers in an STL sequence
container</p>

<p class=CodeChar style='margin-left:0in'>#ifndef PURGE_H</p>

<p class=CodeChar style='margin-left:0in'>#define PURGE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Seq&gt; void
purge(Seq&amp; c) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Seq::iterator i;</p>

<p class=CodeChar style='margin-left:0in'>  for(i = c.begin(); i != c.end();
++i) {</p>

<p class=CodeChar style='margin-left:0in'>    delete *i;</p>

<p class=CodeChar style='margin-left:0in'>    *i = 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Iterator version:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class InpIt&gt;</p>

<p class=CodeChar style='margin-left:0in'>void purge(InpIt begin, InpIt end) {</p>

<p class=CodeChar style='margin-left:0in'>  while(begin != end) {</p>

<p class=CodeChar style='margin-left:0in'>    delete *begin;</p>

<p class=CodeChar style='margin-left:0in'>    *begin = 0;</p>

<p class=CodeChar style='margin-left:0in'>    begin++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // PURGE_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In the first version of <b>purge(&nbsp;)</b>, note that <b>typename</b>
is absolutely necessary; indeed this is exactly the case that the keyword was
added for: <b>Seq</b> is a template argument, and <b>iterator</b> is something
that is nested within that template. So what does <b>Seq::iterator</b> refer
to? The <b>typename</b> keyword specifies that it refers to a type, and not
something else.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1298"
title="Add Comment A1298"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although the container version of <b>purge(&nbsp;)</b> must
work with an STL-style container, the iterator version of <b>purge(&nbsp;)</b>
will work with any range, including an array.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1299"
title="Add Comment A1299"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here is <b>Stlshape.cpp</b>, modified to use the <b>purge(&nbsp;)</b>
function:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1300"
title="Add Comment A1300"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Stlshape2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Stlshape.cpp with the purge()
function</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {};</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Circle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() { cout &lt;&lt;
&quot;~Circle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Triangle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Triangle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Triangle() { cout &lt;&lt;
&quot;~Triangle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Square::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() { cout &lt;&lt;
&quot;~Square\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>typedef std::vector&lt;Shape*&gt;
Container;</p>

<p class=CodeChar style='margin-left:0in'>typedef Container::iterator Iter;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Container shapes;</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Circle);</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Square);</p>

<p class=CodeChar style='margin-left:0in'>  shapes.push_back(new Triangle);</p>

<p class=CodeChar style='margin-left:0in'>  for(Iter i = shapes.begin();</p>

<p class=CodeChar style='margin-left:0in'>      i != shapes.end(); i++)</p>

<p class=CodeChar style='margin-left:0in'>    (*i)-&gt;draw();</p>

<p class=CodeChar style='margin-left:0in'>  purge(shapes);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When using <b>purge(&nbsp;)</b>, you must be careful to
consider ownership issues. If an object pointer is held in more than one
container, you must be sure not to delete it twice, and you don’t want to
destroy the object in the first container before the second one is finished
with it. Purging the same container twice is not a problem, because <b>purge(&nbsp;)</b>
sets the pointer to zero once it deletes that pointer, and calling <b>delete</b>
for a zero pointer is a safe operation.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1301"
title="Add Comment A1301"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440137">Creating your own containers</a></h2>

<p class=MsoNormal>With the STL as a foundation, you can create your own
containers. Assuming you follow the same model of providing iterators, your new
container will behave as if it were a built-in STL container.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1302"
title="Add Comment A1302"><sup>Comment</sup></a></p>

<p class=MsoNormal>Consider the “ring” data structure, which is a circular
sequence container. If you reach the end, it just wraps around to the
beginning. This can be implemented on top of a <b>list</b> as follows:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1303"
title="Add Comment A1303"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Ring.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Making a &quot;ring&quot; data
structure from the STL</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;list&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Ring {</p>

<p class=CodeChar style='margin-left:0in'>  list&lt;T&gt; lst;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // Declaration necessary so the
following </p>

<p class=CodeChar style='margin-left:0in'>  // 'friend' statement sees this
'iterator' </p>

<p class=CodeChar style='margin-left:0in'>  // instead of std::iterator:</p>

<p class=CodeChar style='margin-left:0in'>  class iterator;</p>

<p class=CodeChar style='margin-left:0in'>  friend class iterator;</p>

<p class=CodeChar style='margin-left:0in'>  class iterator : public
std::iterator&lt;</p>

<p class=CodeChar style='margin-left:0in'>   
std::bidirectional_iterator_tag,T,ptrdiff_t&gt;{</p>

<p class=CodeChar style='margin-left:0in'>    typename list&lt;T&gt;::iterator
it;</p>

<p class=CodeChar style='margin-left:0in'>    list&lt;T&gt;* r;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    iterator(list&lt;T&gt;&amp; lst,</p>

<p class=CodeChar style='margin-left:0in'>      const typename
list&lt;T&gt;::iterator&amp; i)</p>

<p class=CodeChar style='margin-left:0in'>      : r(&amp;lst), it(i) {}</p>

<p class=CodeChar style='margin-left:0in'>    bool operator==(const
iterator&amp; x) const {</p>

<p class=CodeChar style='margin-left:0in'>      return it == x.it;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    bool operator!=(const
iterator&amp; x) const {</p>

<p class=CodeChar style='margin-left:0in'>      return !(*this == x);</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    typename list&lt;T&gt;::reference
operator*() const {</p>

<p class=CodeChar style='margin-left:0in'>      return *it;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator&amp; operator++() {</p>

<p class=CodeChar style='margin-left:0in'>      ++it;</p>

<p class=CodeChar style='margin-left:0in'>      if(it == r-&gt;end())</p>

<p class=CodeChar style='margin-left:0in'>        it = r-&gt;begin();</p>

<p class=CodeChar style='margin-left:0in'>      return *this;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator operator++(int) {</p>

<p class=CodeChar style='margin-left:0in'>      iterator tmp = *this;</p>

<p class=CodeChar style='margin-left:0in'>      ++*this;</p>

<p class=CodeChar style='margin-left:0in'>      return tmp;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator&amp; operator--() {</p>

<p class=CodeChar style='margin-left:0in'>      if(it == r-&gt;begin())</p>

<p class=CodeChar style='margin-left:0in'>        it = r-&gt;end();</p>

<p class=CodeChar style='margin-left:0in'>      --it;</p>

<p class=CodeChar style='margin-left:0in'>      return *this;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator operator--(int) {</p>

<p class=CodeChar style='margin-left:0in'>      iterator tmp = *this;</p>

<p class=CodeChar style='margin-left:0in'>      --*this; </p>

<p class=CodeChar style='margin-left:0in'>      return tmp;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator insert(const T&amp; x){</p>

<p class=CodeChar style='margin-left:0in'>      return iterator(*r,
r-&gt;insert(it, x));</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    iterator erase() {</p>

<p class=CodeChar style='margin-left:0in'>      return iterator(*r,
r-&gt;erase(it));</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  void push_back(const T&amp; x) {</p>

<p class=CodeChar style='margin-left:0in'>    lst.push_back(x);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  iterator begin() {</p>

<p class=CodeChar style='margin-left:0in'>    return iterator(lst,
lst.begin());</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'> int size() { return lst.size(); }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Ring&lt;string&gt; rs;</p>

<p class=CodeChar style='margin-left:0in'>  rs.push_back(&quot;one&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  rs.push_back(&quot;two&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  rs.push_back(&quot;three&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  rs.push_back(&quot;four&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  rs.push_back(&quot;five&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Ring&lt;string&gt;::iterator it =
rs.begin();</p>

<p class=CodeChar style='margin-left:0in'>  it++; it++;</p>

<p class=CodeChar style='margin-left:0in'>  it.insert(&quot;six&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  it = rs.begin();</p>

<p class=CodeChar style='margin-left:0in'>  // Twice around the ring:</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; rs.size() *
2; i++)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; *it++ &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can see that most of the coding is in the iterator. The <b>Ring</b>
<b>iterator</b> must know how to loop back to the beginning, so it must keep a
reference to the <b>list </b>of<b> </b>its “parent” <b>Ring</b> object in order
to know if it’s at the end and how to get back to the beginning.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1304"
title="Add Comment A1304"><sup>Comment</sup></a></p>

<p class=MsoNormal>You’ll notice that the interface for <b>Ring</b> is quite
limited; in particular, there is no <b>end(&nbsp;)</b>, since a ring just keeps
looping. This means that you won’t be able to use a <b>Ring</b> in any STL
algorithms that require a past-the-end iterator, which is many of them. (It
turns out that adding this feature is a nontrivial exercise.) Although this can
seem limiting, consider <b>stack</b>, <b>queue,</b> and <b>priority_queue</b>,
which don’t produce any iterators at all!<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1305"
title="Add Comment A1305"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440138">STL extensions</a></h2>

<p class=MsoNormal>Although the STL containers may provide all the
functionality you’ll ever need, they are not complete. For example, the
standard implementations of <b>set</b> and <b>map</b> use trees, and although
these are reasonably fast, they may not be fast enough for your needs. In the
C++ Standards Committee it was generally agreed that hashed implementations of <b>set</b>
and <b>map</b> should have been included in Standard C++; however, there was
not enough time to add these components, and thus they were left out<a
href="#_ftn88" name="_ftnref88" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[88]</span></sup></span></span></sup></span></a>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1306"
title="Add Comment A1306"><sup>Comment</sup></a></p>

<p class=MsoNormal>Fortunately, alternatives are freely available. One of the
nice things about the STL is that it establishes a basic model for creating
STL-like classes, so anything built using the same model is easy to understand
if you are already familiar with the STL.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1307"
title="Add Comment A1307"><sup>Comment</sup></a></p>

<p class=MsoNormal>The SGI STL from Silicon Graphics<a href="#_ftn89"
name="_ftnref89" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[89]</span></sup></span></span></sup></span></a> is one of the most
robust implementations of the STL and can be used to replace your compiler’s
STL if that is found wanting. In addition, SGI has added a number of extensions
including <b>hash_set</b>, <b>hash_multiset</b>, <b>hash_map</b>, <b>hash_multimap</b>,
<b>slist</b> (a singly linked list), and <b>rope</b> (a variant of <b>string</b>
optimized for very large strings and fast concatenation and substring
operations).<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1308"
title="Add Comment A1308"><sup>Comment</sup></a></p>

<p class=MsoNormal>Let’s consider a performance comparison between a tree-based
<b>map</b> and the SGI <b>hash_map</b>. To keep things simple, the mappings
will be from <b>int</b> to <b>int</b>:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1309"
title="Add Comment A1309"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:MapVsHashMap.cpp</p>

<p class=CodeChar style='margin-left:0in'>// The hash_map header is not part of
the </p>

<p class=CodeChar style='margin-left:0in'>// Standard C++ STL. It is an
extension that </p>

<p class=CodeChar style='margin-left:0in'>// is only available as part of the
SGI STL</p>

<p class=CodeChar style='margin-left:0in'>// (Included with the g++
distribution)</p>

<p class=CodeChar style='margin-left:0in'>//{-bor} You can add the header by
hand</p>

<p class=CodeChar style='margin-left:0in'>//{-msc} You can add the header by
hand</p>

<p class=CodeChar style='margin-left:0in'>//{-g++} You can add the header by
hand</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;hash_map&gt; </p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main(){</p>

<p class=CodeChar style='margin-left:0in'>  hash_map&lt;int, int&gt; hm;</p>

<p class=CodeChar style='margin-left:0in'>  map&lt;int, int&gt; m;</p>

<p class=CodeChar style='margin-left:0in'>  clock_t ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      m.insert(make_pair(j,j));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;map insertions:
&quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      hm.insert(make_pair(j,j));</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;hash_map
insertions: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      m[j];</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;map::operator[]
lookups: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      hm[j];</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;hash_map::operator[] lookups: &quot;</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      m.find(j);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;map::find()
lookups: &quot;</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  ticks = clock();</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 100; i++)</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt; 1000; j++)</p>

<p class=CodeChar style='margin-left:0in'>      hm.find(j);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;hash_map::find() lookups: &quot; </p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; clock() - ticks &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The performance test we ran showed a speed improvement of
roughly 4:1 for the <b>hash_map</b> over the <b>map</b> in all operations (and
as expected, <b>find(&nbsp;)</b> is slightly faster than <b>operator[ ]</b> for
lookups for both types of map). If a profiler shows a bottleneck in your <b>map</b>,
consider a <b>hash_map</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1310"
title="Add Comment A1310"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440139">Non-STL containers</a></h2>

<p class=MsoNormal>There are two “non-STL” containers in the standard library: <b>bitset</b>
and <b>valarray</b><a href="#_ftn90" name="_ftnref90" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[90]</span></sup></span></span></sup></span></a>. We
say “non-STL” because neither of these containers fulfills all the requirements
of STL containers. The <b>bitset</b> container, which we covered earlier in
this chapter, packs bits into integers and does not allow direct addressing of
its members. The <b>valarray</b> template class is a vector-like container that
is optimized for efficient numeric computation. Neither container provides
iterators. Although you can instantiate a <b>valarray</b> with nonnumeric
types, it has mathematical functions that are intended to operate with numeric
data, such as <b>sin</b>, <b>cos</b>, <b>tan</b>, and so on. Most of <b>valarray</b>’s
functions and operators operate on a <b>valarray</b> as a whole, as the
following example illustrates.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Valarray1.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates basic valarray
functionality</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;valarray&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>double f(double x) {</p>

<p class=CodeChar style='margin-left:0in'>    return 2.0*x - 1.0;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(const char* lbl, const
valarray&lt;T&gt;&amp; a) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; lbl &lt;&lt;
&quot;: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t i = 0; i &lt;
a.size(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>        cout &lt;&lt; a[i] &lt;&lt; '
';</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  double n[] = {1.0, 2.0, 3.0, 4.0};</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt; v(n, sizeof
n / sizeof n[0]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;v&quot;, v);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt;
sh(v.shift(1));</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;shift 1&quot;, sh);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt; acc(v + sh);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;sum&quot;, acc);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt; trig(sin(v)
+ cos(acc));</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;trig&quot;, trig);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt; p(pow(v,
3.0));</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;3rd power&quot;, p);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;double&gt;
app(v.apply(f));</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;f(v)&quot;, app);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;bool&gt; eq(v == app);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;v == app?&quot;, eq);</p>

<p class=CodeChar style='margin-left:0in'>  double x = v.min();</p>

<p class=CodeChar style='margin-left:0in'>  double y = v.max();</p>

<p class=CodeChar style='margin-left:0in'>  double z = v.sum();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;x = &quot;
&lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; &quot;, z = &quot;
&lt;&lt; z  &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>valarray</b> class provides a constructor that takes
an array of the target type and the count of elements in the array to be used
to initialize the new <b>valarray</b>. The <b>shift(&nbsp;)</b> member function
shifts each <b>valarray</b> element one position to the left (or to the right,
if its argument is negative) and fills in holes with the default value for the
type (zero in this case). There is also a <b>cshift(&nbsp;)</b> member function
that does a circular shift (or “rotate”). All mathematical operators and
functions are overloaded to operate on <b>valarray</b>s, and binary operators
require <b>valarray</b> arguments of the same type and size. The <b>apply(&nbsp;)</b>
member function, like the <b>transform(&nbsp;)</b> algorithm, applies a
function to each element, but the result is collected into a result <b>valarray</b>.
The relational operators return suitably sized instances of <b>valarray&lt;bool&gt;</b>
that indicate the result of element-by-element comparisons, such as with <b>eq</b>
above. Most operations return a new result array, but a few, such as <b>min(&nbsp;)</b>,
<b>max(&nbsp;)</b>, and <b>sum(&nbsp;)</b>, return a single scalar value for
obvious reasons.</p>

<p class=MsoNormal>The most interesting thing you can do with <b>valarray</b>s
is reference subsets of their elements, not only for extracting information,
but for updating it. A subset of a <b>valarray</b> is called a <i>slice</i>,
and certain operators use slices to do their work. The following sample program
uses slices.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C07:Valarray2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates slices and masks</p>

<p class=CodeChar style='margin-left:0in'>//{-bor}</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;valarray&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>void print(const char* lbl, const
valarray&lt;T&gt;&amp; a) {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; lbl &lt;&lt; &quot;:
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt; a.size();
++i)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; a[i] &lt;&lt; ' ';</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  int data[] = {1,2,3,4,5,6,7,8,9,10,11,12};</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; v(data, 12);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; r1(v[slice(0,
4, 3)]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;slice(0,4,3)&quot;,
r1);</p>

<p class=CodeChar style='margin-left:0in'>  // Extract conditionally</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; r2(v[v &gt;
6]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;elements &gt; 6&quot;,
r2);</p>

<p class=CodeChar style='margin-left:0in'>  // Square first column</p>

<p class=CodeChar style='margin-left:0in'>  v[slice(0, 4, 3)] *=
valarray&lt;int&gt;(v[slice(0, 4, 3)]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;after squaring first
row&quot;, v);</p>

<p class=CodeChar style='margin-left:0in'>  // Restore it</p>

<p class=CodeChar style='margin-left:0in'>  int idx[] = {1,4,7,10};</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; save(idx, 4);</p>

<p class=CodeChar style='margin-left:0in'>  v[slice(0, 4, 3)] = save;</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;v restored&quot;, v);</p>

<p class=CodeChar style='margin-left:0in'>  // Extract a 2-d subset: {{1,3,5},
{7, 9, 11}}</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;size_t&gt; siz(2);</p>

<p class=CodeChar style='margin-left:0in'>  siz[0] = 2;</p>

<p class=CodeChar style='margin-left:0in'>  siz[1] = 3;</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;size_t&gt; gap(2);</p>

<p class=CodeChar style='margin-left:0in'>  gap[0] = 6;</p>

<p class=CodeChar style='margin-left:0in'>  gap[1] = 2;</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; r3(v[gslice(0,
siz, gap)]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;2-d slice&quot;, r3);</p>

<p class=CodeChar style='margin-left:0in'>  // Extract a subset via a boolean
mask (bool elements)</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;bool&gt; mask(false,
5);</p>

<p class=CodeChar style='margin-left:0in'>  mask[1] = mask[2] = mask[4] = true;</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; r4(v[mask]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;v[mask]&quot;, r4);</p>

<p class=CodeChar style='margin-left:0in'>  // Extract a subset via an index
mask (size_t elements)</p>

<p class=CodeChar style='margin-left:0in'>  size_t idx2[] = {2,2,3,6};</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;size_t&gt; mask2(idx2,
4);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;int&gt; r5(v[mask2]);</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;v[mask2]&quot;, r5);</p>

<p class=CodeChar style='margin-left:0in'>  // Use an index mask in assignment</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;char&gt; text(&quot;now
is the time&quot;, 15);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;char&gt;
caps(&quot;NITT&quot;, 4);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;size_t&gt; idx3(4);</p>

<p class=CodeChar style='margin-left:0in'>  idx3[0] = 0;</p>

<p class=CodeChar style='margin-left:0in'>  idx3[1] = 4;</p>

<p class=CodeChar style='margin-left:0in'>  idx3[2] = 7;</p>

<p class=CodeChar style='margin-left:0in'>  idx3[3] = 11;</p>

<p class=CodeChar style='margin-left:0in'>  text[idx3] = caps;</p>

<p class=CodeChar style='margin-left:0in'>  print(&quot;capitalized&quot;,
text);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>slice</b> object takes three arguments: the starting
index, the number of elements to extract, and the “stride,” which is the gap
between elements of interest. Slices can be used as indexes into an existing <b>valarray</b>,
and a new <b>valarray</b> containing the extracted elements is returned. A <b>valarray</b>
of <b>bool</b>, such as is returned by the expression <b>v &gt; 6</b>, can be
used as an index into another <b>valarray</b>; the elements corresponding to
the true slots are extracted. As you can see, you can also use slices and masks
as indexes on the left side of an assignment. A <b>gslice</b> object (for
“generalized slice”) is like a slice, except that the counts and strides are
themselves arrays, which allows you to interpret a <b>valarray</b> as a
multidimensional array. The example above extracts a 2 by 3 array from <b>v</b>,
where the numbers start at zero and the numbers for the first dimension are
found six slots apart in <b>v</b>, and the others two apart, which effectively
extracts the matrix</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>1 3 5</p>

<p class=CodeInlineCharChar style='margin-left:0in'>7 9 11</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Here is the complete output for this program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>slice(0,4,3): 1 4 7 10</p>

<p class=CodeChar style='margin-left:0in'>elements &gt; 6: 7 8 9 10</p>

<p class=CodeChar style='margin-left:0in'>after squaring v: 1 2 3 16 5 6 49 8 9
100 11 12</p>

<p class=CodeChar style='margin-left:0in'>v restored: 1 2 3 4 5 6 7 8 9 10 11
12</p>

<p class=CodeChar style='margin-left:0in'>2-d slice: 1 3 5 7 9 11</p>

<p class=CodeChar style='margin-left:0in'>v[mask]: 2 3 5</p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>v[mask2]: 3 3 4 7</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span lang=IT>capitalized:
N o w   I s   T h e   T i m e</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span lang=IT>&nbsp;</span></p>

<p class=MsoNormal>A practical example of slices is found in matrix
multiplication. Consider how you would write a function to multiply two
matrices of integers with arrays.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>void matmult(const int a[][MAXCOLS],
size_t m, size_t n,</p>

<p class=CodeChar style='margin-left:0in'>             const int b[][MAXCOLS],
size_t p, size+t q,</p>

<p class=CodeInlineCharChar style='margin-left:0in'>             int
result[][MAXCOLS);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This function multiplies the <b>m</b>-by-<b>n</b> matrix <b>a</b>
by the <b>p</b>-by-<b>q</b> matrix <b>b</b>, where <b>n</b> and <b>p</b> are
equal, of course. As you can see, without something like <b>valarray</b>, you
need to fix the maximum value for the second dimension of each matrix, since
locations in arrays are statically determined. It is also very difficult to
return a result array by value, so the caller usually passes the result array
as an argument.</p>

<p class=MsoNormal>Using <b>valarray</b> not only allows you to pass any size
matrix, but you can also easily process matrices of any type, and return the
result by value. Here’s how:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// Multiplies compatible matrices in
valarrays</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>valarray&lt;T&gt; matmult(const
valarray&lt;T&gt;&amp; a, size_t arows, </p>

<p class=CodeChar style='margin-left:0in'>                    size_t acols,
const valarray&lt;T&gt;&amp; b, </p>

<p class=CodeChar style='margin-left:0in'>                    size_t brows,
size_t bcols)</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  assert(acols == brows);</p>

<p class=CodeChar style='margin-left:0in'>  valarray&lt;T&gt; result(arows *
bcols);</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt; arows;
++i)</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t j = 0; j &lt; bcols;
++j)</p>

<p class=CodeChar style='margin-left:0in'>    {</p>

<p class=CodeChar style='margin-left:0in'>      // Take dot product of row a[i]
and col b[j]</p>

<p class=CodeChar style='margin-left:0in'>      valarray&lt;T&gt; row =
a[slice(acols*i, acols, 1)];</p>

<p class=CodeChar style='margin-left:0in'>      valarray&lt;T&gt; col =
b[slice(j, brows, bcols)];</p>

<p class=CodeChar style='margin-left:0in'>      result[i*bcols + j] = (row *
col).sum();</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  return result;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each entry in the result matrix is the dot product of a row
in <b>a</b> with a column in <b>b</b>. By taking slices, you can extract these
rows and columns as <b>valarray</b>s and use the global <b>*</b> operator and <b>sum(&nbsp;)</b>
function provided by <b>valarray</b> to do the work succinctly. The result <b>valarray</b>
is computed at runtime; there’s no need to worry about the static limitations
of array dimensions. You do have to compute linear offsets of the position <b>[i][j]</b>
yourself (see the formula <b>i*bcols + j</b> above), but the size and type
freedom is worth it. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1845"
title="Add Comment A1845"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440140">Summary</a></h2>

<p class=MsoNormal>The goal of this chapter was not just to introduce the STL
containers in some considerable depth. (Of course, not every detail could be
covered here, but you should have enough now that you can look up further
information in the other resources.) Our higher hope is that this chapter has
made you grasp the incredible power available in the STL and shown you how much
faster and more efficient your programming activities can be by using and understanding
the STL.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1311"
title="Add Comment A1311"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440141">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a <b>set&lt;char&gt;</b>, open a file (whose name is
provided on the command line), and read that file in a <b>char</b> at a time,
placing each <b>char</b> in the set. Print the results, and observe the
organization. Are there any letters in the alphabet that are not used in that
particular file?</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create three sequences of <b>Noisy</b> objects, a <b>vector</b>, <b>deque</b>,
and <b>list</b>. Sort them. Now write a function template to receive the <b>vector</b>
and <b>deque</b> sequences as a parameter to sort them and record the sorting
time. Write a specialized template function to do the same for <b>list</b>
(ensure to call its member <b>sort(&nbsp;)</b> instead of the generic
algorithm). Compare the performance of the different sequence types.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Write a program to compare the speed of sorting a list using <b>list::sort(&nbsp;)</b>
vs. using <b>std::sort(&nbsp;)</b> (the STL algorithm version of <b>sort(&nbsp;)</b>).</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a generator that produces random <b>int</b> values between
0 and 20 inclusive, and use it to fill a <b>multiset&lt;int&gt;</b>. Count the
occurrences of each value, following the example given in <b>MultiSetWordCount.cpp</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Change <b>StlShape.cpp</b> so that it uses a <b>deque</b> instead
of a <b>vector</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>Reversible.cpp</b> so it works with <b>deque</b> and <b>list</b>
instead of <b>vector</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use a <b>stack&lt;int&gt;</b> and populate it with a Fibonacci
sequence. The program’s command line should take the number of Fibonacci
elements desired, and you should have a loop that looks at the last two
elements on the stack and pushes a new one for every pass through the loop.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>8. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using only three <b>stack</b>s (<i>source</i>, <i>sorted</i>, and
<i>losers</i>), sort a random sequence of numbers by placing the numbers
initially on the <i>source</i> stack. Assume the number on the top of the <i>source</i>
is the largest, and push it on the <i>sorted</i> stack. Continue to pop the <i>source</i>
stack comparing it with the top of the <i>sorted</i> stack. Whichever number is
the smallest, pop it from its stack and push it onto the on the <i>losers’</i>
stack. Once the <i>source</i> stack is empty, repeat the process using the <i>loser’s</i>
stack as the <i>source</i> stack, and use the <i>source</i> stack as the <i>losers’</i>
stack. The algorithm completes when all the numbers have been placed into the <i>winners’</i>
stack.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>9. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Open a text file whose name is provided on the command line. Read
the file a word at a time, and use a <b>multiset&lt;string&gt;</b> to create a
word count for each word.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>10. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>WordCount.cpp</b> so that it uses <b>insert(&nbsp;)</b>
instead of <b>operator[&nbsp;]</b> to insert elements in the map.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>11. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a class that has an <b>operator&lt;</b> and an <b>ostream&amp;
operator&lt;&lt;</b>. The class should contain a priority number. Create a
generator for your class that makes a random priority number. Fill a <b>priority_queue</b>
using your generator, and then pull the elements out to show they are in the
proper order.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>12. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Rewrite <b>Ring.cpp</b> so it uses a <b>deque</b> instead of a <b>list</b>
for its underlying implementation.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>13. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>Ring.cpp</b> so that the underlying implementation can
be chosen using a template argument. (Let that template argument default to <b>list</b>.)</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>14. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create an iterator class called <b>BitBucket</b> that just
absorbs whatever you send to it without writing it anywhere.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>15. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a kind of “hangman” game. Create a class that contains a <b>char</b>
and a <b>bool</b> to indicate whether that <b>char</b> has been guessed yet.
Randomly select a word from a file, and read it into a vector of your new type.
Repeatedly ask the user for a character guess, and after each guess, display
the characters in the word that have been guessed, and display underscores for
the characters that haven’t. Allow a way for the user to guess the whole word.
Decrement a value for each guess, and if the user can get the whole word before
the value goes to zero, they win.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>16. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Open a file and read it into a single string. Turn the string
into a <b>stringstream</b>. Read tokens from the <b>stringstream</b> into a <b>list&lt;string&gt;</b>
using a <b>TokenIterator</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>17. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Compare the performance of <b>stack</b> based on whether it is
implemented with <b>vector</b>, <b>deque</b>, or <b>list</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>18. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a template that implements a singly-linked list called <b>SList</b>.
Provide a default constructor and <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
functions (via an appropriate nested iterator), <b>insert(&nbsp;)</b>, <b>erase(&nbsp;)</b>
and a destructor.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>19. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Generate a sequence of random integers storing them into an array
of <b>int</b>. Initialize a <b>valarray&lt;int&gt;</b> with its contents.
Compute the sum, minimum value, maximum value, average, and median of the
integers using <b>valarray</b> operations.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>20. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a <b>valarray&lt;int&gt;</b> with 12 random values. Create
another <b>valarray&lt;int&gt;</b> with 20 random values. You will interpret
the first <b>valarray</b> as a 3 x 4 matrix of <b>int</b>s and the second as a
4 x 5 matrix of <b>int</b>s, and multiply them by the rules of matrix
multiplication. Store the result in a <b>valarray&lt;int&gt;</b> of size 15,
representing the 3 x 5 result matrix. Use slices to multiply the rows of the
first matrix time the columns of the second. Print the result in rectangular
matrix form.</p>

<p class=MsoNormal><sup>&nbsp;</sup></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section14>

<h1 style='margin-left:0in'><span style='position:relative;z-index:4'><span
style='left:0px;position:absolute;left:-122px;top:-105px;width:734px;
height:118px'>

<table cellpadding=0 cellspacing=0>
 <tr>
  <td width=734 height=118 bgcolor=white style='vertical-align:top;background:
  white'><span style='position:absolute;left:0pt;z-index:4'>
  <table cellpadding=0 cellspacing=0 width="100%">
   <tr>
    <td>
    <div style='padding:3.6pt 7.2pt 3.6pt 7.2pt'>
    <p class=Partbleed>&nbsp;</p>
    <p class=Partbleed>          Part 3</p>
    </div>
    </td>
   </tr>
  </table>
  </span>&nbsp;</td>
 </tr>
</table>

</span></span><a name="_Toc45440142"></a><a name=part3></a>Special Topics</h1>

<p class=MsoNormal><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1314"
title="Add Comment A1314"><sup>Comment</sup></a></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section15>

<h1 style='margin-left:-81.35pt'><a name="_Toc45440143"></a><a
name="_Toc312374132"></a><a name="_Toc305628779"></a><a name="_Toc305593307">8:
Runtime type identification</a></h1>

<p class=Intro style='margin-left:.25in'>Runtime type identification (RTTI)
lets you find the dynamic type of an object when you have only a pointer or a reference
to the base type. </p>

<p class=MsoNormal>This can be thought of as a “secondary” feature in C++, a
pragmatism to help out when you get into rare messy situations. Normally,
you’ll want to intentionally ignore the exact type of an object and let the
virtual function mechanism implement the correct behavior for that type
automatically. On occasion, however, it’s useful to know the exact <i>runtime</i>
(that is, most derived) type of an object for which you only have a base
pointer. Often this information allows you to perform a special-case operation
more efficiently or prevent a base-class interface from becoming ungainly. It
happens enough that most class libraries contain virtual functions to produce
run-time type information. When exception handling was added to C++, it
required information about the runtime type of objects. It became an easy next
step to build access to that information into the language. This chapter
explains what RTTI is for and how to use it. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1315"
title="Add Comment A1315"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440144">Runtime casts</a></h2>

<p class=MsoNormal>One way to determine the runtime type of an object through a
pointer is to employ a <i>runtime cast</i>, which verifies that the attempted
conversion is valid. This is useful when you need to cast a base-class pointer
to a derived type. Since inheritance hierarchies are typically depicted with
base classes above derived classes, such a cast is called a <i>downcast</i>.</p>

<p class=MsoNormal>Consider the following class hierarchy.</p>

<p class=MsoNormal align=center style='text-align:center'><img border=0
width=425 height=252 src="TicV2_files/image009.gif"></p>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In the code that follows, the <b>Investment</b> class has an
extra operation that the other classes do not, so it is important to be able to
know at runtime whether a <b>Security</b> pointer refers to a <b>Investment</b>
object or not. To implement checked runtime casts, each class keeps an integral
identifier to distinguish it from other classes in the hierarchy. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1743"
title="Add Comment A1743"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:CheckedCast.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Checks casts at runtime</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Security {</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  enum {BASEID = 0};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Security() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual bool isA(int id) {</p>

<p class=CodeChar style='margin-left:0in'>     return (id == BASEID);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Stock : public Security {</p>

<p class=CodeChar style='margin-left:0in'>  typedef Security Super;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  enum {OFFSET = 1, TYPEID = BASEID +
OFFSET};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  bool isA(int id) {</p>

<p class=CodeChar style='margin-left:0in'>    return id == TYPEID ||
Super::isA(id);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static Stock* dynacast(Security* s)
{</p>

<p class=CodeChar style='margin-left:0in'>    return (s-&gt;isA(TYPEID)) ?</p>

<p class=CodeChar style='margin-left:0in'>      static_cast&lt;Stock*&gt;(s) :
0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Bond : public Security {</p>

<p class=CodeChar style='margin-left:0in'>  typedef Security Super;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  enum {OFFSET = 2, TYPEID = BASEID +
OFFSET};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  bool isA(int id) {</p>

<p class=CodeChar style='margin-left:0in'>    return id == TYPEID ||
Super::isA(id);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static Bond* dynacast(Security* s)
{</p>

<p class=CodeChar style='margin-left:0in'>    return (s-&gt;isA(TYPEID)) ?</p>

<p class=CodeChar style='margin-left:0in'>      static_cast&lt;Bond*&gt;(s) :
0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Investment : public Security {</p>

<p class=CodeChar style='margin-left:0in'>  typedef Security Super;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  enum {OFFSET = 3, TYPEID = BASEID +
OFFSET};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  bool isA(int id) {</p>

<p class=CodeChar style='margin-left:0in'>    return id == BASEID ||
Super::isA(id);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static Investment*
dynacast(Security* s) {</p>

<p class=CodeChar style='margin-left:0in'>    return (s-&gt;isA(TYPEID)) ?</p>

<p class=CodeChar style='margin-left:0in'>     
static_cast&lt;Investment*&gt;(s) : 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void special() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;special
Investment function\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Metal : public Investment {</p>

<p class=CodeChar style='margin-left:0in'>  typedef Investment Super;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  enum {OFFSET = 4, TYPEID = BASEID +
OFFSET};</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  bool isA(int id) {</p>

<p class=CodeChar style='margin-left:0in'>    return id == BASEID ||
Super::isA(id);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  static Metal* dynacast(Security* s)
{</p>

<p class=CodeChar style='margin-left:0in'>    return (s-&gt;isA(TYPEID)) ?</p>

<p class=CodeChar style='margin-left:0in'>      static_cast&lt;Metal*&gt;(s) :
0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Security*&gt; portfolio;</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Metal);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new
Investment);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Bond);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Stock);</p>

<p class=CodeChar style='margin-left:0in'>  for
(vector&lt;Security*&gt;::iterator it =</p>

<p class=CodeChar style='margin-left:0in'>         portfolio.begin();</p>

<p class=CodeChar style='margin-left:0in'>       it != portfolio.end(); ++it) {</p>

<p class=CodeChar style='margin-left:0in'>    Investment* cm =
Investment::dynacast(*it);</p>

<p class=CodeChar style='margin-left:0in'>    if(cm)</p>

<p class=CodeChar style='margin-left:0in'>      cm-&gt;special();</p>

<p class=CodeChar style='margin-left:0in'>    else</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;not a
Investment&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;cast from
intermediate pointer:\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  Security* sp = new Metal;</p>

<p class=CodeChar style='margin-left:0in'>  Investment* cp =
Investment::dynacast(sp);</p>

<p class=CodeChar style='margin-left:0in'>  if(cp) cout &lt;&lt; &quot;  it's
an Investment\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>Metal* mp =
Metal::dynacast(sp);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>if(mp) cout
&lt;&lt; &quot;  it's a Metal too!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  purge(portfolio);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The polymorphic <b>isA(&nbsp;)</b> function checks to see if
its argument is compatible with its type argument (<b>id</b>), which means that
either <b>id</b> matches the object’s <b>typeID</b> exactly or that of one of
its ancestors in the hierarchy (hence the call to <b>Super::isA(&nbsp;)</b> in
that case). The <b>dynacast(&nbsp;)</b> function, which is static in each
class, calls <b>isA(&nbsp;)</b> for its pointer argument to check if the cast
is valid. If <b>isA(&nbsp;)</b> returns <b>true</b>, the cast is valid, and a
suitably cast pointer is returned. Otherwise, the null pointer is returned,
which tells the caller that the cast is not valid, meaning that the original
pointer is not pointing to an object compatible with (convertible to) the
desired type. All this machinery is necessary to be able to check intermediate
casts, such as from a <b>Security</b> pointer that refers to a <b>Metal</b>
object to a <b>Investment</b> pointer in the previous example program.<a
href="#_ftn91" name="_ftnref91" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[91]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1744"
title="Add Comment A1744"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although for most programs downcasting is not needed (and
indeed is discouraged, since everyday polymorphism solves most problems in
object-oriented application programs), the ability to check a cast to a more
derived type is important for utility programs such as debuggers, class
browsers, and databases. C++ provides such a checked cast with the <b>dynamic_cast</b>
operator. The following program is a rewrite of the previous example using <b>dynamic_cast</b>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1745"
title="Add Comment A1745"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:CheckedCast2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Uses RTTI’s dynamic_cast</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Security {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Security(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Stock : public Security {};</p>

<p class=CodeChar style='margin-left:0in'>class Bond : public Security {};</p>

<p class=CodeChar style='margin-left:0in'>class Investment : public Security {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void special() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;special
Investment function\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Metal : public Investment {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Security*&gt; portfolio;</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Metal);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new
Investment);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Bond);</p>

<p class=CodeChar style='margin-left:0in'>  portfolio.push_back(new Stock);</p>

<p class=CodeChar style='margin-left:0in'>  for
(vector&lt;Security*&gt;::iterator it = </p>

<p class=CodeChar style='margin-left:0in'>                                  
portfolio.begin();</p>

<p class=CodeChar style='margin-left:0in'>       it != portfolio.end(); ++it) {</p>

<p class=CodeChar style='margin-left:0in'>    Investment* cm =
dynamic_cast&lt;Investment*&gt;(*it);</p>

<p class=CodeChar style='margin-left:0in'>    if(cm)</p>

<p class=CodeChar style='margin-left:0in'>      cm-&gt;special();</p>

<p class=CodeChar style='margin-left:0in'>    else</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;not a
Investment&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;cast from
intermediate pointer:\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  Security* sp = new Metal;</p>

<p class=CodeChar style='margin-left:0in'>  Investment* cp =
dynamic_cast&lt;Investment*&gt;(sp);</p>

<p class=CodeChar style='margin-left:0in'>  if(cp) cout &lt;&lt; &quot;  it's
an Investment\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  Metal* mp = dynamic_cast&lt;Metal*&gt;(sp);</p>

<p class=CodeChar style='margin-left:0in'>  if(mp) cout &lt;&lt; &quot;  it's a
Metal too!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  purge(portfolio);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example is much shorter, since most of the code in the
original example was just the overhead for checking the casts. The target type
of a <b>dynamic_cast</b> is placed in angle brackets, like the other new-style
C++ casts (<b>static_cast</b>, and so on), and the object to cast appears as
the operand. <b>dynamic_cast</b> requires that the types you use it with be <i>polymorphic</i>
if you want safe downcasts<a href="#_ftn92" name="_ftnref92" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[92]</span></sup></span></span></sup></span></a>.
This in turn requires that the class must have at least one virtual function.
Fortunately, the <b>Security</b> base class has a virtual destructor, so we
didn’t have to invent some extraneous function to get the job done. <b>dynamic_cast</b>
does its work at runtime, of course, since it has to check the virtual function
table of objects according to there dynamic type. This naturally implies that <b>dynamic_cast</b>
tends to be more expensive than the other new-style casts. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1746"
title="Add Comment A1746"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can also use <b>dynamic_cast</b> with references instead
of pointers, but since there is no such thing as a null reference, you need
another way to know if the cast fails. That “other way” is to catch a <b>bad_cast</b>
exception, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>  Metal m;</p>

<p class=CodeChar style='margin-left:0in'>  Security&amp; s = m;</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    Investment&amp; c =
dynamic_cast&lt;Investment&amp;&gt;(s);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;  it's an
Investment\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  catch (bad_cast&amp;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;s is not an
Investment type\n&quot;;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>  }</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>bad_cast</b> class is defined in the <b>&lt;typeinfo&gt;</b>
header, and, like most of the standard library, is declared in the <b>std</b>
namespace. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1747"
title="Add Comment A1747"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440145">The </a><span
style='font-weight:normal'>typeid</span> operator</h2>

<p class=MsoNormal>The other way to get runtime information for an object is
through the <b>typeid</b> operator. This operator returns an object of class <b>type_info</b>,
which yields information about the type of object to which it was applied. If
the type is polymorphic, it gives information about the most derived type that
applies (the <i>dynamic type</i>); otherwise it yields static type information.
One use of the <b>typeid</b> operator is to get the name of the dynamic type of
an object as a <b>const char*</b>, as you can see in the following example. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1748"
title="Add Comment A1748"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:TypeInfo.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates the typeid operator</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct PolyBase {virtual
~PolyBase(){}};</p>

<p class=CodeChar style='margin-left:0in'>struct PolyDer : PolyBase {};</p>

<p class=CodeChar style='margin-left:0in'>struct NonPolyBase {};</p>

<p class=CodeChar style='margin-left:0in'>struct NonPolyDer : NonPolyBase
{NonPolyDer(int){}};</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Test polymorphic Types</p>

<p class=CodeChar style='margin-left:0in'>  const PolyDer pd;</p>

<p class=CodeChar style='margin-left:0in'>  const PolyBase* ppb = &amp;pd;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(ppb).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(*ppb).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; boolalpha &lt;&lt;
(typeid(*ppb) == typeid(pd))</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (typeid(PolyDer) ==
typeid(const PolyDer))</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Test non-polymorphic Types</p>

<p class=CodeChar style='margin-left:0in'>  const NonPolyDer npd(1);</p>

<p class=CodeChar style='margin-left:0in'>  const NonPolyBase* nppb = &amp;npd;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(nppb).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(*nppb).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; (typeid(*nppb) ==
typeid(npd))</p>

<p class=CodeChar style='margin-left:0in'>    &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Test a built-in type</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(i).name()
&lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The output from this program is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>struct PolyBase const *</p>

<p class=CodeChar style='margin-left:0in'>struct PolyDer</p>

<p class=CodeChar style='margin-left:0in'>true</p>

<p class=CodeChar style='margin-left:0in'>true</p>

<p class=CodeChar style='margin-left:0in'>struct NonPolyBase const *</p>

<p class=CodeChar style='margin-left:0in'>struct NonPolyBase</p>

<p class=CodeChar style='margin-left:0in'>false</p>

<p class=CodeChar style='margin-left:0in'>int</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The first output line just echoes the static type of <b>ppb</b>
because it is a pointer. To get RTTI to kick in, you need to look at the object
a pointer or reference is connected to, which is illustrated in the second
line. Notice that RTTI ignores top-level <b>const</b> and <b>volatile</b>
qualifiers. With non-polymorphic types, you just get the static type (the type
of the pointer itself). As you can see, built-in types are also supported. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1749"
title="Add Comment A1749"><sup>Comment</sup></a></p>

<p class=MsoNormal>It turns out that you can’t store the result of a <b>typeid</b>
operation in a <b>type_info</b> object, because there are no accessible
constructors and assignment is disallowed; you must use it as we have shown. In
addition, the actual string returned by <b>type_info::name(&nbsp;)</b> is
compiler dependent. Some compilers return “class C” instead of just “C”, for
instance, for a class named <b>C</b>. Applying <b>typeid</b> to an expression
that dereferences a null pointer will cause a <b>bad_typeid</b> exception (also
defined in <b>&lt;typeinfo&gt;</b>) to be thrown. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1750"
title="Add Comment A1750"><sup>Comment</sup></a></p>

<p class=MsoNormal>The following example shows that the class name that <b>type_info::name(&nbsp;)</b>
returns is fully qualified.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1337"
title="Add Comment A1337"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:RTTIandNesting.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class One {</p>

<p class=CodeChar style='margin-left:0in'>  class Nested {};</p>

<p class=CodeChar style='margin-left:0in'>  Nested* n;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  One() : n(new Nested) {}</p>

<p class=CodeChar style='margin-left:0in'>  ~One() { delete n; }</p>

<p class=CodeChar style='margin-left:0in'>  Nested* nested() { return n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  One o;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
typeid(*o.nested()).name() &lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>Nested</b> is a member type of the <b>One</b>
class, the result is <b>One::Nested</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1338"
title="Add Comment A1338"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can also ask a <b>type_info</b> object if it precedes
another <b>type_info</b> object in the implementation-defined “collation sequence”
(the native ordering rules for text), using <b>before(type_info&amp;)</b>, which returns <b>true</b> or <b>false</b>. When you say,<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1327"
title="Add Comment A1327"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>if(typeid(me).before(typeid(you)))
// ...</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>you’re asking if <b>me</b> occurs before <b>you</b> in the
current collation sequence. This is useful should you use <b>type_info</b>
objects as keys. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1328"
title="Add Comment A1328"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440146"></a><a name="_Toc312374140">Casting to intermediate
levels</a></h3>

<p class=MsoNormal>As you saw in the earlier program that used the hierarchy of
<b>Security</b> classes, <b>dynamic_cast</b> can detect both exact types and, in an inheritance hierarchy with multiple levels, intermediate types. Here is
another example.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1343"
title="Add Comment A1343"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:IntermediateCast.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class B1 { </p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~B1() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class B2 { </p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~B2() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class MI : public B1, public B2 {};</p>

<p class=CodeChar style='margin-left:0in'>class Mi2 : public MI {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>B2* b2 = new Mi2;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  Mi2* mi2 =
dynamic_cast&lt;Mi2*&gt;(b2);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  MI* mi =
dynamic_cast&lt;MI*&gt;(b2);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>B1* b1 =
dynamic_cast&lt;B1*&gt;(b2);</p>

<p class=CodeChar style='margin-left:0in'>  assert(typeid(b2) != typeid(Mi2*));</p>

<p class=CodeChar style='margin-left:0in'>  assert(typeid(b2) == typeid(B2*));</p>

<p class=CodeChar style='margin-left:0in'>  delete b2;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This example has the extra complication of multiple
inheritance (more on this later in this chapter). If you create an <b>Mi2</b> and upcast it to the root (in this case, one of the two possible roots is
chosen), the <b>dynamic_cast</b> back to either of the derived levels <b>MI</b>
or <b>Mi2</b> is successful. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1344"
title="Add Comment A1344"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can even cast from one root to the other:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1345"
title="Add Comment A1345"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>  B1* b1 =
dynamic_cast&lt;B1*&gt;(b2);</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This is successful because <b>B2</b> is actually pointing to
an <b>Mi2</b> object, which contains a subobject of type <b>B1</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1346"
title="Add Comment A1346"><sup>Comment</sup></a></p>

<p class=MsoNormal>Casting to intermediate levels brings up an interesting
difference between <b>dynamic_cast</b> and <b>typeid</b>. The <b>typeid</b> operator always produces a reference to a static <b>typeinfo</b> object that describes the dynamic type of the object. Thus, it doesn’t give you
intermediate-level information. In the following expression (which is <b>true</b>),
<b>typeid</b> doesn’t see <b>b2</b> as a pointer to the derived type, like <b>dynamic_cast</b>
does:<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1347"
title="Add Comment A1347"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typeid(b2) != typeid(Mi2*)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The type of <b>b2</b> is simply the exact type of the
pointer:<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1348"
title="Add Comment A1348"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>typeid(b2) == typeid(B2*)</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440147"></a><a name="_Toc312374141"><span style='font-weight:
normal'>void</span> pointers</a></h3>

<p class=MsoNormal>RTTI only works for complete types, meaning that all class
information must be available when <b>typeid</b> is used. In particular, it
doesn’t work with <b>void</b> pointers:<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1349" title="Add Comment A1349"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:VoidRTTI.cpp</p>

<p class=CodeChar style='margin-left:0in'>// RTTI &amp; void pointers</p>

<p class=CodeChar style='margin-left:0in'>//!#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Stimpy {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void happy() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual void joy() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Stimpy() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  void* v = new Stimpy;</p>

<p class=CodeChar style='margin-left:0in'>  // Error:</p>

<p class=CodeChar style='margin-left:0in'>//!  Stimpy* s =
dynamic_cast&lt;Stimpy*&gt;(v);</p>

<p class=CodeChar style='margin-left:0in'>  // Error:</p>

<p class=CodeChar style='margin-left:0in'>//!  cout &lt;&lt; typeid(*v).name()
&lt;&lt; endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>void*</b> truly means “no type information at all.”<a
href="#_ftn93" name="_ftnref93" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[93]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1350"
title="Add Comment A1350"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440148"></a><a name="_Toc312374142">Using RTTI with
templates</a></h3>

<p class=MsoNormal>Class templates work well with RTTI, since all they do is
generate classes. As usual, RTTI provides a convenient way to obtain the name
of the class you’re in. The following example prints the order of constructor
and destructor calls: <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1351" title="Add Comment A1351"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:ConstructorOrder.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Order of constructor calls</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;int id&gt; class Announce
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Announce() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; typeid(*this).name()</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;
constructor&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Announce() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
typeid(*this).name()</p>

<p class=CodeChar style='margin-left:0in'>         &lt;&lt; &quot;
destructor&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class X : public Announce&lt;0&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  Announce&lt;1&gt; m1;</p>

<p class=CodeChar style='margin-left:0in'>  Announce&lt;2&gt; m2;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  X() { cout &lt;&lt;
&quot;X::X()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>  ~X() { cout &lt;&lt;
&quot;X::~X()&quot; &lt;&lt; endl; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>int main() { X x; } ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>This template uses a constant <b>int</b> to differentiate
one class from another, but type arguments would work as well. Inside both the
constructor and destructor, RTTI information is used to produce the name of the
class to print. The class <b>X</b> uses both inheritance and composition to
create a class that has an interesting order of constructor and destructor
calls. The output is: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1751"
title="Add Comment A1751"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>Announce&lt;0&gt; constructor </p>

<p class=CodeChar style='margin-left:0in'>Announce&lt;1&gt; constructor </p>

<p class=CodeChar style='margin-left:0in'>Announce&lt;2&gt; constructor </p>

<p class=CodeChar style='margin-left:0in'>X::X()</p>

<p class=CodeChar style='margin-left:0in'>X::~X()</p>

<p class=CodeChar style='margin-left:0in'>Announce&lt;2&gt; destructor </p>

<p class=CodeChar style='margin-left:0in'>Announce&lt;1&gt; destructor </p>

<p class=CodeInlineCharChar style='margin-left:0in'>Announce&lt;0&gt;
destructor</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45440149"></a><a name="_Toc312374145"></a><a
name="_Toc305628784"></a><a name="_Toc305593312">Multiple inheritance</a></h2>

<p class=MsoNormal>Of course, the RTTI mechanisms must work properly with all the complexities of multiple inheritance, including <b>virtual</b> base classes
(discussed in depth in the next chapter—you may want to come back to this after
reading Chapter 9):<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1362"
title="Add Comment A1362"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//:
C08:RTTIandMultipleInheritance.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class BB {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void f() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~BB() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class B1 : virtual public BB {};</p>

<p class=CodeChar style='margin-left:0in'>class B2 : virtual public BB {};</p>

<p class=CodeChar style='margin-left:0in'>class MI : public B1, public B2 {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  BB* bbp = new MI; // Upcast</p>

<p class=CodeChar style='margin-left:0in'>  // Proper name detection:</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; typeid(*bbp).name()
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  // Dynamic_cast works properly:</p>

<p class=CodeChar style='margin-left:0in'>  MI* mip =
dynamic_cast&lt;MI*&gt;(bbp);</p>

<p class=CodeChar style='margin-left:0in'>  // Can't force old-style cast:</p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>//! MI* mip2 =
(MI*)bbp; // Compile error</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The<b> typeid(&nbsp;) </b>operation<b> </b>properly detects
the name of the actual object, even through the <b>virtual</b> base class
pointer. The <b>dynamic_cast</b> also works correctly. But the compiler won’t
even allow you to try to force a cast the old way: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1363"
title="Add Comment A1363"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'><span lang=IT>MI* mip =
(MI*)bbp; // Compile-time error</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span lang=IT>&nbsp;</span></p>

<p class=MsoNormal>The compiler knows this is never the right thing to do, so
it requires that you use a <b>dynamic_cast</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1364"
title="Add Comment A1364"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440150"></a><a name="_Toc312374146"></a><a
name="_Toc305628785"></a><a name="_Toc305593313">Sensible uses for RTTI</a></h2>

<p class=MsoNormal>Because it allows you to discover type information from an
anonymous polymorphic pointer, RTTI is ripe for misuse by the novice because RTTI may make sense before virtual functions do. For many people coming from a
procedural background, it’s difficult not to organize programs into sets of <b>switch</b>
statements. They could accomplish this with RTTI and thus lose the important
value of polymorphism in code development and maintenance. The intent of C++ is
that you use virtual functions throughout your code and that you only use RTTI
when you must. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1365"
title="Add Comment A1365"><sup>Comment</sup></a></p>

<p class=MsoNormal>However, using virtual functions as they are intended
requires that you have control of the base-class definition because at some
point in the extension of your program you may discover the base class doesn’t
include the virtual function you need. If the base class comes from a library
or is otherwise controlled by someone else, a solution to the problem is RTTI: you
can derive a new type and add your extra member function. Elsewhere in the code
you can detect your particular type and call that member function. This doesn’t
destroy the polymorphism and extensibility of the program, because adding a new
type will not require you to hunt for switch statements. However, when you add
new code in the main body that requires your new feature, you’ll have to detect
your particular type. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1366"
title="Add Comment A1366"><sup>Comment</sup></a></p>

<p class=MsoNormal>Putting a feature in a base class might mean that, for the
benefit of one particular class, all the other classes derived from that base
require some meaningless stub for a pure virtual function. This makes the
interface less clear and annoys those who must redefine pure virtual functions
when they derive from that base class.<sup> </sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1367"
title="Add Comment A1367"><sup>Comment</sup></a></p>

<p class=MsoNormal>Finally, RTTI will sometimes solve efficiency problems. If your code uses polymorphism in a nice way, but it turns out that one
of your objects reacts to this general-purpose code in a horribly inefficient
way, you can pick that type out using RTTI and write case-specific code to
improve the efficiency. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1368"
title="Add Comment A1368"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440151"></a><a name="_Toc312374147">A trash recycler</a></h3>

<p class=MsoNormal>To further illustrate a practical use of RTTI, the following
program simulates a trash recycler. Different kinds of “trash” are inserted
into a single container and then later sorted according to their dynamic types.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1369"
title="Add Comment A1369"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:Recycle.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A Trash Recycler</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Trash {</p>

<p class=CodeChar style='margin-left:0in'>  float _weight;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Trash(float wt) : _weight(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual float value() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  float weight() const { return
_weight; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Trash() { cout &lt;&lt;
&quot;~Trash()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Aluminum : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Aluminum(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Aluminum::val = 1.67;</p>

<p class=CodeChar style='margin-left:0in'>class Paper : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Paper(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Paper::val = 0.10;</p>

<p class=CodeChar style='margin-left:0in'>class Glass : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Glass(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Glass::val = 0.23;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Sums up the value of the Trash in
a bin:</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Container&gt;</p>

<p class=CodeChar style='margin-left:0in'>void sumValue(Container&amp; bin,
ostream&amp; os) {</p>

<p class=CodeChar style='margin-left:0in'>  typename Container::iterator tally
= </p>

<p class=CodeChar style='margin-left:0in'>    bin.begin();</p>

<p class=CodeChar style='margin-left:0in'>  float val = 0;</p>

<p class=CodeChar style='margin-left:0in'>  while(tally != bin.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    val += (*tally)-&gt;weight() *
(*tally)-&gt;value();</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; &quot;weight of
&quot;</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt;
typeid(**tally).name()</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot; = &quot;
&lt;&lt; (*tally)-&gt;weight() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    tally++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; &quot;Total value =
&quot; &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0)); // Seed random
number generator</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Trash*&gt; bin;</p>

<p class=CodeChar style='margin-left:0in'>  // Fill up the Trash bin:</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 30; i++)</p>

<p class=CodeChar style='margin-left:0in'>    switch(rand() % 3) {</p>

<p class=CodeChar style='margin-left:0in'>      case 0 :</p>

<p class=CodeChar style='margin-left:0in'>        bin.push_back(new
Aluminum((rand() % 1000)/10.0));</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 1 :</p>

<p class=CodeChar style='margin-left:0in'>        bin.push_back(new
Paper((rand() % 1000)/10.0));</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 2 :</p>

<p class=CodeChar style='margin-left:0in'>        bin.push_back(new
Glass((rand() % 1000)/10.0));</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  // Note: bins hold exact type of
object, not base type:</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Glass*&gt; glassBin;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Paper*&gt; paperBin;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Aluminum*&gt; alumBin;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Trash*&gt;::iterator
sorter = bin.begin();</p>

<p class=CodeChar style='margin-left:0in'>  // Sort the Trash:</p>

<p class=CodeChar style='margin-left:0in'>  while(sorter != bin.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    Aluminum* ap =</p>

<p class=CodeChar style='margin-left:0in'>     
dynamic_cast&lt;Aluminum*&gt;(*sorter);</p>

<p class=CodeChar style='margin-left:0in'>    Paper* pp =</p>

<p class=CodeChar style='margin-left:0in'>     
dynamic_cast&lt;Paper*&gt;(*sorter);</p>

<p class=CodeChar style='margin-left:0in'>    Glass* gp =</p>

<p class=CodeChar style='margin-left:0in'>     
dynamic_cast&lt;Glass*&gt;(*sorter);</p>

<p class=CodeChar style='margin-left:0in'>    if(ap) alumBin.push_back(ap);</p>

<p class=CodeChar style='margin-left:0in'>    else if(pp)
paperBin.push_back(pp);</p>

<p class=CodeChar style='margin-left:0in'>    else if(gp)
glassBin.push_back(gp);</p>

<p class=CodeChar style='margin-left:0in'>    sorter++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  sumValue(alumBin, cout);</p>

<p class=CodeChar style='margin-left:0in'>  sumValue(paperBin, cout);</p>

<p class=CodeChar style='margin-left:0in'>  sumValue(glassBin, cout);</p>

<p class=CodeChar style='margin-left:0in'>  sumValue(bin, cout);</p>

<p class=CodeChar style='margin-left:0in'>  purge(bin);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><a name="_Toc305628786"></a><a name="_Toc305593314">The
nature of this problem is that the trash is thrown unclassified into a single
bin, so the specific type information is “lost.” But later the specific type
information must be recovered to properly sort the trash, and so RTTI is used.<sup>
</sup></a><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1370"
title="Add Comment A1370"><sup>Comment</sup></a></p>

<p class=MsoNormal>We can do even better by using a <b>map</b> that associates
pointers to <b>type_info</b> objects with a vector of <b>Trash</b> pointers.
Since a map requires an ordering predicate, we provide one named <b>TInfoLess</b>
that calls <b>type_info::before(&nbsp;)</b>. As we insert <b>Trash</b> pointers
into the map, they are associated automatically with their <b>type_info</b>
key. <a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1752"
title="Add Comment A1752"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C08:Recycle2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A Trash Recycler</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;typeinfo&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;utility&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Trash {</p>

<p class=CodeChar style='margin-left:0in'>  float wt;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Trash(float wt) : wt(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual float value() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  float weight() const { return wt; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Trash() { cout &lt;&lt;
&quot;~Trash()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>class Aluminum : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Aluminum(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Aluminum::val = 1.67;</p>

<p class=CodeChar style='margin-left:0in'>class Paper : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Paper(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Paper::val = 0.10;</p>

<p class=CodeChar style='margin-left:0in'>class Glass : public Trash {</p>

<p class=CodeChar style='margin-left:0in'>  static float val;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Glass(float wt) : Trash(wt) {}</p>

<p class=CodeChar style='margin-left:0in'>  float value() const { return val; }</p>

<p class=CodeChar style='margin-left:0in'>  static void value(float newval) {</p>

<p class=CodeChar style='margin-left:0in'>    val = newval;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>float Glass::val = 0.23;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Comparator for type_info pointers</p>

<p class=CodeChar style='margin-left:0in'>struct TInfoLess {</p>

<p class=CodeChar style='margin-left:0in'>  bool operator()(const type_info*
t1, const type_info* t2) </p>

<p class=CodeChar style='margin-left:0in'>  const {</p>

<p class=CodeChar style='margin-left:0in'>    return t1-&gt;before(*t2);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>typedef
map&lt;const type_info*, vector&lt;Trash*&gt;, TInfoLess&gt; </p>

<p class=CodeChar style='margin-left:0in;page-break-after:avoid'>  TrashMap;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Sums up the value of the Trash in
a bin:</p>

<p class=CodeChar style='margin-left:0in'>void sumValue(const
TrashMap::value_type&amp; p, ostream&amp; os) {</p>

<p class=CodeChar style='margin-left:0in'> 
vector&lt;Trash*&gt;::const_iterator tally = p.second.begin();</p>

<p class=CodeChar style='margin-left:0in'>  float val = 0;</p>

<p class=CodeChar style='margin-left:0in'>  while(tally != p.second.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    val += (*tally)-&gt;weight() *
(*tally)-&gt;value();</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; &quot;weight of
&quot;</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; p.first-&gt;name() 
// type_info::name()</p>

<p class=CodeChar style='margin-left:0in'>       &lt;&lt; &quot; = &quot;
&lt;&lt; (*tally)-&gt;weight() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    tally++;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; &quot;Total value =
&quot; &lt;&lt; val &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  srand(time(0)); // Seed random
number generator</p>

<p class=CodeChar style='margin-left:0in'>  TrashMap bin;</p>

<p class=CodeChar style='margin-left:0in'>  // Fill up the Trash bin:</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt; 30; i++) {</p>

<p class=CodeChar style='margin-left:0in'>    Trash* tp;</p>

<p class=CodeChar style='margin-left:0in'>    switch(rand() % 3) {</p>

<p class=CodeChar style='margin-left:0in'>      case 0 :</p>

<p class=CodeChar style='margin-left:0in'>        tp = new Aluminum((rand() %
1000)/10.0);</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 1 :</p>

<p class=CodeChar style='margin-left:0in'>        tp = new Paper((rand() %
1000)/10.0);</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>      case 2 :</p>

<p class=CodeChar style='margin-left:0in'>        tp = new Glass((rand() %
1000)/10.0);</p>

<p class=CodeChar style='margin-left:0in'>        break;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>   
bin[&amp;typeid(*tp)].push_back(tp);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Print sorted results</p>

<p class=CodeChar style='margin-left:0in'>  for(TrashMap::iterator p =
bin.begin();</p>

<p class=CodeChar style='margin-left:0in'>      p != bin.end(); ++p) {</p>

<p class=CodeChar style='margin-left:0in'>    sumValue(*p, cout);</p>

<p class=CodeChar style='margin-left:0in'>    purge(p-&gt;second);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We’ve modified <b>sumValue(&nbsp;)</b> to call <b>type_info::name(&nbsp;)</b>
directly, since the <b>type_info</b> object is now available there as the first
member of the <b>TrashMap::value_type</b> pair. This avoids the extra call to <b>typeid</b>
to get the name of the type of <b>Trash</b> being processed that was necessary
in the previous version of this program. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1685"
title="Add Comment A1685"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440152"></a><a name="_Toc312374148">Mechanism
and overhead of RTTI</a></h2>

<p class=MsoNormal>Typically, RTTI is implemented by placing an additional pointer in a class’s virtual function table. This pointer points to the <b>type_info</b> structure for that particular type. The effect of a <b>typeid(&nbsp;)</b>
expression is quite simple: the virtual function table pointer is used to fetch
the <b>type_info</b> pointer, and a reference to the resulting <b>type_info</b>
structure is produced. Since this is just a two-pointer dereference operation,
it is a constant time operation.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1371"
title="Add Comment A1371"><sup>Comment</sup></a></p>

<p class=MsoNormal>For a <b>dynamic_cast&lt;destination*&gt;(source_pointer)</b>,
most cases are quite straightforward: <b>source_pointer</b>’s RTTI information
is retrieved, and RTTI information for the type <b>destination*</b> is fetched.
A library routine then determines whether <b>source_pointer</b>’s type is of
type <b>destination*</b> or a base class of <b>destination*</b>. The pointer it
returns may be adjusted because of multiple inheritance if the base type isn’t the first base of the derived class. The situation is (of course) more
complicated with multiple inheritance in which a base type may appear more than
once in an inheritance hierarchy and virtual base classes are used.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1372"
title="Add Comment A1372"><sup>Comment</sup></a></p>

<p class=MsoNormal>Because the library routine used for <b>dynamic_cast</b>
must check through a list of base classes, the overhead for <b>dynamic_cast</b>
may be higher than <b>typeid(&nbsp;)</b> (but of course you get different
information, which may be essential to your solution), and it may take more
time to discover a base class than a derived class. In addition, <b>dynamic_cast</b>
allows you to compare any type to any other type; you aren’t restricted to
comparing types within the same hierarchy. This adds extra overhead to the
library routine used by <b>dynamic_cast</b>.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1373"
title="Add Comment A1373"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440153"></a><a name="_Toc312374154"></a><a
name="_Toc305628789"></a><a name="_Toc305593317">Summary</a></h2>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>Although normally
you upcast a pointer to a base class and then use the generic interface of that
base class (via virtual functions), occasionally you get into a corner where
things can be more effective if you know the dynamic type of the object pointed
to by a base pointer, and that’s what RTTI provides. The most common misuse may
come from the programmer who doesn’t understand virtual functions and uses RTTI
to do type-check coding instead. The philosophy of C++ seems to be to provide
you with powerful tools and guard for type violations and integrity, but if you
want to deliberately misuse or get around a language feature, there’s nothing
to stop you. Sometimes a slight burn is the fastest way to gain experience.<a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1391"
title="Add Comment A1391"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440154"></a><a name="_Toc312374155">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>C16:AutoCounter.h</b> in Volume 1 of this series so
that it becomes a useful debugging tool. It will be used as a nested member of
each class that you are interested in tracing. Turn <b>AutoCounter</b> into a
template that takes the class name of the surrounding class as the template
argument, and in all the error messages use RTTI to print out the name of the
class.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Use RTTI to assist in program debugging by printing out the exact
name of a template using <b>typeid(&nbsp;)</b>. Instantiate the template for
various types and see what the results are.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify the <b>Instrument</b> hierarchy from Chapter 14 of Volume
1 by first copying <b>Wind5.cpp</b> to a new location. Now add a virtual <b>ClearSpitValve(&nbsp;)</b>
function to the <b>Wind</b> class, and redefine it for all the classes
inherited from <b>Wind</b>. Instantiate a <b>TStash</b> to hold <b>Instrument</b>
pointers, and fill it with various types of <b>Instrument</b> objects created
using the <b>new</b> operator. Now use RTTI to move through the container
looking for objects in class <b>Wind</b>, or derived from <b>Wind</b>. Call the
<b>ClearSpitValve(&nbsp;)</b> function for these objects. Notice that it would
unpleasantly confuse the Instrument base class if it contained a <b>ClearSpitValve(&nbsp;)</b>
function. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1393"
title="Add Comment A1393"><sup>Comment</sup></a></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:always'>
</span>

<div class=Section16>

<h1 style='margin-left:-81.35pt'><a name="_Toc45440155">9: Multiple inheritance</a></h1>

<p class=Intro style='margin-left:.25in'>The basic concept of multiple
inheritance (MI) sounds simple enough: you create a new type by inheriting from
more than one base class. The syntax is exactly what you’d expect, and as long
as the inheritance diagrams are simple, MI can be simple as well.</p>

<p class=MsoNormal>Or maybe not! MI can introduce a number of ambiguities and
strange situations, which are covered in this chapter. But first, it will be
helpful to get a little perspective on the subject. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1687"
title="Add Comment A1687">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440156"></a><a name="_Toc312374097"></a><a
name="_Toc305628758"></a><a name="_Toc305593286">Perspective</a></h2>

<p class=MsoNormal>Before C++, the most successful object-oriented language was
Smalltalk. Smalltalk was created from the ground up as an object-oriented
language. It is often referred to as <i>pure,</i> whereas C++ is called a <i>hybrid</i>
language because it supports multiple programming paradigms, not just the
object-oriented paradigm. One of the design decisions made with Smalltalk was
that all classes would be derived in a single hierarchy, rooted in a single base
class (called <b>Object</b>—this is the model for the <i>object-based hierarchy</i>). You cannot create a new class in Smalltalk without deriving it from an existing
class, which is why it takes a certain amount of time to become productive in
Smalltalk: you must learn the class library before you can start making new
classes. The Smalltalk class hierarchy is therefore a single monolithic tree.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1398"
title="Add Comment A1398">Comment</a></sup></p>

<p class=MsoNormal>Classes in Smalltalk usually have a number of things in
common, and they always have <i>some</i> things in common (the characteristics
and behaviors of <b>Object</b>), so you almost never run into a situation in
which you need to inherit from more than one base class. However, with C++ you
can create as many hierarchy trees as you want. Therefore, for logical
completeness the language must be able to combine more than one class at a time—thus
the need for multiple inheritance.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1399"
title="Add Comment A1399">Comment</a></sup></p>

<p class=MsoNormal>It was not a crystal clear, however, that programmers could
not get by without multiple inheritance, and there was (and still is) a lot of
disagreement about whether it is really essential in C++. MI was added in
AT&amp;T <b>cfront</b> release 2.0 and was the first significant change to the
language. Since then, a number of other features have been added (notably templates
and exceptions) that change the way we think about programming and place MI in
a much less important role. You can think of MI as a “minor” language feature
that is seldom involved in your daily design decisions.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1400"
title="Add Comment A1400">Comment</a></sup></p>

<p class=MsoNormal>One of the most pressing issues at the time that drove MI
involved containers. Suppose you want to create a container that everyone can
easily use. One approach is to use <b>void*</b> as the type inside the
container. The Smalltalk approach, however, is to make a container that holds <b>Object</b>s.
(Remember that <b>Object</b> is the base type of the entire Smalltalk
hierarchy.) Because everything in Smalltalk is ultimately derived from <b>Object</b>,
any container that holds <b>Object</b>s can hold anything. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1401"
title="Add Comment A1401">Comment</a></sup></p>

<p class=MsoNormal>Now consider the situation in C++. Suppose vendor <b>A</b>
creates an object-based hierarchy that includes a useful set of containers
including one you want to use called <b>Holder</b>. Now you come across vendor <b>B</b>’s
class hierarchy that contains some other class that is important to you, a <b>BitImage</b>
class, for example, that holds graphic images. The only way to make a <b>Holder</b>
of <b>BitImage</b>s is to derive a new class from both <b>Object</b>, so it can
be held in the <b>Holder</b>, and <b>BitImage</b>:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1402"
title="Add Comment A1402">Comment</a></sup></p>

<p class=Figure align=center style='text-align:center'><img border=0 width=329
height=163 src="TicV2_files/image010.gif"></p>

<p class=MsoNormal><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1403"
title="Add Comment A1403">Comment</a></sup></p>

<p class=MsoNormal>This was seen as an important reason for MI, and a number of
class libraries were built on this model. However, as you saw in Chapter 5, the
addition of templates has changed the way containers are created, so this
situation isn’t a driving issue for MI.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1404"
title="Add Comment A1404">Comment</a></sup></p>

<p class=MsoNormal>The other reason you may need MI is related to design. You
can intentionally use MI to make a design more flexible or useful (or at least
seemingly so). An example of this is in the original <b>iostream</b> library
design (which still persists in today’s template design, as you saw in Chapter
4):<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1405"
title="Add Comment A1405">Comment</a></sup></p>

<p class=MsoNormal align=center style='text-align:center'><img border=0
width=326 height=205 src="TicV2_files/image011.gif"><sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1406"
title="Add Comment A1406">Comment</a></sup></p>

<p class=MsoNormal>Both <b>istream</b> and <b>ostream</b> are useful classes by
themselves, but they can also be derived from simultaneously by a class that
combines both their characteristics and behaviors. The class <b>ios</b>
provides what is common to all stream classes, and so in this case MI is a
code-factoring mechanism. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1407"
title="Add Comment A1407">Comment</a></sup></p>

<p class=MsoNormal>Regardless of what motivates you to use MI, it’s harder to
use than it might appear. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1408"
title="Add Comment A1408">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440157">Interface inheritance</a></h2>

<p class=MsoNormal>One use of multiple inheritance that is not controversial
pertains to <i>interface inheritance</i>. In C++, all inheritance is <i>implementation
inheritance</i>, because everything in a base class, interface and
implementation, becomes part of a derived class. It is not possible to inherit
only part of a class (the interface alone, say). As Chapter 14 of Volume 1
explains, private and protected inheritance make it possible to restrict access
to members inherited from base classes when used by clients of a derived class
object, but this doesn’t affect the derived class; it still contains all base
class data and can access all non-private base class members. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1688"
title="Add Comment A1688">Comment</a></sup></p>

<p class=MsoNormal>Interface inheritance, on the other hand, only adds member
function declarations to a derived class interface and is not directly
supported in C++. The usual technique to simulate interface inheritance in C++
is to derive from an <i>interface class</i>, which is a class that contains
only declarations (no data or function bodies). These declarations will be pure
virtual functions, of course. Here is an example. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1689"
title="Add Comment A1689">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Interfaces.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Multiple interface inheritance</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Printable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Printable() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual void print(ostream&amp;)
const = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Intable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Intable() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual int toInt() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Stringable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Stringable() {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual string toString() const =
0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Able : public Printable,</p>

<p class=CodeChar style='margin-left:0in'>             public Intable,</p>

<p class=CodeChar style='margin-left:0in'>             public Stringable {</p>

<p class=CodeChar style='margin-left:0in'>  int myData;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Able(int x) {</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>myData = x;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  void
print(ostream&amp; os) const {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    os &lt;&lt; myData;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>}</p>

<p class=CodeChar style='margin-left:0in'>  int toInt() const {</p>

<p class=CodeChar style='margin-left:0in'>    return myData;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>}</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  string toString()
const {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    ostringstream os;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    os &lt;&lt; myData;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>return
os.str();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void testPrintable(const
Printable&amp; p) {</p>

<p class=CodeChar style='margin-left:0in'>  p.print(cout);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void testIntable(const Intable&amp;
n) {</p>

<p class=CodeChar style='margin-left:0in'>  int i = n.toInt() + 1;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void testStringable(const Stringable&amp;
s) {</p>

<p class=CodeChar style='margin-left:0in'>  string buf = s.toString() +
&quot;th&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; buf &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Able a(7);</p>

<p class=CodeChar style='margin-left:0in'>  testPrintable(a);</p>

<p class=CodeChar style='margin-left:0in'>  testIntable(a);</p>

<p class=CodeChar style='margin-left:0in'>  testStringable(a);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1690"
title="Add Comment A1690"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Only pure virtual functions are inherited from classes <b>Printable</b>,
<b>Intable</b>, and <b>Stringable</b>, which must therefore be implemented in
derived class overrides, which the <b>Able</b> class provides. This gives <b>Able</b>
objects multiple “is-a” relationships. The object <b>a</b> can act as a <b>Printable</b>
object because its class <b>Able</b> derives publicly from <b>Printable</b> and
provides an implementation for <b>print(&nbsp;)</b>. The test functions have no
need to know the most-derived type of their parameter; they just need an object
that is substitutable for their parameter’s type. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1691"
title="Add Comment A1691">Comment</a></sup></p>

<p class=MsoNormal>As usual, a template solution is more compact:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Interfaces2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Implicit interface inheritance via
templates</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;sstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Able {</p>

<p class=CodeChar style='margin-left:0in'>  int myData;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Able(int x) {</p>

<p class=CodeChar style='margin-left:0in'>    myData = x;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void print(ostream&amp; os) const {</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; myData;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int toInt() const {</p>

<p class=CodeChar style='margin-left:0in'>    return myData;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>}</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  string toString()
const {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    ostringstream os;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    os &lt;&lt; myData;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>return
os.str();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Printable&gt;</p>

<p class=CodeChar style='margin-left:0in'>void testPrintable(const
Printable&amp; p) {</p>

<p class=CodeChar style='margin-left:0in'>  p.print(cout);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Intable&gt;</p>

<p class=CodeChar style='margin-left:0in'>void testIntable(const Intable&amp;
n) {</p>

<p class=CodeChar style='margin-left:0in'>  int i = n.toInt() + 1;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; i &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Stringable&gt;</p>

<p class=CodeChar style='margin-left:0in'>void testStringable(const
Stringable&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>  string buf = s.toString() +
&quot;th&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; buf &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Able a(7);</p>

<p class=CodeChar style='margin-left:0in'>  testPrintable(a);</p>

<p class=CodeChar style='margin-left:0in'>  testIntable(a);</p>

<p class=CodeChar style='margin-left:0in'>  testStringable(a);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1692"
title="Add Comment A1692"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The names <b>Printable</b>, <b>Intable,</b> and <b>Stringable</b>
are now just template parameters that assume the existence of the operations
indicated in their respective contexts. Some people are more comfortable with
the first version, because the type names guarantee by inheritance that the
expected interfaces are implemented. Others are content with the fact that if
the operations required by the test functions are not satisfied by their
template type arguments, the error is still caught at compile time. The latter
approach is technically a “weaker” form of type checking than the former
(inheritance) approach, but the effect on the programmer (and the program) is
the same. This is one form of weak typing that is acceptable to many of today’s
C++ programmers. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1693"
title="Add Comment A1693">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440158">Implementation inheritance</a></h2>

<p class=MsoNormal>As we stated earlier, C++ provides only implementation
inheritance, meaning that you inherit everything from all your base classes.
This can be a good thing, of course, because it frees you from having to
implement <i>everything</i> in the derived class, as we had to do with the
interface inheritance examples earlier. A common use of multiple inheritance
involves using <i>mixin classes</i>, which are classes not intended to be
instantiated independently, but exist to add capabilities to other classes
through inheritance. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1694"
title="Add Comment A1694">Comment</a></sup></p>

<p class=MsoNormal>As an example, suppose we are clients of a class that
supports access to a database. We will likely only have a header file available
(which is part of the point we are about to make), but for illustration, assume
the following, simple implementation of a <b>Database</b> class: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1695"
title="Add Comment A1695">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Database.h</p>

<p class=CodeChar style='margin-left:0in'>// A prototypical resource class</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DATABASE_H</p>

<p class=CodeChar style='margin-left:0in'>#define DATABASE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::cout;</p>

<p class=CodeChar style='margin-left:0in'>using std::string;</p>

<p class=CodeChar style='margin-left:0in'>using std::runtime_error;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct DatabaseError : runtime_error
{</p>

<p class=CodeChar style='margin-left:0in'>  DatabaseError(const string&amp;
msg) : runtime_error(msg)</p>

<p class=CodeChar style='margin-left:0in'>  {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Database {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Database(const string&amp; dbStr) :
dbid(dbStr) {}</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Database(){}</p>

<p class=CodeChar style='margin-left:0in'>  void open() throw(DatabaseError) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;connected to
&quot; &lt;&lt; dbid &lt;&lt; '\n';</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void close() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; dbid &lt;&lt;
&quot; closed\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  //Other database functions...</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  string dbid;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We’re leaving out actual database functionality (storing,
retrieving, and so on), but that’s actually not important here. Using this
class requires a database connection string and that you call <b>Database::open(&nbsp;)</b>
to connect and <b>Database::close(&nbsp;)</b> to disconnect: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1696"
title="Add Comment A1696">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:UseDatabase.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Database.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Database
db(&quot;MyDatabase&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  db.open();</p>

<p class=CodeChar style='margin-left:0in'>  // Use other db functions...</p>

<p class=CodeChar style='margin-left:0in'>  db.close();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>/* Output:</p>

<p class=CodeChar style='margin-left:0in'>connected to MyDatabase</p>

<p class=CodeChar style='margin-left:0in'>MyDatabase closed</p>

<p class=CodeChar style='margin-left:0in'>*/ ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1697"
title="Add Comment A1697"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In a typical client-server situation, a client will have
multiple objects sharing a connection to a database. It is important that the
database eventually be closed, but only after access to it is no longer
required. It is common to encapsulate this behavior through a class that tracks
the number of client entities using the database connection and to
automatically terminate the connection when that count goes to zero. To add
reference counting to the <b>Database</b> class, we create a mixin class named <b>Countable</b>
and mix it into the <b>Database</b> class by creating a new class, <b>DBConnection</b>,
through multiple inheritance. Here’s the <b>Countable</b> mixin class: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1698"
title="Add Comment A1698">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Countable.h</p>

<p class=CodeChar style='margin-left:0in'>// A &quot;mixin&quot; class</p>

<p class=CodeChar style='margin-left:0in'>#ifndef COUNTABLE_H</p>

<p class=CodeChar style='margin-left:0in'>#define COUNTABLE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Countable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  long attach() { return ++count; }</p>

<p class=CodeChar style='margin-left:0in'>  long detach() {</p>

<p class=CodeChar style='margin-left:0in'>    return (--count &gt; 0) ? count :
(delete this, 0);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  long refCount() const { return
count; }</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  Countable() { count = 0; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Countable() { assert(count
== 0); }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  long count;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1699"
title="Add Comment A1699"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>It is evident that this is not a standalone class because
its constructor is <b>protected</b>; it therefore requires a friend or a
derived class to use it. It is important that the destructor is virtual, of
course, because it is called only from the <b>delete this</b> statement in <b>detach(&nbsp;)</b>,
and we of course want derived objects to be completely destroyed<a
href="#_ftn94" name="_ftnref94" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[94]</span></sup></span></span></sup></span></a>. The <b>DBConnection</b>
class derives from both <b>Database</b> and <b>Countable</b> and provides a
static <b>create(&nbsp;)</b> function that initializes its <b>Countable</b>
subobject. (This is an example of the Factory Method design pattern, discussed
in the next chapter.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1700"
title="Add Comment A1700">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:DBConnection.h</p>

<p class=CodeChar style='margin-left:0in'>// Uses a &quot;mixin&quot; class</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DBCONNECTION_H</p>

<p class=CodeChar style='margin-left:0in'>#define DBCONNECTION_H</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Countable.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Database.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::string;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DBConnection : public Database,
public Countable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static DBConnection* create(const
string&amp; dbStr)</p>

<p class=CodeChar style='margin-left:0in'>  throw(DatabaseError) {</p>

<p class=CodeChar style='margin-left:0in'>    DBConnection* con = new
DBConnection(dbStr);</p>

<p class=CodeChar style='margin-left:0in'>    con-&gt;attach();</p>

<p class=CodeChar style='margin-left:0in'>    assert(con-&gt;refCount() == 1);</p>

<p class=CodeChar style='margin-left:0in'>    return con;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>// Other added functionality as
desired...</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection(const string&amp;
dbStr) throw(DatabaseError)</p>

<p class=CodeChar style='margin-left:0in'>  : Database(dbStr) {</p>

<p class=CodeChar style='margin-left:0in'>    open();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~DBConnection() {</p>

<p class=CodeChar style='margin-left:0in'>    close();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  // Disallow copy</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection(const
DBConnection&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection&amp; operator=(const
DBConnection&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1701"
title="Add Comment A1701"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>We now have a reference-counted database connection without
modifying the <b>Database</b> class, and we can safely assume that it will not
be surreptitiously terminated. The opening and closing is done using the
Resource Acquisition Is Initialization idiom (RAII) mentioned in Chapter 1 via
the <b>DBConnection</b> constructor and destructor. This makes using a <b>DBConnection</b>
easy to use, as the following program shows. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1702"
title="Add Comment A1702">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:UseDatabase2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Tests the Countable
&quot;mixin&quot; class</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DBConnection.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DBClient {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  DBClient(DBConnection* dbCon) {</p>

<p class=CodeChar style='margin-left:0in'>    db = dbCon;</p>

<p class=CodeChar style='margin-left:0in'>    db-&gt;attach();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~DBClient() {</p>

<p class=CodeChar style='margin-left:0in'>    db-&gt;detach();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Other database requests using
db…</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection* db;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection* db =
DBConnection::create(&quot;MyDatabase&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 1);</p>

<p class=CodeChar style='margin-left:0in'>  DBClient c1(db);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 2);</p>

<p class=CodeChar style='margin-left:0in'>  DBClient c2(db);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 3);</p>

<p class=CodeChar style='margin-left:0in'>  // Use database, then release
attach from original create</p>

<p class=CodeChar style='margin-left:0in'>  db-&gt;detach();</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 2);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1703"
title="Add Comment A1703"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The call to <b>DBConnection::create(&nbsp;)</b> calls <b>attach(&nbsp;)</b>,
so when we’re finished, we must explicitly call <b>detach(&nbsp;)</b> to
release the original hold on the connection. Note that the <b>DBClient</b>
class also uses RAII to manage its use of the connection. When the program
terminates, the destructors for the two <b>DBClient</b> objects will decrement
the reference count (by calling <b>detach(&nbsp;)</b>, which <b>DBConnection</b>
inherited from <b>Countable</b>), and the database connection will be closed
when the count reaches zero after the object <b>c1</b> is destroyed. (This is
because of <b>Countable</b>’s virtual destructor, as we explained earlier.) <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1704"
title="Add Comment A1704">Comment</a></sup></p>

<p class=MsoNormal>A template approach is commonly used for mixin inheritance,
allowing the user to specify at compile time which flavor of mixin is desired.
This way you can use different reference-counting approaches without explicitly
defining <b>DBConnection</b> twice. Here’s how it’s done. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1705"
title="Add Comment A1705">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:DBConnection2.h</p>

<p class=CodeChar style='margin-left:0in'>// A parameterized mixin</p>

<p class=CodeChar style='margin-left:0in'>#ifndef DBCONNECTION_H</p>

<p class=CodeChar style='margin-left:0in'>#define DBCONNECTION_H</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Database.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using std::string;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class Counter&gt;</p>

<p class=CodeChar style='margin-left:0in'>class DBConnection : public Database,
public Counter {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static DBConnection* create(const
string&amp; dbStr)</p>

<p class=CodeChar style='margin-left:0in'>  throw(DatabaseError) {</p>

<p class=CodeChar style='margin-left:0in'>    DBConnection* con = new
DBConnection(dbStr);</p>

<p class=CodeChar style='margin-left:0in'>    con-&gt;attach();</p>

<p class=CodeChar style='margin-left:0in'>    assert(con-&gt;refCount() == 1);</p>

<p class=CodeChar style='margin-left:0in'>    return con;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>// Other added functionality as
desired...</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection(const string&amp;
dbStr) throw(DatabaseError)</p>

<p class=CodeChar style='margin-left:0in'>  : Database(dbStr) {</p>

<p class=CodeChar style='margin-left:0in'>    open();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~DBConnection() {</p>

<p class=CodeChar style='margin-left:0in'>    close();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  // Disallow copy</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection(const
DBConnection&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection&amp; operator=(const
DBConnection&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1706"
title="Add Comment A1706"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The only change here is the template prefix to the class
definition (and renaming <b>Countable</b> to <b>Counter</b> for clarity). We
could also make the database class a template parameter (had we multiple
database access classes to choose from), but it is not a mixin, per se, since
it is a standalone class. The following example uses the original <b>Countable</b>
as the <b>Counter</b> mixin type, but we could use any type that implements the
appropriate interface (<b>attach(&nbsp;)</b>, <b>detach(&nbsp;)</b>, and so
on). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1707"
title="Add Comment A1707">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:UseDatabase3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Tests a parameterized
&quot;mixin&quot; class</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Countable.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;DBConnection2.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class DBClient {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'> 
DBClient(DBConnection&lt;Countable&gt;* dbCon) {</p>

<p class=CodeChar style='margin-left:0in'>    db = dbCon;</p>

<p class=CodeChar style='margin-left:0in'>    db-&gt;attach();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~DBClient() {</p>

<p class=CodeChar style='margin-left:0in'>    db-&gt;detach();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection&lt;Countable&gt;* db;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  DBConnection&lt;Countable&gt;* db =
</p>

<p class=CodeChar style='margin-left:0in'>    DBConnection&lt;Countable&gt;::create(&quot;MyDatabase&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 1);</p>

<p class=CodeChar style='margin-left:0in'>  DBClient c1(db);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 2);</p>

<p class=CodeChar style='margin-left:0in'>  DBClient c2(db);</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 3);</p>

<p class=CodeChar style='margin-left:0in'>  db-&gt;detach();</p>

<p class=CodeChar style='margin-left:0in'>  assert(db-&gt;refCount() == 2);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1708"
title="Add Comment A1708"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The general pattern for multiple parameterized mixins is
simply:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>template&lt;class Mixin1, class
Mixin2, … , class MixinK&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Subject : public Mixin1,</p>

<p class=CodeChar style='margin-left:0in'>                public Mixin2,</p>

<p class=CodeChar style='margin-left:0in'>                …</p>

<p class=CodeInlineCharChar style='margin-left:0in'>                public
MixinK {..};</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45440159">Duplicate subobjects</a></h2>

<p class=MsoNormal>When you inherit from a base class, you get a copy of all the data members of that base class in your derived class. The following
program shows how multiple base subobjects might be laid out in memory<a
href="#_ftn95" name="_ftnref95" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[95]</span></sup></span></span></sup></span></a>. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1709"
title="Add Comment A1709">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Offset.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates layout of subobjects
with MI</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class A {</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class B {</p>

<p class=CodeChar style='margin-left:0in'>  int y;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class C : public A, public B {</p>

<p class=CodeChar style='margin-left:0in'>  int z;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;sizeof(A) ==
&quot; &lt;&lt; sizeof(A) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;sizeof(B) ==
&quot; &lt;&lt; sizeof(B) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;sizeof(C) ==
&quot; &lt;&lt; sizeof(C) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  C c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;&amp;c ==
&quot; &lt;&lt; &amp;c &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  A* ap = &amp;c;</p>

<p class=CodeChar style='margin-left:0in'>  B* bp = &amp;c;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;ap == &quot;
&lt;&lt; static_cast&lt;void*&gt;(ap) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;bp == &quot;
&lt;&lt; static_cast&lt;void*&gt;(bp) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  C* cp = static_cast&lt;C*&gt;(bp);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;cp == &quot;
&lt;&lt; static_cast&lt;void*&gt;(cp) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;bp == cp?
&quot; &lt;&lt; boolalpha &lt;&lt; (bp == cp) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cp = 0;</p>

<p class=CodeChar style='margin-left:0in'>  bp = cp;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; bp &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>/* Output:</p>

<p class=CodeChar style='margin-left:0in'>sizeof(A) == 4</p>

<p class=CodeChar style='margin-left:0in'>sizeof(B) == 4</p>

<p class=CodeChar style='margin-left:0in'>sizeof(C) == 12</p>

<p class=CodeChar style='margin-left:0in'>&amp;c == 1245052</p>

<p class=CodeChar style='margin-left:0in'>ap == 1245052</p>

<p class=CodeChar style='margin-left:0in'>bp == 1245056</p>

<p class=CodeChar style='margin-left:0in'>cp == 1245052</p>

<p class=CodeChar style='margin-left:0in'>bp == cp? true</p>

<p class=CodeChar style='margin-left:0in'>0</p>

<p class=CodeInlineCharChar style='margin-left:0in'>*/ ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1710"
title="Add Comment A1710"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>As you can see, the <b>B</b> portion of the object <b>c</b>
is offset 4 bytes from the beginning of the entire object, suggesting the
following layout:</p>

<p class=MsoNormal><img border=0 width=95 height=169
src="TicV2_files/image012.gif"></p>

<p class=MsoNormal>The object <b>c</b> begins with it’s <b>A</b> subobject,
then the <b>B</b> portion, and finally the data from the complete type <b>C</b>
itself. Since a <b>C</b> is-an <b>A</b> and is-a <b>B</b>, it is possible to upcast
to either base type. When upcasting to an A, the resulting pointer points to
the A portion, which happens to be at the beginning of the C object, so the
address <b>ap</b> is the same as the expression <b>&amp;c</b>. When upcasting
to a <b>B</b>, however, the resulting pointer must point to where the <b>B</b>
subobject actually resides, because class B knows nothing about class <b>C</b>
(or class <b>A</b>, for that matter). In other words, the object pointed to by <b>bp</b>
must be able to behave as a standalone <b>B</b> object (except for any required
polymorphic behavior, of course). <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1711"
title="Add Comment A1711">Comment</a></sup></p>

<p class=MsoNormal>When casting <b>bp</b> back to a <b>C*</b>, since the
original object was a <b>C</b> in the first place, the location where the <b>B</b>
subobject resides is known, so the pointer is adjusted back to the original
address of the complete object. If <b>bp</b> had been pointing to a standalone <b>B</b>
object instead of a <b>C</b> object in the first place, the cast would be
illegal.<a href="#_ftn96" name="_ftnref96" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[96]</span></sup></span></span></sup></span></a> Furthermore,
in the comparison <b>bp == cp</b>, <b>cp</b> is implicitly converted to a <b>B*</b>,
since that is the only way to make the comparison meaningful in general (that
is, upcasting is always allowed), hence the <b>true</b> result. So when
converting back and forth between subobjects and complete types, the appropriate
offset is applied. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1712"
title="Add Comment A1712">Comment</a></sup></p>

<p class=MsoNormal>The null pointer requires special handling, obviously, since
blindly subtracting an offset when converting to or from a <b>B</b> subobject
will result in an invalid address if the pointer was zero to start with. For
this reason, when casting to or from a <b>B*</b>, the compiler generates logic
to check first to see if the pointer is zero. If it isn’t, it applies the
offset; otherwise, it leaves it as zero. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1713"
title="Add Comment A1713">Comment</a></sup></p>

<p class=MsoNormal>With the syntax we’ve seen so far, if you have multiple base
classes, and if those base classes in turn have a common base class, you will
have two copies of the top-level base, as you can see in the following example.
<sup><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1714"
title="Add Comment A1714">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Duplicate.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Shows duplicate subobjects</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Top {</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Top(int n) { x = n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int y;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Left(int m, int n) : Top(m) { y =
n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int z;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Right(int m, int n) : Top(m) { z =
n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {</p>

<p class=CodeChar style='margin-left:0in'>  int w;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bottom(int i, int j, int k, int m)</p>

<p class=CodeChar style='margin-left:0in'>  : Left(i, k), Right(j, k) { w = m;
}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Bottom b(1, 2, 3, 4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; sizeof b &lt;&lt;
endl; // 20</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1715"
title="Add Comment A1715"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since the size of <b>b</b> is 20 bytes<a href="#_ftn97"
name="_ftnref97" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[97]</span></sup></span></span></sup></span></a>, there are five
integers altogether in a complete <b>Bottom</b> object. A typical class diagram
for this scenario usually appears as:</p>

<p class=MsoNormal><img border=0 width=363 height=219
src="TicV2_files/image013.gif"></p>

<p class=MsoNormal>This is the so-called “diamond inheritance”, but in this
case it would be better rendered as: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1716"
title="Add Comment A1716">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=342 height=206
src="TicV2_files/image014.gif"></p>

<p class=MsoNormal>The awkwardness of this design surfaces in the constructor
for the <b>Bottom</b> class in the previous code. The user thinks that only
four integers are required, but which arguments should be passed to the two
parameters that <b>Left</b> and <b>Right</b> require? Although this design is
not inherently “wrong,” it is usually not what an application calls for. It
also presents a problem when trying to convert a pointer to a <b>Bottom</b>
object to a pointer to <b>Top</b>. As we showed earlier, the address may need
to be adjusted, depending on where the subobject resides within the complete
object, but in this case there are <i>two</i> <b>Top</b> subobjects to choose
from. The compiler doesn’t know which to choose, so such an upcast is ambiguous
and therefore not allowed. The same reasoning explains why a <b>Bottom</b>
object would not be able to call a function that is only defined in <b>Top</b>.
If such a function <b>Top::f(&nbsp;)</b> existed, calling <b>b.f(&nbsp;)</b>
above would need to refer to a <b>Top</b> subobject as a context in which to
execute, and there are two to choose between. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1717"
title="Add Comment A1717">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440160">Virtual base classes</a></h2>

<p class=MsoNormal>What we usually want in such cases is <i>true</i> diamond
inheritance, in which a single <b>Top</b> object is shared by both <b>Left</b>
and <b>Right</b> subobjects within a complete <b>Bottom</b> object, which is
what the first class diagram depicts. This is achieved by making <b>Top</b> a <i>virtual
base class</i> of <b>Left</b> and <b>Right</b>: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1718"
title="Add Comment A1718">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:VirtualBase.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Shows a shared subobject via a
virtual base</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Top {</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Top(int n) { x = n; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Top(){}</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Top&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; t.x;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  int y;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Left(int m, int n) : Top(m) { y =
n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  int z;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Right(int m, int n) : Top(m) { z =
n; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {</p>

<p class=CodeChar style='margin-left:0in'>  int w;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bottom(int i, int j, int k, int m)</p>

<p class=CodeChar style='margin-left:0in'>  : Top(i), Left(0, j), Right(0, k) {
w = m; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Bottom&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; b.x &lt;&lt;
',' &lt;&lt; b.y &lt;&lt; ',' &lt;&lt; b.z</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; ',' &lt;&lt; b.w;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Bottom b(1, 2, 3, 4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; sizeof b &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
static_cast&lt;void*&gt;(&amp;b) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  Top* p =
static_cast&lt;Top*&gt;(&amp;b);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; *p &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
static_cast&lt;void*&gt;(p) &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; dynamic_cast&lt;void*&gt;(p)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1719"
title="Add Comment A1719"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each virtual base of a given type refers to the same object,
no matter where it appears in the hierarchy<a href="#_ftn98" name="_ftnref98"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[98]</span></sup></span></span></sup></span></a>.
This means that when a <b>Bottom</b> object is instantiated, the object layout
may look something like this: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1720"
title="Add Comment A1720">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=170 height=243
src="TicV2_files/image015.gif"></p>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Left</b> and <b>Right</b> subobjects each have a pointer
(or some conceptual equivalent) to the shared <b>Top</b> subobject, and all
references to that subobject in <b>Left</b> and <b>Right</b> member functions
will go through those these pointers.<a href="#_ftn99" name="_ftnref99" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[99]</span></sup></span></span></sup></span></a> In
this case, there is no ambiguity when upcasting from a <b>Bottom</b> to a <b>Top</b>
object, since there is only one <b>Top</b> object to convert to. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1721"
title="Add Comment A1721">Comment</a></sup></p>

<p class=MsoNormal>The output of the previous program is as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>36</p>

<p class=CodeChar style='margin-left:0in'>1,2,3,4</p>

<p class=CodeChar style='margin-left:0in'>1245032</p>

<p class=CodeChar style='margin-left:0in'>1</p>

<p class=CodeChar style='margin-left:0in'>1245060</p>

<p class=CodeInlineCharChar style='margin-left:0in'>1245032</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The addresses printed suggest that this particular
implementation does indeed store the <b>Top</b> subobject at the end of the
complete object (although it’s not really important where it goes). The result
of a <b>dynamic_cast</b> to <b>void*</b> always resolves to the address of the
complete object. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1722"
title="Add Comment A1722">Comment</a></sup></p>

<p class=MsoNormal>We made the <b>Top</b> destructor virtual so we could apply
the <b>dynamic_cast</b> operator. If you remove that virtual destructor (and
the <b>dynamic_cast</b> statement so the program will compile), the size of <b>Bottom</b>
decreases to 24 bytes. That seems to be a decrease equivalent to the size of
three pointers. What gives? <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1723"
title="Add Comment A1723">Comment</a></sup></p>

<p class=MsoNormal>It’s important not to take these numbers too literally.
Other compilers we use manage only to increase the size by four bytes when the
virtual constructor is added. Not being compiler writers, we can’t tell you their
secrets. We can tell you, however, that with multiple inheritance, a derived
object must behave as if it has multiple VPTRs, one for each of its direct base
classes that also have virtual functions. It’s as simple as that. Compilers can
make whatever optimizations its authors can invent, but the behavior must be
the same. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1724"
title="Add Comment A1724">Comment</a></sup></p>

<p class=MsoNormal>Certainly the strangest thing in the previous code is the
initializer for <b>Top</b> in the <b>Bottom</b> constructor. Normally one
doesn’t worry about initializing subobjects beyond direct base classes, since
all classes take care of initializing their own bases. There are, however,
multiple paths from <b>Bottom</b> to <b>Top</b>, so relying on the intermediate
classes <b>Left</b> and <b>Right</b> to pass along the necessary initialization
data results in an ambiguity (whose responsibility is it?)! For this reason, it
is always the responsibility of the <i>most derived class</i> to initialize a
virtual base. But what about the expressions in the <b>Left</b> and <b>Right</b>
constructors that also initialize <b>Top</b>? They are certainly necessary when
creating standalone <b>Left</b> or <b>Right</b> objects, but must be <i>ignored</i>
when a <b>Bottom</b> object is created (hence the zeros in their initializers
in the <b>Bottom</b> constructor—any values in those slots are ignored when the
<b>Left</b> and <b>Right</b> constructors execute in the context of a <b>Bottom</b>
object). The compiler takes care of all this for you, but it’s important to
understand where the responsibility lies. Always make sure that <i>all concrete
(nonabstract) classes</i> in a multiple inheritance hierarchy are aware of any
virtual bases and initialize them appropriately. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1725"
title="Add Comment A1725">Comment</a></sup></p>

<p class=MsoNormal>These rules of responsibility apply not only to
initialization but to all operations that span the class hierarchy. Consider
the stream inserter in the previous code. We made the data protected so we
could “cheat” and access inherited data in <b>operator&lt;&lt;(ostream&amp;,
const Bottom&amp;)</b>. It usually makes more sense to assign the work of
printing each subobject to its corresponding class and have the derived class
call its base class functions as needed. What would happen if we tried that
with <b>operator&lt;&lt;(&nbsp;)</b>, as the following code illustrates? <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1726"
title="Add Comment A1726">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:VirtualBase2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Shows how not to implement
operator&lt;&lt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Top {</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Top(int n) { x = n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Top&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; t.x;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int y;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Left(int m, int n) : Top(m) { y =
n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Left&amp; l) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
static_cast&lt;const Top&amp;&gt;(l) &lt;&lt; ',' &lt;&lt; l.y;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int z;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Right(int m, int n) : Top(m) { z =
n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Right&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
static_cast&lt;const Top&amp;&gt;(r) &lt;&lt; ',' &lt;&lt; r.z;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {</p>

<p class=CodeChar style='margin-left:0in'>  int w;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bottom(int i, int j, int k, int m)</p>

<p class=CodeChar style='margin-left:0in'>  : Top(i), Left(0, j), Right(0, k) {
w = m; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Bottom&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
static_cast&lt;const Left&amp;&gt;(b)</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; ',' &lt;&lt;
static_cast&lt;const Right&amp;&gt;(b)</p>

<p class=CodeChar style='margin-left:0in'>      &lt;&lt; ',' &lt;&lt; b.w;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Bottom b(1, 2, 3, 4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b &lt;&lt; endl;  //
1,2,1,3,4</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>You can’t just blindly share the responsibility upward in
the usual fashion because the <b>Left</b> and <b>Right</b> stream inserters
each call the <b>Top</b> inserter, and again there will be duplication of data.
Instead you need to mimic what the compiler automatically does with
initialization. One solution is to provide special functions in the classes
that know about the virtual base class, which ignore the virtual base when
printing (leaving the job to the most derived class): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1727"
title="Add Comment A1727">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:VirtualBase3.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A correct stream inserter</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Top {</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Top(int n) { x = n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Top&amp; t) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; t.x;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int y;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  void specialPrint(ostream&amp; os)
const {</p>

<p class=CodeChar style='margin-left:0in'>    // Only print Left's part</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; ','&lt;&lt; y;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Left(int m, int n) : Top(m) { y =
n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Left&amp; l) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
static_cast&lt;const Top&amp;&gt;(l) &lt;&lt; ',' &lt;&lt; l.y;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>  int z;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  void specialPrint(ostream&amp; os)
const {</p>

<p class=CodeChar style='margin-left:0in'>    // Only print Right's part</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; ','&lt;&lt; z;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Right(int m, int n) : Top(m) { z =
n; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Right&amp; r) {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
static_cast&lt;const Top&amp;&gt;(r) &lt;&lt; ',' &lt;&lt; r.z;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {</p>

<p class=CodeChar style='margin-left:0in'>  int w;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bottom(int i, int j, int k, int m)</p>

<p class=CodeChar style='margin-left:0in'>  : Top(i), Left(0, j), Right(0, k) {
w = m; }</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Bottom&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>    os &lt;&lt; static_cast&lt;const
Top&amp;&gt;(b);</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>b.Left::specialPrint(os);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>   
b.Right::specialPrint(os);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>    </span>return os
&lt;&lt; ',' &lt;&lt; b.w;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Bottom b(1, 2, 3, 4);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; b &lt;&lt; endl;  //
1,2,3,4</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~ <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1728"
title="Add Comment A1728"><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></a></sup></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>specialPrint(&nbsp;)</b> functions are <b>protected</b>
since they will be called only by <b>Bottom</b>. They print only their own data
and ignore their <b>Top</b> subobject, because the <b>Bottom</b> inserter is in
control when these functions are called. The <b>Bottom</b> inserter must know
about the virtual base, just as a <b>Bottom</b> constructor needs to. This same
reasoning applies to assignment operators in a hierarchy with a virtual base,
as well as to any function, member or not, that wants to share the work
throughout all classes in the hierarchy. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1729"
title="Add Comment A1729">Comment</a></sup></p>

<p class=MsoNormal>Having discussed virtual base classes, we can now illustrate
the “full story” of object initialization. Since virtual bases give rise to
shared subojects, it makes sense that they should be available before the
sharing takes place. Therefore, the order of initialization of subobjects
follows these rules (recursively, as needed, of course): <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1730"
title="Add Comment A1730">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All virtual base class subobjects are initialized, in top-down,
left-to-right order according to where they appear in class definitions.</p>

<p class=Numbered><span style='font-family:Verdana'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Non-virtual base classes are then initialized in the usual order.</p>

<p class=Numbered><span style='font-family:Verdana'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All member objects are initialized in declaration order.</p>

<p class=Numbered><span style='font-family:Verdana'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The complete object’s constructor executes.</p>

<p class=Numbered>The following program illustrates this behavior. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1731"
title="Add Comment A1731">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:VirtInit.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates initialization order
with virtual bases</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class M {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  M(const string&amp; s) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;M &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class A{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  A(const string&amp; s) : m(&quot;in
A&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>     cout &lt;&lt; &quot;A &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class B</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  B(const string&amp; s) : m(&quot;in
B&quot;)  {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;B &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class C</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  C(const string&amp; s) : m(&quot;in
C&quot;)  {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;C &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class D</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  D(const string&amp; s) : m(&quot;in
D&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;D &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class E : public A, virtual public B,
virtual public C</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  E(const string&amp; s)</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=IT>: A(&quot;from
E&quot;), B(&quot;from E&quot;), C(&quot;from E&quot;), m(&quot;in E&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>    </span>cout
&lt;&lt; &quot;E &quot; &lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class F : virtual public B, virtual
public C, public D</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  F(const string&amp; s)</p>

<p class=CodeChar style='margin-left:0in'>  : B(&quot;from F&quot;),
C(&quot;from F&quot;), D(&quot;from F&quot;), m(&quot;in F&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;F &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class G : public E, public F</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  M m;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  G(const string&amp; s)</p>

<p class=CodeChar style='margin-left:0in'>  : B(&quot;from G&quot;), C(&quot;from
G&quot;), E(&quot;from G&quot;),</p>

<p class=CodeChar style='margin-left:0in'>    F(&quot;from G&quot;), m(&quot;in
G&quot;) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;G &quot;
&lt;&lt; s &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  G g(&quot;from main&quot;);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The classes in this code can be represented by the following
diagram: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1732"
title="Add Comment A1732">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=555 height=269
src="TicV2_files/image016.gif"></p>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Each class has an embedded member of type <b>M</b>. Note
that only four derivations are virtual: <b>E</b> from <b>B</b> and <b>C</b>,
and <b>F</b> from <b>B</b> and <b>C</b>. The output of this program is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>M in B</p>

<p class=CodeChar style='margin-left:0in'>B from G</p>

<p class=CodeChar style='margin-left:0in'>M in C</p>

<p class=CodeChar style='margin-left:0in'>C from G</p>

<p class=CodeChar style='margin-left:0in'>M in A</p>

<p class=CodeChar style='margin-left:0in'>A from E</p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>M in E</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>E from G</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>M in D</span></p>

<p class=CodeChar style='margin-left:0in'>D from F</p>

<p class=CodeChar style='margin-left:0in'>M in F</p>

<p class=CodeChar style='margin-left:0in'>F from G</p>

<p class=CodeChar style='margin-left:0in'>M in G</p>

<p class=CodeChar style='margin-left:0in'>G from main</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The initialization of <b>g</b> requires its <b>E</b> and <b>F</b>
part to first be initialized, but the <b>B</b> and <b>C</b> subobjects are
initialized first, because they are virtual bases, and are initialized from <b>G</b>’s
initializer, <b>G</b> being the most-derived class. The class <b>B</b> has no
base classes, so according to rule 3, its member object <b>m</b> is
initialized, then its constructor prints “<b>B</b> from <b>G</b>”, and
similarly for the <b>C</b> subject of <b>E</b>. The <b>E</b> subobject requires
<b>A</b>, <b>B</b>, and <b>C</b> subobjects. Since <b>B</b> and <b>C</b> have
already been initialized, the <b>A</b> subobject of the <b>E</b> subobject is
initialized next, and then the <b>E</b> subobject itself. The same scenario
repeats for <b>g</b>’s <b>F</b> subobject, but without duplicating the
initialization of the virtual bases. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1733"
title="Add Comment A1733">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440161">Name lookup issues</a></h2>

<p class=MsoNormal>The ambiguities we have illustrated with subobjects apply,
of course, to any names, including function names. If a class has multiple
direct base classes that share member functions of the same name, and you call
one of those member functions, the compiler doesn’t know which one to choose.
The following sample program would report such an error. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1734"
title="Add Comment A1734">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>// C09:AmbiguousName.cpp</p>

<p class=CodeChar style='margin-left:0in'>class Top {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   Bottom b;</p>

<p class=CodeChar style='margin-left:0in'>   b.f();     // error here</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The class <b>Bottom</b> has inherited two functions of the
same name (the signature is irrelevant, since name lookup occurs before
overload resolution), and there is no way to choose between them. The usual
technique to disambiguate the call is to qualify the function call with the
base class name: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1735"
title="Add Comment A1735">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:BreakTie.cpp</p>

<p class=CodeChar style='margin-left:0in'>class Top {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  using Left::f;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   Bottom b;</p>

<p class=CodeChar style='margin-left:0in'>   b.f();     // calls Left::f()</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The name <b>Left::f</b> is now found in the scope of <b>Bottom</b>,
so the name <b>Right::f</b> is not even considered. Of course, if you want to
introduce extra functionality beyond what <b>Left::f(&nbsp;)</b> provides, you
would implement a <b>Bottom::f(&nbsp;)</b> function that calls <b>Left::f(&nbsp;)</b>,
in addition to other things. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1736"
title="Add Comment A1736">Comment</a></sup></p>

<p class=MsoNormal>Functions with the same name occurring in different branches
of a hierarchy often conflict. The following hierarchy has no such problem: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1737"
title="Add Comment A1737">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Dominance.cpp</p>

<p class=CodeChar style='margin-left:0in'>class Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void f() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Left : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f(){}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Right : virtual public Top {</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bottom : public Left, public
Right {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>   Bottom b;</p>

<p class=CodeChar style='margin-left:0in'>   b.f(); // calls Left::f()</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this case, there is no explicit <b>Right::f(&nbsp;)</b>,
so <b>Left::f(&nbsp;)</b>, being the most derived, is chosen. Why? Well,
pretend that <b>Right</b> did not exist, giving the single-inheritance
hierarchy <b>Top &lt;= Left &lt;= Bottom</b>. You would certainly expect <b>Left::f(&nbsp;)</b>
to be the function called by the expression <b>b.f(&nbsp;)</b>, because of
normal scope rules (a derived class is considered a nested scope of a base
class). In general, a name <b>A::f</b> is said to <i>dominate</i> the name <b>B::f</b>
if <b>A</b> derives from <b>B</b>, directly or indirectly, or in other words,
if <b>A</b> is “more derived” in the hierarchy than <b>B.</b><a href="#_ftn100"
name="_ftnref100" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[100]</span></sup></span></span></sup></span></a> To summarize: in
choosing between two functions with the same name, one of which dominates the
other, the compiler chooses the one that dominates. If there is no dominant
function, there is an ambiguity. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1844"
title="Add Comment A1844">Comment</a></sup></p>

<p class=MsoNormal> The following program further illustrates the dominance
principle. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1738"
title="Add Comment A1738">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Dominance2.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class A {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   virtual void f() {cout &lt;&lt;
&quot;A::f\n&quot;;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class B : virtual public A {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>   void f() {cout &lt;&lt;
&quot;B::f\n&quot;;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class C : public B {};</p>

<p class=CodeChar style='margin-left:0in'>class D : public C, virtual public A
{};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main()</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>   B* p = new D;</p>

<p class=CodeChar style='margin-left:0in'>   p-&gt;f();  // calls B::f()</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The class diagram for this hierarchy is as follows. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1739"
title="Add Comment A1739">Comment</a></sup></p>

<p class=MsoNormal><img border=0 width=194 height=301
src="TicV2_files/image017.gif"></p>

<p class=MsoNormal><span class=CodeInlineTrailerCharCharChar><span
style='font-size:3.0pt'>&nbsp;</span></span></p>

<p class=MsoNormal><a name="_Toc312374105">The class <b>A</b> is a (direct, in
this case) base class for <b>B</b>, and so the name <b>B::f</b> dominates <b>A::f</b>.
</a><a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1740"
title="Add Comment A1740"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440162"></a><a name="_Toc312374106"></a><a
name="_Toc305628763"></a><a name="_Toc305593291">Avoiding MI</a></h2>

<p class=MsoNormal>When the question of whether to use multiple inheritance
comes up, you should ask at least two questions: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1451"
title="Add Comment A1451">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Do you need to show the public interfaces of both these classes
through your new type, or could one class be contained within the other, with
only some of its interface exposed in the new class? <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1741"
title="Add Comment A1741">Comment</a></sup></p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Do you need to upcast to both of the base classes? (This applies
when you have more than two base classes, of course.)  <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1742"
title="Add Comment A1742">Comment</a></sup></p>

<p class=MsoNormal>If you can answer “yes” to either question, you can avoid
using MI and should probably do so. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1452"
title="Add Comment A1452">Comment</a></sup></p>

<p class=MsoNormal>One situation to watch for is when one class needs to be
upcast only as a function argument. In that case, the class can be embedded and
an automatic type conversion operator provided in your new class to produce a
reference to the embedded object. Any time you use an object of your new class
as an argument to a function that expects the embedded object, the type
conversion operator is used.<a href="#_ftn101" name="_ftnref101" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[101]</span></sup></span></span></sup></span></a> However,
type conversion can’t be used for normal member selection; that requires
inheritance. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1453"
title="Add Comment A1453">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440163"></a><a name="_Toc312374107"></a><a
name="_Toc305628764"></a><a name="_Toc305593292">Extending an interface</a></h2>

<p class=MsoNormal>One of the best uses for multiple inheritance involves code that’s out of your control. Suppose you’ve acquired a library that consists
of a header file and compiled member functions, but no source code for member
functions. This library is a class hierarchy with virtual functions, and it
contains some global functions that take pointers to the base class of the
library; that is, it uses the library objects polymorphically. Now suppose you
build an application around this library and write your own code that uses the
base class polymorphically. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1456"
title="Add Comment A1456">Comment</a></sup></p>

<p class=MsoNormal>Later in the development of the project or sometime during
its maintenance, you discover that the base-class interface provided by the
vendor doesn’t provide what you need: a function may be non-virtual and you
need it to be virtual, or a virtual function is completely missing in the
interface, but essential to the solution of your problem. Multiple inheritance
is the perfect solution. <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1457"
title="Add Comment A1457">Comment</a></sup></p>

<p class=MsoNormal>For example, here’s the header file for a library you
acquire: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1458"
title="Add Comment A1458">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Vendor.h</p>

<p class=CodeChar style='margin-left:0in'>// Vendor-supplied class header</p>

<p class=CodeChar style='margin-left:0in'>// You only get this &amp; the compiled
Vendor.obj</p>

<p class=CodeChar style='margin-left:0in'>#ifndef VENDOR_H</p>

<p class=CodeChar style='margin-left:0in'>#define VENDOR_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Vendor {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void v() const;</p>

<p class=CodeChar style='margin-left:0in'>  void f() const;</p>

<p class=CodeChar style='margin-left:0in'>  ~Vendor();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Vendor1 : public Vendor {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void v() const;</p>

<p class=CodeChar style='margin-left:0in'>  void f() const;</p>

<p class=CodeChar style='margin-left:0in'>  ~Vendor1();</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void A(const Vendor&amp;);</p>

<p class=CodeChar style='margin-left:0in'>void B(const Vendor&amp;);</p>

<p class=CodeChar style='margin-left:0in'>// Etc.</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // VENDOR_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Assume the library is much bigger, with more derived classes
and a larger interface. Notice that it also includes the functions <b>A(&nbsp;)</b>
and <b>B(&nbsp;)</b>, which take a base reference and treat it polymorphically.
Here’s the implementation file for the library: <sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1459"
title="Add Comment A1459">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Vendor.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>// Implementation of VENDOR.H</p>

<p class=CodeChar style='margin-left:0in'>// This is compiled and unavailable
to you</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Vendor.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void Vendor::v() const {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;Vendor::v()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void Vendor::f() const {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;Vendor::f()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>Vendor::~Vendor() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;~Vendor()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void Vendor1::v() const {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Vendor1::v()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void Vendor1::f() const {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;Vendor1::f()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>Vendor1::~Vendor1() {</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt;
&quot;~Vendor1()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void A(const Vendor&amp; V) {</p>

<p class=CodeChar style='margin-left:0in'>  // ...</p>

<p class=CodeChar style='margin-left:0in'>  V.v();</p>

<p class=CodeChar style='margin-left:0in'>  V.f();</p>

<p class=CodeChar style='margin-left:0in'>  //..</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void B(const Vendor&amp; V) {</p>

<p class=CodeChar style='margin-left:0in'>  // ...</p>

<p class=CodeChar style='margin-left:0in'>  V.v();</p>

<p class=CodeChar style='margin-left:0in'>  V.f();</p>

<p class=CodeChar style='margin-left:0in'>  //..</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In your project, this source code is unavailable to you.
Instead, you get a compiled file as <b>Vendor.obj</b> or <b>Vendor.lib</b> (or
with the equivalent file suffixes for your system).<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1460"
title="Add Comment A1460">Comment</a></sup></p>

<p class=MsoNormal>The problem occurs in the use of this library. First, the
destructor isn’t virtual. In addition, <b>f(&nbsp;)</b> was not made virtual;
we assume the library creator decided it wouldn’t need to be. And you discover
that the interface to the base class is missing a function essential to the
solution of your problem. Also suppose you’ve already written a fair amount of
code using the existing interface (not to mention the functions <b>A(&nbsp;)</b>
and <b>B(&nbsp;),</b> which are out of your control), and you don’t want to
change it.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1461"
title="Add Comment A1461">Comment</a></sup></p>

<p class=MsoNormal>To repair the problem, create your own class interface and
multiply inherit a new set of derived classes from your interface and from the
existing classes:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1462"
title="Add Comment A1462">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C09:Paste.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} Vendor</p>

<p class=CodeChar style='margin-left:0in'>// Fixing a mess with MI</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Vendor.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class MyBase { // Repair Vendor
interface</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void v() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void f() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  // New interface function:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void g() const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~MyBase() { cout &lt;&lt;
&quot;~MyBase()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Paste1 : public MyBase, public
Vendor1 {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void v() const {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Paste1::v()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    Vendor1::v();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void f() const {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Paste1::f()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    Vendor1::f();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void g() const {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;Paste1::g()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~Paste1() { cout &lt;&lt;
&quot;~Paste1()\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Paste1&amp; p1p = *new Paste1;</p>

<p class=CodeChar style='margin-left:0in'>  MyBase&amp; mp = p1p; // Upcast</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;calling
f()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  mp.f();  // Right behavior</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;calling
g()\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  mp.g(); // New behavior</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;calling
A(p1p)\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  A(p1p); // Same old behavior</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;calling
B(p1p)\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  B(p1p);  // Same old behavior</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;delete
mp\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  // Deleting a reference to a heap
object:</p>

<p class=CodeChar style='margin-left:0in'>  delete &amp;mp; // Right behavior</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In <b>MyBase</b> (which does <i>not</i> use MI), both <b>f(&nbsp;)</b>
and the destructor are now virtual, and a new virtual function <b>g(&nbsp;)</b>
has been added to the interface. Now each of the derived classes in the
original library must be re-created, mixing in the new interface with MI. The
functions <b>Paste1::v(&nbsp;)</b> and <b>Paste1::f(&nbsp;)</b>need to call
only the original base-class versions of their functions. But now, if you
upcast to <b>MyBase</b> as in <b>main(&nbsp;)<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1463"
title="Add Comment A1463"><span style='font-weight:normal'>Comment</span></a></sup></b></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInlineCharChar style='margin-left:0in'>MyBase* mp = p1p; // Upcast</p>

</div>

<p class=MsoNormal>any function calls made through <b>mp</b> will be polymorphic,
including <b>delete</b>. Also, the new interface function <b>g(&nbsp;)</b> can
be called through <b>mp</b>. Here’s the output of the program:<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1464"
title="Add Comment A1464">Comment</a></sup></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>calling f()</p>

<p class=CodeChar style='margin-left:0in'>Paste1::f()</p>

<p class=CodeChar style='margin-left:0in'>Vendor1::f()</p>

<p class=CodeChar style='margin-left:0in'>calling g()</p>

<p class=CodeChar style='margin-left:0in'>Paste1::g()</p>

<p class=CodeChar style='margin-left:0in'>calling A(p1p)</p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Paste1::v()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Vendor1::v()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Vendor::f()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>calling B(p1p)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Paste1::v()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Vendor1::v()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>Vendor::f()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>delete mp</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>~Paste1()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>~Vendor1()</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>~Vendor()</span></p>

<p class=CodeChar style='margin-left:0in'>~MyBase()</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>The original library functions <b>A(&nbsp;)</b> and <b>B(&nbsp;)</b>
still work the same (assuming the new <b>v(&nbsp;)</b> calls its base-class
version). The destructor is now virtual and exhibits the correct behavior.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1465"
title="Add Comment A1465">Comment</a></sup></p>

<p class=MsoNormal>Although this is a messy example, it does occur in practice,
and it’s a good demonstration of where multiple inheritance is clearly
necessary: You must be able to upcast to both base classes.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1466"
title="Add Comment A1466">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440164"></a><a name="_Toc312374108"></a><a
name="_Toc305628765"></a><a name="_Toc305593293">Summary</a></h2>

<p class=MsoNormal>One reason MI exists in C++ is that it is a hybrid language
and couldn’t enforce a single monolithic class hierarchy the way Smalltalk and
Java do. Instead, C++ allows many inheritance trees to be formed, so sometimes
you may need to combine the interfaces from two or more trees into a new class.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1467"
title="Add Comment A1467">Comment</a></sup></p>

<p class=MsoNormal>If no “diamonds” appear in your class hierarchy, MI is fairly
simple (although identical function signatures in base classes must still be
resolved). If a diamond appears, you may want to eliminate duplicate subobjects
by introducing virtual base classes. This not only adds confusion, but the
underlying representation becomes more complex and less efficient.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1468"
title="Add Comment A1468">Comment</a></sup></p>

<p class=MsoNormal>Multiple inheritance has been called the “goto of the ’90s”.<a
href="#_ftn102" name="_ftnref102" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[102]</span></sup></span></span></sup></span></a> This seems
appropriate because, like a goto, MI is best avoided in normal programming, but
can occasionally be very useful. It’s a “minor” but more advanced feature of
C++, designed to solve problems that arise in special situations. If you find
yourself using it often, you might want to take a look at your reasoning. A
good Occam’s Razor is to ask, “Must I upcast to all the base classes?” If not,
your life will be easier if you embed instances of all the classes you <i>don’t</i>
need to upcast to.<sup><a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1469"
title="Add Comment A1469">Comment</a></sup></p>

<h2 style='margin-left:0in'><a name="_Toc45440165"></a><a name="_Toc312374109">Exercises</a></h2>

<p class=MsoNormal>These exercises will take you step by step through the
complexities of MI.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a base class <b>X</b> with a single constructor that takes
an <b>int</b> argument and a member function <b>f(&nbsp;)</b>, which takes no
arguments and returns <b>void</b>. Now derive <b>Y</b> and <b>Z</b> from <b>X</b>,
creating constructors for each of them that take a single <b>int</b> argument.
Now derive <b>A</b> from <b>Y</b> and <b>Z</b>. Create an object of class <b>A</b>,
and call <b>f(&nbsp;)</b> for that object. Fix the problem with explicit disambiguation.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Starting with the results of exercise 1, create a pointer to an <b>X</b>
called <b>px</b>, and assign to it the address of the object of type <b>A</b>
you created before. Fix the problem using a virtual base class. Now fix <b>X</b>
so you no longer have to call the constructor for <b>X</b> inside <b>A</b>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Starting with the results of exercise 2, remove the explicit
disambiguation for <b>f(&nbsp;)</b>, and see if you can call <b>f(&nbsp;)</b>
through <b>px</b>. Trace it to see which function gets called. Fix the problem
so the correct function will be called in a class hierarchy.</p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Georgia'>&nbsp;</span></p>

</div>

<span style='font-size:10.5pt;font-family:Georgia'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section17>

<h1 style='margin-left:0in'><a name="_Toc408018793"></a><a name="_Toc407441460"></a><a
name="_Toc375545412"></a><a name="_Toc312374156"></a><a name="_Toc45440166"></a><a
name="_Toc11818293"></a><a name=DesignPatterns></a>10: Design patterns</h1>

<p class=Intro style='margin-left:.25in'>“… describe a problem which occurs
over and over again in our environment, and then describe the core of the
solution to that problem, in such a way that you can use this solution a
million times over, without ever doing it the same way twice”  – Christopher
Alexander</p>

<p class=Intro style='margin-left:.25in'>This chapter introduces the important
and yet nontraditional “patterns” approach to program design. </p>

<p class=MsoNormal>Probably the most important step forward in recent times in
object-oriented design is the “design patterns” movement, chronicled in <i>Design Patterns</i>, by Gamma, Helm, Johnson &amp; Vlissides (Addison-Wesley,
1995).<a href="#_ftn103" name="_ftnref103" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[103]</span></sup></span></span></sup></span></a> That
book shows 23 solutions to particular classes of problems. In this chapter, we
discuss the basic concepts of design patterns and provide code examples that
illustrate selected patterns. This should whet your appetite for reading <i>Design
Patterns</i> (a source of what has now become an essential, almost mandatory
vocabulary for object-oriented programming). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1753"
title="Add Comment A1753"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440167"></a><a name="_Toc11818294"></a><a
name="_Toc408018794">The pattern concept</a></h2>

<p class=MsoNormal>At first blush, you can think of a pattern as an especially
clever and insightful way to solve a particular class of problems. That is, it
looks like a lot of people have worked out all the angles of a problem and have
come up with the most general, flexible solution for it. The problem could be
one you have seen and solved before, but your solution probably didn’t have the
kind of completeness you’ll see embodied in a pattern. Furthermore, the pattern
exists independently of any particular implementation and, indeed, can be
implemented in a number of ways. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1754"
title="Add Comment A1754"><sup>Comment</sup></a></p>

<p class=MsoNormal>Although they’re called “design patterns,” they really
aren’t tied to the realm of design only. A pattern seems to stand apart from
the traditional way of thinking about analysis, design, and implementation.
Instead, a pattern embodies a complete idea within a program, and thus it can
sometimes span the analysis phase and high-level design phase. Because a
pattern has a direct implementation in code, you might not expect it to show up
before low-level design or implementation (and in fact you might not realize
that you need a particular pattern until you get to those phases). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1755"
title="Add Comment A1755"><sup>Comment</sup></a></p>

<p class=MsoNormal>The basic concept of a pattern can also be seen as the basic
concept of program design in general: adding layers of abstraction. Whenever you abstract something, you’re isolating particular details, and one of the most
compelling motivations for this is to <i>separate things that change from
things that stay the same</i>. Another way to put this is that once you find
some part of your program that’s likely to change for one reason or another,
you’ll want to keep those changes from propagating other modifications
throughout your code. Not only does this make the code easier to maintain, but
it also renders code easier to read and understand (which invariably results in
lowered costs over time). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1756"
title="Add Comment A1756"><sup>Comment</sup></a></p>

<p class=MsoNormal>The most difficult part of developing an elegant and
maintainable design is often discovering what we call “the vector of change.” (Here, “vector” refers to the maximum gradient as understood in the sciences, and
not a container class.) This means finding the most important thing that
changes in your system or, put another way, discovering where your greatest
cost is. Once you discover the vector of change, you have the focal point
around which to structure your design. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1757"
title="Add Comment A1757"><sup>Comment</sup></a></p>

<p class=MsoNormal>So the goal of design patterns is to isolate changes in your
code. If you look at it this way, you’ve been seeing some design patterns
already in this book. For example, inheritance could be thought of as a design pattern (albeit one implemented by the compiler). It allows you to
express differences in behavior (that’s the thing that changes) in objects that
all have the same interface (that’s what stays the same). Composition could also be considered a pattern, since it allows you to
change—dynamically or statically—the objects that implement your class, and
thus the way that class works. Normally, however, features that are directly
supported by a programming language have not been classified as design
patterns. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1758"
title="Add Comment A1758"><sup>Comment</sup></a></p>

<p class=MsoNormal>You’ve also already seen another pattern that appears in <i>Design
Patterns</i>: the <i>iterator</i>. This is the fundamental tool used in the
design of the STL (Standard Template Library); it hides the particular
implementation of the container as you’re stepping through and selecting the
elements one by one. Iterators allow you to write generic code that performs an
operation on all the elements in a range without regard to the container that
holds the range. Thus, your generic code can be used with any container that
can produce iterators. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1759"
title="Add Comment A1759"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440168"></a><a name="_Toc11818295"></a><a
name="_Toc408018795">The singleton</a></h2>

<p class=MsoNormal>Possibly the simplest design pattern is the Singleton, which is a way to provide one and only one instance of a class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:SingletonPattern.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Singleton {</p>

<p class=CodeChar style='margin-left:0in'>  static Singleton s;</p>

<p class=CodeChar style='margin-left:0in'>  <span lang=SV>int i;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  Singleton(int x) :
i(x) { }</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>Singleton&amp;
operator=(Singleton&amp;);  // disallowed</p>

<p class=CodeChar style='margin-left:0in'>  Singleton(const
Singleton&amp;);       // disallowed</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static Singleton&amp; instance() {</p>

<p class=CodeChar style='margin-left:0in'>    return s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int getValue() { return i; }</p>

<p class=CodeChar style='margin-left:0in'>  void setValue(int x) { i = x; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>Singleton Singleton::s(47);</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Singleton&amp; s =
Singleton::instance();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s.getValue() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  Singleton&amp; s2 =
Singleton::instance();</p>

<p class=CodeChar style='margin-left:0in'>  s2.setValue(9);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s.getValue() &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The key to creating a singleton is to prevent the client
programmer from having any control over the lifetime of the object. To do this,
you must declare all constructors <b>private</b>, and you must<b> </b>prevent
the compiler from implicitly generating any constructors. Note that the copy constructor and assignment operator are declared private to prevent any sort of
copies being made. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1760"
title="Add Comment A1760"><sup>Comment</sup></a></p>

<p class=MsoNormal>You must also decide how you’re going to create the object.
Here, it’s created statically, but you can also wait until the client
programmer asks for one and create it on demand. In the latter case, if you
return a pointer instead of a reference, the user could inadvertently delete
the pointer, so the implementation above is considered safest. In any case, the
object should be stored privately. You provide access through public methods.
Here, <b>instance(&nbsp;)</b> produces a reference to the <b>Singleton</b>
object. The rest of the interface (<b>getValue(&nbsp;)</b> and <b>setValue(&nbsp;)</b>)
is the regular class interface. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1761"
title="Add Comment A1761"><sup>Comment</sup></a></p>

<p class=MsoNormal>Note that you aren’t restricted to creating only one object.
This technique easily supports the creation of a limited pool of objects. In
that situation, however, you can be confronted with the problem of sharing
objects in the pool. If this is an issue, you can create a solution involving a
check-out and check-in of the shared objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1762"
title="Add Comment A1762"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440169">Variations on singleton</a></h3>

<p class=MsoNormal>Any static member object inside a class is an expression of
singleton: one and only one will be made. So in a sense, the language has
direct support for the idea; we certainly use it on a regular basis. However, a
problem is associated with static objects (member or not), and that’s the order
of initialization, as described in Volume 1 of this book. If one static object
depends on another, it’s important that the objects are initialized in the
correct order. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1763"
title="Add Comment A1763"><sup>Comment</sup></a></p>

<p class=MsoNormal>In Volume 1, you were shown how defining a static object
inside a function can be used to control initialization order. This delays the
initialization of the object until the first time the function is called. If
the function returns a reference to the static object, it gives you the effect
of a singleton while removing much of the worry of static initialization. For
example, suppose you want to create a log file upon the first call to a
function that returns a reference to that log file. This header file will do
the trick: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1764"
title="Add Comment A1764"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:LogFile.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef LOGFILE_H</p>

<p class=CodeChar style='margin-left:0in'>#define LOGFILE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;fstream&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>std::ofstream&amp; logfile();</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // LOGFILE_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The implementation <i>must not be inlined</i>, because that
would mean that the whole function, including the static object definition
within, could be duplicated in any translation unit where it’s included, which
violates C++’s one-definition rule. This would most certainly foil the attempts
to control the order of initialization (but potentially in a very subtle and
hard-to-detect fashion). So the implementation must be separate: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1765"
title="Add Comment A1765"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:LogFile.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;LogFile.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>std::ofstream&amp; logfile() {</p>

<p class=CodeChar style='margin-left:0in'>  static std::ofstream
log(&quot;Logfile.log&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  return log;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now the <b>log</b> object will not be initialized until the
first time <b>logfile(&nbsp;)</b> is called. So if you use the function in one
file: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1766"
title="Add Comment A1766"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:UseLog1.h</p>

<p class=CodeChar style='margin-left:0in'>#ifndef USELOG1_H</p>

<p class=CodeChar style='margin-left:0in'>#define USELOG1_H</p>

<p class=CodeChar style='margin-left:0in'>void f();</p>

<p class=CodeChar style='margin-left:0in'>#endif // USELOG1_H ///:~</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>//: C10:UseLog1.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;UseLog1.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;LogFile.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>void f() {</p>

<p class=CodeChar style='margin-left:0in'>  logfile() &lt;&lt; __FILE__
&lt;&lt; std::endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>And again in another file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:UseLog2.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} LogFile UseLog1</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;UseLog1.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;LogFile.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void g() {</p>

<p class=CodeChar style='margin-left:0in'>  logfile() &lt;&lt; __FILE__
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>} </p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  f();</p>

<p class=CodeChar style='margin-left:0in'>  g();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>the <b>log </b>object doesn’t get created until the first
call to <b>f(&nbsp;)</b>.</p>

<p class=MsoNormal>You can easily combine the creation of the static object
inside a member function with the singleton class. <b>SingletonPattern.cpp</b>
can be modified to use this approach<a href="#_ftn104" name="_ftnref104"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[104]</span></sup></span></span></sup></span></a>:
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1767"
title="Add Comment A1767"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:SingletonPattern2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Meyers’ Singleton</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Singleton {</p>

<p class=CodeChar style='margin-left:0in'>  int i;</p>

<p class=CodeChar style='margin-left:0in'>  Singleton(int x) : i(x) { }</p>

<p class=CodeChar style='margin-left:0in'>  void operator=(Singleton&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Singleton(const Singleton&amp;);</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static Singleton&amp; instance() {</p>

<p class=CodeChar style='margin-left:0in'>    static Singleton s(47);</p>

<p class=CodeChar style='margin-left:0in'>    return s;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  int getValue() { return i; }</p>

<p class=CodeChar style='margin-left:0in'>  void setValue(int x) { i = x; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Singleton&amp; s = Singleton::instance();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s.getValue() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  Singleton&amp; s2 =
Singleton::instance();</p>

<p class=CodeChar style='margin-left:0in'>  s2.setValue(9);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; s.getValue() &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>An especially interesting case is if two singletons depend
on each other, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:FunctionStaticSingleton.cpp</p>

<p class=CodeChar style='margin-left:0in'>class Singleton1 {</p>

<p class=CodeChar style='margin-left:0in'>  Singleton1() {}</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static Singleton1&amp; ref() {</p>

<p class=CodeChar style='margin-left:0in'>    static Singleton1 single;</p>

<p class=CodeChar style='margin-left:0in'>    return single;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Singleton2 {</p>

<p class=CodeChar style='margin-left:0in'>  Singleton1&amp; s1;</p>

<p class=CodeChar style='margin-left:0in'>  Singleton2(Singleton1&amp; s) :
s1(s) {}</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static Singleton2&amp; ref() {</p>

<p class=CodeChar style='margin-left:0in'>    static Singleton2
single(Singleton1::ref());</p>

<p class=CodeChar style='margin-left:0in'>    return single;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Singleton1&amp; f() { return s1; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Singleton1&amp; s1 =
Singleton2::ref().f();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>When <b>Singleton2::ref(&nbsp;)</b> is called, it causes its
sole <b>Singleton2</b> object to be created. In the process of this creation, <b>Singleton1::ref(&nbsp;)</b>
is called, and that causes the sole <b>Singleton1</b> object to be created.
Because this technique doesn’t rely on the order of linking or loading, the
programmer has much better control over initialization, leading to fewer
problems. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1768"
title="Add Comment A1768"><sup>Comment</sup></a></p>

<p class=MsoNormal>Yet another variation on Singleton allows you to separate
the “singleton-ness” of an object from its implementation. This is achieved
through templates, using the Curiously Recurring Template Pattern mentioned in
Chapter 5. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1769"
title="Add Comment A1769"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:CuriousSingleton.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Separates a class from its
singleton-ness (almost)</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>template&lt;class T&gt;</p>

<p class=CodeChar style='margin-left:0in'>class Singleton {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  static T&amp; instance() {</p>

<p class=CodeChar style='margin-left:0in'>    static T theInstance;</p>

<p class=CodeChar style='margin-left:0in'>    return theInstance;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  Singleton(){}</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Singleton(){}</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  Singleton(const Singleton&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Singleton&amp; operator=(const
Singleton&amp;);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>// A sample class to be made into a
Singleton</p>

<p class=CodeChar style='margin-left:0in'>class MyClass : public
Singleton&lt;MyClass&gt; {</p>

<p class=CodeChar style='margin-left:0in'>  int x;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  friend class
Singleton&lt;MyClass&gt;;</p>

<p class=CodeChar style='margin-left:0in'>  MyClass(){x = 0;}</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void setValue(int n) { x = n; }</p>

<p class=CodeChar style='margin-left:0in'>  int getValue() const { return x; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  MyClass&amp; m =
MyClass::instance();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; m.getValue() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>  m.setValue(1);</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; m.getValue() &lt;&lt;
endl;</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal><b>MyClass</b> is made a Singleton by:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>making
its constructor private or protected</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>making
<b>Singleton&lt;MyClass&gt;</b> a friend, and</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>deriving
<b>MyClass</b> from <b>Singleton&lt;MyClass&gt;</b>.</p>

<p class=MsoNormal>The self-referencing in step 3 may sound implausible, but as
we explained in Chapter 5, it works because there is only static data dependent
on the template argument in the <b>Singleton</b> template. In other words, the
code for the class <b>Singleton&lt;MyClass&gt;</b> can be instantiated by the
compiler because it is not dependent on the size of <b>MyClass</b>. It’s only
later, when <b>Singleton&lt;MyClass&gt;::instance(&nbsp;)</b> is first called,
that the size of <b>MyClass</b> is needed, and of course by then compilation of
<b>MyClass</b> is complete and its size is known<a href="#_ftn105"
name="_ftnref105" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[105]</span></sup></span></span></sup></span></a>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1770"
title="Add Comment A1770"><sup>Comment</sup></a></p>

<p class=MsoNormal>It’s interesting how intricate implementing such a simple
pattern as Singleton can be. We haven’t even addressed issues of thread safety,
and yet many pages have elapsed since the beginning of this section. The last
thing we wish to say about Singleton is that it should be used sparingly. True
singleton objects arise very rarely, and the last thing a Singleton should be
used for is to replace a global variable<a href="#_ftn106" name="_ftnref106"
title=""><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[106]</span></sup></span></span></sup></span></a>.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1843"
title="Add Comment A1843"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440170"></a><a name="_Toc11818296"></a><a
name="_Toc408018796">Classifying patterns</a></h2>

<p class=MsoNormal><i>Design Patterns</i> discusses 23 patterns, classified
under three purposes (all of which revolve around the particular aspect that
can vary): </p>

<p class=Numbered><span style='font-family:Verdana'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Creational</b>: how an object can be created. This often
involves isolating the details of object creation so your code isn’t dependent
on what types of objects there are and thus doesn’t have to be changed when you
add a new type of object. The aforementioned Singleton is classified as a
creational pattern, and later in this chapter you’ll see examples of Factory<i>
</i>Method. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1771"
title="Add Comment A1771"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Structural</b>: designing objects to satisfy particular
project constraints. These affect the way objects are connected with other
objects to ensure that changes in the system don’t require changes to those
connections. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1772"
title="Add Comment A1772"><sup>Comment</sup></a></p>

<p class=Numbered><span style='font-family:Verdana'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Behavioral</b>: objects that handle particular types of
actions within a program. These encapsulate processes that you want to perform,
such as interpreting a language, fulfilling a request, moving through a
sequence (as in an iterator), or implementing an algorithm. This chapter
contains examples of the Observer and the Visitor patterns. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1773"
title="Add Comment A1773"><sup>Comment</sup></a></p>

<p class=MsoNormal><i>Design Patterns</i> includes a section on each of its 23
patterns along with one or more examples for each, typically in C++ but
sometimes in Smalltalk. This book will not repeat all the details of the patterns
shown in <i>Design Patterns</i> since that book stands on its own and should be
studied separately. The catalog and examples provided here are intended to
rapidly give you a grasp of the patterns, so you can get a decent feel for what
patterns are about and why they are so important. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1774"
title="Add Comment A1774"><sup>Comment</sup></a></p>

<h3><a name="_Toc408018797"></a><a name="_Toc375545413"></a><a
name="_Toc45440171"></a><a name="_Toc11818297">Features, idioms, patterns</a></h3>

<p class=MsoNormal>Work is continuing beyond what is in the GoF book, of
course; hence, there are more patterns and a more refined process on defining
design patterns in general.<a href="#_ftn107" name="_ftnref107" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[107]</span></sup></span></span></sup></span></a> This
is important because it is not easy to identify new patterns or to properly
describe them. There has been some confusion in the popular literature on what
a design pattern is, for example. Patterns are not trivial nor are they
typically represented by features that are built into a programming language.
Constructors and destructors, for example, could be called the “guaranteed
initialization and cleanup design pattern.” These are important and essential
constructs, but they’re routine language constructs and are not rich enough to
be considered a design pattern. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1775"
title="Add Comment A1775"><sup>Comment</sup></a></p>

<p class=MsoNormal>Another non-example comes from various forms of aggregation.
Aggregation is a completely fundamental principle in object-oriented
programming: you make objects out of other objects. Yet sometimes this idea is
erroneously classified as a pattern. This is unfortunate because it pollutes
the idea of the design pattern and suggests that anything that surprises you
the first time you see it should be made into a design pattern. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1776"
title="Add Comment A1776"><sup>Comment</sup></a></p>

<p class=MsoNormal>Yet another misguided example is found in the Java language;
the designers of the JavaBeans specification decided to refer to the simple
“get/set” naming convention as a design pattern (for example, <b>getInfo(&nbsp;)</b>
returns an <b>Info</b> property and <b>setInfo(&nbsp;)</b> changes it). This is
just a commonplace naming convention and in no way constitutes a design
pattern. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1777"
title="Add Comment A1777"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440172">Building complex objects</a></h2>

<p class=MsoNormal>The class that will be created in the next example models a
bicycle that can have a choice of parts, according to its type (mountain bike,
touring bike, or racing bike). This is called the <b>Builder</b> design
pattern. A builder class is associated with each flavor of bicycle, each of
which implements the interface specified in the abstract class <b>BicycleBuilder</b>.
A separate class, <b>BicycleTechnician</b>, uses a concrete <b>BicycleBuilder</b>
object to construct a <b>Bicycle</b> object. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1778"
title="Add Comment A1778"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:Bicycle.h</p>

<p class=CodeChar style='margin-left:0in'>// Defines classes to build bicycles</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates the Builder Design
Pattern</p>

<p class=CodeChar style='margin-left:0in'>#ifndef BICYCLE_H</p>

<p class=CodeChar style='margin-left:0in'>#define BICYCLE_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iosfwd&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class BicyclePart {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  enum BPart {FRAME, WHEEL, SEAT,
DERAILLEUR,</p>

<p class=CodeChar style='margin-left:0in'>    HANDLEBAR, SPROCKET, RACK, SHOCK,
NPARTS};</p>

<p class=CodeChar style='margin-left:0in'>  BicyclePart(BPart);</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(std::ostream&amp;,
const BicyclePart&amp;);</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  BPart id;</p>

<p class=CodeChar style='margin-left:0in'>  static std::string names[NPARTS];</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bicycle {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  ~Bicycle();</p>

<p class=CodeChar style='margin-left:0in'>  void addPart(BicyclePart*);</p>

<p class=CodeChar style='margin-left:0in'>  friend std::ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(std::ostream&amp;,
const Bicycle&amp;);</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  std::vector&lt;BicyclePart*&gt;
parts;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class BicycleBuilder {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  BicycleBuilder() {</p>

<p class=CodeChar style='margin-left:0in'>    product = 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void createProduct() {</p>

<p class=CodeChar style='margin-left:0in'>    product = new Bicycle;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildFrame() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildWheel() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildSeat() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildDerailleur() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildHandlebar() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildSprocket() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildRack() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void buildShock() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual std::string getBikeName()
const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  Bicycle* getProduct() {</p>

<p class=CodeChar style='margin-left:0in'>    Bicycle* temp = product;</p>

<p class=CodeChar style='margin-left:0in'>    product = 0;  // relinquish
product</p>

<p class=CodeChar style='margin-left:0in'>    return temp;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  Bicycle* product;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class MountainBikeBuilder : public
BicycleBuilder {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void buildFrame();</p>

<p class=CodeChar style='margin-left:0in'>  void buildWheel();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSeat();</p>

<p class=CodeChar style='margin-left:0in'>  void buildDerailleur();</p>

<p class=CodeChar style='margin-left:0in'>  void buildHandlebar();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSprocket();</p>

<p class=CodeChar style='margin-left:0in'>  void buildRack();</p>

<p class=CodeChar style='margin-left:0in'>  void buildShock();</p>

<p class=CodeChar style='margin-left:0in'>  std::string getBikeName() const {</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;MountainBike&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class TouringBikeBuilder : public
BicycleBuilder {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void buildFrame();</p>

<p class=CodeChar style='margin-left:0in'>  void buildWheel();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSeat();</p>

<p class=CodeChar style='margin-left:0in'>  void buildDerailleur();</p>

<p class=CodeChar style='margin-left:0in'>  void buildHandlebar();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSprocket();</p>

<p class=CodeChar style='margin-left:0in'>  void buildRack();</p>

<p class=CodeChar style='margin-left:0in'>  void buildShock();</p>

<p class=CodeChar style='margin-left:0in'>  std::string getBikeName() const {</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;TouringBike&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class RacingBikeBuilder : public BicycleBuilder
{</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void buildFrame();</p>

<p class=CodeChar style='margin-left:0in'>  void buildWheel();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSeat();</p>

<p class=CodeChar style='margin-left:0in'>  void buildDerailleur();</p>

<p class=CodeChar style='margin-left:0in'>  void buildHandlebar();</p>

<p class=CodeChar style='margin-left:0in'>  void buildSprocket();</p>

<p class=CodeChar style='margin-left:0in'>  void buildRack();</p>

<p class=CodeChar style='margin-left:0in'>  void buildShock();</p>

<p class=CodeChar style='margin-left:0in'>  std::string getBikeName() const {</p>

<p class=CodeChar style='margin-left:0in'>    return &quot;RacingBike&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class BicycleTechnician {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  BicycleTechnician() {</p>

<p class=CodeChar style='margin-left:0in'>    builder = 0;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void setBuilder(BicycleBuilder* b)
{</p>

<p class=CodeChar style='margin-left:0in'>    builder = b;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void construct();</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  BicycleBuilder* builder;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>#endif ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>A <b>Bicycle</b> holds a vector of pointers to <b>BicyclePart</b>
representing the parts used to construct the bicycle. To initiate the
construction of a bicycle, a technician calls <b>BicycleBuilder::createproduct(&nbsp;)</b>
on a derived <b>BicycleBuilder</b> object. The <b>BicycleTechnician::construct(&nbsp;)</b>
function calls all the functions in the <b>BicycleBuilder</b> interface (since
it doesn’t know what type of concrete builder it has). The concrete builder
classes omit (via empty function bodies) those actions that do not apply to the
type of bicycle they build, as you can see in the following implementation
file. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1779"
title="Add Comment A1779"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:Bicycle.cpp {O}</p>

<p class=CodeChar style='margin-left:0in'>// Defines classes to build bicycles</p>

<p class=CodeChar style='margin-left:0in'>// Illustrates the Builder Design
Pattern</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cassert&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Bicycle.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// BicyclePart implementation</p>

<p class=CodeChar style='margin-left:0in'>BicyclePart::BicyclePart(BPart bp) {</p>

<p class=CodeChar style='margin-left:0in'>  id = bp;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(ostream&amp; os,
const BicyclePart&amp; bp) {</p>

<p class=CodeChar style='margin-left:0in'>  return os &lt;&lt; bp.names[bp.id];</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>std::string
BicyclePart::names[NPARTS] = {</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Frame&quot;,
&quot;Wheel&quot;, &quot;Seat&quot;, &quot;Derailleur&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Handlebar&quot;,
&quot;Sprocket&quot;, &quot;Rack&quot;, &quot;Shock&quot;};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Bicycle implementation</p>

<p class=CodeChar style='margin-left:0in'>Bicycle::~Bicycle() {</p>

<p class=CodeChar style='margin-left:0in'>  purge(parts);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void Bicycle::addPart(BicyclePart*
bp) {</p>

<p class=CodeChar style='margin-left:0in'>  parts.push_back(bp);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp;</p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(ostream&amp; os,
const Bicycle&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  os &lt;&lt; &quot;{ &quot;;</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
b.parts.size(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=SV>os &lt;&lt;
*b.parts[i] &lt;&lt; ' ';</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV>  </span>return os
&lt;&lt; '}';</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// MountainBikeBuilder implementation</p>

<p class=CodeChar style='margin-left:0in'>void MountainBikeBuilder::buildFrame()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::FRAME));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
MountainBikeBuilder::buildWheel() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::WHEEL));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void MountainBikeBuilder::buildSeat()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SEAT));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
MountainBikeBuilder::buildDerailleur() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(</p>

<p class=CodeChar style='margin-left:0in'>    new
BicyclePart(BicyclePart::DERAILLEUR));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
MountainBikeBuilder::buildHandlebar() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(</p>

<p class=CodeChar style='margin-left:0in'>    new
BicyclePart(BicyclePart::HANDLEBAR));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
MountainBikeBuilder::buildSprocket() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SPROCKET));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void MountainBikeBuilder::buildRack()
{}</p>

<p class=CodeChar style='margin-left:0in'>void
MountainBikeBuilder::buildShock() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SHOCK));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// TouringBikeBuilder implementation</p>

<p class=CodeChar style='margin-left:0in'>void TouringBikeBuilder::buildFrame()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::FRAME));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void TouringBikeBuilder::buildWheel()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::WHEEL));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void TouringBikeBuilder::buildSeat()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SEAT));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
TouringBikeBuilder::buildDerailleur() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::DERAILLEUR));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
TouringBikeBuilder::buildHandlebar() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(</p>

<p class=CodeChar style='margin-left:0in'>    new
BicyclePart(BicyclePart::HANDLEBAR));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
TouringBikeBuilder::buildSprocket() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SPROCKET));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void TouringBikeBuilder::buildRack()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::RACK));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void TouringBikeBuilder::buildShock()
{}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// RacingBikeBuilder implementation</p>

<p class=CodeChar style='margin-left:0in'>void RacingBikeBuilder::buildFrame()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::FRAME));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void RacingBikeBuilder::buildWheel()
{</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::WHEEL));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void RacingBikeBuilder::buildSeat() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SEAT));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
RacingBikeBuilder::buildDerailleur() {}</p>

<p class=CodeChar style='margin-left:0in'>void
RacingBikeBuilder::buildHandlebar() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(</p>

<p class=CodeChar style='margin-left:0in'>    new
BicyclePart(BicyclePart::HANDLEBAR));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void
RacingBikeBuilder::buildSprocket() {</p>

<p class=CodeChar style='margin-left:0in'>  product-&gt;addPart(new
BicyclePart(BicyclePart::SPROCKET));</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>void RacingBikeBuilder::buildRack()
{}</p>

<p class=CodeChar style='margin-left:0in'>void RacingBikeBuilder::buildShock()
{}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// BicycleTechnician implementation</p>

<p class=CodeChar style='margin-left:0in'>void BicycleTechnician::construct()</p>

<p class=CodeChar style='margin-left:0in'>{</p>

<p class=CodeChar style='margin-left:0in'>  assert(builder);</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;createProduct();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildFrame();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildWheel();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildSeat();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildDerailleur();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildHandlebar();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildSprocket();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildRack();</p>

<p class=CodeChar style='margin-left:0in'>  builder-&gt;buildShock();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}; ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>Bicycle</b> stream inserter calls the corresponding
inserter for each <b>BicyclePart</b>, and that prints out its type name so that
you can see what a <b>Bicycle</b> contains. The power of this pattern is that
it separates the algorithm for assembling parts into a complete product from
the parts themselves and allows different algorithms for different products via
different implementations of a common interface. Here is a sample program,
along with the resulting output, that uses these classes. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1780"
title="Add Comment A1780"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:BuildBicycles.cpp</p>

<p class=CodeChar style='margin-left:0in'>//{L} Bicycle</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstddef&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Bicycle.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Constructs a bike via a concrete
builder</p>

<p class=CodeChar style='margin-left:0in'>Bicycle*</p>

<p class=CodeChar style='margin-left:0in'>buildMeABike(BicycleTechnician&amp;
t, BicycleBuilder* builder) {</p>

<p class=CodeChar style='margin-left:0in'>  t.setBuilder(builder);</p>

<p class=CodeChar style='margin-left:0in'>  t.construct();</p>

<p class=CodeChar style='margin-left:0in'>  Bicycle* b =
builder-&gt;getProduct();</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;Built a &quot;
&lt;&lt; builder-&gt;getBikeName() &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  return b;</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  // Create an order for some
bicycles</p>

<p class=CodeChar style='margin-left:0in'>  map &lt;string, size_t&gt; order;</p>

<p class=CodeChar style='margin-left:0in'>  order[&quot;mountain&quot;] = 2;</p>

<p class=CodeChar style='margin-left:0in'>  order[&quot;touring&quot;] = 1;</p>

<p class=CodeChar style='margin-left:0in'>  order[&quot;racing&quot;] = 3;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>  // Build bikes</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Bicycle*&gt; bikes;</p>

<p class=CodeChar style='margin-left:0in'>  BicycleBuilder* m = new
MountainBikeBuilder;</p>

<p class=CodeChar style='margin-left:0in'>  BicycleBuilder* t = new
TouringBikeBuilder;</p>

<p class=CodeChar style='margin-left:0in'>  BicycleBuilder* r = new
RacingBikeBuilder;</p>

<p class=CodeChar style='margin-left:0in'>  BicycleTechnician tech;</p>

<p class=CodeChar style='margin-left:0in'>  map&lt;string, size_t&gt;::iterator
it = order.begin();</p>

<p class=CodeChar style='margin-left:0in'>  while (it != order.end()) {</p>

<p class=CodeChar style='margin-left:0in'>    BicycleBuilder* builder;</p>

<p class=CodeChar style='margin-left:0in'>    if (it-&gt;first ==
&quot;mountain&quot;)</p>

<p class=CodeChar style='margin-left:0in'>      builder = m;</p>

<p class=CodeChar style='margin-left:0in'>    else if (it-&gt;first ==
&quot;touring&quot;)</p>

<p class=CodeChar style='margin-left:0in'>      builder = t;</p>

<p class=CodeChar style='margin-left:0in'>    else if (it-&gt;first ==
&quot;racing&quot;)</p>

<p class=CodeChar style='margin-left:0in'>      builder = r;</p>

<p class=CodeChar style='margin-left:0in'>    for (size_t i = 0; i &lt;
it-&gt;second; ++i)</p>

<p class=CodeChar style='margin-left:0in'>     
bikes.push_back(buildMeABike(tech, builder));</p>

<p class=CodeChar style='margin-left:0in'>    <span lang=IT>++it;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  delete m;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  delete t;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  delete r;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT>  </span>// Display
inventory</p>

<p class=CodeChar style='margin-left:0in'>  for (size_t i = 0; i &lt;
bikes.size(); ++i)</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Bicycle:
&quot; &lt;&lt; *bikes[i] &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  purge(bikes);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>/* Output:</p>

<p class=CodeChar style='margin-left:0in'>Built a MountainBike</p>

<p class=CodeChar style='margin-left:0in'>Built a MountainBike</p>

<p class=CodeChar style='margin-left:0in'>Built a RacingBike</p>

<p class=CodeChar style='margin-left:0in'>Built a RacingBike</p>

<p class=CodeChar style='margin-left:0in'>Built a RacingBike</p>

<p class=CodeChar style='margin-left:0in'>Built a TouringBike</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat
Derailleur Handlebar Sprocket Shock }</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat
Derailleur Handlebar Sprocket Shock }</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat Handlebar
Sprocket }</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat Handlebar
Sprocket }</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat Handlebar
Sprocket }</p>

<p class=CodeChar style='margin-left:0in'>Bicycle: { Frame Wheel Seat
Derailleur Handlebar Sprocket Rack } */ ///:~ <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1781"
title="Add Comment A1781"><sup><span style='font-size:12.0pt;font-family:Georgia'>Comment</span></sup></a></p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45440173"></a><a name="_Toc11818300">Factories:
encapsulating object creation</a></h2>

<p class=MsoNormal>When you discover that you need to add new types to a
system, the most sensible first step is to use polymorphism to create a common
interface to those new types. This separates the rest of the code in your
system from the knowledge of the specific types that you are adding. New types
can be added without disturbing existing code … or so it seems. At first it
would appear that you need to change the code in such a design only in the
place where you inherit a new type, but this is not quite true. You must still
create an object of your new type, and at the point of creation you must
specify the exact constructor to use. Thus, if the code that creates objects is
distributed throughout your application, you have the same problem when adding
new types—you must still chase down all the points of your code where type
matters. It happens to be the <i>creation</i> of the type that matters in this
case rather than the <i>use</i> of the type (which is taken care of by
polymorphism), but the effect is the same: adding a new type can cause
problems. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1782"
title="Add Comment A1782"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution is to force the creation of objects to occur
through a common <i>factory</i> rather than to allow the creational code to be
spread throughout your system. If all the code in your program must go through
this factory whenever it needs to create one of your objects, all you must do
when you add a new object is modify the factory. This design is a variation of
the pattern commonly known as <i>Factory Method</i>. Since every
object-oriented program creates objects, and since it’s likely you will extend
your program by adding new types, factories may be the most useful of all
design patterns. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1783"
title="Add Comment A1783"><sup>Comment</sup></a></p>

<p class=MsoNormal>As an example, let’s revisit the <b>Shape</b> system. One
approach to implementing a factory is to define a <b>static</b> member function
in the base class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:ShapeFactory1.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void erase() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {}</p>

<p class=CodeChar style='margin-left:0in'>  class BadShapeCreation : public
logic_error {</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    BadShapeCreation(string type) </p>

<p class=CodeChar style='margin-left:0in'>      : logic_error(&quot;Cannot
create type &quot; + type)</p>

<p class=CodeChar style='margin-left:0in'>    {}</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  static Shape* factory(const
string&amp; type) </p>

<p class=CodeChar style='margin-left:0in'>    throw(BadShapeCreation);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Circle() {} // Private constructor</p>

<p class=CodeChar style='margin-left:0in'>  friend class Shape;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Circle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Circle::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() { cout &lt;&lt;
&quot;Circle::~Circle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Square() {}</p>

<p class=CodeChar style='margin-left:0in'>  friend class Shape;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Square::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Square::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() { cout &lt;&lt;
&quot;Square::~Square\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>Shape* Shape::factory(const
string&amp; type) </p>

<p class=CodeChar style='margin-left:0in'>  throw(Shape::BadShapeCreation) {</p>

<p class=CodeChar style='margin-left:0in'>  if(type == &quot;Circle&quot;)
return new Circle;</p>

<p class=CodeChar style='margin-left:0in'>  if(type == &quot;Square&quot;)
return new Square;</p>

<p class=CodeChar style='margin-left:0in'>  throw BadShapeCreation(type);</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>char* shlist[] = {
&quot;Circle&quot;, &quot;Square&quot;, &quot;Square&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Circle&quot;,
&quot;Circle&quot;, &quot;Circle&quot;, &quot;Square&quot;, &quot;&quot; };</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Shape*&gt; shapes;</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    for(char** cp = shlist; **cp;
cp++)</p>

<p class=CodeChar style='margin-left:0in'>     
shapes.push_back(Shape::factory(*cp));</p>

<p class=CodeChar style='margin-left:0in'>  } catch(Shape::BadShapeCreation e)
{</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; e.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    purge(shapes);</p>

<p class=CodeChar style='margin-left:0in'>    return 1;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt;
shapes.size(); i++) {</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;draw();</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;erase();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  purge(shapes);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The <b>factory(&nbsp;)</b> function takes an argument that
allows it to determine what type of  <b>Shape</b> to create; it happens to be a
<b>string</b> in this case, but it could be any set of data. The <b>factory(&nbsp;)</b>
is now the only other code in the system that needs to be changed when a new
type of <b>Shape </b>is added. (The initialization data for the objects will
presumably come from somewhere outside the system and will not be a hard-coded
array as in the previous example.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1784"
title="Add Comment A1784"><sup>Comment</sup></a></p>

<p class=MsoNormal>To ensure that the creation can only happen in the <b>factory(&nbsp;)</b>,
the constructors for the specific types of <b>Shape</b> are made <b>private</b>,
and <b>Shape</b> is declared a <b>friend</b> so that <b>factory(&nbsp;)</b> has
access to the constructors. (You could also declare only <b>Shape::factory(&nbsp;)</b>
to be a <b>friend</b>, but it seems reasonably harmless to declare the entire
base class as a <b>friend.</b>) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1785"
title="Add Comment A1785"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440174"></a><a name="_Toc11818301">Polymorphic factories</a></h3>

<p class=MsoNormal>The <b>static factory(&nbsp;)</b> member function in the
previous example forces all the creation operations to be focused in one spot,
so that’s the only place you need to change the code. This is certainly a
reasonable solution, as it nicely encapsulates the process of creating objects.
However, <i>Design Patterns</i> emphasizes that the reason for the Factory
Method pattern is so that different types of factories can be derived from the basic
factory. Factory Method is in fact a special type of polymorphic factory.
However, <i>Design Patterns</i> does not provide an example, but instead just
repeats the example used for the <i>Abstract Factory</i>. Here is <b>ShapeFactory1.cpp</b>
modified so the Factory Methods are in a separate class as virtual functions: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1786"
title="Add Comment A1786"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:ShapeFactory2.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Polymorphic factory methods</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;map&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;stdexcept&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void erase() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class ShapeFactory {</p>

<p class=CodeChar style='margin-left:0in'>  virtual Shape* create() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  static map&lt;string,
ShapeFactory*&gt; factories;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~ShapeFactory() {}</p>

<p class=CodeChar style='margin-left:0in'>  friend class
ShapeFactoryInitializer;</p>

<p class=CodeChar style='margin-left:0in'>  class BadShapeCreation : public
logic_error {</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    BadShapeCreation(string type) </p>

<p class=CodeChar style='margin-left:0in'>      : logic_error(&quot;Cannot
create type &quot; + type)</p>

<p class=CodeChar style='margin-left:0in'>    {}</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  static Shape* </p>

<p class=CodeChar style='margin-left:0in'>  createShape(const string&amp; id)
throw(BadShapeCreation){</p>

<p class=CodeChar style='margin-left:0in'>    if(factories.find(id) !=
factories.end())</p>

<p class=CodeChar style='margin-left:0in'>      return
factories[id]-&gt;create();</p>

<p class=CodeChar style='margin-left:0in'>    else</p>

<p class=CodeChar style='margin-left:0in'>      throw BadShapeCreation(id);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Define the static object:</p>

<p class=CodeChar style='margin-left:0in'>map&lt;string, ShapeFactory*&gt; </p>

<p class=CodeChar style='margin-left:0in'>  ShapeFactory::factories;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Circle() {} // Private constructor</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Circle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Circle::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() { cout &lt;&lt;
&quot;Circle::~Circle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  friend class
ShapeFactoryInitializer;</p>

<p class=CodeChar style='margin-left:0in'>  class Factory;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Factory;</p>

<p class=CodeChar style='margin-left:0in'>  class Factory : public ShapeFactory
{</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    Shape* create() { return new
Circle; }</p>

<p class=CodeChar style='margin-left:0in'>    friend class
ShapeFactoryInitializer;</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Square() {}</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Square::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Square::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() { cout &lt;&lt;
&quot;Square::~Square\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>private:</p>

<p class=CodeChar style='margin-left:0in'>  friend class
ShapeFactoryInitializer;</p>

<p class=CodeChar style='margin-left:0in'>  class Factory;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Factory;</p>

<p class=CodeChar style='margin-left:0in'>  class Factory : public ShapeFactory
{</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    Shape* create() { return new
Square; }</p>

<p class=CodeChar style='margin-left:0in'>    friend class
ShapeFactoryInitializer;</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Singleton to initialize the
ShapeFactory:</p>

<p class=CodeChar style='margin-left:0in'>class ShapeFactoryInitializer {</p>

<p class=CodeChar style='margin-left:0in'>  static ShapeFactoryInitializer si;</p>

<p class=CodeChar style='margin-left:0in'>  ShapeFactoryInitializer() {</p>

<p class=CodeChar style='margin-left:0in'>   
ShapeFactory::factories[&quot;Circle&quot;] =</p>

<p class=CodeChar style='margin-left:0in'>      new Circle::Factory;</p>

<p class=CodeChar style='margin-left:0in'>   
ShapeFactory::factories[&quot;Square&quot;] =</p>

<p class=CodeChar style='margin-left:0in'>      new Square::Factory;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~ShapeFactoryInitializer() {</p>

<p class=CodeChar style='margin-left:0in'>    delete
ShapeFactory::factories[&quot;Circle&quot;];</p>

<p class=CodeChar style='margin-left:0in'>    delete
ShapeFactory::factories[&quot;Square&quot;];</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Static member definition:</p>

<p class=CodeChar style='margin-left:0in'>ShapeFactoryInitializer</p>

<p class=CodeChar style='margin-left:0in'>  ShapeFactoryInitializer::si;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>char* shlist[] = {
&quot;Circle&quot;, &quot;Square&quot;, &quot;Square&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Circle&quot;,
&quot;Circle&quot;, &quot;Circle&quot;, &quot;Square&quot;, &quot;&quot; };</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Shape*&gt; shapes;</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    for(char** cp = shlist; **cp;
cp++)</p>

<p class=CodeChar style='margin-left:0in'>      shapes.push_back(</p>

<p class=CodeChar style='margin-left:0in'>       
ShapeFactory::createShape(*cp));</p>

<p class=CodeChar style='margin-left:0in'>  }
catch(ShapeFactory::BadShapeCreation e) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; e.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    return 1;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  for(size_t i = 0; i &lt; shapes.size();
i++) {</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;draw();</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;erase();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  purge(shapes);</p>

<p class=CodeChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Now the Factory Method appears in its own class, <b>ShapeFactory</b>,
as the <b>virtual create(&nbsp;)</b>. This is a private member function, which
means it cannot be called directly but can be overridden. The subclasses of <b>Shape</b>
must each create their own subclasses of <b>ShapeFactory</b> and override the <b>create(&nbsp;)</b>
member function to create an object of their own type. These factories are
private, so that they are only accessible from the main Factory Method. This
way, all client code must go through the Factory Method in order to create
objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1787"
title="Add Comment A1787"><sup>Comment</sup></a></p>

<p class=MsoNormal>The actual creation of shapes is performed by calling <b>ShapeFactory::createShape(&nbsp;)</b>,
which is a static member function that uses the <b>map</b> in <b>ShapeFactory</b>
to find the appropriate factory object based on an identifier that you pass it.
The factory is immediately used to create the shape object, but you could
imagine a more complex problem in which the appropriate factory object is
returned and then used by the caller to create an object in a more
sophisticated way. However, it seems that much of the time you don’t need the
intricacies of the polymorphic Factory Method, and a single static member
function in the base class (as shown in <b>ShapeFactory1.cpp</b>) will work
fine. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1788"
title="Add Comment A1788"><sup>Comment</sup></a></p>

<p class=MsoNormal>Notice that the <b>ShapeFactory</b> must be initialized by
loading its <b>map</b> with factory objects, which takes place in the singleton
<b>ShapeFactoryInitializer</b>. So to add a new type to this design you must
define the type, create a factory, and modify <b>ShapeFactoryInitializer</b> so
that an instance of your factory is inserted in the map. This extra complexity
again suggests the use of a <b>static</b> Factory Method if you don’t need to
create individual factory objects. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1789"
title="Add Comment A1789"><sup>Comment</sup></a></p>

<h3><a name="_Toc312374165"></a><a name="_Toc305628794"></a><a
name="_Toc305593322"></a><a name="_Toc45440175"></a><a name="_Toc11818302">Abstract
factories</a></h3>

<p class=MsoNormal>The Abstract Factory pattern looks like the factory objects
we’ve seen previously, with not one but several Factory Methods. Each of the
factory methods creates a different kind of object. The idea is that when you
create the factory object, you decide how all the objects created by that
factory will be used. The example in <i>Design Patterns</i> implements
portability across various graphical user interfaces (GUIs): you create a
factory object appropriate to the GUI that you’re working with, and from then
on when you ask it for a menu, a button, a slider, and so on, it will
automatically create the appropriate version of that item for the GUI. Thus,
you’re able to isolate, in one place, the effect of changing from one GUI to
another. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1790"
title="Add Comment A1790"><sup>Comment</sup></a></p>

<p class=MsoNormal>As another example, suppose you are creating a
general-purpose gaming environment and you want to be able to support different
types of games. Here’s how it might look using an Abstract Factory: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1791"
title="Add Comment A1791"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:AbstractFactory.cpp</p>

<p class=CodeChar style='margin-left:0in'>// A gaming environment</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Obstacle {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void action() = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Player {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void
interactWith(Obstacle*) = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Kitty: public Player {</p>

<p class=CodeChar style='margin-left:0in'>  virtual void interactWith(Obstacle*
ob) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Kitty has
encountered a &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    ob-&gt;action();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class KungFuGuy: public Player {</p>

<p class=CodeChar style='margin-left:0in'>  virtual void interactWith(Obstacle*
ob) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;KungFuGuy now
battles against a &quot;;</p>

<p class=CodeChar style='margin-left:0in'>    ob-&gt;action();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Puzzle: public Obstacle {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void action() { cout &lt;&lt;
&quot;Puzzle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class NastyWeapon: public Obstacle {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void action() { cout &lt;&lt;
&quot;NastyWeapon\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// The abstract factory:</p>

<p class=CodeChar style='margin-left:0in'>class GameElementFactory {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual Player* makePlayer() = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual Obstacle* makeObstacle() =
0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Concrete factories:</p>

<p class=CodeChar style='margin-left:0in'>class KittiesAndPuzzles : </p>

<p class=CodeChar style='margin-left:0in'>  public GameElementFactory {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual Player* makePlayer() { </p>

<p class=CodeChar style='margin-left:0in'>    return new Kitty;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual Obstacle* makeObstacle() {</p>

<p class=CodeChar style='margin-left:0in'>    return new Puzzle;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class KillAndDismember : </p>

<p class=CodeChar style='margin-left:0in'>  public GameElementFactory {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual Player* makePlayer() { </p>

<p class=CodeChar style='margin-left:0in'>    return new KungFuGuy;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual Obstacle* makeObstacle() {</p>

<p class=CodeChar style='margin-left:0in'>    return new NastyWeapon;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class GameEnvironment {</p>

<p class=CodeChar style='margin-left:0in'>  GameElementFactory* gef;</p>

<p class=CodeChar style='margin-left:0in'>  Player* p;</p>

<p class=CodeChar style='margin-left:0in'>  Obstacle* ob;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  GameEnvironment(GameElementFactory*
factory) :</p>

<p class=CodeChar style='margin-left:0in'>    gef(factory),
p(factory-&gt;makePlayer()), </p>

<p class=CodeChar style='margin-left:0in'>    ob(factory-&gt;makeObstacle()) {}</p>

<p class=CodeChar style='margin-left:0in'>  void play() {</p>

<p class=CodeChar style='margin-left:0in'>    p-&gt;interactWith(ob);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ~GameEnvironment() {</p>

<p class=CodeChar style='margin-left:0in'>    delete p;</p>

<p class=CodeChar style='margin-left:0in'>    delete ob;</p>

<p class=CodeChar style='margin-left:0in'>    delete gef;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  GameEnvironment </p>

<p class=CodeChar style='margin-left:0in'>    g1(new KittiesAndPuzzles),</p>

<p class=CodeChar style='margin-left:0in'>    g2(new KillAndDismember);</p>

<p class=CodeChar style='margin-left:0in'>  g1.play();</p>

<p class=CodeChar style='margin-left:0in'>  g2.play();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>/* Output:</p>

<p class=CodeChar style='margin-left:0in'>Kitty has encountered a Puzzle</p>

<p class=CodeChar style='margin-left:0in'>KungFuGuy now battles against a
NastyWeapon */ ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>In this environment, <b>Player</b> objects interact with <b>Obstacle</b>
objects, but the types of players and obstacles depend on the game. You
determine the kind of game by choosing a particular <b>GameElementFactory</b>,
and then the <b>GameEnvironment</b> controls the setup and play of the game. In
this example, the setup and play are simple, but those activities (the <i>initial
conditions</i> and the <i>state change</i>) can determine much of the game’s
outcome. Here, <b>GameEnvironment</b> is not designed to be inherited, although
it could very possibly make sense to do that. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1792"
title="Add Comment A1792"><sup>Comment</sup></a></p>

<p class=MsoNormal>This example also illustrates <i>double dispatching</i>,
which will be explained later.</p>

<h3><a name="_Toc45440176"></a><a name="_Toc11818303">Virtual constructors</a></h3>

<p class=MsoNormal>One of the primary goals of using a factory is to  organize your code so you don’t have to select an exact type of constructor when
creating an object. That is, you can say, “I don’t know precisely what type of
object you are, but here’s the information. Create yourself.”  <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1793"
title="Add Comment A1793"><sup>Comment</sup></a></p>

<p class=MsoNormal>In addition, during a constructor call the virtual mechanism
does not operate (early binding occurs). Sometimes this is awkward. For
example, in the <b>Shape </b>program it seems logical that inside the
constructor for a <b>Shape</b> object, you would want to set everything up and
then <b>draw(&nbsp;)</b> the <b>Shape</b>. The <b>draw(&nbsp;)</b> function
should be a virtual function, a message to the <b>Shape</b> that it should draw
itself appropriately, depending on whether it is a circle, a square, a line,
and so on. However, this doesn’t work inside the constructor, virtual functions resolve to the “local” function bodies when called in constructors. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1794"
title="Add Comment A1794"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you want to be able to call a virtual function inside the
constructor and have it do the right thing, you must use a technique to <i>simulate</i>
a virtual constructor (which is a variation of the Factory Method). This is a
conundrum. Remember, the idea of a virtual function is that you send a message
to an object and let the object figure out the right thing to do. But a
constructor builds an object. So a virtual constructor would be like saying, “I
don’t know exactly what type of object you are, but build yourself anyway.” In
an ordinary constructor, the compiler must know which VTABLE address to bind to the VPTR, and if it existed, a virtual constructor couldn’t do
this because it doesn’t know all the type information at compile time. It makes
sense that a constructor can’t be virtual because it is the one function that
absolutely must know everything about the type of the object. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1797"
title="Add Comment A1797"><sup>Comment</sup></a></p>

<p class=MsoNormal>And yet there are times when you want something
approximating the behavior of a virtual constructor.</p>

<p class=MsoNormal>In the <b>Shape</b> example, it would be nice to hand the <b>Shape</b>
constructor some specific information in the argument list and let the
constructor create a specific type of <b>Shape</b> (a <b>Circle</b>, <b>Square</b>)
with no further intervention. Ordinarily, you’d have to make an explicit call
to the <b>Circle</b>, <b>Square</b> constructor yourself. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1796"
title="Add Comment A1796"><sup>Comment</sup></a></p>

<p class=MsoNormal>Coplien<a href="#_ftn108" name="_ftnref108" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[108]</span></sup></span></span></sup></span></a> calls
his solution to this problem “envelope and letter classes.” The “envelope”
class is the base class, a shell that contains a pointer to an object of the
base class. The constructor for the “envelope” determines (at runtime, when the
constructor is called, not at compile time, when the type checking is normally
done) what specific type to make, creates an object of that specific type (on
the heap), and then assigns the object to its pointer. All the function calls
are then handled by the base class through its pointer. So the base class is
acting as a proxy for the derived class: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1795"
title="Add Comment A1795"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:VirtualConstructor.cpp</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;exception&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Shape* s;</p>

<p class=CodeChar style='margin-left:0in'>  // Prevent copy-construction &amp;
operator=</p>

<p class=CodeChar style='margin-left:0in'>  Shape(Shape&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Shape operator=(Shape&amp;);</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  Shape() { s = 0; };</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void draw() { s-&gt;draw();
}</p>

<p class=CodeChar style='margin-left:0in'>  virtual void erase() {
s-&gt;erase(); }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void test() { s-&gt;test();
};</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Shape() {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;~Shape\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    if(s) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Making
virtual call: &quot;;</p>

<p class=CodeChar style='margin-left:0in'>      s-&gt;erase(); // Virtual call</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;delete s:
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    delete s; // The polymorphic
deletion</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  class BadShapeCreation : public
exception {</p>

<p class=CodeChar style='margin-left:0in'>    string reason;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    BadShapeCreation(string type) {</p>

<p class=CodeChar style='margin-left:0in'>      reason = &quot;Cannot create
type &quot; + type;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    ~BadShapeCreation() throw() {}</p>

<p class=CodeChar style='margin-left:0in'>    const char *what() const throw()
{ </p>

<p class=CodeChar style='margin-left:0in'>      return reason.c_str(); </p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  };</p>

<p class=CodeChar style='margin-left:0in'>  Shape(string type)
throw(BadShapeCreation);</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Circle : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Circle(Circle&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Circle operator=(Circle&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Circle() {} // Private constructor</p>

<p class=CodeChar style='margin-left:0in'>  friend class Shape;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Circle::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Circle::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void test() { draw(); }</p>

<p class=CodeChar style='margin-left:0in'>  ~Circle() { cout &lt;&lt;
&quot;Circle::~Circle\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Square : public Shape {</p>

<p class=CodeChar style='margin-left:0in'>  Square(Square&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Square operator=(Square&amp;);</p>

<p class=CodeChar style='margin-left:0in'>  Square() {}</p>

<p class=CodeChar style='margin-left:0in'>  friend class Shape;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  void draw() { cout &lt;&lt;
&quot;Square::draw\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void erase() { cout &lt;&lt;
&quot;Square::erase\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>  void test() { draw(); }</p>

<p class=CodeChar style='margin-left:0in'>  ~Square() { cout &lt;&lt;
&quot;Square::~Square\n&quot;; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>Shape::Shape(string type) </p>

<p class=CodeChar style='margin-left:0in'>  throw(Shape::BadShapeCreation) {</p>

<p class=CodeChar style='margin-left:0in'>  if(type == &quot;Circle&quot;) </p>

<p class=CodeChar style='margin-left:0in'>    s = new Circle;</p>

<p class=CodeChar style='margin-left:0in'>  else if(type == &quot;Square&quot;)</p>

<p class=CodeChar style='margin-left:0in'>    s = new Square;</p>

<p class=CodeChar style='margin-left:0in'>  else throw BadShapeCreation(type);</p>

<p class=CodeChar style='margin-left:0in'>  draw();  // Virtual call in the
constructor</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>char* shlist[] = { &quot;Circle&quot;,
&quot;Square&quot;, &quot;Square&quot;,</p>

<p class=CodeChar style='margin-left:0in'>  &quot;Circle&quot;,
&quot;Circle&quot;, &quot;Circle&quot;, &quot;Square&quot;, &quot;&quot; };</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Shape*&gt; shapes;</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;virtual
constructor calls:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  try {</p>

<p class=CodeChar style='margin-left:0in'>    for(char** cp = shlist; **cp;
cp++)</p>

<p class=CodeChar style='margin-left:0in'>      shapes.push_back(new
Shape(*cp));</p>

<p class=CodeChar style='margin-left:0in'>  } catch(Shape::BadShapeCreation e)
{</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; e.what() &lt;&lt;
endl;</p>

<p class=CodeChar style='margin-left:0in'>    for(int j = 0; j &lt;
shapes.size(); j++)</p>

<p class=CodeChar style='margin-left:0in'>      delete shapes[j];</p>

<p class=CodeChar style='margin-left:0in'>    return 1;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  for(int i = 0; i &lt;
shapes.size(); i++) {</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;draw();</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;test\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;test();</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;end
test\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    shapes[i]-&gt;erase();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Shape c(&quot;Circle&quot;); //
Create on the stack</p>

<p class=CodeChar style='margin-left:0in'>  cout &lt;&lt; &quot;destructor
calls:&quot; &lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  for(int j = 0; j &lt;
shapes.size(); j++) {</p>

<p class=CodeChar style='margin-left:0in'>    delete shapes[j];</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt;
&quot;\n------------\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The base class <b>Shape</b> contains a pointer to an object
of type <b>Shape</b> as its only data member. When you build a “virtual
constructor” scheme, you must exercise special care to ensure this pointer is
always initialized to a live object. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1798"
title="Add Comment A1798"><sup>Comment</sup></a></p>

<p class=MsoNormal>Each time you derive a new subtype from <b>Shape</b>, you
must go back and add the creation for that type in one place, inside the
“virtual constructor” in the <b>Shape</b> base class. This is not too onerous a
task, but the disadvantage is you now have a dependency between the <b>Shape</b>
class and all classes derived from it (a reasonable trade-off, it seems). Also,
because it is a proxy, the base-class interface is truly the only thing the
user sees. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1799"
title="Add Comment A1799"><sup>Comment</sup></a></p>

<p class=MsoNormal>In this example, the information you must hand the virtual
constructor about what type to create is very explicit: it’s a <b>string</b>
that names the type. However, your scheme can use other information—for
example, in a parser the output of the scanner can be handed to the virtual
constructor, which then uses that information to determine which token to
create. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1800"
title="Add Comment A1800"><sup>Comment</sup></a></p>

<p class=MsoNormal>The virtual constructor <b>Shape(type)</b> can only be
declared inside the class; it cannot be defined until after all the derived
classes have been declared. However, the default constructor can be defined inside <b>class Shape</b>, but it should be made <b>protected</b> so temporary <b>Shape</b>
objects cannot be created. This default constructor is only called by the
constructors of derived-class objects. You are forced to explicitly create a
default constructor because the compiler will create one for you automatically
only if there are <i>no</i> constructors defined. Because you must define <b>Shape(type)</b>,
you must also define <b>Shape(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1801"
title="Add Comment A1801"><sup>Comment</sup></a></p>

<p class=MsoNormal>The default constructor in this scheme has at least one
important chore—it must set the value of the <b>s</b> pointer to zero. This may
sound strange at first, but remember that the default constructor will be
called as part of the construction of the <i>actual object</i>—in Coplien’s
terms, the “letter,” not the “envelope.” However, the “letter” is derived from
the “envelope,” so it also inherits the data member <b>s</b>. In the
“envelope,” <b>s</b> is important because it points to the actual object, but
in the “letter,” <b>s</b> is simply excess baggage. Even excess baggage should
be initialized, however, and if <b>s</b> is not set to zero by the default
constructor called for the “letter,” bad things happen (as you’ll see later). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1802"
title="Add Comment A1802"><sup>Comment</sup></a></p>

<p class=MsoNormal>The virtual constructor takes as its argument information
that completely determines the type of the object. Notice, though, that this
type information isn’t read and acted upon until runtime, whereas normally the
compiler must know the exact type at compile time (one other reason this system
effectively imitates virtual constructors). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1803"
title="Add Comment A1803"><sup>Comment</sup></a></p>

<p class=MsoNormal>The virtual constructor uses its argument to select the
actual (“letter”) object to construct, which is then assigned to the pointer
inside the “envelope.” At that point, the construction of the “letter” has been
completed, so any virtual calls will be properly directed. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1804"
title="Add Comment A1804"><sup>Comment</sup></a></p>

<p class=MsoNormal>As an example, consider the call to <b>draw(&nbsp;)</b>
inside the virtual constructor. If you trace this call (either by hand or with
a debugger), you can see that it starts in the <b>draw(&nbsp;)</b> function in
the base class, <b>Shape</b>. This function calls <b>draw(&nbsp;)</b> for the
“envelope” <b>s</b> pointer to its “letter.” All types derived from <b>Shape</b>
share the same interface, so this virtual call is properly executed, even
though it seems to be in the constructor. (Actually, the constructor for the
“letter” has already completed.) As long as all virtual calls in the base class
simply make calls to identical virtual functions through the pointer to the
“letter,” the system operates properly. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1805"
title="Add Comment A1805"><sup>Comment</sup></a></p>

<p class=MsoNormal>To understand how it works, consider the code in <b>main(&nbsp;)</b>.
To fill the <b>vector shapes</b>, “virtual constructor” calls are made to <b>Shape</b>.
Ordinarily in a situation like this, you would call the constructor for the
actual type, and the VPTR for that type would be installed in the object. Here,
however, the VPTR used in each case is the one for <b>Shape</b>, not the one
for the specific <b>Circle</b>, <b>Square</b>, or <b>Triangle</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1806"
title="Add Comment A1806"><sup>Comment</sup></a></p>

<p class=MsoNormal>In the <b>for</b> loop where the <b>draw(&nbsp;)</b> and <b>erase(&nbsp;)
</b>functions are called for each <b>Shape</b>, the virtual function call
resolves, through the VPTR, to the corresponding type. However, this is <b>Shape</b>
in each case. In fact, you might wonder why <b>draw(&nbsp;)</b> and <b>erase(&nbsp;)
</b>were made <b>virtual</b> at all. The reason shows up in the next step: the
base-class version of <b>draw(&nbsp;)</b> makes a call, through the “letter”
pointer <b>s</b>, to the <b>virtual</b> function <b>draw(&nbsp;)</b> for the
“letter.” This time the call resolves to the actual type of the object, not
just the base class <b>Shape</b>. Thus, the runtime cost of using virtual
constructors is one more virtual call every time you make a virtual function
call. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1807"
title="Add Comment A1807"><sup>Comment</sup></a></p>

<p class=MsoNormal>To create any function that is overridden, such as <b>draw(&nbsp;)</b>,
<b>erase(&nbsp;),</b> or <b>test(&nbsp;)</b>, you must proxy all calls to the <b>s</b>
pointer in the base class implementation, as shown earlier. This is because,
when the call is made, the call to the envelope’s member function will resolve
as being to <b>Shape</b>, and not to a derived type of <b>Shape</b>. Only when
you make the proxy call to <b>s</b> will the virtual behavior take place. In <b>main(&nbsp;)</b>,
you can see that everything works correctly, even when calls are made inside
constructors and destructors. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1808"
title="Add Comment A1808"><sup>Comment</sup></a></p>

<h4>Destructor operation</h4>

<p class=MsoNormal>The activities of destruction in this scheme are also
tricky. To understand, let’s verbally walk through what happens when you call <b>delete</b>
for a pointer to a <b>Shape</b> object—specifically, a <b>Square</b>—created on
the heap. (This is more complicated than an object created on the stack.) This
will be a <b>delete</b> through the polymorphic interface, as in the statement <b>delete
shapes[i]</b> in <b>main(&nbsp;)</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1809"
title="Add Comment A1809"><sup>Comment</sup></a></p>

<p class=MsoNormal>The type of the pointer <b>shapes[i]</b> is of the base
class <b>Shape</b>, so the compiler makes the call through <b>Shape</b>.
Normally, you might say that it’s a virtual call, so <b>Square</b>’s destructor
will be called. But with the virtual constructor scheme, the compiler is
creating actual <b>Shape</b> objects, even though the constructor initializes
the letter pointer to a specific type of <b>Shape</b>. The virtual mechanism <i>is</i>
used, but the VPTR inside the <b>Shape</b> object is <b>Shape</b>’s VPTR, not <b>Square</b>’s.
This resolves to <b>Shape</b>’s destructor, which calls <b>delete</b> for the
letter pointer <b>s</b>, which actually points to a <b>Square</b> object. This
is again a virtual call, but this time it resolves to <b>Square</b>’s
destructor. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1810"
title="Add Comment A1810"><sup>Comment</sup></a></p>

<p class=MsoNormal>With a destructor, however, C++ guarantees, via the
compiler, that all destructors in the hierarchy are called. <b>Square</b>’s
destructor is called first, followed by any intermediate destructors, in order,
until finally the base-class destructor is called. This base-class destructor
has code that says <b>delete s</b>. When this destructor was called originally,
it was for the “envelope” <b>s</b>, but now it’s for the “letter” <b>s</b>,
which is there because the “letter” was inherited from the “envelope,” and not
because it contains anything. So <i>this</i> call to <b>delete</b> should do
nothing. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1811"
title="Add Comment A1811"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution to the problem is to make the “letter” <b>s</b>
pointer zero. Then when the “letter” base-class destructor is called, you get <b>delete
0</b>, which by definition does nothing. Because the default constructor is
protected, it will be called <i>only</i> during the construction of a “letter,”
so that’s the only situation in which <b>s</b> is set to zero. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1812"
title="Add Comment A1812"><sup>Comment</sup></a></p>

<p class=MsoNormal>Your most common tool for hiding construction will probably
be ordinary factory methods rather than the more complex approaches. The idea
of adding new types with minimal effect on the rest of the system will be
further explored later in this chapter. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1813"
title="Add Comment A1813"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440177"></a><a name="_Toc11818307">Observer</a></h2>

<p class=MsoNormal>The Observer pattern solves a fairly common problem: what if
a group of objects needs to update themselves when some other object changes
state? This can be seen in the “model-view” aspect of Smalltalk’s MVC
(model-view-controller) or the almost-equivalent “Document-View Architecture.”
Suppose that you have some data (the “document”) and more than one view, say a
plot and a textual view. When you change the data, the two views must know to
update themselves, and that’s what the observer facilitates.  <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1815"
title="Add Comment A1815"><sup>Comment</sup></a></p>

<p class=MsoNormal>Two types of objects are used to implement the observer
pattern in the following code. The <b>Observable</b> class keeps track of
everybody who wants to be informed when a change happens. The <b>Observable</b>
class calls the <b>notifyObservers(&nbsp;)</b> member function for each
observer on the list. The <b>notifyObservers(&nbsp;)</b> member function is
part of the base class <b>Observable</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1816"
title="Add Comment A1816"><sup>Comment</sup></a></p>

<p class=MsoNormal>There are actually two “things that change” in the observer
pattern: the quantity of observing objects and the way an update occurs. That
is, the observer pattern allows you to modify both of these without affecting the
surrounding code. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1817"
title="Add Comment A1817"><sup>Comment</sup></a></p>

<p class=MsoNormal>You can implement the observer pattern in a number of ways,
but the code shown here will create a framework from which you can build your
own observer code, following the example. First, this interface describes what
an observer looks like: <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1818"
title="Add Comment A1818"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:Observer.h</p>

<p class=CodeChar style='margin-left:0in'>// The Observer interface</p>

<p class=CodeChar style='margin-left:0in'>#ifndef OBSERVER_H</p>

<p class=CodeChar style='margin-left:0in'>#define OBSERVER_H</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Observable;</p>

<p class=CodeChar style='margin-left:0in'>class Argument {};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Observer {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  // Called by the observed object,
whenever </p>

<p class=CodeChar style='margin-left:0in'>  // the observed object is changed:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void </p>

<p class=CodeChar style='margin-left:0in'>  update(Observable* o, Argument *
arg) = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // OBSERVER_H ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Since <b>Observer</b> interacts with <b>Observable</b> in
this approach, <b>Observable</b> must be declared first. In addition, the <b>Argument</b>
class is empty and only acts as a base class for any type of argument you want
to pass during an update. If you want, you can simply pass the extra argument
as a <b>void*</b>. You’ll have to downcast in either case. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1819"
title="Add Comment A1819"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> Observer</b> type is an “interface” class that only
has one member function, <b>update(&nbsp;)</b>. This function is called by the
object that’s being observed, when that object decides it’s time to update all
its observers. The arguments are optional; you could have an <b>update(&nbsp;)</b>
with no arguments, and that would still fit the observer pattern. However this
is more general—it allows the observed object to pass the object that caused
the update (since an <b>Observer </b>may be registered with more than one
observed object) and any extra information if that’s helpful, rather than
forcing the <b>Observer</b> object to hunt around to see who is updating and to
fetch any other information it needs. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1820"
title="Add Comment A1820"><sup>Comment</sup></a></p>

<p class=MsoNormal>The “observed object” will be of type <b>Observable</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:Observable.h</p>

<p class=CodeChar style='margin-left:0in'>// The Observable class</p>

<p class=CodeChar style='margin-left:0in'>#ifndef OBSERVABLE_H</p>

<p class=CodeChar style='margin-left:0in'>#define OBSERVABLE_H</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Observer.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;set&gt;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Observable {</p>

<p class=CodeChar style='margin-left:0in'>  bool changed;</p>

<p class=CodeChar style='margin-left:0in'>  std::set&lt;Observer*&gt;
observers;</p>

<p class=CodeChar style='margin-left:0in'>protected:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void setChanged() { changed
= true; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void clearChanged(){
changed = false; }</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void
addObserver(Observer&amp; o) {</p>

<p class=CodeChar style='margin-left:0in'>    observers.insert(&amp;o);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void
deleteObserver(Observer&amp; o) {</p>

<p class=CodeChar style='margin-left:0in'>    observers.erase(&amp;o);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void deleteObservers() {</p>

<p class=CodeChar style='margin-left:0in'>    observers.clear();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual int countObservers() {</p>

<p class=CodeChar style='margin-left:0in'>    return observers.size();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual bool hasChanged() { return
changed; }</p>

<p class=CodeChar style='margin-left:0in'>  // If this object has changed,
notify all</p>

<p class=CodeChar style='margin-left:0in'>  // of its observers:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void notifyObservers(Argument*
arg=0) {</p>

<p class=CodeChar style='margin-left:0in'>    if(!hasChanged()) return;</p>

<p class=CodeChar style='margin-left:0in'>    clearChanged(); // Not
&quot;changed&quot; anymore</p>

<p class=CodeChar style='margin-left:0in'>   
std::set&lt;Observer*&gt;::iterator it;</p>

<p class=CodeChar style='margin-left:0in'>    for(it = observers.begin(); </p>

<p class=CodeChar style='margin-left:0in'>      it != observers.end(); it++)</p>

<p class=CodeChar style='margin-left:0in'>      (*it)-&gt;update(this, arg);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeInlineCharChar style='margin-left:0in'>#endif // OBSERVABLE_H
///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>Again, the design here is more elaborate than is necessary;
as long as there’s a way to register an <b>Observer</b> with an <b>Observable</b>
and a way for the <b>Observable</b> to update its <b>Observer</b>s, the set of
member functions doesn’t matter. However, this design is intended to be
reusable. (It was lifted from the design used in the Java standard library<a
href="#_ftn109" name="_ftnref109" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'>[109]</span></sup></span></span></sup></span></a>.) <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1821"
title="Add Comment A1821"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> Observable</b> object has a flag to indicate whether
it’s been changed. In a simpler design, there would be no flag; if something
happened, everyone would be notified. Notice, however, that the control of the
flag’s state is <b>protected</b> so that only an inheritor can decide what
constitutes a change, and not the end user of the resulting derived <b>Observer</b>
class. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1822"
title="Add Comment A1822"><sup>Comment</sup></a></p>

<p class=MsoNormal>The collection of <b>Observer</b> objects is kept in a <b>set&lt;Observer*&gt;</b>
to prevent duplicates; the <b>set insert(&nbsp;)</b>, <b>erase(&nbsp;)</b>, <b>clear(&nbsp;),</b>
and <b>size(&nbsp;)</b> functions are exposed to allow <b>Observer</b>s to be
added and removed at any time, thus providing runtime flexibility. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1823"
title="Add Comment A1823"><sup>Comment</sup></a></p>

<p class=MsoNormal>Most of the work is done in <b>notifyObservers(&nbsp;)</b>.
If the <b>changed</b> flag has not been set, this does nothing. Otherwise, it
first clears the <b>changed</b> flag so that repeated calls to <b>notifyObservers(&nbsp;)</b>
won’t waste time. This is done before notifying the observers in case the calls
to <b>update(&nbsp;)</b> do anything that causes a change back to this <b>Observable</b>
object. It then moves through the <b>set</b> and calls back to the <b>update(&nbsp;)</b>
member function of each <b>Observer</b>. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1824"
title="Add Comment A1824"><sup>Comment</sup></a></p>

<p class=MsoNormal>At first it may appear that you can use an ordinary <b>Observable</b>
object to manage the updates. But this doesn’t work; to get an effect, you <i>must</i>
derive from <b>Observable</b> and somewhere in your derived-class code call <b>setChanged(&nbsp;)</b>. This is the member function that sets the “changed” flag,
which means that when you call <b>notifyObservers(&nbsp;)</b> all the observers
will, in fact, get notified. <i>Where</i> you call <b>setChanged(&nbsp;)</b>
depends on the logic of your program. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1825"
title="Add Comment A1825"><sup>Comment</sup></a></p>

<p class=MsoNormal>Now we encounter a dilemma. Objects that are being observed
may have more than one such item of interest. For example, if you’re dealing
with a GUI item—a button, say—the items of interest might be the mouse clicked
the button, the mouse moved over the button, and (for some reason) the button
changed its color. So we’d like to be able to report all these events to
different observers, each of which is interested in a different type of event. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1826"
title="Add Comment A1826"><sup>Comment</sup></a></p>

<p class=MsoNormal>The problem is that we would normally reach for multiple
inheritance in such a situation: “I’ll inherit from <b>Observable</b> to deal
with mouse clicks, and I’ll … er … inherit from <b>Observable</b> to deal with
mouse-overs, and, well, … hmm, that doesn’t work.” <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1827"
title="Add Comment A1827"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440178">The “inner class” idiom</a></h3>

<p class=MsoNormal>Here’s a situation in which we do actually need to (in
effect) upcast to more than one type, but in this case we need to provide
several <i>different</i> implementations of the same base type. The solution is
something we’ve lifted from Java, which takes C++’s nested class one step
further. Java has a built-in feature called an <i>inner class</i>, which is
like a nested class in C++, but it has access to the nonstatic data of its
containing class by implicitly using the “this” pointer of the class object it
was created within.<a href="#_ftn110" name="_ftnref110" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[110]</span></sup></span></span></sup></span></a> <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1828"
title="Add Comment A1828"><sup>Comment</sup></a></p>

<p class=MsoNormal>To implement the inner class idiom in C++, we must obtain
and use a pointer to the containing object explicitly. Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:InnerClassIdiom.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Example of the &quot;inner
class&quot; idiom</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Poingable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void poing() = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void callPoing(Poingable&amp; p) {</p>

<p class=CodeChar style='margin-left:0in'>  p.poing();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bingable {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void bing() = 0;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>void callBing(Bingable&amp; b) {</p>

<p class=CodeChar style='margin-left:0in'>  b.bing();</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Outer {</p>

<p class=CodeChar style='margin-left:0in'>  string name;</p>

<p class=CodeChar style='margin-left:0in'>  // Define one inner class:</p>

<p class=CodeChar style='margin-left:0in'>  class Inner1;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Outer::Inner1;</p>

<p class=CodeChar style='margin-left:0in'>  class Inner1 : public Poingable {</p>

<p class=CodeChar style='margin-left:0in'>    Outer* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    Inner1(Outer* p) : parent(p) {}</p>

<p class=CodeChar style='margin-left:0in'>    void poing() {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;poing
called for &quot;</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; parent-&gt;name
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>      // Accesses data in the outer
class object</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } inner1;</p>

<p class=CodeChar style='margin-left:0in'>  // Define a second inner class:</p>

<p class=CodeChar style='margin-left:0in'>  class Inner2;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Outer::Inner2;</p>

<p class=CodeChar style='margin-left:0in'>  class Inner2 : public Bingable {</p>

<p class=CodeChar style='margin-left:0in'>    Outer* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    Inner2(Outer* p) : parent(p) {}</p>

<p class=CodeChar style='margin-left:0in'>    void bing() {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;bing called
for &quot;</p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; parent-&gt;name
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } inner2;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Outer(const string&amp; nm) :
name(nm), </p>

<p class=CodeChar style='margin-left:0in'>    inner1(this), inner2(this) {}</p>

<p class=CodeChar style='margin-left:0in'>  // Return reference to interfaces</p>

<p class=CodeChar style='margin-left:0in'>  //  implemented by the inner
classes:</p>

<p class=CodeChar style='margin-left:0in'>  operator Poingable&amp;() { return
inner1; }</p>

<p class=CodeChar style='margin-left:0in'>  operator Bingable&amp;() { return
inner2; }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Outer x(&quot;Ping Pong&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  // Like upcasting to multiple base
types!:</p>

<p class=CodeChar style='margin-left:0in'>  callPoing(x);</p>

<p class=CodeChar style='margin-left:0in'>  callBing(x);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The example begins with the <b>Poingable</b> and <b>Bingable
</b>interfaces, each of which contain a single member function. The services
provided by <b>callPoing(&nbsp;)</b> and <b>callBing(&nbsp;) </b>require that
the object they receive implement the <b>Poingable</b> and <b>Bingable </b>interfaces,
respectively, but they put no other requirements on that object so as to
maximize the flexibility of using <b>callPoing(&nbsp;)</b> and <b>callBing(&nbsp;)</b>.
Note the lack of <b>virtual</b> destructors in either interface—the intent is
that you never perform object destruction via the interface. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1829"
title="Add Comment A1829"><sup>Comment</sup></a></p>

<p class=MsoNormal>The<b> Outer</b> constructor contains some private data (<b>name</b>),
and it wants to provide both a <b>Poingable</b> interface and a <b>Bingable </b>interface
so it can be used with <b>callPoing(&nbsp;) </b>and <b>callBing(&nbsp;)</b>. Of
course, in this situation we <i>could</i> simply use multiple inheritance. This
example is just intended to show the simplest syntax for the idiom; you’ll see
a real use shortly. To provide a <b>Poingable</b> object without deriving <b>Outer</b>
from <b>Poingable</b>, the inner class idiom is used. First, the declaration <b>class
Inner</b> says that, somewhere, there is a nested class of this name. This
allows the <b>friend</b> declaration for the class, which follows. Finally, now
that the nested class has been granted access to all the private elements of <b>Outer</b>,
the class can be defined. Notice that it keeps a pointer to the <b>Outer</b>
which created it, and this pointer must be initialized in the constructor.
Finally, the <b>poing(&nbsp;)</b> function from <b>Poingable</b> is
implemented. The same process occurs for the second inner class which implements
<b>Bingable</b>. Each inner class has a single <b>private</b> instance created,
which is initialized in the <b>Outer</b> constructor. By creating the member
objects and returning references to them, issues of object lifetime are
eliminated. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1830"
title="Add Comment A1830"><sup>Comment</sup></a></p>

<p class=MsoNormal>Notice that both inner class definitions are <b>private</b>,
and in fact the client code doesn’t have any access to details of the
implementation, since the two access methods <b>operator Poingable&amp;(&nbsp;)</b>
and <b>operator Bingable&amp;(&nbsp;)</b> only return a reference to the upcast
interface, not to the object that implements it. In fact, since the two inner
classes are <b>private</b>, the client code cannot even downcast to the
implementation classes, thus providing complete isolation between interface and
implementation. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1831"
title="Add Comment A1831"><sup>Comment</sup></a></p>

<p class=MsoNormal>Just to push a point, we’ve taken the extra liberty here of
defining the automatic type conversion operators <b>operator
Poingable&amp;(&nbsp;)</b> and <b>operator Bingable&amp;(&nbsp;)</b>. In <b>main(&nbsp;)</b>,
you can see that these actually allow a syntax that looks like <b>Outer</b>
multiply inherits from <b>Poingable</b> and <b>Bingable</b>. The difference is
that the casts in this case are one way. You can get the effect of an upcast to
<b>Poingable</b> or <b>Bingable</b>, but you cannot downcast back to an <b>Outer</b>.
In the following example of <b>observer</b>, you’ll see the more typical
approach: you provide access to the inner class objects using ordinary member
functions, not automatic type conversion operations. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1832"
title="Add Comment A1832"><sup>Comment</sup></a></p>

<h3><a name="_Toc45440179">The observer example</a></h3>

<p class=MsoNormal>Armed with the <b>Observer</b> and <b>Observable </b>header
files and the inner class idiom, we can look at an example of the Observer
pattern:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:ObservedFlower.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstration of
&quot;observer&quot; pattern</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;Observable.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Flower {</p>

<p class=CodeChar style='margin-left:0in'>  bool isOpen;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Flower() : isOpen(false), </p>

<p class=CodeChar style='margin-left:0in'>    openNotifier(this),
closeNotifier(this) {}</p>

<p class=CodeChar style='margin-left:0in'>  void open() { // Opens its petals</p>

<p class=CodeChar style='margin-left:0in'>    isOpen = true;</p>

<p class=CodeChar style='margin-left:0in'>    openNotifier.notifyObservers();</p>

<p class=CodeChar style='margin-left:0in'>    closeNotifier.open();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  void close() { // Closes its petals</p>

<p class=CodeChar style='margin-left:0in'>    isOpen = false;</p>

<p class=CodeChar style='margin-left:0in'>    closeNotifier.notifyObservers();</p>

<p class=CodeChar style='margin-left:0in'>    openNotifier.close();</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Using the &quot;inner
class&quot; idiom:</p>

<p class=CodeChar style='margin-left:0in'>  class OpenNotifier;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Flower::OpenNotifier;</p>

<p class=CodeChar style='margin-left:0in'>  class OpenNotifier : public
Observable {</p>

<p class=CodeChar style='margin-left:0in'>    Flower* parent;</p>

<p class=CodeChar style='margin-left:0in'>    bool alreadyOpen;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    OpenNotifier(Flower* f) :
parent(f), </p>

<p class=CodeChar style='margin-left:0in'>      alreadyOpen(false) {}</p>

<p class=CodeChar style='margin-left:0in'>    void notifyObservers(Argument*
arg=0) {</p>

<p class=CodeChar style='margin-left:0in'>      if(parent-&gt;isOpen &amp;&amp;
!alreadyOpen) {</p>

<p class=CodeChar style='margin-left:0in'>        setChanged();</p>

<p class=CodeChar style='margin-left:0in'>        Observable::notifyObservers();</p>

<p class=CodeChar style='margin-left:0in'>        alreadyOpen = true;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    void close() { alreadyOpen =
false; }</p>

<p class=CodeChar style='margin-left:0in'>  } openNotifier;</p>

<p class=CodeChar style='margin-left:0in'>  class CloseNotifier;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Flower::CloseNotifier;</p>

<p class=CodeChar style='margin-left:0in'>  class CloseNotifier : public
Observable {</p>

<p class=CodeChar style='margin-left:0in'>    Flower* parent;</p>

<p class=CodeChar style='margin-left:0in'>    bool alreadyClosed;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    CloseNotifier(Flower* f) :
parent(f), </p>

<p class=CodeChar style='margin-left:0in'>      alreadyClosed(false) {}</p>

<p class=CodeChar style='margin-left:0in'>    void notifyObservers(Argument*
arg=0) {</p>

<p class=CodeChar style='margin-left:0in'>      if(!parent-&gt;isOpen
&amp;&amp; !alreadyClosed) {</p>

<p class=CodeChar style='margin-left:0in'>        setChanged();</p>

<p class=CodeChar style='margin-left:0in'>       
Observable::notifyObservers();</p>

<p class=CodeChar style='margin-left:0in'>        alreadyClosed = true;</p>

<p class=CodeChar style='margin-left:0in'>      }</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>    void open() { alreadyClosed =
false; }</p>

<p class=CodeChar style='margin-left:0in'>  } closeNotifier;</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Bee {</p>

<p class=CodeChar style='margin-left:0in'>  string name;</p>

<p class=CodeChar style='margin-left:0in'>  // An &quot;inner class&quot; for
observing openings:</p>

<p class=CodeChar style='margin-left:0in'>  class OpenObserver;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Bee::OpenObserver;</p>

<p class=CodeChar style='margin-left:0in'>  class OpenObserver : public
Observer {</p>

<p class=CodeChar style='margin-left:0in'>    Bee* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    OpenObserver(Bee* b) : parent(b)
{}</p>

<p class=CodeChar style='margin-left:0in'>    void update(Observable*, Argument
*) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Bee &quot;
&lt;&lt; parent-&gt;name </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot;'s breakfast
time!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } openObsrv;</p>

<p class=CodeChar style='margin-left:0in'>  // Another &quot;inner class&quot;
for closings:</p>

<p class=CodeChar style='margin-left:0in'>  class CloseObserver;</p>

<p class=CodeChar style='margin-left:0in'>  friend class Bee::CloseObserver;</p>

<p class=CodeChar style='margin-left:0in'>  class CloseObserver : public
Observer {</p>

<p class=CodeChar style='margin-left:0in'>    Bee* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    CloseObserver(Bee* b) : parent(b)
{}</p>

<p class=CodeChar style='margin-left:0in'>    void update(Observable*, Argument
*) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Bee &quot;
&lt;&lt; parent-&gt;name </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot;'s bed
time!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } closeObsrv;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Bee(string nm) : name(nm), </p>

<p class=CodeChar style='margin-left:0in'>    openObsrv(this), closeObsrv(this)
{}</p>

<p class=CodeChar style='margin-left:0in'>  Observer&amp; openObserver() {
return openObsrv; }</p>

<p class=CodeChar style='margin-left:0in'>  Observer&amp; closeObserver() {
return closeObsrv;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Hummingbird {</p>

<p class=CodeChar style='margin-left:0in'>  string name;</p>

<p class=CodeChar style='margin-left:0in'>  class OpenObserver;</p>

<p class=CodeChar style='margin-left:0in'>  friend class
Hummingbird::OpenObserver;</p>

<p class=CodeChar style='margin-left:0in'>  class OpenObserver : public
Observer {</p>

<p class=CodeChar style='margin-left:0in'>    Hummingbird* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    OpenObserver(Hummingbird* h) :
parent(h) {}</p>

<p class=CodeChar style='margin-left:0in'>    void update(Observable*, Argument
*) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Hummingbird
&quot; &lt;&lt; parent-&gt;name </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot;'s breakfast
time!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } openObsrv;</p>

<p class=CodeChar style='margin-left:0in'>  class CloseObserver;</p>

<p class=CodeChar style='margin-left:0in'>  friend class
Hummingbird::CloseObserver;</p>

<p class=CodeChar style='margin-left:0in'>  class CloseObserver : public
Observer {</p>

<p class=CodeChar style='margin-left:0in'>    Hummingbird* parent;</p>

<p class=CodeChar style='margin-left:0in'>  public:</p>

<p class=CodeChar style='margin-left:0in'>    CloseObserver(Hummingbird* h) :
parent(h) {}</p>

<p class=CodeChar style='margin-left:0in'>    void update(Observable*, Argument
*) {</p>

<p class=CodeChar style='margin-left:0in'>      cout &lt;&lt; &quot;Hummingbird
&quot; &lt;&lt; parent-&gt;name </p>

<p class=CodeChar style='margin-left:0in'>        &lt;&lt; &quot;'s bed
time!\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  } closeObsrv;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Hummingbird(string nm) : name(nm), </p>

<p class=CodeChar style='margin-left:0in'>    openObsrv(this), closeObsrv(this)
{}</p>

<p class=CodeChar style='margin-left:0in'>  Observer&amp; openObserver() {
return openObsrv; }</p>

<p class=CodeChar style='margin-left:0in'>  Observer&amp; closeObserver() {
return closeObsrv;}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  Flower f;</p>

<p class=CodeChar style='margin-left:0in'>  Bee ba(&quot;A&quot;),
bb(&quot;B&quot;);</p>

<p class=CodeChar style='margin-left:0in'>  Hummingbird ha(&quot;A&quot;),
hb(&quot;B&quot;);</p>

<p class=CodeChar style='margin-left:0in'> 
f.openNotifier.addObserver(ha.openObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.openNotifier.addObserver(hb.openObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.openNotifier.addObserver(ba.openObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.openNotifier.addObserver(bb.openObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.closeNotifier.addObserver(ha.closeObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.closeNotifier.addObserver(hb.closeObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.closeNotifier.addObserver(ba.closeObserver());</p>

<p class=CodeChar style='margin-left:0in'> 
f.closeNotifier.addObserver(bb.closeObserver());</p>

<p class=CodeChar style='margin-left:0in'>  // Hummingbird B decides to sleep
in:</p>

<p class=CodeChar style='margin-left:0in'> 
f.openNotifier.deleteObserver(hb.openObserver());</p>

<p class=CodeChar style='margin-left:0in'>  // Something changes that interests
observers:</p>

<p class=CodeChar style='margin-left:0in'>  f.open();</p>

<p class=CodeChar style='margin-left:0in'>  f.open(); // It's already open, no
change.</p>

<p class=CodeChar style='margin-left:0in'>  // Bee A doesn't want to go to bed:</p>

<p class=CodeChar style='margin-left:0in'>  f.closeNotifier.deleteObserver(</p>

<p class=CodeChar style='margin-left:0in'>    ba.closeObserver());</p>

<p class=CodeChar style='margin-left:0in'>  f.close();</p>

<p class=CodeChar style='margin-left:0in'>  f.close(); // It's already closed;
no change</p>

<p class=CodeChar style='margin-left:0in'>  f.openNotifier.deleteObservers();</p>

<p class=CodeChar style='margin-left:0in'>  f.open();</p>

<p class=CodeChar style='margin-left:0in'>  f.close();</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<p class=MsoNormal>The events of interest are that a <b>Flower</b> can open or
close. Because of the use of the inner class idiom, both these events can be
separately observable phenomena. The <b>OpenNotifier</b> and <b>CloseNotifier</b>
classes both derive from <b>Observable</b>, so they have access to <b>setChanged(&nbsp;)</b>
and can be handed to anything that needs an <b>Observable</b>. You’ll notice
that, contrary to <b>InnerClassIdiom.cpp</b>, the <b>Observable</b> descendants
are <b>public</b>. This is because some of their member functions must be
available to the client programmer. There’s nothing that says that an inner
class must be <b>private</b>; in <b>InnerClassIdiom.cpp</b> we were simply
following the design guideline “make things as private as possible.” You could
make the classes <b>private</b> and expose the appropriate member functions by
proxy in <b>Flower</b>, but it wouldn’t gain much. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1833"
title="Add Comment A1833"><sup>Comment</sup></a></p>

<p class=MsoNormal>The inner class idiom also comes in handy to define more
than one kind of <b>Observer</b>, in <b>Bee</b> and <b>Hummingbird</b>, since
both those classes may want to independently observe <b>Flower</b> openings and
closings. Notice how the inner class idiom provides something that has most of
the benefits of inheritance (the ability to access the private data in the
outer class, for example). <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1834"
title="Add Comment A1834"><sup>Comment</sup></a></p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, you can see one of the primary
benefits of the Observer pattern: the ability to change behavior at runtime by
dynamically registering and unregistering <b>Observer</b>s with <b>Observable</b>s.
<a href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1835"
title="Add Comment A1835"><sup>Comment</sup></a></p>

<p class=MsoNormal>If you study the previous code, you’ll see that <b>OpenNotifier
</b>and <b>CloseNotifier</b> use the basic <b>Observable</b> interface. This
means that you could derive from other completely different <b>Observer</b>
classes; the only connection the <b>Observer</b>s have with <b>Flower</b>s is
the <b>Observer</b> interface. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1836"
title="Add Comment A1836"><sup>Comment</sup></a></p>

<h2 style='margin-left:0in'><a name="_Toc45440180"></a><a name="_Toc11818308">Multiple
dispatching</a></h2>

<p class=MsoNormal>When dealing with multiple types that are interacting, a
program can get particularly messy. For example, consider a system that parses
and executes mathematical expressions. You want to be able to say <b>Number +
Number</b>, <b>Number * Number</b>, and so on, where <b>Number</b> is the base
class for a family of numerical objects. But when you say <b>a + b</b>, and you
don’t know the exact type of either <b>a</b> or <b>b</b>, how can you get them
to interact properly? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1837"
title="Add Comment A1837"><sup>Comment</sup></a></p>

<p class=MsoNormal>The answer starts with something you probably don’t think
about: C++ performs only single dispatching. That is, if you are performing an
operation on more than one object whose type is unknown, C++ can invoke the
dynamic binding mechanism on only one of those types. This doesn’t solve the
problem, so you end up detecting some types manually and effectively producing
your own dynamic binding behavior. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1838"
title="Add Comment A1838"><sup>Comment</sup></a></p>

<p class=MsoNormal>The solution is called <i>multiple dispatching</i>. Remember that polymorphism can occur only via member function calls, so if you want
double dispatching to occur, there must be two member function calls: the first
to determine the first unknown type, and the second to determine the second
unknown type. With multiple dispatching, you must have a virtual call for each of
the types. Generally, you’ll set up a configuration such that a single member
function call produces more than one dynamic member function call and thus
services more than one type in the process. To get this effect, you need to
work with more than one virtual function: you’ll need a virtual function call
for each dispatch. The virtual functions in the following example are called <b>compete(&nbsp;)
</b>and <b>eval(&nbsp;)</b> and are both members of the same type. (In this
case, there will be only two dispatches, which is referred to as <i>double dispatching.</i>) If you are working with two different type hierarchies
that are interacting, you’ll need a virtual call in each hierarchy. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1839"
title="Add Comment A1839"><sup>Comment</sup></a></p>

<p class=MsoNormal>Here’s an example of multiple dispatching:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:PaperScissorsRock.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstration of multiple
dispatching</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iterator&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Paper;</p>

<p class=CodeChar style='margin-left:0in'>class Scissors;</p>

<p class=CodeChar style='margin-left:0in'>class Rock;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>enum Outcome { win, lose, draw };</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>operator&lt;&lt;(ostream&amp; os,
const Outcome out) {</p>

<p class=CodeChar style='margin-left:0in'>  switch(out) {</p>

<p class=CodeChar style='margin-left:0in'>    default:</p>

<p class=CodeChar style='margin-left:0in'>    case win: return os &lt;&lt;
&quot;win&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    case lose: return os &lt;&lt;
&quot;lose&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    case draw: return os &lt;&lt;
&quot;draw&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>}</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Item {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual Outcome compete(const
Item*) = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual Outcome eval(const Paper*)
const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual Outcome eval(const
Scissors*) const= 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual Outcome eval(const Rock*)
const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ostream&amp;
print(ostream&amp; os) const = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Item() {}</p>

<p class=CodeChar style='margin-left:0in'>  friend ostream&amp; </p>

<p class=CodeChar style='margin-left:0in'>  operator&lt;&lt;(ostream&amp; os,
const Item* it) {</p>

<p class=CodeChar style='margin-left:0in'>    return it-&gt;print(os);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Paper : public Item {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Outcome compete(const Item* it) {</p>

<p class=CodeChar style='margin-left:0in'>    return it-&gt;eval(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Paper*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return draw;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Scissors*) const
{</p>

<p class=CodeChar style='margin-left:0in'>    return win;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Rock*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return lose;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ostream&amp; print(ostream&amp; os)
const {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; &quot;Paper  
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Scissors : public Item {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Outcome compete(const Item* it) {</p>

<p class=CodeChar style='margin-left:0in'>    return it-&gt;eval(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Paper*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return lose;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Scissors*) const
{</p>

<p class=CodeChar style='margin-left:0in'>    return draw;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Rock*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return win;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ostream&amp; print(ostream&amp; os)
const {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt;
&quot;Scissors&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Rock : public Item {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  Outcome compete(const Item* it) {</p>

<p class=CodeChar style='margin-left:0in'>    return it-&gt;eval(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Paper*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return win;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Scissors*) const
{</p>

<p class=CodeChar style='margin-left:0in'>    return lose;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  Outcome eval(const Rock*) const {</p>

<p class=CodeChar style='margin-left:0in'>    return draw;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  ostream&amp; print(ostream&amp; os)
const {</p>

<p class=CodeChar style='margin-left:0in'>    return os &lt;&lt; &quot;Rock   
&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct ItemGen {</p>

<p class=CodeChar style='margin-left:0in'>  ItemGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  Item* operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    switch(rand() % 3) {</p>

<p class=CodeChar style='margin-left:0in'>      default:</p>

<p class=CodeChar style='margin-left:0in'>      case 0:</p>

<p class=CodeChar style='margin-left:0in'>        return new Scissors;</p>

<p class=CodeChar style='margin-left:0in'>      case 1:</p>

<p class=CodeChar style='margin-left:0in'>        return new Paper;</p>

<p class=CodeChar style='margin-left:0in'>      case 2:</p>

<p class=CodeChar style='margin-left:0in'>        return new Rock;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct Compete {</p>

<p class=CodeChar style='margin-left:0in'>  Outcome operator()(Item* a, Item*
b) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; a &lt;&lt;
&quot;\t&quot; &lt;&lt; b &lt;&lt; &quot;\t&quot;;</p>

<p class=CodeChar style='margin-left:0in'>    return a-&gt;compete(b);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  const int sz = 20;</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Item*&gt; v(sz*2);</p>

<p class=CodeChar style='margin-left:0in'>  generate(v.begin(), v.end(),
ItemGen());</p>

<p class=CodeChar style='margin-left:0in'>  transform(v.begin(), v.begin() +
sz, </p>

<p class=CodeChar style='margin-left:0in'>    v.begin() + sz, </p>

<p class=CodeChar style='margin-left:0in'>   
ostream_iterator&lt;Outcome&gt;(cout, &quot;\n&quot;), </p>

<p class=CodeChar style='margin-left:0in'>    Compete());</p>

<p class=CodeChar style='margin-left:0in'>  purge(v);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h3><a name="_Toc45440181"></a><a name="_Toc11818309">Multiple dispatching</a>
with Visitor</h3>

<p class=MsoNormal>The assumption is that you have a primary class hierarchy
that is fixed; perhaps it’s from another vendor and you can’t make changes to
that hierarchy. However, you’d like to add new polymorphic member functions to
that hierarchy, which means that normally you’d have to add something to the
base class interface. So the dilemma is that you need to add member functions
to the base class, but you can’t touch the base class. How do you get around
this? <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1840"
title="Add Comment A1840"><sup>Comment</sup></a></p>

<p class=MsoNormal>The design pattern that solves this kind of problem is
called a “visitor” (the final one in <i>Design Patterns</i>), and it builds on
the double<i>-</i>dispatching scheme shown in the previous section. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1841"
title="Add Comment A1841"><sup>Comment</sup></a></p>

<p class=MsoNormal>The Visitor pattern allows you to extend the interface of
the primary type by creating a separate class hierarchy of type <b>Visitor </b>to
“virtualize” the operations performed on the primary type. The objects of the
primary type simply “accept” the visitor and then call the visitor’s
dynamically<b>-</b>bound member function. <a
href="mailto:1kingja@uvsc.edu;cda@freshsources.com?Subject=%5bTICV2%5dA1842"
title="Add Comment A1842"><sup>Comment</sup></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'>//: C10:BeeAndFlowers.cpp</p>

<p class=CodeChar style='margin-left:0in'>// Demonstration of
&quot;visitor&quot; pattern</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;algorithm&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;cstdlib&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;ctime&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;iostream&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;string&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &lt;vector&gt;</p>

<p class=CodeChar style='margin-left:0in'>#include &quot;../purge.h&quot;</p>

<p class=CodeChar style='margin-left:0in'>using namespace std;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Gladiolus;</p>

<p class=CodeChar style='margin-left:0in'>class Renuculus;</p>

<p class=CodeChar style='margin-left:0in'>class Chrysanthemum;</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Visitor {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Gladiolus* f) =
0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Renuculus* f) =
0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Chrysanthemum*
f) = 0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Visitor() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Flower {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void accept(Visitor&amp;) =
0;</p>

<p class=CodeChar style='margin-left:0in'>  virtual ~Flower() {}</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Gladiolus : public Flower {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void accept(Visitor&amp; v)
{</p>

<p class=CodeChar style='margin-left:0in'>    v.visit(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Renuculus : public Flower {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void accept(Visitor&amp; v)
{</p>

<p class=CodeChar style='margin-left:0in'>    v.visit(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>class Chrysanthemum : public Flower {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void accept(Visitor&amp; v)
{</p>

<p class=CodeChar style='margin-left:0in'>    v.visit(this);</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Add the ability to produce a
string:</p>

<p class=CodeChar style='margin-left:0in'>class StringVal : public Visitor {</p>

<p class=CodeChar style='margin-left:0in'>  string s;</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  operator const string&amp;() {
return s; }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Gladiolus*) {</p>

<p class=CodeChar style='margin-left:0in'>    s = &quot;Gladiolus&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Renuculus*) {</p>

<p class=CodeChar style='margin-left:0in'>    s = &quot;Renuculus&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Chrysanthemum*)
{</p>

<p class=CodeChar style='margin-left:0in'>    s = &quot;Chrysanthemum&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>// Add the ability to do
&quot;Bee&quot; activities:</p>

<p class=CodeChar style='margin-left:0in'>class Bee : public Visitor {</p>

<p class=CodeChar style='margin-left:0in'>public:</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Gladiolus*) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Bee and
Gladiolus\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Renuculus*) {</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Bee and
Renuculus\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  virtual void visit(Chrysanthemum*)
{</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; &quot;Bee and
Chrysanthemum\n&quot;;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>struct FlowerGen {</p>

<p class=CodeChar style='margin-left:0in'>  FlowerGen() { srand(time(0)); }</p>

<p class=CodeChar style='margin-left:0in'>  Flower* operator()() {</p>

<p class=CodeChar style='margin-left:0in'>    switch(rand() % 3) {</p>

<p class=CodeChar style='margin-left:0in'>      default:</p>

<p class=CodeChar style='margin-left:0in'>      case 0: return new Gladiolus;</p>

<p class=CodeChar style='margin-left:0in'>      case 1: return new Renuculus;</p>

<p class=CodeChar style='margin-left:0in'>      case 2: return new
Chrysanthemum;</p>

<p class=CodeChar style='margin-left:0in'>    }</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>};</p>

<p class=CodeChar style='margin-left:0in'>&nbsp;</p>

<p class=CodeChar style='margin-left:0in'>int main() {</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Flower*&gt; v(10);</p>

<p class=CodeChar style='margin-left:0in'>  generate(v.begin(), v.end(), FlowerGen());</p>

<p class=CodeChar style='margin-left:0in'>  vector&lt;Flower*&gt;::iterator it;</p>

<p class=CodeChar style='margin-left:0in'>  // It's almost as if I added a
virtual function</p>

<p class=CodeChar style='margin-left:0in'>  // to produce a Flower string
representation:</p>

<p class=CodeChar style='margin-left:0in'>  StringVal sval;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = v.begin(); it != v.end();
it++) {</p>

<p class=CodeChar style='margin-left:0in'>    (*it)-&gt;accept(sval);</p>

<p class=CodeChar style='margin-left:0in'>    cout &lt;&lt; string(sval)
&lt;&lt; endl;</p>

<p class=CodeChar style='margin-left:0in'>  }</p>

<p class=CodeChar style='margin-left:0in'>  // Perform &quot;Bee&quot;
operation on all Flowers:</p>

<p class=CodeChar style='margin-left:0in'>  Bee bee;</p>

<p class=CodeChar style='margin-left:0in'>  for(it = v.begin(); it != v.end();
it++)</p>

<p class=CodeChar style='margin-left:0in'>    (*it)-&gt;accept(bee);</p>

<p class=CodeChar style='margin-left:0in'>  purge(v);</p>

<p class=CodeInlineCharChar style='margin-left:0in'>} ///:~</p>

</div>

<p class=CodeInlineTrailerCharChar>&nbsp;</p>

<h2 style='margin-left:0in'><a name="_Toc45440182"></a><a name="_Toc11818325"></a><a
name="_Toc408018808"></a><a name="_Toc375545420">Exercises</a></h2>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Using <b>SingletonPattern.cpp</b> as a starting point, create a
class that manages a fixed number of its own objects. Assume the objects are
database connections and you only have a license to use a fixed quantity of
these at any one time.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a minimal Observer-Observable design in two classes,
without base classes and without the extra arguments in <b>Observer.h</b> and
the member functions in <b>Observable.h</b>. Just create the bare minimum in
the two classes, and then demonstrate your design by creating one <b>Observable</b>
and many <b>Observer</b>s and cause the <b>Observable</b> to update the <b>Observer</b>s.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Change <b>InnerClassIdiom.cpp</b> so that <b>Outer</b> uses
multiple inheritance instead of the inner class idiom.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Explain how <b>AbstractFactory.cpp</b> demonstrates <i>Double
Dispatching</i> and the <i>Factory Method</i>.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify <b>ShapeFactory2.cpp</b> so that it uses an <i>Abstract
Factory</i> to create different sets of shapes (for example, one particular
type of factory object creates “thick shapes,” another creates “thin shapes,”
but each factory object can create all the shapes: circles, squares, triangles,
and so on).</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create a business-modeling environment with three types of <b>Inhabitant</b>:
<b>Dwarf</b> (for engineers), <b>Elf</b> (for marketers), and <b>Troll</b> (for
managers). Now create a class called <b>Project</b> that creates the different
inhabitants and causes them to <b>interact(&nbsp;)</b> with each other using
multiple dispatching.</p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt'><span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Modify the example in exercise 6 to make the interactions more
detailed. Each <b>Inhabitant</b> can randomly produce a <b>Weapon</b> using <b>getWeapon(&nbsp;)</b>:
a <b>Dwarf</b> uses <b>Jargon</b> or <b>Play</b>, an <b>Elf</b> uses <b>InventFeature</b>
or <b>SellImaginaryProduct</b>, and a <b>Troll</b> uses <b>Edict</b> and <b>Schedule</b>.
You must decide which weapons “win” and “lose” in each interaction (as in <b>PaperScissorsRock.cpp</b>).
Add a <b>battle(&nbsp;)</b> member function to <b>Project</b> that takes two <b>Inhabitant</b>s
and matches them against each other. Now create a <b>meeting(&nbsp;)</b> member
function for <b>Project</b> that creates groups of <b>Dwarf</b>, <b>Elf,</b>
and <b>Manager</b> and battles the groups against each other until only members
of one group are left standing. These are the “winners.”</p>

<p class=MsoNormal style='margin-left:0in'>&nbsp;</p>

</div>

<b><span style='font-size:24.0pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span></b>

<div class=Section18>

<h1 style='margin-left:-81.35pt'><a name="_Toc312374168"></a><a
name="_Toc45440183"></a><a name="_Toc40780393">11: Concurrency</a></h1>

<p class=Intro>Note that the ZThreads library is in the midst of a significant
modification, so there will come a time when the default Zthread library will
not work with this chapter. At that point you should watch for an upgrade of
the chapter.</p>

<p class=Intro>Objects provide a way to divide a program into independent
sections. Often, you also need to partition a program into separate,
independently running subtasks.</p>

<p class=MsoNormal><a name=BBB></a>Each of these independent subtasks is called
a <i>thread</i>, and you program as if each thread runs by itself and has the
CPU to itself. An underlying mechanism is actually dividing up the CPU time for
you, but in general, you don’t have to think about it, which helps to simplify
programming with multiple threads.<a
href="mailto:TIJ3@MindView.net?Subject=%5bTIJ3%5dChap14_2194"
title="Send BackTalk Comment"></a></p>

<p class=MsoNormal><a href="mailto:TIJ3@MindView.net?Subject=%5bTIJ3%5dChap14_2194"
title="Send BackTalk Comment"><span style='color:windowtext'>A </span><span style='color:windowtext'><i>process</i> is a self-contained program running with
its own address space. A </span><span
style='color:windowtext'><i>multitasking</i> operating system is capable of
running more than one process (program) at a time, while making it look like
each one is chugging along on its own, by periodically switching the CPU from
one task to another. A <i>thread</i> is a single sequential flow of control <i>within</i>
a process. A single process can thus have multiple concurrently executing
threads. </span>

<p class=MsoNormal><span style='color:windowtext'>There are many possible uses
for multithreading, but you’ll most often want to use it when you have some
part of your program tied to a particular event or resource. To keep from
holding up the rest of your program, you create a thread associated with that
event or resource and let it run independently of the main program. </span>

<p class=MsoNormal><span style='color:windowtext'>Concurrent programming is
like stepping into an entirely new world and learning a new programming
language, or at least a new set of language concepts. With the appearance of
thread support in most microcomputer operating systems, extensions for threads
have also been appearing in programming languages or libraries. In all cases,
thread programming:</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>Seems mysterious and requires a shift in the way you
think about programming.</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>Looks similar to thread support in other languages, so
when you understand threads, you understand a common tongue.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Understanding concurrent
programming is on the same order of difficulty as understanding polymorphism.
If you apply some effort, you can fathom the basic mechanism, but it generally
takes deep study and understanding in order to develop a true grasp of the
subject. The goal of this chapter is to give you a solid foundation in the
basics of concurrency so that you can understand the concepts and write
reasonable multithreaded programs. Be aware that you can easily become
overconfident, so if you are writing anything complex, you will need to study
dedicated books on the topic. </span>

<h2 style='margin-left:0in'><span style='color:windowtext'>Motivation</span></h2>

<p class=MsoNormal><span style='color:windowtext'>One of the most compelling
reasons for concurrency is to produce a responsive user interface. </span><span
style='color:windowtext'>Consider a program that performs some CPU-intensive
operation and thus ends up ignoring user input and being unresponsive. The
basic problem is that the program needs to continue performing its operations, and
at the same time it needs to return control to the user interface so that the
program can respond to the user. If you have a “quit” button, you don’t want to
be forced to poll it in every piece of code you write in your program (this
would couple your quit button across the program, and be a maintenance
headache), and yet you want the quit button to be responsive, as if you <i>were</i>
checking it regularly. </span>

<p class=MsoNormal><span style='color:windowtext'>A conventional function
cannot continue performing its operations and at the same time return control
to the rest of the program. In fact, this sounds like an impossible thing to
accomplish, as if the CPU must be in two places at once, but this is precisely
the illusion that concurrency provides. </span>

<p class=MsoNormal><span style='color:windowtext'>Concurrency can also be used
to optimize throughput. For example, you might be able to do important work
while you’re stuck waiting for input to arrive on an I/O port. Without
threading, the only reasonable solution is to poll the I/O port, which is
awkward and can be difficult. </span>

<p class=MsoNormal><span style='color:windowtext'>If you have a multiprocessor
machine, multiple threads may be distributed across multiple processors, which
can dramatically improve throughput. This is often the case with powerful
multiprocessor web servers, which can distribute large numbers of user requests
across CPUs in a program that allocates one thread per request. </span>

<p class=MsoNormal><span style='color:windowtext'>One thing to keep in mind is
that a program with many threads must be able to run on a single-CPU machine.
Therefore, it must also be possible to write the same program without using any
threads. However, multithreading provides an important organizational benefit,
so that the design of your program can be greatly simplified. Some types of
problems, such as simulation—a video game, for example—are very difficult to
solve without support for concurrency. </span>

<p class=MsoNormal><span style='color:windowtext'>The threading model is a
programming convenience to simplify juggling several operations at the same
time within a single program. With threads, the CPU will pop around and give
each thread some of its time. Each thread has the consciousness of constantly
having the CPU to itself, but the CPU’s time is actually sliced between all the
threads. The exception to this is if your program is running on multiple CPUs,
but one of the great things about threading is that you are abstracted away
from this layer, so your code does not need to know whether it is actually
running on a single CPU or many. Thus, threads are a way to create
transparently scalable programs—if a program is running too slowly, it can
easily be made faster by adding CPUs to your computer. Multitasking and multithreading
tend to be the most reasonable ways to utilize multiprocessor systems. </span>

<p class=MsoNormal><span style='color:windowtext'>Threading can reduce computing efficiency somewhat in
single-CPU machines, but the net improvement in program design, resource
balancing, and user convenience is often quite valuable. In general, threads
enable you to create a more loosely-coupled design; otherwise, parts of your
code would be forced to pay explicit attention to tasks that would normally be
handled by threads. </span>

<h2 style='margin-left:0in'><span style='color:windowtext'>Concurrency in C++</span></h2>

<p class=MsoNormal><span style='color:windowtext'>When the C++ standards
committee was creating the initial C++ standard, a concurrency mechanism was
explicitly excluded, because C didn’t have one and also because there were a
number of competing approaches to implementing concurrency. It seemed too much
of a constraint to force programmers to use only one of these.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The alternative turned out to
be worse, however. To use concurrency, you had to find and learn a library and
deal with its idiosyncracies and the uncertainties of working with a particular
vendor. In addition, there was no guarantee that such a library would work on
different compilers or across different platforms. Also, since concurrency was
not part of the standard language, it was more difficult to find C++
programmers that also understood concurrent programming.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Another influence may have
been the Java language, which included concurrency in the core language.
Although multithreading is still complicated, Java programmers tend to start
learning and using it from the beginning.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The next iteration of the C++
standard is seriously considering the addition of concurrency support to C++,
but at the time of this writing it is unclear what the library will look like.
So as the basis for this chapter we decided to use the Zthread library, because
we preferred the design, and it is open-source and freely available at <i>http://zthread.sourceforge.net</i>.
Eric Crahen, the author of the Zthread library, was instrumental in creating
this chapter (the bulk of this chapter was translated from the one in <i>Thinking
in Java, 3<sup>rd</sup> edition</i>).</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Installing Zthreads</span></h2>

<p class=MsoNormal><span style='color:windowtext'>ZThreads is distributed as
source code, so after downloading from the above URL, there are two steps to
install and use it:</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>Compile the library.</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>Configure your project to use the library.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The preferred method for
compiling ZThreads for most flavors of UNIX (Linux, SunOS, Cygwin, etc.) is to
use the configure script. After unpacking the files (using <b>tar</b>),<b> </b>simply
execute:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>./configure
&amp;&amp; make install</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>from the main directory of
the ZThreads archive to compile and install a copy of the library in the <i>/usr/local</i>
directory. A number of options can be customized when using this script,
including the locations of files. To find more details about these execute</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>./configure
–help</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>In order to simplify
compilation for other platforms and compilers (such as Borland, Microsoft, and
MetroWerks), project files for recent versions of these development
environments have been included in the ZThreads source distribution. You will
find these projects prepared for you in the <i>build</i> directory of the main
directory in the ZThreads archive. With your favorite IDE, open the appropriate
project file and by selecting the ‘build all’ or ‘compile all’ option you will
be able to build the library. The binaries will be placed in either a directory
named <i>Debug</i> or a directory named <i>Release</i> depending on what you
have chosen to build; the default is to build the debug version of the library.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Once the compilation has
succeeded, the next step is to create a project that uses the newly-compiled
library. First, you must let the compiler know where the headers are located,
so that your <b>#include</b> statements will work properly. Typically, you will
add an option like the following to your project:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>-I/path/to/installation/include</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>If you used the <i>configure</i>
script, the installation path will be whatever you selected for the prefix
(which defaults to <i>/usr/local</i>). If you used one of the project files in
the <i>build</i> directory, the installation path would simply be the path to
the main directory of the ZThreads archive.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Next, you’ll need to add an
option to your project that will let the linker know where to find the library.
This will look like:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>-L/path/to/installation/lib
–lZThread</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>if you used the configure
script, or:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>-L/path/to/installation/Debug
ZThread.lib</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>if you used one of the
project files provided. Again, if the <i>configure</i> script was used, the
installation path will be whatever you selected for the prefix. Otherwise, if
you’ve used a provided project file, the path will be the path to the main
directory of the ZThreads archive.</span></p>

<p class=MsoNormal><span style='color:windowtext'>If you are using a compiler
for which no project file has been included you can still compile the library
fairly easily. You simply need to create a new project and add all the <i>.cxx </i>files
in the <i>src</i> directory of the ZThreads archive to the list of files to be
compiled. Also, be sure to include the <i>include</i> directory of the archive
in the the header search path for your project. Again, the exact details will
vary from compiler to compiler so you’ll need to be somewhat familiar with your
toolset to be able to use this option.</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Defining Tasks</span></h2>

<p class=MsoNormal><span style='color:windowtext'>Ultimately, threads are used
to carry out some task, so before you can use a thread you’ll need some way to
describe that task. The <b>Runnable</b> class provides a common interface for
any arbitrary task to be executed without exposing the details of how that task
is run. Here is the core of the ZThread <b>Runnable</b> class which you will
find in <b>Runnable.h</b> in the <i>include</i> directory, after installing the
ZThread library:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Runnable() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() = 0;</span></p>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>};</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>By making this a pure
abstract base class (or as pure as possible, given the constraints on virtual
destructors), <b>Runnable</b> allows an easy mixin combination with a base
class and other interfaces.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Defining a task simply
requires inheriting from the <b>Runnable</b> class. The most important function
for any <b>Runnable</b> is <b>run(&nbsp;)</b>, which you must override to make
the task do your bidding. Thus, <b>run(&nbsp;)</b> is the code that will be
executed when it comes time to carry out your task. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The following example creates
a simple task called <b>LiftOff</b> that displays the countdown before liftoff.
The </span><span
style='color:windowtext'><b>Runnable</b>’s <b>run(&nbsp;)</b> function is
overridden to perform the work. </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:LiftOff.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Demonstration of the Runnable interface.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
LIFTOFF_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
LIFTOFF_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Runnable.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
LiftOff : public ZThread::Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
LiftOff(int count, int ident = 0) : </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
countDown(count), id(ident) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~LiftOff() throw() { </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
std::cout &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(countDown--)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
std::cout &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; countDown &lt;&lt;
std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
std::cout &lt;&lt; &quot;Liftoff!&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// LIFTOFF_H ///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>As usual, we are careful not
to use any <b>using namespace</b> directives in a header file. The identifier <b>id
</b>allows you to distinguish between multiple instances of the task. If you
only make a single instance, you can use the default value for <b>ident</b>.
The destructor will allow you to see whether a task is properly destroyed.</span></p>

<p class=MsoNormal><span style='color:windowtext'>In the following example, the
task’s <b>run(&nbsp;)</b> is not driven by a thread; it is simply called
directly in <b>main(&nbsp;)</b>:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:NoThread.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
LiftOff launch(10);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
launch.run();</span></p>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>When something inherits </span><span style='color:windowtext'><b>Runnable</b>, it means that it has a <b>run(&nbsp;)</b>
function, but that’s nothing special—it doesn’t produce any innate threading
abilities. To achieve threading behavior, you must use the <b>Thread</b> class.</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Using Threads</span></h2>

<p class=MsoNormal><span style='color:windowtext'>To drive a <b>Runnable</b>
object with a thread, you create a separate <b>Thread</b> object and hand the <b>Runnable</b>
object to the <b>Thread</b>’s<b> </b><b>run(&nbsp;)</b> function. This performs
the thread initialization and then calls the <b>Runnable</b>’s<b> run(&nbsp;)</b>
as an interruptable thread. By driving <b>LiftOff</b> with a <b>Thread</b>, the
example below shows how any task can be run in the context of another thread:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:BasicThreads.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// The
most basic use of the Thread class.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.run(new LiftOff(10));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Waiting for LiftOff&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='color:windowtext'>Synchronization_Exception</span></b><span
style='color:windowtext'> is part of the ZThread library, and is the base class
for all ZThread exceptions. It will be thrown if there is an error starting or
using the thread.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>Thread::run(&nbsp;)</b>
member function only needs a pointer to a <b>Runnable</b> object. It will
perform the necessary initialization and then call that <b>Runnable</b>’s <b>run(&nbsp;)</b>
member function to start the task, and then <i>return to the calling thread</i>,
which in this case is the thread for <b>main(&nbsp;)</b>. That is, even though
you have, in effect, made a member function call to <b>LiftOff::run(&nbsp;)</b>
and that function has not yet finished, you can still perform other operations
in the <b>main(&nbsp;)</b> thread (this ability is not restricted to the <b>main(&nbsp;)</b>
thread – any thread can start another thread). You can see this by running the
program – even though <b>LiftOff::run(&nbsp;)</b> has been called, the “Waiting
for LiftOff” message will appear before the countdown has completed. Thus, the
program is running two functions at once – <b>LiftOff::run(&nbsp;)</b> and <b>main(&nbsp;)</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You can easily add more
threads by creating multiple threads driving multiple tasks. This way, you can
see how all the threads run in concert with each other:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:MoreBasicThreads.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Adding more threads.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const int sz = 5;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[sz];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    </span><span
lang=SV style='color:windowtext'>for(int i = 0; i &lt; sz; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>     
</span><span style='color:windowtext'>t[i].run(new LiftOff(10, i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Waiting for LiftOff&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    </span><span
lang=SV style='color:windowtext'>for(int i = 0; i &lt; sz; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>     
</span><span style='color:windowtext'>t[i].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Here, the second argument for
the <b>LiftOff</b> constructor is used to uniquely identify each task. When you
run the program you’ll see that the execution of the different tasks are mixed
together as the threads are swapped in and out. This swapping is automatically
controlled by the thread scheduler. Also, if you have multiple processors on
your machine, the thread scheduler will quietly distribute the threads among
the different processors.</span></p>

<h3><span style='color:windowtext'>Joining Threads</span></h3>

<p class=MsoNormal><span style='color:windowtext'>If you want a <b>Thread</b>
to <b>run(&nbsp;)</b> a task to completion, you must call <b>join(&nbsp;)</b>
on that thread before the <b>Thread</b> object goes out of scope. When a thread
calls <b>t.join(&nbsp;) </b>on another thread <b>t</b>, the calling thread is
suspended until the target thread <b>t</b> finishes executing its task (that
is, the task returns from its <b>run()</b> function), at which point the
overhead resources used by <b>t</b> are released. Any thread may call <span style='color:windowtext'><b>join(&nbsp;)</b> on another thread in order to wait for
that thread to complete before the first thread proceeds.</span></p>

<p class=MsoNormal><span style='color:windowtext'>In the </span><b><span
style='color:windowtext'>BasicThreads.cpp</span></b><span style='color:windowtext'>,
there are two threads – the <b>main(&nbsp;)</b> thread and <b>t</b>. The call
to <b>t.join(&nbsp;)</b> means that <b>main(&nbsp;)</b> is suspended until <b>t</b>
completes (when the <b>main()</b> thread calls <b>join()</b>, it’s saying “I’ll
wait for you to join me here”). Thus, <b>main(&nbsp;)</b> cannot exit until <b>t</b>
finishes its job. If you comment out the call to <b>t.join(&nbsp;)</b>, you’ll
see that <b>t</b> doesn’t finish its job before <b>main(&nbsp;) </b>exits.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You may also call <b>join(&nbsp;)</b>
with a timeout argument (in either milliseconds or milliseconds and
nanoseconds) so that if the target thread doesn’t finish in that period of
time, the call to <b>join(&nbsp;)</b> returns anyway.</span></p>

<h3><span style='color:windowtext'>Creating responsive user interfaces</span></h3>

<p class=MsoNormal><span style='color:windowtext'>As stated earlier, one of the
motivations for using threading is to create a responsive user interface.
Although we don’t cover <i>graphical </i>user interfaces in this book, you can
still see a simple example of a console-based user interface.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The following example reads
lines from a file and prints them to the console, sleeping (suspending the
current thread; you’ll learn more about this later) for a second after each
line is displayed. During this process it doesn’t look for user input, so the
UI is unresponsive:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:UnresponsiveUI.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Lack of threading produces an unresponsive UI.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;fstream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const int SZ = 100; // Buffer size;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  char
buf[SZ];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Press &lt;Enter&gt; to quit:&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ifstream file(&quot;UnresponsiveUI.cpp&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
while(file.getline(buf, SZ)) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; buf &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread::sleep(1000); // Time in milliseconds</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
Read input from the console</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
cin.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Shutting down...&quot; &lt;&lt; endl;</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext;background:white'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>To make the program
responsive, you can execute a task that displays the file in a separate thread.
The main thread can then watch for user input so the program becomes
responsive:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:ResponsiveUI.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Changed to create a responsive interface</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;fstream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
DisplayTask : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ifstream in;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static const int SZ = 100;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  char
buf[SZ];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  bool
quitFlag;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
DisplayTask(const string&amp; file) : quitFlag(false) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
in.open(file.c_str());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~DisplayTask() throw() { in.close(); }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(in.getline(buf, SZ) &amp;&amp; !quitFlag) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; buf &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::sleep(1000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
stop() { quitFlag = true; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Press &lt;Enter&gt; to quit:&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
DisplayTask* dt = new DisplayTask(&quot;ResponsiveUI.cpp&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.run(dt);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cin.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
dt-&gt;stop();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Shutting down...&quot; &lt;&lt; endl;</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Now the main thread can
respond immediately when you press &lt;Return&gt;, and call <b>stop()</b> on
the <b>DisplayTask</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>This example also shows the
need for communication between tasks – the task in the main thread needs to
tell the <b>DisplayTask</b> to shut down. Of course, since we have a pointer to
the <b>DisplayTask</b> you might think of just calling <b>delete</b> on that
pointer to kill the task, but this produces very unreliable programs. The
problem is that the task could be in the middle of something important when you
destroy it, and so you are likely to put the program in an unstable state.
Here, the task itself decides when it’s safe to shut down – the easiest way to
do this is by simply notifying the task that you’d like it to stop by setting a
Boolean flag, and when the task gets to a stable point it can check that flag
and do whatever is necessary to clean up before returning from <b>run()</b>.
When the task returns from <b>run()</b>, the <b>Thread</b> knows that the task
has completed.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Inter-task communication is a
considerable topic that will be covered later in this chapter.</span></p>

<h3><span style='color:windowtext'>Managing Tasks</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Memory and resource
management is a major concern in C++. The examples shown here create <b>Runnable</b>
objects on the heap using <b>new</b>, but those objects are never explicitly
deleted. However, you can see from the output when you run the programs that
the thread library keeps track of each task and eventually deletes it, because
the destructors for the tasks are called. This happens when the <b>Runnable::run(&nbsp;)
</b>member function completes – returning from <b>run()</b> tells the thread
that the task is finished.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Burdening the <b>Thread</b>
with deleting a task is a problem because that <b>Thread</b> doesn’t
necessarily know if another <b>Thread</b> still needs to make a reference to
that <b>Runnable</b>. Giving the <b>Thread</b> the responsibility for deleting <b>Runnable</b>s
is also problematic since a <b>Thread</b> does not necessarily know how a <b>Runnable</b>
was created, so the <b>Runnable</b> may be prematurely destroyed by another
thread. To deal with this problem, tasks in ZThreads are reference counted. The
task is maintained until the reference count for that task goes to zero, at
which point the task is deleted. Because the task must be deleted dynamically,
tasks cannot be created on the stack, but instead must always be created using <b>new</b>.</span></p>

<h3><span style='color:windowtext'>Simplifying with Executors</span></h3>

<p class=MsoNormal><span style='color:windowtext'>You can simplify your coding
overhead by using <i>Executors</i>.<i> </i>Executors provide a layer of
indirection between a client and the execution of a task; instead of a client executing
a task directly, an intermediate object executes the task. If you use an <b>Executor</b>
you don’t have to worry about calling <b>join(&nbsp;)</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>We can show this by using an <b>Executor</b>
instead of explicitly creating <b>Thread</b> objects in <b>MoreBasicThreads.cpp</b>.
A <b>LiftOff</b> object knows how to run a specific task; like the <i>Command</i>
<i>Pattern</i>, it exposes a single function to be executed. An <b>Executor</b>
object knows how build the appropriate context to execute <b>Runnable</b>
objects. In the following example, the <b>ThreadedExecutor</b> is used to
create one thread per task:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
c11:ThreadedExecutor.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new LiftOff(10, i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>An <b>Executor</b> is a
template that must be given a <b>Mutex</b> type in order to perform its
operations. You’ll learn about mutexes later and you can ignore them here.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Note that a single Executor
can be used to create and manage all the threads in your system.  You must
still place the threading code inside a <b>try</b> block because an <b>Executor</b>’s
<b>execute(&nbsp;)</b> function may throw <b>Synchronization_Exception</b>s if
something goes wrong. This is true for any function that involves changing the
state of a synchronization object (starting threads, </span><span
style='color:windowtext'>acquiring mutexes, waiting on conditions, etc.), as
you will learn later in this chapter.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Before a program exits, it
should cancel any <b>Executor</b>s that were used. This causes the <b>Executor</b>s
to reject any further tasks that are submitted to them by throwing an
exception. The program will exit as soon as any remaining tasks in the <b>Executor</b>
complete.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Note that, using an <b>Executor</b>,
the threads will complete without calls to <b>join(&nbsp;)</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>In the prior example, the <b>ThreadedExecutor</b>
creates a thread for each task that you want to run, but the way these tasks
are executed can be changed very easily by replacing the <b>ThreadedExecutor</b>
with a different type of <b>Executor</b>. In this chapter, using a <b>ThreadedExecutor</b>
is fine, but in production code it might result in excessive costs from the
creation of too many threads. In that case, you can replace it with a <b>PoolExecutor</b>,
which will use a limited set of threads to execute submitted tasks in parallel:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:PoolExecutor.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/PoolExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Constructor argument is minimum number of threads:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
PoolExecutor&lt;Mutex&gt; executor(5);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new LiftOff(10, i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>With the <b>PoolExecutor</b>,
you do expensive thread allocation once, up front. This saves time because you
aren't constantly paying for thread creation overhead for every single task. Also,
in an event-driven system, events that require threads to handle them can be
generated as quickly as you want and you're not going to overrun the available
resources because the <b>PoolExecutor</b> uses a bounded number of <b>Thread</b>
objects. Thus, although this book will use <b>ThreadedExecutor</b>s, you should
consider using <b>PoolExecutor</b>s in production code.</span></p>

<p class=MsoNormal><span style='color:windowtext'>A <b>ConcurrentExecutor</b>
is like a <b>PoolExecutor</b> with a fixed size of one thread. This is handy
for anything you want to just run in another thread continually (a long lived
task), such as a task that listens to incoming socket connections. It is also
handy for short tasks that you want to get handled by another thread, maybe
small tasks that update a log locally, or even remotely, or for an
event-dispatching thread. </span></p>

<p class=MsoNormal><span style='color:windowtext'>If more than one task is
submitted to a <b>ConcurrentExecutor</b>, each task will run to completion
before the next task is begun, all using the same thread. So in the following
example:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:ConcurrentExecutor.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ConcurrentExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ConcurrentExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new LiftOff(10, i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>you’ll see each task
completed, in the order that it was submitted, before the next one is begun.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Like a <b>ConcurrentExecutor</b>,
a <b>SynchronousExecutor</b> is used when you want only one task at a time to
run, serially instead of concurrently. Unlike <b>ConcurrentExecutor</b>, <b>SynchronousExecutor</b>
doesn’t create or manage threads on it own. It uses the thread that submits the
task, and thus only acts as a focal point for synchronization. If you have <b>n</b>
threads submitting tasks to a <b>SynchronousExecutor</b>, those threads are all
blocked on <b>execute(&nbsp;)</b>. One by one they will be allowed to continue
as the previous tasks in the queue complete, but no two tasks are ever run at
once.</span></p>

<p class=MsoNormal><span style='color:windowtext'>For example, suppose you have
a number of threads running tasks that use the file system, but you are writing
portable code so you don’t want to use <b>flock(&nbsp;)</b> or another
OS-specific call to lock a file. You can run these tasks with a <b>SynchronousExecutor</b>
to ensure that only one task at a time is running from any thread. This way,
you don’t have to deal with synchronizing on the shared resource (and you won’t
clobber the file system in the meantime). A better solution is to actually
synchronize on the resource, but a <b>SynchronousExecutor</b> lets you skip the
trouble of getting a coordinated properly just to prototype something.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:SynchronousExecutor.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/SynchronousExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;LiftOff.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
SynchronousExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new LiftOff(10, i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>When you run the program
you’ll see that the tasks are executed in the order they are submitted, and
each task runs to completion before the next one starts. What you don’t see is
that no new threads are created – the <b>main() </b>thread is used for each
task, since in this example, that’s the thread that submits all the tasks.
Because <b>SynchronousExecutor</b> is primarily for prototyping you may not use
it much in production code.</span></p>

<h3><span style='color:windowtext'>Yielding</span></h3>

<p class=MsoNormal><span style='color:windowtext'>If you know that you’ve
accomplished what you need to during one pass through a loop in your <b>run(&nbsp;)</b>
function (most <b>run(&nbsp;)</b> functions involve a long-running loop), you
can give a hint to the thread scheduling mechanism that you’ve done enough and
that some other thread might as well have the CPU. This hint (and it <i>is</i>
a hint—there’s no guarantee your implementation will listen to it) takes the
form of the </span><span
style='color:windowtext'><b>yield(&nbsp;)</b> function. </span></p>

<p class=MsoNormal><span style='color:windowtext'>We can make a modified version
of the <b>LiftOff</b> examples by yielding after each loop:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:YieldingTask.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Suggesting when to switch threads with yield().</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
YieldingTask : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int threadCount;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
YieldingTask() : countDown(5) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    id
= threadCount++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~YieldingTask() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend ostream&amp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(ostream&amp; os, const YieldingTask&amp; yt) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;#&quot; &lt;&lt; yt.id &lt;&lt; &quot;: &quot;
&lt;&lt; yt.countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(true) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; *this &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
if(--countDown == 0) return;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::yield();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
YieldingTask::threadCount = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new YieldingTask);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext;background:white'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>You can see that the task’s <b>run(&nbsp;)
</b>member function is entirely surrounded by an infinite loop. By using <b>yield(&nbsp;)</b>,
the output is evened up quite a bit over that without yielding. Try commenting out
the call to <b>Thread::yield(&nbsp;)</b> to see the difference. In general,
however, <b>yield(&nbsp;) </b>is useful only in rare situations, and you can’t
rely on it to do any serious tuning of your application.</span></p>

<h3><span style='color:windowtext'>Sleeping</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Another way you can control
the behavior of your threads is by calling <b>sleep(&nbsp;)</b> to cease
execution of that thread for a given number of milliseconds. In the preceding
example, if you replace the call to <b>yield(&nbsp;)</b> with a call to </span><span style='color:windowtext'><b>sleep(&nbsp;)</b>, you get the following: </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:SleepingTask.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Calling sleep() to pause for awhile.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//#include
&lt;string&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
SleepingTask : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int threadCount;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
SleepingTask() : countDown(5) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    id
= threadCount++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~SleepingTask() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend ostream&amp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(ostream&amp; os, const SleepingTask&amp; st) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;#&quot; &lt;&lt; st.id &lt;&lt; &quot;: &quot;
&lt;&lt; st.countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(true) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
cout &lt;&lt; *this &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
if(--countDown == 0) return;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Thread::sleep(100);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
} catch(Interrupted_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        cerr
&lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
SleepingTask::threadCount = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new SleepingTask);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='color:windowtext'>Thread::sleep()</span></b><span
style='color:windowtext'> can throw an </span><b><span style='color:windowtext'>Interrupted_Exception</span></b><span
style='color:windowtext'> (you’ll learn about interrupts later) and you can see
that this is caught in <b>run()</b>. But the task is created and executed
inside a <b>try</b> block in <b>main()</b> that catches </span><b><span
style='color:windowtext'>Synchronization_Exception</span></b><span
style='color:windowtext'> (the base class for all ZThread exceptions), so
wouldn’t it be possible to just ignore the exception in <b>run()</b> and assume
that it will propagate to the handler in <b>main()</b>? However, Execeptions
won’t propagate across threads back to <b>main()</b>. Also, note that <b>run()</b>
has a <b>throw()</b> clause which means that any exception that attempts to
escape from <b>run()</b> will be treated as an unhandled exception (this
defaults to calling <b>abort()</b>). Thus, you must handle any exceptions
locally that may arise within a task.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You’ll notice that the
threads tend to run in any order, which means that <b>sleep(&nbsp;)</b> is also
not a way for you to control the order of thread execution. It just stops the
execution of the thread for awhile. The only guarantee that you have is that
the thread will sleep at least 100 milliseconds (in this example), but it may
take longer before the thread resumes execution, because the thread scheduler
still has to get back to it after the sleep interval expires. </span></p>

<p class=MsoNormal><span style='color:windowtext'>If you must control the order
of execution of threads, your best bet is not to use threads at all, but
instead to write your own cooperative routines that hand control to each other
in a specified order. </span></p>

<h3><span style='color:windowtext'>Priority</span></h3>

<p class=MsoNormal><span style='color:windowtext'>The </span><span style='color:windowtext'><i>priority</i> of a thread tells the scheduler how
important this thread is. Although the order that the CPU runs a set of threads
is indeterminate, if there are a number of threads waiting to run, the scheduler
will <i>lean</i> toward the one with the highest priority first. However, this
doesn’t mean that threads with lower priority aren’t run (that is, you can’t
get deadlocked because of priorities). Lower priority threads just tend to run
less often. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Here’s <b>MoreBasicThreads.cpp</b>
modified so that the priority levels are demonstrated. The priorities are
adjusting by using <b>Thread</b>’s <b>setPriority(&nbsp;)</b> function.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:SimplePriorities.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Shows the use of thread priorities.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cmath&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
SimplePriorities : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Thread&amp; t; // The Thread that's running this task</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
volatile double d; // No optimization</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int threadCount;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
SimplePriorities(Thread&amp; th) : t(th),countDown(5),d(0.0){</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    id
= threadCount++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~SimplePriorities() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend ostream&amp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(ostream&amp; os, const SimplePriorities&amp; sp) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;#&quot; &lt;&lt; sp.id &lt;&lt; &quot; priority:
&quot; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; sp.t.getPriority() &lt;&lt; &quot; count: &quot;&lt;&lt; sp.countDown;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(true) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// An expensive, interruptable operation:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
for(int i = 1; i &lt; 100000; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
d = d + (M_PI + M_E) / (double)i;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; *this &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
if(--countDown == 0) return;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
SimplePriorities::threadCount = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread h;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
h.setPriority(High);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
h.run(new SimplePriorities(h));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread* t = new Thread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t-&gt;setPriority(Low);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t-&gt;run(new SimplePriorities(*t));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
h.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext;background:
white'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Here, <b>operator&lt;&lt;(&nbsp;)</b>
is overridden to display the identifier, priority, and <b>countDown</b> value
of the task. To do this, a reference to the thread must be captured in the
task’s constructor.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You can see that the priority
level of thread <b>h</b> is at the highest level, and all the rest of the
threads are at the lowest level. We are not using an <b>Executor</b> in this
example because we need direct access to the threads in order to set their
priorities.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Inside <b>run(&nbsp;)</b>,
100,000 repetitions of a rather expensive floating-point calculation are performed,
involving <b>double</b> addition and division. The variable <b>d</b> has been
made <b>volatile</b> to ensure that no optimization is performed. Without this
calculation, you don’t see the effect of setting the priority levels (try it:
comment out the <b>for</b> loop containing the <b>double</b> calculations).
With the calculation, you see that thread <b>h</b> is given a higher preference
by the thread scheduler (at least, this was the behavior on a Windows 2000
machine). The calculation takes long enough that the thread scheduling
mechanism jumps in and changes threads, and pays attention to the priorities so
that thread <b>h</b> gets preference. </span></p>

<p class=MsoNormal><span style='color:windowtext'>You can also read the
priority of an existing thread with </span><span style='color:windowtext'><b>getPriority(&nbsp;) </b>and change it at any time
(not just before the thread is run, as in <b><span style='background:white'>SimplePriorities.cpp</span></b>)
with </span><span
style='color:windowtext'><b>setPriority(&nbsp;)</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Mapping priorities to operating
systems is problematic. For example, Windows 2000 has 7 priority levels that
are not fixed, so the mapping is indeterminate, while Sun’s Solaris has 2</span><sup><span
style='color:windowtext'>31 </span></sup><span style='color:windowtext'>levels.
The only portable approach is to stick to very large priority granulations,
such as the <b>Low</b>, <b>Medium</b> and <b>High</b> used in the <b>ZThread</b>
library. </span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Sharing limited
resources</span></h2>

<p class=MsoNormal><span
style='color:windowtext'>You can think of a single-threaded program as one
lonely entity moving around through your problem space and doing one thing at a
time. Because there’s only one entity, you never have to think about the
problem of two entities trying to use the same resource at the same time,
problems like two people trying to park in the same space, walk through a door
at the same time, or even talk at the same time. </span></p>

<p class=MsoNormal><span style='color:windowtext'>With multithreading, things
aren’t lonely anymore, but you now have the possibility of two or more threads
trying to use the same resource at once. Colliding over a resource must be
prevented, or else you’ll have two threads trying to access the same bank
account at the same time, print to the same printer, adjust the same valve, and
so on. </span></p>

<p class=MsoNormal><span style='color:windowtext'>This section introduces the
problem of colliding over shared resources and the tools that are used to solve
the problem.</span></p>

<h3><span style='color:windowtext'>Improperly accessing resources</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Consider the following
example where one task generates even numbers, while other tasks consume those
numbers. In this case, the only job of the consumer threads is to check the
validity of the even numbers.</span></p>

<p class=MsoNormal><span style='color:windowtext'>We’ll first define <b>EvenChecker</b>,<b>
</b>the consumer thread, since it will be reused in all the subsequent
examples. To decouple <b>EvenChecker</b> from the various different types of
generators that we will experiment with, we’ll create an interface called <b>Generator</b>
which contains the minimum necessary functions that <b>EvenChecker</b> must
know about: that it has a <b>getValue()</b> function and it can be canceled.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:EvenChecker.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
EVENCHECKER_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
EVENCHECKER_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Cancelable.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Generator : public ZThread::Cancelable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static bool quitFlag; // &quot;true&quot; means return from run()</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual int getValue() = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void cancel() { quitFlag = true; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual bool isCanceled() { return quitFlag; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Generator() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
EvenChecker : public ZThread::Runnable, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public
ZThread::Cancelable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Generator* generator;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int idCounter;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static bool quitFlag;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
EvenChecker(Generator* g) : generator(g) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    id
= idCounter++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~EvenChecker() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
std::cout &lt;&lt; &quot;~EvenChecker &quot; &lt;&lt; id &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void cancel() { quitFlag = true; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual bool isCanceled() { return quitFlag; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// EVENCHECKER_H ///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>These classes also introduce
the pure abstract <b>Cancelable</b> class which is part of ZThread. The goal of
<b>Cancelable </b>is to provide a consistent interface for telling a <b>Runnable</b>
object to stop itself via the <b>cancel()</b> function, and to see whether the
task has been canceled with the <b>isCanceled()</b> function. Here, the very
simple approach of using a <b>static bool quitFlag</b> is used, as previously
seen in <b>ResponsiveUI.cpp</b>. In this case, we want to shut down all threads
<i>en masse</i>, so the use of a <b>static</b> flag is adequate – when one
thread shuts down, the <b>static</b> flag is set so that all the threads in the
class will see it and shut down.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Later, you’ll learn that some
of the assumptions made in this code are innappropriate in more stringent
threading situations, but for these examples they are reasonably safe. Also in
later sections, you’ll see that the ZThread library contains more general
mechanisms for thread signaling.</span></p>

<p class=MsoNormal><b><span style='color:windowtext'>EvenChecker</span></b><span
style='color:windowtext'> tasks constantly read and test the values from their
associated <b>Generator</b>. This file also includes the definitions for the <b>static</b>
fields:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:EvenChecker.cpp {O}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;EvenChecker.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>void
EvenChecker::run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
while(!isCanceled()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
int val = generator-&gt;getValue();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(val % 2 != 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; val &lt;&lt; &quot; not even!&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
generator-&gt;cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cancel(); // Cancel all EvenCheckers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
Generator::quitFlag = false;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
EvenChecker::quitFlag = false;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
EvenChecker::idCounter = 0;</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Note that if the <b>isCanceled()</b>
is true, <b>run()</b> returns, which tells the <b>Executor</b> that the task is
complete. Any <b>EvenChecker</b> task can <b>cancel() </b>itself and it can
call <b>Generator::cancel()</b> to set the <b>Generator</b>’s <b>quitFlag</b>
in order to cause a graceful shutdown. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>EvenGenerator</b> is
very simple – you can get the current value with <b>getValue()</b>, and the <b>run()</b>
function is constantly incrementing to the next even value:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:EvenGenerator.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
When threads collide.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
EvenChecker Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;EvenChecker.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
EvenGenerator : public Generator, public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
currentEvenValue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
EvenGenerator() { currentEvenValue = 0; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~EvenGenerator() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;~EvenGenerator&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getValue() { return currentEvenValue; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(!isCanceled()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++; // Danger point here!</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
EvenGenerator* eg = new EvenGenerator;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.execute(eg);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 10; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new EvenChecker(eg));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>It’s possible for one thread
to call <b>getValue()</b> after the first increment of <b>currentEvenValue</b>
and before the second (at the place in the code commented “Danger point
here!”), in which case the value would be in an “incorrect” state. To prove
that this can happen, we create a group of <b>EvenChecker</b> objects to
continually read the output of an <b>EvenGenerator</b> and test to make sure if
each one is even. If not, the error is reported and the program is shut down.</span></p>

<p class=MsoNormal><span style='color:windowtext'>This program may not detect
the problem until the <b>EvenGenerator</b> has completed many cycles, depending
on the particulars of your operating system and other implementation details.
If you want to see it fail much faster, try putting a call to <b>yield()</b>
between the first and second increments. In any event, it <i>will</i>
eventually fail because the <b>EvenChecker</b> threads are able to access the
information in <b>EvenGenerator</b> while it’s in an “incorrect” state.</span></p>

<h3><span style='color:windowtext'>Controlling access</span></h3>

<p class=MsoNormal><span style='color:windowtext'>This example shows a
fundamental problem when using threads: You never know when a thread might be
run. Imagine sitting at a table with a fork, about to spear the last piece of
food on your plate, and as your fork reaches for it, the food suddenly vanishes
(because your thread was suspended and another task came in and stole the
food). That’s the problem that you’re dealing with when writing concurrent
programs. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Sometimes you don’t care if a
resource is being accessed at the same time you’re trying to use it (the food
is on some other plate). But for multithreading to work, you need some way to
prevent two threads from accessing the same resource, at least during critical
periods. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Preventing this kind of
collision is simply a matter of putting a lock on a resource when one thread is
using it. The first thread that accesses a resource locks it, and then the
other threads cannot access that resource until it is unlocked, at which time
another thread locks and uses it, etc. If the front seat of the car is the
limited resource, the child who shouts “Dibs!” asserts the lock.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Thus, we need to be able to
prevent any other tasks from accessing the storage when that storage is not in
a proper state. That is, we need to have a mechanism to <i>exclude</i> a second
task from accessing the storage when a first task is already using it. This
idea is fundamental to all multithreading systems and is called <i>mutual
exclusion</i>; the mechanism used abbreviates this to <i>mutex</i>. The ZThread
library contains a mutex mechanism declared in the header <b>Mutex.h</b>.</span></p>

<p class=MsoNormal><span style='color:windowtext'>To solve the problem in the
above program, we identify the <i>critical sections</i> where mutual exclusion
must apply, then we <i>aquire</i> the mutex before entering the critical
section and <i>release</i> it at the end of the critical section. Only one
thread at a time is able to acquire the mutex, so mutual exclusion is achieved:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:MutexEvenGenerator.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Preventing thread collisions with mutexes.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
EvenChecker Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;EvenChecker.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
MutexEvenGenerator : </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public
Generator, public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
currentEvenValue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
MutexEvenGenerator() { currentEvenValue = 0; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~MutexEvenGenerator() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;~MutexEvenGenerator&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getValue() { </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.acquire();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
int rval = currentEvenValue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.release();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return rval;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(!isCanceled()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
lock.acquire();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::yield();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
lock.release();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
MutexEvenGenerator* eg = new MutexEvenGenerator;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.execute(eg);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 10; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new EvenChecker(eg));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>The only changes here are in <b>MutexEvenGenerator</b>,
which adds a <b>Mutex</b> called <b>lock</b>, and uses <b>acquire()</b> and <b>release()</b>
in <b>getValue()</b> and <b>run()</b>. Note that <b>getValue()</b> must capture
the return value inside the critical section, because if you return from inside
the critical section you won’t release the lock and will thus prevent it from
being acquired again (this usually leads to <i>deadlock</i>, which you’ll learn
about at the end of this chapter).</span></p>

<p class=MsoNormal><span style='color:windowtext'>[[ Exercise: in
MutexEvenGenerator::getValue(), change the code so that the return expression
precedes the release() statement and see what happens. ]]</span></p>

<h3><span style='color:windowtext'>Simplified coding with Guards</span></h3>

<p class=MsoNormal><span style='color:windowtext'>The use of mutexes rapidly
becomes complicated when exceptions are introduced. In order to make sure that
the mutex is always released, you must ensure that each possible exception path
includes a call to <b>release()</b>. In addition, any function that has
multiple return paths must carefully ensure that it calls <b>release()</b> at
the appropriate points.</span></p>

<p class=MsoNormal><span style='color:windowtext'>These problems can be easily
solved by using the fact that a stack-based object has a destructor that is
always called regardless of how you exit from a function scope. In the ZThread
library, this is implemented as the <b>Guard</b> template. The <b>Guard</b>
template creates objects on the local stack that <b>acquire() </b>a <b>Lockable</b>
object when constructed and <b>release()</b> that lock when destroyed. Because
the <b>Guard</b> object exists on the local stack, it will automatically be destroyed
however the function exits, and will therefore always unlock the <b>Lockable</b>
object. Here’s the above example reimplemented using <b>Guard</b>s:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:GuardedEvenGenerator.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Simplifying mutexes with the Guard template.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
EvenChecker Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;EvenChecker.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
GuardedEvenGenerator : </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public
Generator, public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
currentEvenValue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
GuardedEvenGenerator() { currentEvenValue = 0; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~GuardedEvenGenerator() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;~GuardedEvenGenerator&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getValue() { </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return currentEvenValue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(!isCanceled()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::yield();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
currentEvenValue++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
GuardedEvenGenerator* eg = new GuardedEvenGenerator;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.execute(eg);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 10; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
executor.execute(new EvenChecker(eg));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
executor.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Note that the temporary
return value is no longer necessary in <b>getValue()</b>. In general, there is
less code for the user to write, and the opportunity for user error is greatly
reduced. Additionally, you can nest guards, make guards that overlap mutexes
for certain regions and even create proxy classes that automatically lock a
mutex for the duration of each function call.</span></p>

<p class=MsoNormal><span style='color:windowtext'>An interesting feature of the
<b>Guard</b> template is that it can be used to manipulate other guards safely.
For example, a second <b>Guard</b> can be used to temporarily unlock a guard:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:TemporaryUnlocking.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Temporarily unlocking another guard.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
TemporaryUnlocking {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
f() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
lock is acquired</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
...</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Guard&lt;Mutex, UnlockedScope&gt; h(g);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// lock is released</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// ...</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// lock is acquired</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
...</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
lock is released</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
TemporaryUnlocking t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
t.f();</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>A Guard can also be used to
try to acquire a lock for a certain amount of time, and then abort:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:TimedLocking.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Limited time locking.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
TimedLocking {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
f() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex, TimedLockedScope&lt;500&gt; &gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
...</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
TimedLocking t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
t.f();</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>In this example, a <b>Timeout_Exception</b>
will be thrown if the lock cannot be acquired within 500 milliseconds.</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Terminating tasks</span></h2>

<p class=MsoNormal><span style='color:windowtext'>In previous examples we have
seen the use of a “quit flag” and the <b>Cancelable</b> interface in order to
terminate a task. This is a simple, gentle approach to the problem, and
preferable when it works, since you are making a civilized request to the task
to finish up what it is doing and quit, whenever it gets around to it. However,
there are situations where the task must be terminated more abruptly. In this
section, you’ll learn about the issues and problems of such termination.</span></p>

<h3><span style='color:windowtext'>The </span><span style='color:windowtext'>Ornamental</span><span
 style='color:windowtext'> </span><span style='color:windowtext'>Garden</span></span></h3>

<p class=MsoNormal><span style='color:windowtext'>First, let’s look at an
example that not only demonstrates the termination problem but is also an
additional example of resource sharing. This is a simulation of an ornamental
garden, where the garden committee would like to know how many people enter the
garden each day though its multiple gates (two, in this case, but you can
easily add more). Each gate has a turnstile or some other kind of counter, and
after the turnstile count is incremented, a shared count that represents the total
number of people in the garden is incremented.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:OrnamentalGarden.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/ThreadedExecutor.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;vector&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdlib&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;ctime&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Count {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
value;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Count() : value(0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
srand(time(0)); // Seed the random number generator</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
increment() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Comment the following line to see counting fail:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
int temp = value;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(rand() &lt; RAND_MAX/2) // Yield half the time</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::yield();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return (value = ++temp);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
operator()() { return value; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Entrance : public Runnable, public Cancelable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static Count count;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
value;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static vector&lt;Entrance*&gt; entrances;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static bool quitFlag;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static Mutex lock, iolock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
show(int total) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Lock on a static Mutex so multiple instances of</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
this task can't collide with each other over output:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(iolock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; *this &lt;&lt; &quot; Total: &quot; &lt;&lt; total &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Entrance(int n) : value(0), id(n) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
entrances.push_back(this);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int total() { return count(); }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  static
int sumOfEntrances() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
int sum = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
vector&lt;Entrance*&gt;::iterator it = entrances.begin();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(it != entrances.end()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
sum += (*it)-&gt;value;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
it++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return sum;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!isCanceled()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
value++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
show(count.increment());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Thread::sleep(100);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Guard&lt;Mutex&gt; g(iolock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; *this &lt;&lt; &quot;: &quot; &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(iolock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Exiting &quot; &lt;&lt; *this &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
cancel() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
quitFlag = true;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  bool
isCanceled() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return quitFlag;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend ostream&amp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(ostream&amp; os, const Entrance&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;Entrance &quot; &lt;&lt; e.id &lt;&lt; &quot;: &quot;
&lt;&lt; e.value;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Count
Entrance::count;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Mutex
Entrance::lock, Entrance::iolock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>vector&lt;Entrance*&gt;
Entrance::entrances;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
Entrance::quitFlag = false;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Press &lt;ENTER&gt; to quit&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Entrance* e[] = { new Entrance(1), new Entrance(2) };</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ThreadedExecutor&lt;Mutex&gt; executor;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; sizeof e/sizeof *e; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>      </span><span
lang=IT style='color:windowtext'>executor.execute(e[i]);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT style='color:windowtext'>   
cin.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT style='color:windowtext'>   
for(int i = 0; i &lt; sizeof e/sizeof *e; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT style='color:windowtext'>     
e[i]-&gt;cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=IT style='color:windowtext'>   
</span><span style='color:windowtext'>cout &lt;&lt; &quot;Total: &quot;
&lt;&lt; Entrance::total() &lt;&lt; endl</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; &quot;Sum of Entrances: &quot; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; Entrance::sumOfEntrances() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='color:windowtext'>Count</span></b><span
style='color:windowtext'> is the class that keeps the master count of visitors
to the garden. A <b>Count</b> object is a <b>static </b>field in <b>Entrance</b>,
and thus shared by all <b>Entrance</b> objects. The <b>value</b> in <b>Count</b>
holds the current number of visitors, and a <b>Mutex</b> called <b>lock</b> is
used to prevent multiple tasks from modifying the <b>value</b> at the same
time. A <b>Guard</b> is used with <b>lock</b> in <b>increment()</b> to
synchronize access to <b>value</b>. This function uses <b>rand()</b> to cause a
<b>yield()</b> roughly half the time, in the middle of the fetch of <b>value</b>
into <b>temp </b>and the increment and store of <b>temp</b> back into <b>value</b>.
Because of this, if you comment out the <b>Guard</b> creation, you will rapidly
see the program break because both threads will be accessing and modifying <b>value</b>
at the same time.</span></p>

<h4><span style='color:windowtext'>Atomic operations</span></h4>

<p class=MsoNormal><span style='color:windowtext'>Note that the <b>operator()()</b>
returns the value without synchronization (that is, it has no <b>Guard</b>
object). This brings up an interesting point, because this code will <i>probably</i>
work fine with most compilers and systems without synchronization. The reason
is that in general, a simple operation like returning an <b>int</b> will be an <i>atomic
operation</i>, which means that it will probably happen in a single
microprocessor instruction that will not get interrupted (the multithreading
mechanism is unable to stop a thread in the middle of a microprocessor
instruction). In fact, if we removed the fetch of <b>value</b> into <b>temp</b>
and removed the <b>yield()</b> , and instead simply incremented <b>value</b>
directly, we probably wouldn’t need a lock at all because the increment
operation is <i>usually</i> atomic, as well.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The problem is that the C++
standard doesn’t guarantee atomicity for any of these operations. Although
operations like returning an <b>int</b> and incrementing an <b>int</b> are
almost certainly atomic on most machines, there’s no guarantee. And because
there’s no guarantee, you have to assume the worst. Sometimes you might
investigate the atomicity behavior on a particular machine (usually by looking
at assembly language) and write code based on those assumptions, but that’s
always dangerous and ill-advised, because it’s too easy for that information to
be lost or hidden, and the next person that comes along may assume that this
code can be ported to another machine, and then go mad tracking down the
occasional glitch caused by thread collisons.</span></p>

<p class=MsoNormal><span style='color:windowtext'>So, while the code in the
above example seems to work, it’s not airtight and thus on some machines you
may see abberrant behavior. There are exercises at the end of the chapter that
ask you to repair these problems.</span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>Entrance</b> class
contains the <b>static Count</b> object containing the total visitor count, and
it also keeps a local <b>value</b> with the number of visitors that have passed
through this entrance. This provides a double-check against the <b>count</b>
object to make sure that the proper number of visitors is being recorded. In
the <b>Entrance</b> constructor, the new <b>Entrance</b> object is added to a
master <b>static</b> list called <b>entrances</b>, and this is used inside <b>sumOfEntrances()</b>
to iterate over all the individual <b>Entrance</b> values and add them up. The <b>run()</b>
function simply increments the local value and the <b>count</b> object and
sleeps for 100 milliseconds.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You’ll notice there are two <b>Mutex</b>
objects in <b>Entrance</b>: <b>lock</b>, used in the same way that you’ve seen
mutexes used so far, and <b>iolock</b>, which is used when performing IO
operations. This second lock is necessary because C++ iostreams have no thread
safety (since the original C++ standard explicitly excluded threads, it wasn’t
possible). This means that if two tasks are trying to write to the console, for
example, their outputs can easily stumble over each other, and that’s exactly
what happens in this example without the <b>iolock</b> (try removing the <b>iolock</b>
statements to see what happens). Since each <b>Entrance</b> object is driven by
a different thread, each task can be swapped out in mid-sentence. By
synchronizing all output with the <b>iolock</b>, this is prevented.</span></p>

<p class=MsoNormal><span style='color:windowtext'>[[ Exercise: comment out the
guard in Count::run() in OrnamentalGarden.cpp. Exercise: change the
Count::increment() function so that it does a direct increment of value; remove
the guard and try to see if that causes a failure. Is this safe and reliable?
Exercise: Make Count as thread-safe as possible. Exercise: determine whether
the increment and return of <b>int</b>s is atomic on your machine. Exercise:
remove the iolock statements and explain the results. Exercise: try using <b>iolock</b>
inside <b>Entrance::operator&lt;&lt;()</b>. Why doesn’t this work? Exercise:
Make OrnamentalGarden.cpp as thread-safe as possible, without adding
unnecessary synchronization. Justify your choices. ]]</span></p>

<p class=MsoNormal><span style='color:windowtext'>As this program runs, you
will see the total count and the count at each entrance displayed as people
walk through a turnstile. If you comment out the <b>Guard</b> object in <b>Count</b>,<b>
</b>you’ll notice that the total number of people is not what you expect it to
be. If you were to add together the number of people counted by each turnstile,
you’ll find that the total reported falls short of that number. As long as the <b>Mutex</b>
is there to synchronize access to the <b>Counter</b>, things seem to work
correctly, but keep in mind that <b>Count::increment()</b> exaggerates the
potential for failure by using <b>temp</b> and <b>yield()</b>. In real
threading problems, the possibility for failure may be statistically very
small, so you can easily fall into the trap of believing things are working
correctly. Just as in the example above, there are likely to be hidden problems
that haven’t occurred to you, so you must be exceptionally dilligent when
reviewing concurrent code.</span></p>

<h3><span style='color:windowtext'>Terminating when blocked</span></h3>

<p class=MsoNormal><b><span style='color:windowtext'>Entrance::run()</span></b><span
style='color:windowtext'> in the previous example includes a call to <b>sleep()</b>.
We know that in that example, the sleep will eventually wake up and the task
will reach the top of the loop where it has an opportunity to terminate by
checking the <b>isCancelled()</b> status. However, <b>sleep()</b> is just one
situation where a thread is <i>blocked</i> from executing, and sometimes you
must terminate a task that’s blocked.</span></p>

<h4><span style='color:windowtext'>Thread states</span></h4>

<p class=MsoNormal><span style='color:windowtext'>A thread can be in any one of four states:</span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><i><span style='color:windowtext'>New</span></i><span
style='color:windowtext'>: A Thread remains in this state only momentarily, as
it is being created. It allocates any neccessary system resources making it a
eligble to recieve CPU time. The scheduler will then transition this thread to
the Runnable or Blocked state. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><i><span style='color:windowtext'>Runnable</span></i><span
style='color:windowtext'>: This means that a thread <i>can</i> be run when the
time-slicing mechanism has CPU cycles available for the thread. Thus, the
thread might or might not be running at any moment, but there’s nothing to
prevent it from being run if the scheduler can arrange it; it’s not dead or
blocked. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><i><span style='color:windowtext'>Blocked</span></i><span
style='color:windowtext'>: The thread could be run, but there’s something that
prevents it (it might be waiting for IO to complete, for example). While a
thread is in the blocked state, the scheduler will simply skip over it and not
give it any CPU time. Until a thread reenters the runnable state, it won’t
perform any operations. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><i><span style='color:windowtext'>Dead</span></i><span
style='color:windowtext'>: A Thread in the Dead state is no longer schedulable
and is not elgible to recieve any CPU time. Its task is completed and it is no
longer Runnable. The normal way for a thread to die is by returning from its <b>run(&nbsp;)
</b>function.</span></p>

<h4><span style='color:windowtext'>Becoming blocked</span></h4>

<p class=MsoNormal><span style='color:windowtext'>A thread is blocked when
there’s some reason that it cannot continue running. A thread can become
blocked for the following reasons:</span><span
style='color:windowtext'> </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>You’ve put the thread to sleep by
calling <b>sleep(milliseconds),</b> in which case it will not be run for the
specified time. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>You’ve suspended the execution of
the thread with <b>wait(&nbsp;)</b>. It will not become runnable again until
the thread gets the <b>signal(&nbsp;)</b> or <b>broadcast(&nbsp;)</b> message.
We’ll examine these in a later section. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>7.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>The thread is waiting for some I/O
to complete. </span></p>

<p class=Numbered><span style='font-family:Verdana;color:windowtext'>8.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>The thread is trying to enter code
that is guarded by a mutex, and that mutex is occupied by another thread. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The problem we need to look
at now is this: sometimes you may want to terminate a thread that is in a
blocked state. It can be blocked for any of the reasons in the above list (<i>except
</i>for IO, as you’ll see). If you can’t wait for it to get back to the top of
the loop and check the <b>isCancelled()</b> state, you have to abort the thread
out of its blocked state.</span></p>

<h3><span style='color:windowtext'>Interruption</span></h3>

<p class=MsoNormal><span style='color:windowtext'>As you might imagine, it’s
much messier to break out of the middle of a loop than it is to wait for the
loop to get to a test of <b>isCancelled()</b> (a place where the programmer is
ready to leave the loop). When you break out of a blocked task, it means you
are breaking out in a place in your <b>run()</b> loop where you may have
objects created that need destroying, and resources acquired that may need
cleanup. Because of this, breaking out of the middle of a <b>run()</b> loop in
a task is more like throwing an exception than anything else, so exceptions are
used for this kind of abort (This walks the fine edge of being an inappropriate
use of exceptions because it means you are often using them for control flow).
To return to a known good state when terminating a task this way, you must
carefully consider the state of your code and properly clean up everything
inside the <b>catch</b> clause. We’ll look at these issues in this section.</span></p>

<p class=MsoNormal><span style='color:windowtext'>To terminate a blocked
thread, the ZThread library provides the <b>Thread</b>::</span><span style='color:windowtext'><b>interrupt(&nbsp;)</b> function. This sets the <i>interrupted
status</i> for that thread. A thread with its interrupted status set will throw
an <b>Interrupted_Exception</b> if it is already blocked or it attempts a
blocking operation. The interrupted status will be reset when the exception is
thrown or if the task calls <b>Thread::interrupted()</b>. As you’ll see, <b>Thread::interrupted()</b>
provides a second way to leave your <b>run()</b> loop, without throwing an
exception.</span></p>

<p class=MsoNormal><span style='color:windowtext'>Here’s an example that shows
the basics of <b>interrupt()</b>:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//: C11:Interrupting.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Interrupting a blocked thread.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Blocked : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::sleep(1000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; &quot;Waiting for get() in run():&quot;;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cin.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; &quot;Caught Interrupted_Exception&quot; &lt;&lt; endl; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Exit the task</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main(int argc, char* argv[]) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.run(new Blocked);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(argc &gt; 1)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Thread::sleep(1100);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>You can see that <b>run()</b>
contains <i>two</i> points where blocking can occur: the <b>Thread::sleep(1000)</b>
and the <b>cin.get()</b>. By giving the program any command-line argument, you
tell <b>main()</b> to sleep long enough that the task will finish its <b>sleep()</b>
and move into the <b>cin.get()</b>, but if you don’t give the program an
argument the <b>sleep()</b> in <b>main()</b> is skipped. In this case the call
to <b>interrupt()</b> will occur while the task is sleeping, and you’ll see
that this will cause <b>Interrupted_Exception</b> to be thrown. If you give the
program a command-line argument, you’ll discover that if a task is blocked
because of IO, it cannot be interrupted. That is, you can interrupt out of any
blocking operation <i>except</i> IO.</span></p>

<p class=MsoNormal><span style='color:windowtext'>This is a little
disconcerting if you’re creating a thread that performs IO, because it means
that IO has the potential of locking up your multithreaded program. The problem
is that, again, C++ was not designed with threading in mind; quite the
opposite, it effectively pretends that threading doesn’t exist. Thus the iostream
library is not thread-friendly. If the new C++ standard decides to add thread
support, the iostream library may need to be reconsidered in the process.</span></p>

<h4><span style='color:windowtext'>Blocked by a Mutex</span></h4>

<p class=MsoNormal><span style='color:windowtext'>In the previous list of ways
to become blocked, the last one happens when you’re trying to call a method
whose mutex has already been acquired. In this situation, the calling task will
be suspended until the mutex becomes available. The following example tests
whether this kind of blocking is interruptable:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:Interrupting2.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Interrupting a thread blocked </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
with a synchronization guard.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
BlockedMutex {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BlockedMutex() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.acquire();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
f() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
This will never be available</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Blocked2 : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BlockedMutex blocked;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; &quot;Waiting for f() in BlockedMutex&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
blocked.f();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Exit the task</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main(int argc, char* argv[]) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.run(new Blocked2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    t.interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>The class <b>BlockedMutex</b>
has a constructor that acquires its own <b>Mutex</b>, and never releases it.
For that reason, if you try to call <b>f()</b> you will always be blocked
because the <b>Mutex</b> cannot be acquired. In <b>Blocked2</b> the <b>run()</b>
method will therefore be stopped at the call to <b>blocked.f()</b>. When you
run the program you’ll see that, unlike the iostream call, <b>interrupt()</b>
can break out of a call that’s blocked by a mutex.</span></p>

<h4><span style='color:windowtext'>Checking for an interrupt</span></h4>

<p class=MsoNormal><span style='color:windowtext'>Note that when you call <b>interrupt()
</b>on a thread, the only time that the interrupt occurs is when the task
enters, or is already inside, a blocking operation (except, as we’ve seen, in
the case of IO, where you’re just stuck). But what if you’ve written code that
may or may not make such a blocking call, depending on the conditions in which
it is run? If you can only exit by throwing an exception on a blocking call,
you won’t always be able to leave the <b>run() </b>loop. Thus, if you call <b>interrupt()</b>
to stop a task, your task needs a <i>second</i> opportunity to exit in the
event that your <b>run()</b> loop doesn’t happen to be making any blocking
calls.</span></p>

<p class=MsoNormal><span style='color:windowtext'>This opportunity is presented
by the <i>interrupted status</i> which is set by the call to <b>interrupt()</b>.
You check for the interrupted status by calling <b>interrupted()</b>. This not
only tells you whether <b>interrupt()</b> has been called, it also clears the
interrupted status. [[ explain why ]]</span></p>

<p class=MsoNormal><span style='color:windowtext'>The following example shows
the typical idiom that you should use in your <b>run()</b> function to handle
both blocked and non-blocked possibilities when the interrupted status is set: </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:Interrupting3.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
General idiom for interrupting a task.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cmath&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdlib&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
NeedsCleanup {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
NeedsCleanup(int ident) : id(ident) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;NeedsCleanup &quot; &lt;&lt; id &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~NeedsCleanup() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;~NeedsCleanup &quot; &lt;&lt; id &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Blocked3 : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
volatile double d;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Blocked3() : d(0.0) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!Thread::interrupted()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
point1:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
NeedsCleanup n1(1);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
cout &lt;&lt; &quot;Sleeping&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        Thread::sleep(1000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
point2:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
NeedsCleanup n2(2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
cout &lt;&lt; &quot;Calculating&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// A time-consuming, non-blocking operation:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
for(int i = 1; i &lt; 100000; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
d = d + (M_PI + M_E) / (double)i;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; &quot;Exiting via while() test&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cout &lt;&lt; &quot;Exiting via Interrupted_Exception&quot; &lt;&lt; endl; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main(int argc, char* argv[]) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
if(argc != 2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; &quot;usage: &quot; &lt;&lt; argv[0] </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; &quot; delay-in-milliseconds&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
exit(1);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
delay = atoi(argv[1]);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.run(new Blocked3);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread::sleep(delay);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t.join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>NeedsCleanup</b> class
is used to emphasize the necessity of proper resource cleanup if you leave the
loop via an exception. Note that there are no pointers defined in <b>Blocked3::run()</b>
because, for exception safety, all resources must be enclosed in stack-based
objects so that the exception handler can automatically clean them up by
calling the destructor.</span></p>

<p class=MsoNormal><span style='color:windowtext'>You must give the program a
command-line argument which is the delay time in milliseconds before it calls <b>interrupt()</b>.
By using different delays, you can exit <b>Blocked3::run()</b> at different
points in the loop: in the blocking <b>sleep()</b> call, and in the
non-blocking mathematical calculation. You’ll see that if <b>interrupt()</b> is
called after the label <b>point2 </b>(during the non-blocking operation), first
the loop is completed, then all the local objects are destructed, and finally
the loop is exited at the top via the <b>while</b> statement. However, if <b>interrupt()</b>
is called between <b>point1 </b>and <b>point2 </b>(after the <b>while</b>
statement but before or during the blocking operation <b>sleep()</b>), the task
exits via the <b>Interrupted_Exception</b>. In that case, only the stack
objects that have been created up to the point where the exception is thrown
are cleaned up, and you have the opportunity to perform any other cleanup in
the <b>catch</b> clause.</span></p>

<p class=MsoNormal><span style='color:windowtext'>A class designed to respond
to an <b>interrupt(&nbsp;) </b>must establish a policy  that ensures it will
remain in a consistent state. This generally means that all resource acquisition
should be wrapped inside of stack-based objects so that the destructors will be
called regardless of how the <b>run() </b>loop exits. Correctly done, code like
this can be very elegant. Components can be created that completely encapsulate
their synchronization mechanisms but are still responsive to an external
stimulus (via <b>interrupt(&nbsp;)</b>) without adding any special functions to
an object’s interface.</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Cooperation between
threads</span></h2>

<p class=MsoNormal><span style='color:windowtext'>After understanding that
tasks can collide with each other, the way that you can keep them from
colliding, and the techniques for terminating a task, the next step is to learn
how to make tasks cooperate with each other. The key to doing this is by
handshaking between threads, which is safely implemented using the functions <b>wait(&nbsp;)</b>
and <b>signal(&nbsp;)</b>. </span></p>

<h3><span style='color:windowtext'>Wait and signal</span></h3>

<p class=MsoNormal><span style='color:windowtext'>It’s important to understand
that <b>sleep(&nbsp;)</b> <i>does not </i>release the lock when it is called.
On the other hand, the function </span><span style='color:windowtext'><b>wait(&nbsp;)</b> does release the lock, which means
that other </span><span
style='color:windowtext'><b>synchronized</b> functions in the thread object can
be called during a <b>wait(&nbsp;)</b>. When a thread enters a call to <b>wait(&nbsp;)</b>
inside a function, that thread’s execution is suspended, and the lock on that
object is released. </span></p>

<p class=MsoNormal><span style='color:windowtext'>There are two forms of <b>wait(&nbsp;)</b>.
The first takes an argument in milliseconds that has the same meaning as in <b>sleep(&nbsp;)</b>:
“Pause for this period of time.” The difference is that in <b>wait(&nbsp;)</b>:</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>The object lock is released during the <b>wait(&nbsp;)</b>.</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>You can come out of the <b>wait(&nbsp;)</b> due to a <b>signal(&nbsp;)</b>
or <b>broadcast(&nbsp;)</b>,<b> </b>or by letting the clock run out. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The second form of <b>wait(&nbsp;)</b>
takes no arguments; this version is more commonly used. This <b>wait(&nbsp;)</b>
continues indefinitely until the thread receives a <b>signal(&nbsp;)</b> or <b>broadcast(&nbsp;)</b>.
</span></p>

<p class=MsoNormal><span
style='color:windowtext'>One fairly unique aspect of <b>wait(&nbsp;)</b>, <b>signal(&nbsp;)</b>,
and <b>broadcast(&nbsp;) </b>is that these functions are part of the base class
<b>Object</b> and not part of <b>Thread</b>, as is <b>sleep(&nbsp;)</b>.
Although this seems a bit strange at first—to have something that’s exclusively
for threading as part of the universal base class—it’s essential because they
manipulate the lock that’s also part of every object. As a result, you can put
a <b>wait(&nbsp;)</b> inside any <b>synchronized</b> function, regardless of
whether that class inherits from <b>Thread</b> or implements <b>Runnable</b>.
In fact, the <i>only</i> place you can call <b>wait(&nbsp;)</b>, <b>signal(&nbsp;)</b>,
or <b>broadcast(&nbsp;)</b> is within a <b>synchronized</b> function or block (<b>sleep(&nbsp;)</b>
can be called within non-<b>synchronized</b> functions since it doesn’t
manipulate the lock). If you call any of these within a function that’s not <b>synchronized,</b>
the program will compile, but when you run it, you’ll get an </span><span style='color:windowtext'><b>IllegalMonitorStateException</b> with the somewhat
nonintuitive message “current thread not owner.” This message means that the
thread calling <b>wait(&nbsp;)</b>, <b>signal(&nbsp;)</b>, or <b>broadcast(&nbsp;)</b>
must “own” (acquire) the lock for the object before it can call any of these
functions. </span></p>

<p class=MsoNormal><span style='color:windowtext'>You can ask another object to
perform an operation that manipulates its own lock. To do this, you must first
capture that object’s lock. For example, if you want to <b>signal(&nbsp;)</b>
an object <b>x</b>, you must do so inside a <b>synchronized</b> block that
acquires the lock for <b>x</b>: </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>synchronized(x)
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
x.signal();</span></p>

<p class=CodeInline style='margin-left:0in'><span style='color:windowtext'>}</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Typically, <b>wait(&nbsp;)</b>
is used when you’re waiting for some condition that is under the control of
forces outside of the current function to change (typically, this condition
will be changed by another thread). You don’t want to idly wait while testing
the condition inside your thread; this is called a “busy wait” and it’s a very
bad use of CPU cycles. So <b>wait(&nbsp;)</b> allows you to put the thread to
sleep while waiting for the world to change, and only when a <b>signal(&nbsp;)</b>
or <b>broadcast(&nbsp;) </b>occurs does the thread wake up and check for
changes. Thus, <b>wait(&nbsp;)</b> provides a way to synchronize activities between
threads. </span></p>

<p class=MsoNormal><span style='color:windowtext'>As an example, consider a
restaurant that has one chef and one waitperson. The waitperson must wait for
the chef to prepare a meal. When the chef has a meal ready, the chef notifies
the waitperson, who then gets the meal and goes back to waiting. This is an
excellent example of thread cooperation: The chef represents the </span><span style='color:windowtext'><i>producer</i>, and the waitperson represents the <i>consumer</i>.
Here is the story modeled in code: </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:Restaurant.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// The
producer-consumer approach to thread cooperation.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Condition.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Singleton.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;deque&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Order {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
number;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Order(int num) : number(num) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getNumber() const { return number; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend ostream&amp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(ostream&amp; os, const Order&amp; ord) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;Order &quot; &lt;&lt; ord.number;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Restaurant : public Cancelable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Condition notEmpty;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Condition isEmpty;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
deque&lt;Order&gt; queue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  bool
canceled;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Restaurant() : notEmpty(lock),</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
isEmpty(lock), canceled(false) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
~Restaurant() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Order get() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while (queue.size() == 0 &amp;&amp; !canceled)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
notEmpty.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(queue.size() == 0) // Queue canceled</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
throw Cancellation_Exception();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Order order = queue.front();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
queue.pop_front();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wake empty waiters</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(queue.size() == 0)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
isEmpty.broadcast();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return order;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
put(Order order) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(canceled)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
throw Cancellation_Exception();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
queue.push_back( order );</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wake one waiter</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
notEmpty.signal();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void cancel() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
canceled = true;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
notEmpty.broadcast();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual bool isCanceled() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return canceled;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Display {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
pickedUp(Order order) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Picked up &quot; &lt;&lt; order &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
cookedUp(Order order) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Cooked up &quot; &lt;&lt; order &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Customer : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Restaurant&amp; restaurant;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Customer(Restaurant&amp; r) : restaurant(r) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!Thread::interrupted()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Order order = restaurant.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Singleton&lt;Display&gt;::instance()-&gt;pickedUp(order);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Thread::sleep(2000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Exit</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Chef : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Restaurant&amp; restaurant;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
unsigned int count, limit;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Chef(Restaurant&amp; r, unsigned int max = 10) :</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    restaurant(r),
count(0), limit(max) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!Thread::interrupted()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Order order(count++);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
restaurant.put(order);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Singleton&lt;Display&gt;::instance()-&gt;cookedUp(order);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Thread::sleep(1000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
if(count &gt;= limit)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
break;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
restaurant.cancel();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Exit</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Restaurant restaurant;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[2];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t[0].run(new Customer(restaurant));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t[1].run(new Chef(restaurant, 10));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t[0].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t[1].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='color:windowtext'>Order</span></b><span
style='color:windowtext'> is a simple immutable value class. </span></p>

<p class=MsoNormal><span style='color:windowtext'>A <b>WaitPerson</b> must know
what <b>Restaurant</b> they are working for because they must fetch the order
from the restaurant’s “order window,” <b>restaurant.order</b>. In <b>run(&nbsp;)</b>,
the <b>WaitPerson</b> goes into <b>wait(&nbsp;)</b> mode, stopping that thread
until it is woken up with a <b>signal(&nbsp;)</b> from the <b>Chef</b>. Since
this is a very simple program, we know that only one thread will be waiting on
the <b>WaitPerson</b>’s lock: the <b>WaitPerson</b> thread itself. For this
reason it’s safe to call <b>signal(&nbsp;)</b>. In more complex situations,
multiple threads may be waiting on a particular object lock, so you don’t know
which thread should be awakened. The solutions is to call <b>broadcast(&nbsp;)</b>,
which wakes up all the threads waiting on that lock. Each thread must then
decide whether the notification is relevant. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Notice that the <b>wait(&nbsp;)</b>
is wrapped in a <b>while(&nbsp;)</b> statement that is testing for the same
thing that is being waited for. This seems a bit strange at first—if you’re
waiting for an order, once you wake up the order must be available, right? The
problem is that in a multithreading application, some other thread might swoop
in and grab the order while the <b>WaitPerson</b> is waking up. The only safe
approach is to <i>always</i> use the following idiom for a <b>wait(&nbsp;)</b>:
</span></p>

<p class=MsoNormal style='margin-left:.5in'><b><span style='color:windowtext'>while(conditionIsNotMet)<br>
    wait(&nbsp;);</span></b></p>

<p class=MsoNormal><span style='color:windowtext'>This guarantees that the
condition will be met before you get out of the wait loop, and if you have
either been notified of something that doesn’t concern the condition (as can
happen with <b>broadcast(&nbsp;)</b>), or the condition changes before you get
fully out of the wait loop, you are guaranteed to go back into waiting. </span></p>

<p class=MsoNormal><span style='color:windowtext'>A <b>Chef</b> object must
know what restaurant he or she is working for (so the <b>Order</b>s can be
placed in <b>restaurant.order</b>)<b> </b>and the <b>WaitPerson</b> who is
picking up the meals, so that <b>WaitPerson</b> can be notified when an order
is ready. In this simplified example, the <b>Chef</b> is generating the <b>Order</b>
objects, then signaling the <b>WaitPerson</b> that an order is ready. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Observe that the call to <b>signal(&nbsp;)</b>
must first capture the lock on <b>waitPerson</b>. The call to <b>wait(&nbsp;)</b>
in <b>WaitPerson.run(&nbsp;) </b>automatically releases the lock, so this is
possible. Because the lock must be owned in order to call <b>signal(&nbsp;)</b>,
it’s guaranteed that two threads trying to call <b>signal(&nbsp;)</b> on one
object won’t step on each other’s toes. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The preceding example has
only a single spot for one thread to store an object so that another thread can
later use that object. However, in a typical producer-consumer implementation,
you use a first-in, first-out queue in order to store the objects being
produced and consumed. See the exercises at the end of the chapter to learn
more about this. </span></p>

<h3><span style='color:windowtext'>Bounded Resources</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Another classic example of
this kind of problem is the narrow bridge. Imagine a narrow bridge over a deep
canyon. The bridge is so narrow only one car can pass over it at a time. Its an
old and somewhat rickety bridge, so only three cars at a time can be on it
safely at once. How can we design a solution that keeps as much traffic as
possible flowing over the bridge safely?</span></p>

<p class=MsoNormal><span style='color:windowtext'>One way to solve this problem
is model it as a reader-writer problem.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:Bridge.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/CountingSemaphore.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Semaphore.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Singleton.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Display {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
readerAcquired() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;read lock acquired &quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
readerReleased() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;read lock released&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
writerAcquired() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;write lock acquired&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
writerReleased() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;write lock released&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
ReadWriteLock {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Semaphore lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
CountingSemaphore read, write;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
nr_active, nr_waiting;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
nw_active, nw_waiting;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
capacity;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ReadWriteLock(int n) : lock(1) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
nr_active = nw_active = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
nr_waiting =  nw_waiting = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
capacity = n;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
acquireRead() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Guard&lt;Semaphore&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// No wait if there are no writers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// and we aren't at capacity</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
if((nw_active + nw_waiting == 0)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        
&amp;&amp; nr_active &lt; capacity) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nr_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
read.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
} else</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nr_waiting++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
read.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
releaseRead() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Semaphore&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
nr_active--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
If this is the last reader, wake any waiting writers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(nr_active &lt; 1 &amp;&amp; nw_waiting &gt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
for(int count = 0; nw_waiting &gt; 0</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
&amp;&amp; count &lt; capacity;)  {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// Wake a writer</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
write.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nw_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nw_waiting--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
count++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
else if(nw_waiting == 0 &amp;&amp; nr_waiting &gt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Wake a reader</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
read.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
nr_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
nr_waiting--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
acquireWrite() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Guard&lt;Semaphore&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// No wait if there are no readers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>      //
and we aren't at capacity</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
if((nr_active + nr_waiting == 0)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        
&amp;&amp; nw_active &lt; capacity) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nw_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
write.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
} else</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nw_waiting++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
write.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
releaseWrite() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Semaphore&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
nw_active--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
If this is the last writer, wake any waiting readers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(nw_active &lt; 1 &amp;&amp; nr_waiting &gt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
for(int count = 0; nr_waiting &gt; 0</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
&amp;&amp; count &lt; capacity;)  {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// Wake a reader</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
read.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        nr_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
nr_waiting--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
count++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
else if(nr_waiting == 0 &amp;&amp; nw_waiting &gt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Wake a writer</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
write.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
nw_active++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
nw_waiting--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Reader : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ReadWriteLock&amp; lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Reader(ReadWriteLock&amp; rwlock) : lock(rwlock) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Reader() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.acquireRead();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;readerAcquired();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread::sleep(2000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.releaseRead();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;readerReleased();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Writer : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ReadWriteLock&amp; lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Writer(ReadWriteLock&amp; rwlock) : lock(rwlock) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Writer() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.acquireWrite();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;writerAcquired();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread::sleep(1000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
lock.releaseWrite();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;writerReleased();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ReadWriteLock lock(3);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Handle&lt;Reader&gt; r(new Reader(lock));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Handle&lt;Writer&gt; w(new Writer(lock));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[10];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 5; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].run(r);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 5; i &lt; 10; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].run(w);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 10; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Cars going in one direction
can be treated as readers while cars going in the other can be treated as
writers.</span></p>

<h3><span style='color:windowtext'>Solving Threading problems with Queues</span></h3>

<p class=MsoNormal><span style='color:windowtext'>For example, you can easily
create a simple bounded queue that will block threads waiting for items to
arrive <i>and</i> allow those blocked threads to abort their <b>wait(&nbsp;)</b>
without exposing anything other than a simple <b>get(&nbsp;)</b> and <b>put(&nbsp;)</b>
accessory.</span><span style='color:windowtext'> </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:BoundedQueue.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
BOUNDEDQUEUE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
BOUNDEDQUEUE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Condition.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;deque&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>template&lt;class
T&gt; class BoundedQueue {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  ZThread::Condition
cond;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::deque&lt;T&gt; data;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BoundedQueue() : cond(lock) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
put(T item) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
data.push_back(item);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cond.signal();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  T
get() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(data.empty())</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cond.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    T
returnVal = data.front();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
data.pop_front();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return returnVal;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// BOUNDEDQUEUE_H ///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:TestBoundedQueue.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;string&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;BoundedQueue.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BoundedQueue&lt;string&gt; stringQueue;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
stringQueue.put(&quot;Hello, &quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
stringQueue.put(&quot;world!&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; stringQueue.get();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; stringQueue.get();</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=MsoNormal><span style='color:windowtext'>&nbsp;</span></p>

<h3><span style='color:windowtext'>The barbershop</span></h3>

<p class=MsoNormal><span style='color:windowtext'>As a second example, picture
a barbershop consisting of a waiting room with some chairs for waiting, and a
single barber’s chair for getting your haircut. Customers enter the barber shop
and wait in that first set of chairs for the barber’s chair to be free. Once it
is free, they move to that chair the barber cuts their hair and sends them on
their way. The barber is a often sleepy and if no one is around he likes to
take a nap in his chair until some customer comes to wake him up.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:SleepingBarber.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// The
Sleeping Barber problem.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/CountingSemaphore.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Semaphore.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Singleton.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Display {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
barberSleep() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Barber sleeping...&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
barberAwake() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Barber awakened, cutting hair&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
barberDone() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Barber finished cutting hair&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
shopEnter(int id) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Customer &quot; &lt;&lt; id</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
&lt;&lt; &quot; entering shop, waiting for barber.&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
shopExit(int id) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Customer &quot; &lt;&lt; id</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; &quot; woke up, leaving shop.&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
shopFull(int id) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Barber shop full!, Customer &quot; &lt;&lt; id</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; &quot; leaving.&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
shopHaircut(int id) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cout &lt;&lt; &quot;Customer &quot; &lt;&lt; id</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&lt;&lt; &quot; getting haircut.&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Generator {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Generator() : id(0) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
next() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Guard&lt;Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return ++id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
BarberShop {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //!
Customers waiting for a haircut</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
CountingSemaphore customer;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //!
Haircut completed</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
CountingSemaphore barber;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //!
Keep track of when a customer is done</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Semaphore complete;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //!
Serialize data access</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Semaphore mutex;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //!
Number of seats in the shop</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
seats;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
waiting;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BarberShop(int n = 3)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  :
customer(0), barber(0), complete(0), mutex(1) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
waiting = 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
seats = n;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
waitForHaircut(int id) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
mutex.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Leave if the shop is full</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
if(waiting &lt; seats) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
waiting++;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Singleton&lt;Display&gt;::instance()-&gt;shopEnter(id);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Let the barber know someone is waiting</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
customer.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
mutex.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Wait for the barber to wake up or to</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// finish with someone's hair</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
barber.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Singleton&lt;Display&gt;::instance()-&gt;shopHaircut(id);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Let the barber know the customer woke up</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
complete.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Singleton&lt;Display&gt;::instance()-&gt;shopExit(id);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    } else
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
Singleton&lt;Display&gt;::instance()-&gt;shopFull(id);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
mutex.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
waitForCustomer() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;barberSleep();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wait for a customer to show up</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
customer.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;barberAwake();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Serialize access to the waiting variable</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
mutex.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Update the waiter count</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
waiting--;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
barber.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
mutex.post();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wait for the customer to wake up</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
complete.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Singleton&lt;Display&gt;::instance()-&gt;barberDone();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Customer : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BarberShop&amp; shop;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Customer(BarberShop&amp; bs) : shop(bs) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    id
= Singleton&lt;Generator&gt;::instance()-&gt;next();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Customer() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Precondition based on interruption</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!Thread::interrupted()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
shop.waitForHaircut(id);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// Pause before trying again:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
Thread::sleep(2000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Signal to quit</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Barber : public Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
BarberShop&amp; shop;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Barber(BarberShop&amp; bs) : shop(bs) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Barber() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Precondition based on interruption</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!Thread::interrupted())</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
shop.waitForCustomer();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Interrupted_Exception&amp;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Signal to quit</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[8];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
BarberShop shop;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
t[7].run(new Barber(shop));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 7; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].run(new Customer(shop));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Run for 10 seconds</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread::sleep(10000);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Communicate with any running tasks</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 8; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Join instead of using daemon threads. These</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
tasks are all sharing that BarberShop object</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
which lives on the stack and we need to be</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
sure that object will not be deleted before</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
the threads are all done</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; 8; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<h3><span style='color:windowtext'>Synchronizing classes</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Guards are quite versatile
and can also be used to create a synchronized wrapper for an entire class. This
means that every member function in the class will automatically be guarded.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:GuardedObject.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Transferred Locking Scope, used to create a</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
GuardedObject template. A GuardedObject will</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
automatically lock and unlock an internal Lockable</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
object as each member function invocation </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
begins and ends.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
GUARDEDOBJECT_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
GUARDEDOBJECT_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>namespace
ZThread {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>template
&lt;class T, class LockType = Mutex&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
GuardedObject {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
LockType _lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  T
_p;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
GuardedObject(const GuardedObject&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
GuardedObject&amp; operator=(const GuardedObject&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
class TransferedScope {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
template &lt;class LockType1, class LockType2&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
static void shareScope(LockHolder&lt;LockType1&gt;&amp; l1,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>                          
LockHolder&lt;LockType2&gt;&amp; l2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
l1.disable();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
l2.getLock().acquire();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
template &lt;class LockType1&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
static void createScope(LockHolder&lt;LockType1&gt;&amp; l) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
// Don't acquire the lock when created</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
template &lt;class LockType1&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
static void destroyScope(LockHolder&lt;LockType1&gt;&amp; l) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
l.getLock().release();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  };</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
class Proxy : Guard&lt;LockType, TransferedScope&gt; {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
T&amp; _object;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Proxy(LockType&amp; lock, T&amp; object)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     :
Guard&lt;LockType, TransferedScope&gt;(lock),</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>      
_object(object) { }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    T*
operator-&gt;() { return &amp;_object; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  };</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
GuardedObject() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Proxy operator-&gt;() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Proxy p(_lock, _p);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return p;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>} //
End of namespace</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// GUARDEDOBJECT_H ///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>The GuardedObject template
can now be used to create a wrapper for an object that synchronizes each
function call.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:TestGuardedObjectTemplate.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;GuardedObject.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
MyClass {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
func1() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
func2() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
MyClass a;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
a.func1(); // not synchronized</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
a.func2(); // not synchronized</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
GuardedObject&lt;MyClass&gt; b;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
b-&gt;func1(); // synchronized, only one thread at a time</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
b-&gt;func2(); // synchronized, only one thread at a time</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Here object <b>a</b> is a not
synchronized, meaning that <b>func1(&nbsp;)</b> and <b>func2(&nbsp;)</b> can be
called at any time by any number of threads. Object <b>b</b> is protected by
the GuardedObject wrapper, each function is locked in such a way that only one
function can be called any time, no matter now many threads are making
requests.</span></p>

<p class=MsoNormal><span style='color:windowtext'>This GuardedObject wrapper
should be used with care, a user needs to be conscience of two important
things. One is that the wrappers locks with a class level granularity, which
may affect performance in some cases. If a class contains some unrelated
functions, it would be better to synchronize those functions internally with
two different locks. Another is that just locking a mutex does not
automatically make a class thread safe.</span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Deadlock</span></h2>

<p class=MsoNormal><span style='color:windowtext'>Because threads can become blocked <i>and</i> because
objects can have <b>synchronized</b> functions that prevent threads from
accessing that object until the synchronization lock is released, it’s possible
for one thread to get stuck waiting for another thread, which in turn waits for
another thread, etc., until the chain leads back to a thread waiting on the
first one. You get a continuous loop of threads waiting on each other, and no
one can move. This is called <i>deadlock</i>. </span></p>

<p class=MsoNormal><span style='color:windowtext'>If you try running a program
and it deadlocks right away, you immediately know you have a problem and you
can track it down. The real problem is when your program seems to be working
fine but has the hidden potential to deadlock. In this case you may get no
indication that deadlocking is a possibility, so it will be latent in your program
until it unexpectedly happens to a customer (and you probably won’t be able to
easily reproduce it). Thus, preventing deadlock by careful program design is a
critical part of developing concurrent programs. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Let’s look at the classic
demonstration of deadlock, invented by Dijkstra: the </span><span style='color:windowtext'><i>dining philosophers</i> problem. The basic
description specifies five philosophers (but the example shown here will allow
any number). These philosophers spend part of their time thinking and part of
their time eating. While they are thinking, they don’t need any shared
resources, but when they are eating, they sit at a table with a limited number
of utensils. In the original problem description, the utensils are forks, and
two forks are required to get spaghetti from a bowl in the middle of the table,
but it seems to make more sense to say that the utensils are chopsticks;
clearly, each philosopher will require two chopsticks in order to eat. </span></p>

<p class=MsoNormal><span style='color:windowtext'>A difficulty is introduced
into the problem: As philosophers, they have very little money, so they can
only afford five chopsticks. These are spaced around the table between them.
When a philosopher wants to eat, he or she must get the chopstick to the left
and the one to the right. If the philosopher on either side is using the desired
chopstick, then our philosopher must wait. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Note that the reason this
problem is interesting is because it demonstrates that a program can appear to
run correctly but actually be deadlock prone. To show this, the command-line
arguments allow you to adjust the number of philosophers and a factor to affect
the amount of time each philosopher spends thinking. If you have lots of
philosophers and/or they spend a lot of time thinking, you may never see the
deadlock even though it remains a possibility. The default command-line
arguments tend to make it deadlock fairly quickly: </span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:DiningPhilosophers.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Classes for Dining Philosohophers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
DININGPHILOSOPHERS_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
DININGPHILOSOPHERS_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//#include
&quot;Random.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Condition.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Guard.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Mutex.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Singleton.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;zthread/Thread.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;fstream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;string&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdlib&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cmath&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;ctime&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>static
const int PHILOSOPHERS = 5;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Philosopher;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Display {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
thinking(const Philosopher&amp; p);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
eating(const Philosopher&amp; p);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
left(const Philosopher&amp; p);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
right(const Philosopher&amp; p);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Chopstick {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Mutex lock;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Condition notTaken;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  bool
taken;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Chopstick() : notTaken(lock), taken(false) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
take() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
while(taken)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
notTaken.wait();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
taken = true;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  void
drop() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
taken = false;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
notTaken.signal();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Philosopher : public ZThread::Runnable {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Chopstick&amp; left;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Chopstick&amp; right;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
id; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
//Random random;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Philosopher(Chopstick&amp; l, Chopstick&amp; r, int ident) </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    :
left(l), right(r), id(ident) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
srand(time(0));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual ~Philosopher() throw() {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int randSleepTime() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return rand()/(RAND_MAX/5)*1000;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
virtual void run() throw() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
try {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
while(!ZThread::Thread::interrupted()) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
ZThread::Singleton&lt;Display&gt;::</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
instance()-&gt;thinking(*this);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>        ZThread::Thread::sleep(randSleepTime());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// Hungry</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
ZThread::Singleton&lt;Display&gt;::</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
instance()-&gt;right(*this);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
right.take();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
ZThread::Singleton&lt;Display&gt;::</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
instance()-&gt;left(*this);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
left.take();        </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
// Eating</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
ZThread::Singleton&lt;Display&gt;::</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>         
instance()-&gt;eating(*this);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
ZThread::Thread::sleep(randSleepTime());     </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
right.drop();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
left.drop();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }
catch(ZThread::Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
std::cerr &lt;&lt; *this &lt;&lt; e.what() &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
identity() const { return id; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend std::ostream&amp; </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
operator&lt;&lt;(std::ostream&amp; os, const Philosopher&amp; p) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return os &lt;&lt; &quot;Philosopher &quot; &lt;&lt; p.identity();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void Display::thinking(const Philosopher&amp; p) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::cout &lt;&lt; p &lt;&lt; &quot; thinking&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void Display::eating(const Philosopher&amp; p) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::cout &lt;&lt; p &lt;&lt; &quot; eating&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void Display::left(const Philosopher&amp; p) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::cout &lt;&lt; p &lt;&lt; &quot; grabbing left&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void Display::right(const Philosopher&amp; p) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::cout &lt;&lt; p &lt;&lt; &quot; grabbing right&quot; &lt;&lt; std::endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// DININGPHILOSOPHERS_H ///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>&nbsp;</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:DeadlockingDiningPhilosophers.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Dining Philosohophers w/ Deadlock</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
“DiningPhilosophers.h”</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() { </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Press &lt;ENTER&gt; to quit&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[PHILOSOPHERS];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Chopstick c[PHILOSOPHERS];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
int j = (i+1) &gt; (PHILOSOPHERS-1) ? 0 : (i+1);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].run(new Philosopher(c[i], c[j], i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wait for any key</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
string s;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
getline(cin, s);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>Both <b>Chopstick</b> and <b>Philosopher</b>
use an auto-incremented <b>static</b> <b>counter</b> to give each element an
identification number. Each <b>Philosopher</b> is given a reference to a left
and right <b>Chopstick</b> object; these are the utensils that must be picked
up before that <b>Philosopher</b> can eat. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>static</b> field <b>ponder</b>
indicates whether the philosophers will spend any time thinking. If the value
is nonzero, then it will be used to randomly generate a sleep time inside <b>think(&nbsp;)</b>.
This way, you can show that if your threads (philosophers) are spending more
time on other tasks (thinking) then they have a much lower probability of
requiring the shared resources (chopsticks) and thus you can convince yourself
that the program is deadlock free, even though it isn’t. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Inside <b>eat(&nbsp;)</b>, a <b>Philosopher</b>
acquires the left chopstick by synchronizing on it. If the chopstick is
unavailable, then the philosopher blocks while waiting. When the left chopstick
is acquired, the right one is acquired the same way. After eating, the right
chopstick is released, then the left. </span></p>

<p class=MsoNormal><span style='color:windowtext'>In <b>run(&nbsp;)</b>, each <b>Philosopher</b>
just thinks and eats continuously. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>main(&nbsp;)</b>
function requires at least three arguments and prints a usage message if these
are not present. The third argument can be the string “deadlock,” in which case
the deadlocking version of the program is used. Any other string will cause the
non-deadlocking version to be used. The last (optional) argument is a timeout
factor, which will abort the program after that number of seconds (whether it’s
deadlocked or not). The timeout is necessary for the program to be run
automatically as part of the book code testing process. </span></p>

<p class=MsoNormal><span style='color:windowtext'>After the array of <b>Philosopher</b>
is created and the ponder value is set, two <b>Chopstick</b> objects are
created, and the first one is also stored in the <b>first</b> variable for use
later. Every reference in the array except the last one is initialized by
creating a new <b>Philosopher</b> object and handing it the <b>left</b> and <b>right</b>
chopsticks. After each initialization, the left chopstick is moved to the right
and the right is given a new <b>Chopstick</b> object to be used for the next <b>Philosopher</b>.
</span></p>

<p class=MsoNormal><span style='color:windowtext'>In the deadlocking version,
the last <b>Philosopher</b> is given the left chopstick and the <b>first</b>
chopstick that was stored earlier. That’s because the last <b>Philosopher</b>
is sitting right next to the very first one, and they both share that first
chopstick. With this arrangement, it’s possible at some point for all the
philosophers to be trying to eat and waiting on the philosopher next to them to
put down their chopstick, and the program will deadlock. </span></p>

<p class=MsoNormal><span style='color:windowtext'>To repair the problem, you
must understand that </span><span
style='color:windowtext'>deadlock can occur if four conditions are
simultaneously met: </span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>Mutual exclusion: At least one resource used by the
threads must not be shareable. In this case, a chopstick can be used by only
one philosopher at a time. </span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>At least one process must be holding a resource and
waiting to acquire a resource currently held by another process. That is, for
deadlock to occur, a philosopher must be holding one chopstick and waiting for
the other one. </span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>A resource cannot be preemptively taken away from a
process. All processes must only release resources as a normal event. Our
philosophers are polite and they don’t grab chopsticks from other philosophers.
</span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'><span style='color:windowtext'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:windowtext'>A circular wait must happen, whereby a process waits
on a resource held by another process, which in turn is waiting on a resource
held by another process, and so on, until one of the processes is waiting on a
resource held by the first process, thus gridlocking everything. In this
example, the circular wait happens because each philosopher tries to get the
left chopstick first and then the right. In the preceding example, the deadlock
is broken by swapping the initialization order in the constructor for the last
philosopher, causing that last philosopher to actually get the right chopstick
first, then the left. </span></p>

<p class=MsoNormal><span style='color:windowtext'>Because all of these
conditions must be met in order to cause deadlock, you only need to stop one of
them from occurring in order to prevent deadlock. In this program, the easiest
way to prevent deadlock is to break condition four. This condition happens
because each philosopher is trying to pick up their chopsticks in a particular
sequence: first left, then right. Because of that, it’s possible to get into a
situation where each of them is holding their left chopstick and waiting to get
the right one, causing the circular wait condition. However, if the last
philosopher is initialized to try to get the right chopstick first and then the
left, then that philosopher will never prevent the philosopher on the immediate
left from picking up his or her right chopstick, so the circular wait is
prevented. This is only one solution to the problem, but you could also solve
it by preventing one of the other conditions (see more advanced threading books
for more details). </span></p>

<p class=MsoNormal><span style='color:windowtext'>The following example shows
how the deadlock can be removed from the Dining Philosopher program.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C11:FixedDiningPhilosophers.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Dining Philosohophers w/o Deadlock</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//{L}
Zthread</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;DiningPhilosophers.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace ZThread;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
main() {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  cout
&lt;&lt; &quot;Press &lt;ENTER&gt; to quit&quot; &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  try
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Thread t[PHILOSOPHERS];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Chopstick c[PHILOSOPHERS];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
int j = (i+1) &gt; (PHILOSOPHERS-1) ? 0 : (i+1);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
if(i &lt; (PHILOSOPHERS-1))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
t[i].run(new Philosopher(c[i], c[j], i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>      else</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>       
t[i].run(new Philosopher(c[j], c[i], i));</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Wait for any key</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
string s;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
getline(cin, s);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].interrupt();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
for(int i = 0; i &lt; PHILOSOPHERS; i++)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
t[i].join();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }
catch(Synchronization_Exception&amp; e) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
cerr &lt;&lt; e.what() &lt;&lt; endl;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailer><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>By ensuring that the last
philosopher picks up and puts down his left fork before his right, the deadlock
is removed and the program will run smoothly.</span></p>

<p class=MsoNormal><span style='color:windowtext'>There is no language support
to help prevent deadlock; it’s up to you to avoid it by careful design. These
are not comforting words to the person who’s trying to debug a deadlocking
program. </span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Summary</span></h2>

<p class=MsoNormal><span style='color:windowtext'>It is vital to learn when to
use </span><span style='color:windowtext'>concurrency and when to avoid it. The main reasons to
use it are: to manage a number of tasks whose intermingling will make more
efficient use of the computer (including the ability to transparently
distribute the tasks across multiple CPUs), allow better code organization, or
be more convenient for the user. The classic example of resource balancing is
to use the CPU during I/O waits. The classic example of user convenience is to
monitor a “stop” button during long downloads. </span></p>

<p class=MsoNormal><span style='color:windowtext'>An additional advantage to
threads is that they provide “light” execution context switches (on the order
of 100 instructions) rather than “heavy” process context switches (thousands of
instructions). Since all threads in a given process share the same memory
space, a light context switch changes only program execution and local
variables. A process change –the heavy context switch—must exchange the full
memory space. </span></p>

<p class=MsoNormal><span style='color:windowtext'>The main drawbacks to
multithreading are: </span></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='color:windowtext'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Slowdown occurs while waiting for
shared resources.</span></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='color:windowtext'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Additional CPU overhead is
required to manage threads.</span></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='color:windowtext'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Unrewarded complexity arises from
poor design decisions.</span></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='color:windowtext'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Opportunities are created for
pathologies such as starving, racing, deadlock, and livelock.</span></p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='color:windowtext'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Inconsistenciesoccur across
platforms. For instance, while developing some of the examples for this book, I
discovered race conditions that quickly appeared on some computers but that
wouldn’t appear on others. If you developed a program on the latter, you might
get badly surprised when you distribute it.</span></p>

<p class=MsoNormal><span style='color:windowtext'>One of the biggest
difficulties with threads occurs because more than one thread might be sharing
a resource—such as the memory in an object—and you must make sure that multiple
threads don’t try to read and change that resource at the same time. This
requires judicious use of the <b>synchronized</b> keyword, which is an
essential tool, but must be understood thoroughly because it can quietly
introduce deadlock situations. </span></p>

<p class=MsoNormal><span style='color:windowtext'>In addition, there’s a
certain art to the application of threads. C++ is designed to allow you to
create as many objects as you need to solve your problem—at least in theory.
(Creating millions of objects for an engineering finite-element analysis, for
example, might not be practical in C++.) However, it seems that there is an
upper bound to the number of threads you’ll want to create, because at some
number, threads seem to become balky. This critical point can be hard to
detect, and will often depend on the OS and thread library; it could be less
than a hundred or in the thousands. As you often create only a handful of
threads to solve a problem, this is typically not much of a limit; yet in a
more general design it becomes a constraint. </span></p>

<p class=MsoNormal><span style='color:windowtext'>A significant nonintuitive
issue in threading is that, because of thread scheduling, you can often make
your applications run <i>faster</i> by inserting calls to <b>yield(&nbsp;) </b>or
even <b>sleep(&nbsp;)</b> inside <b>run(&nbsp;)</b>’s main loop. This
definitely makes it feel like an art, in particular when the longer delays seem
to speed up performance. The reason this happens is that shorter delays can
cause the end-of-<b>sleep(&nbsp;)</b> scheduler interrupt to happen before the
running thread is ready to go to sleep, forcing the scheduler to stop it and
restart it later so it can finish what it was doing and then go to sleep. The
extra context switches can end up slowing things down, and the use of <b>yield(&nbsp;)</b>
or <b>sleep(&nbsp;)</b> may prevent the extra switches. It takes extra thought
to realize how messy things can get. </span></p>

<p class=MsoNormal><span style='color:windowtext'>In general, regardless of how
simple threading can seem using a particular language or library, you should
consider it a black art, where there’s always something you haven’t considered
that can bite you when you least expect it (note that the Dining Philosophers
problem can be adjusted so that deadlock rarely happens, so you can get the
impression that everything is OK). An appropriate quote comes from Guido Van
Rossum, creator of the Python programming language:</span></p>

<p class=MsoNormal style='margin-left:.5in'><i><span style='color:windowtext'>In
any project that is multi-threaded, most bugs will come from threading issues. 
This is regardless of programming language – it’s a deep, as yet ununderstood
property of threads.</span></i></p>

<p class=MsoNormal><span style='color:windowtext'>For more advanced discussions
of threading, see <i>Concurrent Programming in Java</i>, 2<sup>nd</sup>
Edition, by Doug Lea, Addison-Wesley, 2000. </span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Exercises</span></h2>

<p class=MsoNormal><span style='font-size:8.0pt;color:windowtext'>Solutions to
selected exercises can be found in the electronic document <i>The Thinking in
C++ Annotated Solution Guide</i>, available for a small fee from <i>www.BruceEckel.com</i>.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>1. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Inherit a class from Thread and
override the run(&nbsp;) function. Inside run(&nbsp;), print a message, and
then call sleep(&nbsp;). Repeat this three times, then return from run(&nbsp;).
Put a start-up message in the constructor and override finalize(&nbsp;) to
print a shut-down message. Make a separate thread class that calls
System.gc(&nbsp;) and System.runFinalization(&nbsp;) inside run(&nbsp;),
printing a message as it does so. Make several thread objects of both types and
run them to see what happens. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>2. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>modify EvenGenerator.cpp to use
interrupt() instead of quit flags. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>3. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>modify quitflag to use interrupt
on other examples]]</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>4. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>MutexEvenGenerator.cpp</b>
so that it uses the <b>Guard</b> template instead of a “raw” mutex.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>5. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>In Chapter 8, locate the <b>GreenhouseController.cpp</b>
example, which consists of four files. In <b>Event.cpp</b>, the class <b>Event</b>
is based on watching the time. Change <b>Event</b> so that it is a <b>Thread</b>,
and change the rest of the design so that it works with this new <b>Thread</b>-based
<b>Event</b>. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>6. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify the previous exercise so
that the <b>java.util.Timer</b> class is used to run the system. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>7. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>SimpleThread.cpp</b> so
that all the threads are daemon threads and verify that the program ends as
soon as <b>main(&nbsp;)</b> is able to exit. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>8. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Demonstrate that <b>java.util.Timer</b>
scales to large numbers by creating a program that generates many <b>Timer</b>
objects that perform some simple task when the timeout completes (if you want
to get fancy, you can jump forward to the “Windows and Applets” chapter and use
the <b>Timer</b> objects to draw pixels on the screen, but printing to the
console is sufficient).</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>9. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Demonstrate that a <b>synchronized</b>
function in a class can call a second <b>synchronized</b> function in the same
class, which can then call a third <b>synchronized</b> function in the same
class. Create a separate <b>Thread</b> object that invokes the first <b>synchronized</b>
function.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>10. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Create two <b>Thread</b>
subclasses, one with a <b>run(&nbsp;)</b> that starts up and then calls <b>wait(&nbsp;)</b>.
The other class’s <b>run(&nbsp;)</b> should capture the reference of the first <b>Thread
</b>object. Its <b>run(&nbsp;) </b>should call <b>broadcast(&nbsp;)</b> for the
first thread after some number of seconds have passed so that first thread can
print a message. </span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>11. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Create an example of a “busy
wait.” One thread sleeps for awhile and then sets a flag to <b>true</b>. The
second thread watches that flag inside a while loop (this is the “busy wait”)
and when the flag becomes <b>true</b>, sets it back to false and reports the
change to the console. Note how much wasted time the program spends inside the
“busy wait” and create a second version of the program that uses <b>wait(&nbsp;)</b>
instead of the “busy wait.”</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>12. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>Restaurant.cpp</b> to
use <b>broadcast(&nbsp;)</b> and observe any difference in behavior.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>13. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>Restaurant.cpp</b> so
that there are multiple <b>WaitPerson</b>s, and indicate which one gets each <b>Order</b>.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>14. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>Restaurant.cpp</b> so
that multiple <b>WaitPerson</b>s generate order requests to multiple <b>Chef</b>s,
who produce orders and signal the <b>WaitPerson</b> who generated the request.
You’ll need to use queues for both incoming order requests and outgoing orders.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>15. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify the previous exercise to
add <b>Customer</b> objects that are also threads. The <b>Customer</b>s will
place order requests with <b>WaitPerson</b>s, who give the requests to the <b>Chef</b>s,
who fulfill the orders and signal the appropriate <b>WaitPerson</b>, who gives
it to the appropriate <b>Customer</b>.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>16. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>PipedIO.cpp</b> so that <b>Sender</b>
reads and sends lines from a text file.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>17. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Change <b>DiningPhilosophers.cpp</b>
so that the philosophers just pick the next available chopstick (when a
philosopher is done with their chopsticks, they drop them into a bin. When a
philosopher wants to eat, they take the next two available chopsticks from the bin).
Does this eliminate the possibility of deadlock? Can you re-introduce deadlock
by simply reducing the number of available chopsticks?</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>18. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Inherit a class from <b>java.util.Timer</b>
and implement the <b>requestStop(&nbsp;)</b> function as in <b>Stopping.cpp</b>.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>19. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Modify <b>SimpleThread.cpp</b> so
that all threads receive an <b>interrupt(&nbsp;)</b> before they are completed.</span></p>

<p class=Exercises style='text-indent:-1.0in'><span style='font-size:12.0pt;
color:windowtext'><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>20. <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:windowtext'>Solve a single producer, single
consumer problem using <b>wait(&nbsp;)</b> and <b>signal(&nbsp;)</b>. The
producer must not overflow the receiver's buffer, which can happen if the
producer is faster than the consumer. If the consumer is faster than the
producer, then it must not read the same data more than once. Do not assume
anything about the relative speeds of the producer or consumer.</span></p>

<p class=Intro><span style='color:windowtext'>&nbsp;</span></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Georgia;color:windowtext'>&nbsp;</span></p>

</p>

<span style='color:windowtext'><br clear=all style='page-break-before:right'>
</span>

<div class=Section19>

<h1 style='margin-left:-81.35pt'><span style='color:windowtext'>A: Recommended
reading</span></h1>

<p class=MsoNormal><span style='color:windowtext'> [ Note that some or all of
these were listed in the first edition, so I think most might be replaced with
new entries (but you might want to check to make sure). ]<sup><span
style='color:red'>Comment</span></sup></span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>C</span></h2>

<p class=MsoNormal><b><span style='color:windowtext'>Thinking in C: Foundations
for Java &amp; C++</span></b><span style='color:windowtext'>, by Chuck Allison
(a MindView, Inc. Seminar on CD ROM, 1999, available at
http://www.MindView.net). A course including lectures and slides in the
foundations of the C Language to prepare you to learn Java or C++. This is not
an exhaustive course in C; only the necessities for moving on to the other
languages are included. An extra section covering features for the C++
programmer is included. Prerequisite: experience with a high-level programming
language, such as Pascal, BASIC, Fortran, or LISP. <sup><span style='color:
red'>Comment</span></sup></span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>General C++</span></h2>

<p class=MsoNormal><b><span style='color:windowtext'>The C++ Programming
Language, 3<sup>rd</sup> edition</span></b><span style='color:windowtext'>, by
Bjarne Stroustrup (Addison-Wesley 1997). To some degree, the goal of the book
that you’re currently holding is to allow you to use Bjarne’s book as a
reference. Since his book contains the description of the language by the
author of that language, it’s typically the place where you’ll go to resolve
any uncertainties about what C++ is or isn’t supposed to do. When you get the
knack of the language and are ready to get serious, you’ll need it.<sup><span
style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><b><span style='color:windowtext'>C++ Primer, 3<sup>rd</sup>
Edition</span></b><span style='color:windowtext'>, by </span><span
  style='color:windowtext'>Stanley</span><span style='color:windowtext'>
Lippman and Josee Lajoie (Addison-Wesley 1998). Not that much of a primer
anymore; it’s evolved into a thick book filled with lots of detail, and the one
that I reach for along with Stroustrup’s when trying to resolve an issue. <i>Thinking
in C++</i>  should provide a basis for understanding the <i>C++ Primer </i>as
well as Stroustrup’s book.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><b><span style='color:windowtext'>C &amp; C++ Code Capsules</span></b><span
style='color:windowtext'>, by Chuck Allison (Prentice-Hall, 1998). Assumes that
you already know C and C++, and covers some of the issues that you may be rusty
on, or that you may not have gotten right the first time. This book fills in C
gaps as well as C++ gaps.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>The C++ ANSI/ISO Standard.
This is <i>not</i> free, unfortunately (I certainly didn’t get paid for my time
and effort on the Standards Committee – in fact, it cost me a lot of money).
But at least you can buy the electronic form in PDF for only $18 at <span
style='color:red'>http://www.cssinfo.com</span>.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Large Scale C++ (?) by John
Lakos.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>C++ Gems, Stan Lippman,
editor. SIGS publications.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>The Design &amp; Evolution of
C++, by Bjarne Stroustrup<sup><span style='color:red'>Comment</span></sup></span></p>

<h3><span style='color:windowtext'>Bruce’s books</span><span style='color:windowtext'>
</span></h3>

<p class=MsoNormal><span style='color:windowtext'>Not all of these are
currently available.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Computer Interfacing with
Pascal &amp; C (Self-published via the Eisys imprint; only available via the
Web site)<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Using C++<sup><span
style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>C++ Inside &amp; Out<sup><span
style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Thinking in C++, 1<sup>st</sup>
edition<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Black Belt C++, the Master’s
Collection (edited by Bruce Eckel) (out of print).<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Thinking in Java, 2<sup>nd</sup>
edition<sup><span style='color:red'>Comment</span></sup></span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>Depth &amp; dark
corners</span></h2>

<p class=MsoNormal><span style='color:windowtext'>Books that go more deeply
into topics of the language, and help you avoid the typical pitfalls inherent
in developing C++ programs.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Effective C++ and More
Effective C++, by Scott Meyers.<sup><span style='color:red'>Comment</span></sup></span></p>

<p class=MsoNormal><span style='color:windowtext'>Ruminations on C++ by Koenig
&amp; Moo.<sup><span style='color:red'>Comment</span></sup></span></p>

<h2 style='margin-left:0in'><span style='color:windowtext'>The STL</span></h2>

<h2 style='margin-left:0in'><span style='color:windowtext'>Design Patterns</span></h2>

<p class=MsoNormal><sup><span style='color:windowtext'><span style='color:red'>Comment</span></span></sup></p>

</div>

<span style='color:windowtext'><br clear=all style='page-break-before:right'>
</span>

<div class=Section20>

<p class=MsoNormal><sup><span style='color:windowtext'><span style='color:red'>Comment</span></span></sup></p>

<h1 style='margin-left:-81.35pt'><span style='color:windowtext'>B: Etc</span></h1>

<p class=Intro><span style='color:windowtext'>This appendix contains files that
are required to build the files in Volume 2.</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
:require.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Test for error conditions in programs</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//
Local &quot;using namespace std&quot; for old compilers</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
REQUIRE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
REQUIRE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdio&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdlib&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;fstream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void require(bool requirement, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* msg = &quot;Requirement failed&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(!requirement) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    </span><span
lang=SV style='color:windowtext'>fputs(msg, stderr);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>   
fputs(&quot;\n&quot;, stderr);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>   
</span><span style='color:windowtext'>exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void requireArgs(int argc, int args, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* msg = &quot;Must use %d arguments&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   if
(argc != args + 1) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
fprintf(stderr, msg, args);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
fputs(&quot;\n&quot;, stderr);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void requireMinArgs(int argc, int minArgs,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* msg = </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
&quot;Must use at least %d arguments&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
if(argc &lt; minArgs + 1) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    </span><span
lang=SV style='color:windowtext'>fprintf(stderr, msg, minArgs);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>   
fputs(&quot;\n&quot;, stderr);</span></p>

<p class=CodeChar style='margin-left:0in'><span lang=SV style='color:windowtext'>   
</span><span style='color:windowtext'>exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void assure(std::ifstream&amp; in, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* filename = &quot;&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
if(!in) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
fprintf(stderr,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&quot;Could not open file %s\n&quot;, filename);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void assure(std::ofstream&amp; in, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* filename = &quot;&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
if(!in) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
fprintf(stderr,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&quot;Could not open file %s\n&quot;, filename);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// Do
we need this???</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>inline
void assure(std::fstream&amp; in, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const char* filename = &quot;&quot;) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
using namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
if(!in) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
fprintf(stderr,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
&quot;Could not open file %s\n&quot;, filename);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
exit(EXIT_FAILURE);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>#endif
// REQUIRE_H ///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C0B:Dummy.cpp</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// To
give the makefile at least one target </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>// for
this directory</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>int
main() {} ///:~</span></p>

</div>

<p class=MsoNormal><sup><span style='color:windowtext'><span style='color:red'>Comment</span></span></sup></p>

<p class=MsoNormal><span style='color:windowtext'>The <b>Date</b> class files:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C02:Date.h</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#ifndef
DATE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#define
DATE_H</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;string&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;stdexcept&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iosfwd&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>class
Date {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>public:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  // A
class for date calculations</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
struct Duration {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
int years, months, days;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
Duration(int y, int m, int d)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    :
years(y), months(m) ,days(d) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  };</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
An exception class</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
struct DateError : public std::logic_error {</span></p>

<p class=CodeChar style='margin-left:0in;text-indent:24.0pt'><span
style='color:windowtext'>DateError(const std::string&amp; msg = &quot;&quot;)</span></p>

<p class=CodeChar style='margin-left:0in;text-indent:24.0pt'><span
style='color:windowtext'>  : std::logic_error(msg) {}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  };</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Date();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Date(int, int, int) throw(DateError);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
Date(const std::string&amp;) throw(DateError);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getYear() const;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getMonth() const;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
getDay() const;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
std::string toString() const;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend Duration duration(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator&lt;(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator&lt;=(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator&gt;(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator&gt;=(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator==(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend bool operator!=(const Date&amp;, const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;,</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>                                 
const Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>                                 
Date&amp;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>private:</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
year, month, day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
compare(const Date&amp;) const;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
static int daysInPrevMonth(int year, int mon);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#endif
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C02:Date.cpp {O}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&quot;Date.h&quot;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iostream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;sstream&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cstdlib&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;string&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;algorithm&gt; // for swap()</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;ctime&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;cassert&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>#include
&lt;iomanip&gt;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>using
namespace std;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>namespace
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
const int daysInMonth[][13] = {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
{0,31,28,31,30,31,30,31,31,30,31,30,31},</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
{0,31,29,31,30,31,30,31,31,30,31,30,31}};</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
inline bool isleap(int y) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return y%4 == 0 &amp;&amp; y%100 != 0 || y%400 == 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Date::Date()
{</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
Get current date</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
time_t tval = time(0);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
struct tm *now = localtime(&amp;tval);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  year
= now-&gt;tm_year + 1900;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
month = now-&gt;tm_mon + 1;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  day
= now-&gt;tm_mday;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Date::Date(int
yr,int mon,int dy) throw(Date::DateError) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(!(1 &lt;= mon &amp;&amp; mon &lt;= 12))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
throw DateError(&quot;Bad month in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(!(1 &lt;= dy &amp;&amp; dy &lt;= daysInMonth[isleap(year)][mon]))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
throw DateError(&quot;Bad day in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  year
= yr;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
month = mon;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  day
= dy;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Date::Date(const
std::string&amp; s) throw(Date::DateError) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
Assume YYYYMMDD format</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(!(s.size() == 8))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
throw DateError(&quot;Bad string in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
for(int n = 8; --n &gt;= 0;)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    if
(!isdigit(s[n]))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
throw DateError(&quot;Bad string in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
string buf = s.substr(0, 4);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  year
= atoi(buf.c_str());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  buf
= s.substr(4, 2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
month = atoi(buf.c_str());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  buf
= s.substr(6, 2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  day
= atoi(buf.c_str());</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(!(1 &lt;= month &amp;&amp; month &lt;= 12))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
throw DateError(&quot;Bad month in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'><span
style='color:windowtext'>if (!(1 &lt;= day &amp;&amp; day &lt;=  </span></p>

<p class=CodeChar style='margin-left:0in;text-indent:12.0pt'><span
style='color:windowtext'>  daysInMonth[isleap(year)][month]))</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
throw DateError(&quot;Bad day in Date ctor&quot;);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
Date::getYear() const { return year; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
Date::getMonth() const { return month; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
Date::getDay() const { return day; }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>string
Date::toString() const {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
ostringstream os;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
os.fill('0');</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  os
&lt;&lt; setw(4) &lt;&lt; year</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
&lt;&lt; setw(2) &lt;&lt; month</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
&lt;&lt; setw(2) &lt;&lt; day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return os.str();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int Date::compare(const
Date&amp; d2) const {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
result = year - d2.year;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(result == 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
result = month - d2.month;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    if
(result == 0)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
result = day - d2.day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return result;   </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>int
Date::daysInPrevMonth(int year, int month) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(month == 1) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
--year;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
month = 12;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  else</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
--month;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return daysInMonth[isleap(year)][month];</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator&lt;(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return d1.compare(d2) &lt; 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator&lt;=(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return d1 &lt; d2 || d1 == d2;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator&gt;(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return !(d1 &lt; d2) &amp;&amp; !(d1 == d2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator&gt;=(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return !(d1 &lt; d2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator==(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return d1.compare(d2) == 0;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>bool
operator!=(const Date&amp; d1, const Date&amp; d2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return !(d1 == d2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>Date::Duration
</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>duration(const
Date&amp; date1, const Date&amp; date2) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
y1 = date1.year;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
y2 = date2.year;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
m1 = date1.month;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
m2 = date2.month;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
d1 = date1.day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
d2 = date2.day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
Compute the compare</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
order = date1.compare(date2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(order == 0)</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
return Date::Duration(0,0,0);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  else
if (order &gt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Make date1 precede date2 locally</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
using std::swap;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
swap(y1, y2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
swap(m1, m2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
swap(d1, d2);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
years = y2 - y1;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
months = m2 - m1;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
days = d2 - d1;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
assert(years &gt; 0 ||</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
years == 0 &amp;&amp; months &gt; 0 ||</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
years == 0 &amp;&amp; months == 0 &amp;&amp; days &gt; 0);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
Do the obvious corrections (must adjust days</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
before months!) - This is a loop in case the</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  //
previous month is February, and days &lt; -28.</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
lastMonth = m2;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  int
lastYear = y2;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
while (days &lt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Borrow from month</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
assert(months &gt; 0);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
days += Date::daysInPrevMonth(</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>     
lastYear, lastMonth--);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
--months;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(months &lt; 0) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    //
Borrow from year</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
assert(years &gt; 0);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
months += 12;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
--years;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  }</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return Date::Duration(years, months, days);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>ostream&amp;
operator&lt;&lt;(ostream&amp; os, const Date&amp; d) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  char
fillc = os.fill('0');</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  os
&lt;&lt; setw(2) &lt;&lt; d.getMonth() &lt;&lt; ‘-‘</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
&lt;&lt; setw(2) &lt;&lt; d.getDay() &lt;&lt; ‘-‘</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    
&lt;&lt; setw(4) &lt;&lt; setfill(fillc) &lt;&lt; d.getYear();</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return os;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>&nbsp;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>istream&amp;
operator&gt;&gt;(istream&amp; is, Date&amp; d) {</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  is
&gt;&gt; d.month;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  char
dash;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  is
&gt;&gt; dash;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(dash != '-') </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>    is.setstate(ios::failbit);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  is
&gt;&gt; d.day;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  is
&gt;&gt; dash;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  if
(dash != '-') </span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>   
is.setstate(ios::failbit);</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>  is
&gt;&gt; d.year;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'> 
return is;</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>}
///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>The file test.txt used in
Chapter 6:</span></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>//:
C06:Test.txt</span></p>

<p class=CodeChar style='margin-left:0in'><span style='color:windowtext'>f a f
d A  G f d F a A F h f A d f f a a</span></p>

<p class=CodeInlineCharChar style='margin-left:0in'><span style='color:windowtext'>///:~</span></p>

</div>

<p class=CodeInlineTrailerCharChar><span style='color:windowtext'>&nbsp;</span></p>

<p class=MsoNormal><span style='color:windowtext'>&nbsp;</span></p>

</div>

<span style='color:windowtext'><br clear=all style='page-break-before:always'>
</span>

<div class=Section21>

<h1 style='margin-left:0in'><img width=734 height=118
src="TicV2_files/image018.gif" align=left hspace=12 alt="Text Box: 	&#13;&#10;"><span
style='color:windowtext'>Index</span></h1>

</div>

<span style='font-size:9.0pt;color:windowtext'><br clear=all style='page-break-before:
auto'>
</span>

<div class=Section22>

<p class=MsoNormal></p>

</div>

<span style='color:windowtext'><br clear=all style='page-break-before:auto'>
</span>

<div class=Section23>

<p class=MsoIndex1><span style='color:windowtext'>abort(&nbsp;)</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C library function,
44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>abstraction</span></p>

<p class=MsoIndex2><span style='color:windowtext'>in program design, 644</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ANSI/ISO C++ committee, 24</span></p>

<p class=MsoIndex1><span style='color:windowtext'>applicator, 232</span></p>

<p class=MsoIndex1><span style='color:windowtext'>applying a function to a
container, 291</span></p>

<p class=MsoIndex1><span style='color:windowtext'>arguments</span></p>

<p class=MsoIndex2><span style='color:windowtext'>variable argument list, 184</span></p>

<p class=MsoIndex1><span style='color:windowtext'>atof(&nbsp;), 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>atoi(&nbsp;), 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>automatic type conversion</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and exception handling, 40</span></p>

<p class=MsoIndex1><span style='color:windowtext'>awk, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>bad_cast</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>bad_typeid</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>before(&nbsp;)</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run-time type identification,
587</span></p>

<p class=MsoIndex1><span style='color:windowtext'>behavioral design patterns,
652</span></p>

<p class=MsoIndex1><span style='color:windowtext'>blocking</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and threads, 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>book errors, reporting, 25</span></p>

<p class=MsoIndex1><span style='color:windowtext'>bubble sort, 305</span></p>

<p class=MsoIndex1><span style='color:windowtext'>buffering, iostream, 203</span></p>

<p class=MsoIndex1><span style='color:windowtext'>bytes, reading raw, 194</span></p>

<p class=MsoIndex1><span style='color:windowtext'>C</span></p>

<p class=MsoIndex2><span style='color:windowtext'>basic data types, 184</span></p>

<p class=MsoIndex2><span style='color:windowtext'>error handling in C, 32</span></p>

<p class=MsoIndex2><span style='color:windowtext'>rand(&nbsp;), Standard
library, 249</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C, 24</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C library function
abort(&nbsp;), 44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>C++</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ANSI/ISO C++ committee, 24</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++, 24</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard string class, 185</span></p>

<p class=MsoIndex1><span style='color:windowtext'>cast</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run-time type identification,
casting to intermediate levels, 588</span></p>

<p class=MsoIndex1><span style='color:windowtext'>catch, 37</span></p>

<p class=MsoIndex2><span style='color:windowtext'>catching any exception, 42</span></p>

<p class=MsoIndex1><span style='color:windowtext'>chaining, in iostreams, 188</span></p>

<p class=MsoIndex1><span style='color:windowtext'>change</span></p>

<p class=MsoIndex2><span style='color:windowtext'>vector of change, 644</span></p>

<p class=MsoIndex1><span style='color:windowtext'>character</span></p>

<p class=MsoIndex2><span style='color:windowtext'>transforming strings to typed
values, 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>class</span></p>

<p class=MsoIndex2><span style='color:windowtext'>class hierarchies and
exception handling, 41</span></p>

<p class=MsoIndex2><span style='color:windowtext'>maintaining library source,
237</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ string, 185</span></p>

<p class=MsoIndex2><span style='color:windowtext'>wrapping, 179</span></p>

<p class=MsoIndex1><span style='color:windowtext'>cleaning up the stack during
exception handling, 46</span></p>

<p class=MsoIndex1><span style='color:windowtext'>command line</span></p>

<p class=MsoIndex2><span style='color:windowtext'>interface, 191</span></p>

<p class=MsoIndex1><span style='color:windowtext'>committee, ANSI/ISO C++, 24</span></p>

<p class=MsoIndex1><span style='color:windowtext'>compile time</span></p>

<p class=MsoIndex2><span style='color:windowtext'>error checking, 184</span></p>

<p class=MsoIndex1><span style='color:windowtext'>compiler error tests, 242</span></p>

<p class=MsoIndex1><span style='color:windowtext'>composition</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and design patterns, 645</span></p>

<p class=MsoIndex1><span style='color:windowtext'>console I/O, 192</span></p>

<p class=MsoIndex1><span style='color:windowtext'>constructor</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and exception handling, 46,
48, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>default constructor, 676</span></p>

<p class=MsoIndex2><span style='color:windowtext'>default constructor
synthesized by the compiler, 646</span></p>

<p class=MsoIndex2><span style='color:windowtext'>failing, 79</span></p>

<p class=MsoIndex2><span style='color:windowtext'>order of constructor and
destructor calls, 590</span></p>

<p class=MsoIndex2><span style='color:windowtext'>private constructor, 646</span></p>

<p class=MsoIndex2><span style='color:windowtext'>simulating virtual
constructors, 672</span></p>

<p class=MsoIndex2><span style='color:windowtext'>virtual functions inside
constructors, 672</span></p>

<p class=MsoIndex1><span style='color:windowtext'>controlling</span></p>

<p class=MsoIndex2><span style='color:windowtext'>template instantiation, 328</span></p>

<p class=MsoIndex1><span style='color:windowtext'>conversion</span></p>

<p class=MsoIndex2><span style='color:windowtext'>automatic type conversions
and exception handling, 40</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Coplien, James, 673</span></p>

<p class=MsoIndex1><span style='color:windowtext'>creating</span></p>

<p class=MsoIndex2><span style='color:windowtext'>manipulators, 232</span></p>

<p class=MsoIndex1><span style='color:windowtext'>creational design patterns,
652</span></p>

<p class=MsoIndex1><span style='color:windowtext'>critical section, and
synchronized block, 742</span></p>

<p class=MsoIndex1><span style='color:windowtext'>data</span></p>

<p class=MsoIndex2><span style='color:windowtext'>C data types, 184</span></p>

<p class=MsoIndex1><span style='color:windowtext'>datalogger, 244</span></p>

<p class=MsoIndex1><span style='color:windowtext'>dead, Thread, 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>deadlock</span></p>

<p class=MsoIndex2><span style='color:windowtext'>conditions, 766</span></p>

<p class=MsoIndex2><span style='color:windowtext'>multithreading, 761</span></p>

<p class=MsoIndex1><span style='color:windowtext'>decimal</span></p>

<p class=MsoIndex2><span style='color:windowtext'>dec in iostreams, 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>dec manipulator in iostreams,
227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>formatting, 220</span></p>

<p class=MsoIndex1><span style='color:windowtext'>default</span></p>

<p class=MsoIndex2><span style='color:windowtext'>constructor, 676</span></p>

<p class=MsoIndex1><span style='color:windowtext'>default constructor</span></p>

<p class=MsoIndex2><span style='color:windowtext'>synthesized by the compiler,
646</span></p>

<p class=MsoIndex1><span style='color:windowtext'>design</span></p>

<p class=MsoIndex2><span style='color:windowtext'>abstraction in program
design, 644</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and efficiency, 305</span></p>

<p class=MsoIndex1><span style='color:windowtext'>design patterns, 643</span></p>

<p class=MsoIndex2><span style='color:windowtext'>behavioral, 652</span></p>

<p class=MsoIndex2><span style='color:windowtext'>creational, 652</span></p>

<p class=MsoIndex2><span style='color:windowtext'>observer, 680</span></p>

<p class=MsoIndex2><span style='color:windowtext'>structural, 652</span></p>

<p class=MsoIndex2><span style='color:windowtext'>vector of change, 644</span></p>

<p class=MsoIndex2><span style='color:windowtext'>visitor, 696</span></p>

<p class=MsoIndex1><span style='color:windowtext'>destructor</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and exception handling, 46,
79</span></p>

<p class=MsoIndex2><span style='color:windowtext'>order of constructor and
destructor calls, 590</span></p>

<p class=MsoIndex1><span style='color:windowtext'>dining philosophers,
threading, 761</span></p>

<p class=MsoIndex1><span style='color:windowtext'>dispatching</span></p>

<p class=MsoIndex2><span style='color:windowtext'>double dispatching, 692</span></p>

<p class=MsoIndex2><span style='color:windowtext'>multiple dispatching, 692</span></p>

<p class=MsoIndex1><span style='color:windowtext'>domain_error</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>double dispatching, 692</span></p>

<p class=MsoIndex1><span style='color:windowtext'>dynamic_cast</span></p>

<p class=MsoIndex2><span style='color:windowtext'>difference between
dynamic_cast and typeid(&nbsp;), run-time type identification, 589</span></p>

<p class=MsoIndex1><span style='color:windowtext'>efficiency</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and threads, 703</span></p>

<p class=MsoIndex2><span style='color:windowtext'>design, 305</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run-time type identification,
593</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ellipses, with exception
handling, 42</span></p>

<p class=MsoIndex1><span style='color:windowtext'>endl, iostreams, 228</span></p>

<p class=MsoIndex1><span style='color:windowtext'>errno, 32</span></p>

<p class=MsoIndex1><span style='color:windowtext'>error</span></p>

<p class=MsoIndex2><span style='color:windowtext'>compile-time checking, 184</span></p>

<p class=MsoIndex2><span style='color:windowtext'>error handling in C, 32</span></p>

<p class=MsoIndex2><span style='color:windowtext'>recovery, 31</span></p>

<p class=MsoIndex2><span style='color:windowtext'>reporting errors in book, 25</span></p>

<p class=MsoIndex1><span style='color:windowtext'>exception handling, 31</span></p>

<p class=MsoIndex2><span style='color:windowtext'>asynchronous events, 74</span></p>

<p class=MsoIndex2><span style='color:windowtext'>atomic allocations for
safety, 50</span></p>

<p class=MsoIndex2><span style='color:windowtext'>automatic type conversions,
40</span></p>

<p class=MsoIndex2><span style='color:windowtext'>bad_cast Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>bad_typeid Standard C++
library exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>catching any exception, 42</span></p>

<p class=MsoIndex2><span style='color:windowtext'>class hierarchies, 41</span></p>

<p class=MsoIndex2><span style='color:windowtext'>cleaning up the stack during
a throw, 46</span></p>

<p class=MsoIndex2><span style='color:windowtext'>constructors, 46, 48</span></p>

<p class=MsoIndex2><span style='color:windowtext'>constructors, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>destructors, 46, 79</span></p>

<p class=MsoIndex2><span style='color:windowtext'>domain_error Standard C++
library exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ellipses, 42</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception handler, 37</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception hierarchies, 77</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception matching, 40</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception Standard C++
library exception type, 58</span></p>

<p class=MsoIndex2><span style='color:windowtext'>invalid_argument Standard C++
library exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>length_error Standard C++
library exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>logic_error Standard C++
library exception type, 58</span></p>

<p class=MsoIndex2><span style='color:windowtext'>multiple inheritance, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>naked pointers, 48</span></p>

<p class=MsoIndex2><span style='color:windowtext'>object slicing and exception
handling, 40</span></p>

<p class=MsoIndex2><span style='color:windowtext'>out_of_range Standard C++
library exception type, 59</span></p>

<p class=MsoIndex2><span style='color:windowtext'>overhead, 79</span></p>

<p class=MsoIndex2><span style='color:windowtext'>programming guidelines, 73</span></p>

<p class=MsoIndex2><span style='color:windowtext'>references, 52, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>re-throwing an exception, 43</span></p>

<p class=MsoIndex2><span style='color:windowtext'>runtime_error Standard C++
library exception type, 58</span></p>

<p class=MsoIndex2><span style='color:windowtext'>set_terminate(&nbsp;), 44</span></p>

<p class=MsoIndex2><span style='color:windowtext'>set_unexpected( ), 61</span></p>

<p class=MsoIndex2><span style='color:windowtext'>specification, 60</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 58</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exceptions, 56</span></p>

<p class=MsoIndex2><span style='color:windowtext'>termination vs. resumption,
39</span></p>

<p class=MsoIndex2><span style='color:windowtext'>throwing &amp; catching
pointers, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>throwing an exception, 35</span></p>

<p class=MsoIndex2><span style='color:windowtext'>typical uses of exceptions,
76</span></p>

<p class=MsoIndex2><span style='color:windowtext'>uncaught exceptions, 44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>extensible program, 184</span></p>

<p class=MsoIndex1><span style='color:windowtext'>extractor, 187</span></p>

<p class=MsoIndex1><span style='color:windowtext'>file</span></p>

<p class=MsoIndex2><span style='color:windowtext'>iostreams, 185, 192</span></p>

<p class=MsoIndex1><span style='color:windowtext'>FILE, stdio, 180</span></p>

<p class=MsoIndex1><span style='color:windowtext'>fill</span></p>

<p class=MsoIndex2><span style='color:windowtext'>width, precision, iostream,
222</span></p>

<p class=MsoIndex1><span style='color:windowtext'>flags, iostreams format, 218</span></p>

<p class=MsoIndex1><span style='color:windowtext'>flush, iostreams, 227, 228</span></p>

<p class=MsoIndex1><span style='color:windowtext'>format flags, iostreams, 218</span></p>

<p class=MsoIndex1><span style='color:windowtext'>formatting</span></p>

<p class=MsoIndex2><span style='color:windowtext'>formatting manipulators,
iostreams, 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>in-core, 210</span></p>

<p class=MsoIndex2><span style='color:windowtext'>iostream internal data, 218</span></p>

<p class=MsoIndex2><span style='color:windowtext'>output stream, 217</span></p>

<p class=MsoIndex1><span style='color:windowtext'>fseek(&nbsp;), 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>FSTREAM.H, 200</span></p>

<p class=MsoIndex1><span style='color:windowtext'>function</span></p>

<p class=MsoIndex2><span style='color:windowtext'>applying a function to a
container, 291</span></p>

<p class=MsoIndex2><span style='color:windowtext'>function templates, 280</span></p>

<p class=MsoIndex2><span style='color:windowtext'>pointer to a function, 45</span></p>

<p class=MsoIndex1><span style='color:windowtext'>get pointer, 209</span></p>

<p class=MsoIndex1><span style='color:windowtext'>get(&nbsp;), 193, 201</span></p>

<p class=MsoIndex2><span style='color:windowtext'>overloaded versions, 194</span></p>

<p class=MsoIndex2><span style='color:windowtext'>with streambuf, 205</span></p>

<p class=MsoIndex1><span style='color:windowtext'>getline(&nbsp;), 193, 201</span></p>

<p class=MsoIndex1><span style='color:windowtext'>getPriority(&nbsp;), 721</span></p>

<p class=MsoIndex1><span style='color:windowtext'>goto</span></p>

<p class=MsoIndex2><span style='color:windowtext'>non-local goto,
setjmp(&nbsp;) and longjmp(&nbsp;), 33</span></p>

<p class=MsoIndex1><span style='color:windowtext'>graphical user interface
(GUI), 192</span></p>

<p class=MsoIndex1><span style='color:windowtext'>GUI</span></p>

<p class=MsoIndex2><span style='color:windowtext'>graphical user interface, 192</span></p>

<p class=MsoIndex1><span style='color:windowtext'>handler, exception, 37</span></p>

<p class=MsoIndex1><span style='color:windowtext'>hex, 227</span></p>

<p class=MsoIndex1><span style='color:windowtext'>hex (hexadecimal) in
iostreams, 227</span></p>

<p class=MsoIndex1><span style='color:windowtext'>hex(&nbsp;), 221</span></p>

<p class=MsoIndex1><span style='color:windowtext'>hexadecimal, 220</span></p>

<p class=MsoIndex1><span style='color:windowtext'>hierarchy</span></p>

<p class=MsoIndex2><span style='color:windowtext'>object-based hierarchy, 602</span></p>

<p class=MsoIndex1><span style='color:windowtext'>I/O</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and threads, blocking, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>console, 192</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ifstream, 185, 198, 205</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ignore(&nbsp;), 201</span></p>

<p class=MsoIndex1><span style='color:windowtext'>IllegalMonitorStateException,
755</span></p>

<p class=MsoIndex1><span style='color:windowtext'>in-core formatting, 210</span></p>

<p class=MsoIndex1><span style='color:windowtext'>inheritance</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and design patterns, 644</span></p>

<p class=MsoIndex2><span style='color:windowtext'>multiple inheritance and
run-time type identification, 589, 591, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>templates, 302</span></p>

<p class=MsoIndex1><span style='color:windowtext'>input</span></p>

<p class=MsoIndex2><span style='color:windowtext'>line at a time, 191</span></p>

<p class=MsoIndex1><span style='color:windowtext'>inserter, 187</span></p>

<p class=MsoIndex1><span style='color:windowtext'>interface</span></p>

<p class=MsoIndex2><span style='color:windowtext'>command-line, 191</span></p>

<p class=MsoIndex2><span style='color:windowtext'>graphical user (GUI), 192</span></p>

<p class=MsoIndex2><span style='color:windowtext'>repairing an interface with
multiple inheritance, 636</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Runnable, 708</span></p>

<p class=MsoIndex1><span style='color:windowtext'>interfaces</span></p>

<p class=MsoIndex2><span style='color:windowtext'>responsive user, 721</span></p>

<p class=MsoIndex1><span style='color:windowtext'>interpreter, printf(&nbsp;)
run-time, 183</span></p>

<p class=MsoIndex1><span style='color:windowtext'>interrupt(&nbsp;), 748</span></p>

<p class=MsoIndex2><span style='color:windowtext'>threading, 718</span></p>

<p class=MsoIndex1><span style='color:windowtext'>invalid_argument</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>IOSTREAM.H, 200</span></p>

<p class=MsoIndex1><span style='color:windowtext'>iostreams</span></p>

<p class=MsoIndex2><span style='color:windowtext'>applicator, 232</span></p>

<p class=MsoIndex2><span style='color:windowtext'>automatic, 221</span></p>

<p class=MsoIndex2><span style='color:windowtext'>buffering, 203</span></p>

<p class=MsoIndex2><span style='color:windowtext'>dec, 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>dec (decimal), 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>endl, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>files, 192</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>fixed</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>flush, 227, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>format flags, 218</span></p>

<p class=MsoIndex2><span style='color:windowtext'>formatting manipulators, 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>fseek(&nbsp;), 207</span></p>

<p class=MsoIndex2><span style='color:windowtext'>get(&nbsp;), 201</span></p>

<p class=MsoIndex2><span style='color:windowtext'>getline(&nbsp;), 201</span></p>

<p class=MsoIndex2><span style='color:windowtext'>hex, 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>hex (hexadecimal), 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ignore(&nbsp;), 201</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>internal</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>internal formatting data, 218</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ios::basefield, 220</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ios::beg, 207</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ios::cur, 207</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::dec</span></b><span
style='color:windowtext'>, 221</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ios::end, 207</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::fill(&nbsp;)</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::fixed</span></b><span
style='color:windowtext'>, 221</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ios::flags(&nbsp;), 218</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::hex</span></b><span
style='color:windowtext'>, 221</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::internal</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::left</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::oct</span></b><span
style='color:windowtext'>, 221</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::precision(&nbsp;)</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::right</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::scientific</span></b><span
style='color:windowtext'>, 221</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::showbase</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::showpoint</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::showpos</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::skipws</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::unitbuf</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::uppercase</span></b><span
style='color:windowtext'>, 219</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>ios::width(&nbsp;)</span></b><span
style='color:windowtext'>, 222</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>left</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>manipulators, creating, 232</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>noshowbase</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>noshowpoint</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>noshowpos</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>noskipws</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>nouppercase</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>oct (octal), 227</span></p>

<p class=MsoIndex2><span style='color:windowtext'>open modes, 202</span></p>

<p class=MsoIndex2><span style='color:windowtext'>precision(&nbsp;), 247</span></p>

<p class=MsoIndex2><span style='color:windowtext'>rdbuf(&nbsp;), 204</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>resetiosflags</span></b><span
style='color:windowtext'>, 229</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>right</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>scientific</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>seekg(&nbsp;), 207</span></p>

<p class=MsoIndex2><span style='color:windowtext'>seeking in, 207</span></p>

<p class=MsoIndex2><span style='color:windowtext'>seekp(&nbsp;), 207</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>setbase</span></b><span
style='color:windowtext'>, 229</span></p>

<p class=MsoIndex2><span style='color:windowtext'>setf(&nbsp;), 219, 246</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>setfill</span></b><span
style='color:windowtext'>, 229</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>setiosflags</span></b><span
style='color:windowtext'>, 229</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>setprecision</span></b><span
style='color:windowtext'>, 229</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>showbase</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>showpoint</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>showpos</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>skipws</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>tellg(&nbsp;), 207</span></p>

<p class=MsoIndex2><span style='color:windowtext'>tellp(&nbsp;), 207</span></p>

<p class=MsoIndex2><b><span style='color:windowtext'>uppercase</span></b><span
style='color:windowtext'>, 228</span></p>

<p class=MsoIndex2><span style='color:windowtext'>width, fill and precision,
222</span></p>

<p class=MsoIndex2><span style='color:windowtext'>ws, 228</span></p>

<p class=MsoIndex1><span style='color:windowtext'>istream, 185</span></p>

<p class=MsoIndex1><b><span style='color:windowtext'>istringstreams</span></b><span
style='color:windowtext'>, 185</span></p>

<p class=MsoIndex1><span style='color:windowtext'>istrstream, 210</span></p>

<p class=MsoIndex1><span style='color:windowtext'>iterator, 645</span></p>

<p class=MsoIndex1><span style='color:windowtext'>join(&nbsp;), threading, 710</span></p>

<p class=MsoIndex1><span style='color:windowtext'>keyword</span></p>

<p class=MsoIndex2><span style='color:windowtext'>catch, 37</span></p>

<p class=MsoIndex1><span style='color:windowtext'>length_error</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>library</span></p>

<p class=MsoIndex2><span style='color:windowtext'>maintaining class source, 237</span></p>

<p class=MsoIndex1><span style='color:windowtext'>LIMITS.H, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>line input, 191</span></p>

<p class=MsoIndex1><span style='color:windowtext'>logic_error</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 58</span></p>

<p class=MsoIndex1><span style='color:windowtext'>longjmp(&nbsp;), 33</span></p>

<p class=MsoIndex1><span style='color:windowtext'>maintaining class library
source, 237</span></p>

<p class=MsoIndex1><span style='color:windowtext'>manipulator</span></p>

<p class=MsoIndex2><span style='color:windowtext'>creating, 232</span></p>

<p class=MsoIndex2><span style='color:windowtext'>iostreams formatting, 227</span></p>

<p class=MsoIndex1><span style='color:windowtext'>method</span></p>

<p class=MsoIndex2><span style='color:windowtext'>synchronized method and
blocking, 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>modes, iostream open, 202</span></p>

<p class=MsoIndex1><span style='color:windowtext'>modulus operator, 249</span></p>

<p class=MsoIndex1><span style='color:windowtext'>monolithic, 602</span></p>

<p class=MsoIndex1><span style='color:windowtext'>multiple dispatching, 692</span></p>

<p class=MsoIndex1><span style='color:windowtext'>multiple inheritance</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and exception handling, 78</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and run-time type
identification, 589, 591, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>duplicate subobjects, 616</span></p>

<p class=MsoIndex2><span style='color:windowtext'>repairing an interface, 636</span></p>

<p class=MsoIndex1><span style='color:windowtext'>multitasking, 701</span></p>

<p class=MsoIndex1><span style='color:windowtext'>multithreading, 701</span></p>

<p class=MsoIndex2><span style='color:windowtext'>blocking, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>drawbacks, 769</span></p>

<p class=MsoIndex2><span style='color:windowtext'>when to use it, 769</span></p>

<p class=MsoIndex1><span style='color:windowtext'>naked pointers, and exception
handling, 48</span></p>

<p class=MsoIndex1><span style='color:windowtext'>non-local goto</span></p>

<p class=MsoIndex2><span style='color:windowtext'>setjmp(&nbsp;) and
longjmp(&nbsp;), 33</span></p>

<p class=MsoIndex1><span style='color:windowtext'>notify(&nbsp;), 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>notifyAll(&nbsp;), 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>notifyObservers(&nbsp;), 680,
683</span></p>

<p class=MsoIndex1><span style='color:windowtext'>object</span></p>

<p class=MsoIndex2><span style='color:windowtext'>object-based hierarchy, 602</span></p>

<p class=MsoIndex2><span style='color:windowtext'>slicing, and exception
handling, 40</span></p>

<p class=MsoIndex2><span style='color:windowtext'>temporary, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Object</span></p>

<p class=MsoIndex2><span style='color:windowtext'>wait( ) and notify( ), 755</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Observable, 680</span></p>

<p class=MsoIndex1><span style='color:windowtext'>observer design pattern, 680</span></p>

<p class=MsoIndex1><span style='color:windowtext'>oct, 227</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ofstream, 185, 199</span></p>

<p class=MsoIndex1><span style='color:windowtext'>open modes, iostreams, 202</span></p>

<p class=MsoIndex1><span style='color:windowtext'>operator</span></p>

<p class=MsoIndex2><span style='color:windowtext'>[], 52</span></p>

<p class=MsoIndex2><span style='color:windowtext'>&lt;&lt;, 187</span></p>

<p class=MsoIndex2><span style='color:windowtext'>&gt;&gt;, 187</span></p>

<p class=MsoIndex2><span style='color:windowtext'>modulus, 249</span></p>

<p class=MsoIndex1><span style='color:windowtext'>order</span></p>

<p class=MsoIndex2><span style='color:windowtext'>of constructor and destructor
calls, 590</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ostream, 185, 201</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ostringstreams, 185</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ostrstream, 210</span></p>

<p class=MsoIndex1><span style='color:windowtext'>out_of_range</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 59</span></p>

<p class=MsoIndex1><span style='color:windowtext'>output</span></p>

<p class=MsoIndex2><span style='color:windowtext'>stream formatting, 217</span></p>

<p class=MsoIndex1><span style='color:windowtext'>overhead</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception handling, 79</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Park, Nick, 293</span></p>

<p class=MsoIndex1><span style='color:windowtext'>patterns, design patterns,
643</span></p>

<p class=MsoIndex1><span style='color:windowtext'>perror(&nbsp;), 32</span></p>

<p class=MsoIndex1><span style='color:windowtext'>philosophers, dining and
threading, 761</span></p>

<p class=MsoIndex1><span style='color:windowtext'>pointer</span></p>

<p class=MsoIndex2><span style='color:windowtext'>pointer to a function, 45</span></p>

<p class=MsoIndex1><span style='color:windowtext'>polymorphism, 592</span></p>

<p class=MsoIndex1><span style='color:windowtext'>precision</span></p>

<p class=MsoIndex2><span style='color:windowtext'>width, fill, iostream, 222</span></p>

<p class=MsoIndex1><span style='color:windowtext'>precision(&nbsp;), 247</span></p>

<p class=MsoIndex1><span style='color:windowtext'>preprocessor</span></p>

<p class=MsoIndex2><span style='color:windowtext'>stringizing, 225</span></p>

<p class=MsoIndex1><span style='color:windowtext'>printf(&nbsp;), 183, 217</span></p>

<p class=MsoIndex2><span style='color:windowtext'>error code, 31</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run-time interpreter, 183</span></p>

<p class=MsoIndex1><span style='color:windowtext'>priority, thread, 719</span></p>

<p class=MsoIndex1><span style='color:windowtext'>private</span></p>

<p class=MsoIndex2><span style='color:windowtext'>constructor, 646</span></p>

<p class=MsoIndex1><span style='color:windowtext'>process, and threading, 701</span></p>

<p class=MsoIndex1><span style='color:windowtext'>producer-consumer, threading,
756</span></p>

<p class=MsoIndex1><span style='color:windowtext'>put pointer, 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>raise(&nbsp;), 33</span></p>

<p class=MsoIndex1><span style='color:windowtext'>rand(&nbsp;), 249</span></p>

<p class=MsoIndex1><span style='color:windowtext'>RAND_MAX, 249</span></p>

<p class=MsoIndex1><span style='color:windowtext'>rapid development, 305</span></p>

<p class=MsoIndex1><span style='color:windowtext'>raw, reading bytes, 194</span></p>

<p class=MsoIndex1><span style='color:windowtext'>rdbuf(&nbsp;), 204</span></p>

<p class=MsoIndex1><span style='color:windowtext'>read(&nbsp;), 195</span></p>

<p class=MsoIndex1><span style='color:windowtext'>reading raw bytes, 194</span></p>

<p class=MsoIndex1><span style='color:windowtext'>reference</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and exception handling, 52,
78</span></p>

<p class=MsoIndex1><span style='color:windowtext'>reporting errors in book, 25</span></p>

<p class=MsoIndex1><span style='color:windowtext'>responsive user interfaces,
721</span></p>

<p class=MsoIndex1><span style='color:windowtext'>resume(&nbsp;), 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>resumption</span></p>

<p class=MsoIndex2><span style='color:windowtext'>termination vs. resumption,
exception handling, 39</span></p>

<p class=MsoIndex1><span style='color:windowtext'>re-throwing an exception, 43</span></p>

<p class=MsoIndex1><span style='color:windowtext'>root, 78</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Runnable</span></p>

<p class=MsoIndex2><span style='color:windowtext'>interface, 708</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run(&nbsp;), 707</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Thread, 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>run-time interpreter for
printf(&nbsp;), 183</span></p>

<p class=MsoIndex1><span style='color:windowtext'>run-time type identification,
579</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and efficiency, 593</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and multiple inheritance,
589, 591, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and templates, 590</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and void pointers, 589</span></p>

<p class=MsoIndex2><span style='color:windowtext'>before(&nbsp;), 587</span></p>

<p class=MsoIndex2><span style='color:windowtext'>casting to intermediate
levels, 588</span></p>

<p class=MsoIndex2><span style='color:windowtext'>difference between
dynamic_cast and typeid(&nbsp;), 589</span></p>

<p class=MsoIndex2><span style='color:windowtext'>mechanism &amp; overhead, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>misuse, 592</span></p>

<p class=MsoIndex2><span style='color:windowtext'>typeinfo, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>VTABLE, 599</span></p>

<p class=MsoIndex2><span style='color:windowtext'>when to use it, 592</span></p>

<p class=MsoIndex1><span style='color:windowtext'>runtime_error</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library
exception type, 58</span></p>

<p class=MsoIndex1><span style='color:windowtext'>section, critical section and
synchronized block, 742</span></p>

<p class=MsoIndex1><span style='color:windowtext'>sed, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>seekg(&nbsp;), 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>seeking in iostreams, 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>seekp(&nbsp;), 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>serialization, 249</span></p>

<p class=MsoIndex1><span style='color:windowtext'>set</span></p>

<p class=MsoIndex2><span style='color:windowtext'>STL set class example, 448</span></p>

<p class=MsoIndex1><span style='color:windowtext'>set_terminate(&nbsp;), 44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>set_unexpected(&nbsp;)</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception handling, 61</span></p>

<p class=MsoIndex1><span style='color:windowtext'>setChanged(&nbsp;), 683</span></p>

<p class=MsoIndex1><span style='color:windowtext'>setf(&nbsp;), iostreams, 219,
246</span></p>

<p class=MsoIndex1><span style='color:windowtext'>setjmp(&nbsp;), 33</span></p>

<p class=MsoIndex1><span style='color:windowtext'>setPriority(&nbsp;), 721</span></p>

<p class=MsoIndex1><span style='color:windowtext'>signal(&nbsp;), 33, 74</span></p>

<p class=MsoIndex1><span style='color:windowtext'>simulating virtual
constructors, 672</span></p>

<p class=MsoIndex1><span style='color:windowtext'>singleton, 645</span></p>

<p class=MsoIndex1><span style='color:windowtext'>sleep(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>threading, 717</span></p>

<p class=MsoIndex1><span style='color:windowtext'>slicing</span></p>

<p class=MsoIndex2><span style='color:windowtext'>object slicing and exception
handling, 40</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Smalltalk, 602</span></p>

<p class=MsoIndex1><span style='color:windowtext'>sort</span></p>

<p class=MsoIndex2><span style='color:windowtext'>bubble sort, 305</span></p>

<p class=MsoIndex1><span style='color:windowtext'>specification</span></p>

<p class=MsoIndex2><span style='color:windowtext'>exception, 60</span></p>

<p class=MsoIndex1><span style='color:windowtext'>standard</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C, 24</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++, 24</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Standard C++ libraries</span></p>

<p class=MsoIndex2><span style='color:windowtext'>standard library exception
types, 56</span></p>

<p class=MsoIndex2><span style='color:windowtext'>string class, 185</span></p>

<p class=MsoIndex1><span style='color:windowtext'>standard template library</span></p>

<p class=MsoIndex2><span style='color:windowtext'>set class example, 448</span></p>

<p class=MsoIndex1><b><span style='color:windowtext'>stdio</span></b><span
style='color:windowtext'>, 179</span></p>

<p class=MsoIndex1><span style='color:windowtext'>STDIO.H, 198</span></p>

<p class=MsoIndex1><span style='color:windowtext'>stream, 185</span></p>

<p class=MsoIndex2><span style='color:windowtext'>output formatting, 217</span></p>

<p class=MsoIndex1><span style='color:windowtext'>streambuf, 204</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and get(&nbsp;), 205</span></p>

<p class=MsoIndex1><span style='color:windowtext'>streampos, moving, 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>string</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Standard C++ library string
class, 185</span></p>

<p class=MsoIndex2><span style='color:windowtext'>transforming character
strings to typed values, 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>stringizing, preprocessor,
225</span></p>

<p class=MsoIndex1><span style='color:windowtext'>strstream, 210</span></p>

<p class=MsoIndex1><span style='color:windowtext'>structural design patterns,
652</span></p>

<p class=MsoIndex1><span style='color:windowtext'>subobject</span></p>

<p class=MsoIndex2><span style='color:windowtext'>duplicate subobjects in
multiple inheritance, 616</span></p>

<p class=MsoIndex1><span style='color:windowtext'>suspend(&nbsp;), 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>synchronized</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and wait(&nbsp;) &amp;
notify(&nbsp;), 754</span></p>

<p class=MsoIndex2><span style='color:windowtext'>method, and blocking, 753</span></p>

<p class=MsoIndex1><span style='color:windowtext'>tellg(&nbsp;), 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>tellp(&nbsp;), 207</span></p>

<p class=MsoIndex1><span style='color:windowtext'>template</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and inheritance, 302</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and run-time type
identification, 590</span></p>

<p class=MsoIndex2><span style='color:windowtext'>controlling instantiation,
328</span></p>

<p class=MsoIndex2><span style='color:windowtext'>function templates, 280</span></p>

<p class=MsoIndex1><span style='color:windowtext'>temporary</span></p>

<p class=MsoIndex2><span style='color:windowtext'>object, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>terminate(&nbsp;)</span></p>

<p class=MsoIndex2><span style='color:windowtext'>uncaught exceptions, 44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>termination</span></p>

<p class=MsoIndex2><span style='color:windowtext'>vs. resumption, exception
handling, 39</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Thread, 701</span></p>

<p class=MsoIndex2><span style='color:windowtext'>blocked, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>dead, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>deadlock, 761</span></p>

<p class=MsoIndex2><span style='color:windowtext'>drawbacks, 769</span></p>

<p class=MsoIndex2><span style='color:windowtext'>getPriority(&nbsp;), 721</span></p>

<p class=MsoIndex2><span style='color:windowtext'>I/O and threads, blocking,
753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>interrupt(&nbsp;), 748</span></p>

<p class=MsoIndex2><span style='color:windowtext'>new Thread, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>notify(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>notifyAll(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>priority, 719</span></p>

<p class=MsoIndex2><span style='color:windowtext'>resume(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Runnable, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>Runnable interface, 708</span></p>

<p class=MsoIndex2><span style='color:windowtext'>setPriority(&nbsp;), 721</span></p>

<p class=MsoIndex2><span style='color:windowtext'>sharing resources, 724</span></p>

<p class=MsoIndex2><span style='color:windowtext'>sleep(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>states, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>suspend(&nbsp;), 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>synchronized method and
blocking, 753</span></p>

<p class=MsoIndex2><span style='color:windowtext'>threads and efficiency, 703</span></p>

<p class=MsoIndex2><span style='color:windowtext'>wait(&nbsp;), 753, 754</span></p>

<p class=MsoIndex2><span style='color:windowtext'>when to use threads, 769</span></p>

<p class=MsoIndex1><span style='color:windowtext'>throwing an exception, 35</span></p>

<p class=MsoIndex1><span style='color:windowtext'>transforming character
strings to typed values, 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>try block, 36</span></p>

<p class=MsoIndex1><span style='color:windowtext'>type</span></p>

<p class=MsoIndex2><span style='color:windowtext'>automatic type conversions
and exception handling, 40</span></p>

<p class=MsoIndex2><span style='color:windowtext'>run-time type identification
(RTTI), 579</span></p>

<p class=MsoIndex1><span style='color:windowtext'>typeid(&nbsp;)</span></p>

<p class=MsoIndex2><span style='color:windowtext'>difference between
dynamic_cast and typeid(&nbsp;), run-time type identification, 589</span></p>

<p class=MsoIndex1><span style='color:windowtext'>typeinfo</span></p>

<p class=MsoIndex2><span style='color:windowtext'>structure, 599</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ULONG_MAX, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>uncaught exceptions, 44</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Unix, 236</span></p>

<p class=MsoIndex1><span style='color:windowtext'>Urlocker, Zack, 642</span></p>

<p class=MsoIndex1><span style='color:windowtext'>user interface</span></p>

<p class=MsoIndex2><span style='color:windowtext'>responsive, with threading,
702, 721</span></p>

<p class=MsoIndex1><span style='color:windowtext'>value</span></p>

<p class=MsoIndex2><span style='color:windowtext'>transforming character
strings to typed values, 212</span></p>

<p class=MsoIndex1><span style='color:windowtext'>variable</span></p>

<p class=MsoIndex2><span style='color:windowtext'>variable argument list, 184</span></p>

<p class=MsoIndex1><span style='color:windowtext'>vector of change, 644</span></p>

<p class=MsoIndex1><span style='color:windowtext'>virtual</span></p>

<p class=MsoIndex2><span style='color:windowtext'>simulating virtual
constructors, 672</span></p>

<p class=MsoIndex2><span style='color:windowtext'>virtual functions inside
constructors, 672</span></p>

<p class=MsoIndex1><span style='color:windowtext'>visitor pattern, 696</span></p>

<p class=MsoIndex1><span style='color:windowtext'>void</span></p>

<p class=MsoIndex2><span style='color:windowtext'>void pointers and run-time
type identification, 589</span></p>

<p class=MsoIndex1><span style='color:windowtext'>VPTR, 672</span></p>

<p class=MsoIndex1><span style='color:windowtext'>VTABLE, 672</span></p>

<p class=MsoIndex2><span style='color:windowtext'>and run-time type
identification, 599</span></p>

<p class=MsoIndex1><span style='color:windowtext'>wait(&nbsp;), 753, 754</span></p>

<p class=MsoIndex1><span style='color:windowtext'>wrapping, class, 179</span></p>

<p class=MsoIndex1><span style='color:windowtext'>write(&nbsp;), 195</span></p>

<p class=MsoIndex1><span style='color:windowtext'>ws, 228</span></p>

<p class=MsoIndex1><span style='color:windowtext'>yield(&nbsp;), threading, 716</span></p>

</div>

<span style='color:windowtext'><br clear=all style='page-break-before:auto'>
</span>

<div class=Section24>

<p class=MsoNormal><span style='color:windowtext'><sup> </sup></span></p>

</div>

</p>

</p>

</p>

</p>

</p>

</p>

</p>

</p>

</a><a name="_Toc40780404"></a><a name="_Toc24775840"></a><a
name="_Toc375545480"></a><a name="_Toc40780411"></a><a name="_Toc375545481"></a><a
name="_Toc24775849"></a><a name="_Toc45440221"></a><a name="_Toc45440220"></a><a
name="_Toc45440219"></a><a name="_Toc45440218"></a><a name="_Toc45440217"></a><a
name="_Toc45440216"></a><a name="_Toc45440215"></a><a name="_Toc45440214"></a><a
name=RecommendedReading></a><a name="_Toc45440213"></a><a name="_Toc375545490"></a><a
name="_Toc24775861"></a><a name="_Toc40780420"></a><a name="_Toc45440212"></a><a
name="_Toc375545489"></a><a name="_Toc24775860"></a><a name="_Toc40780419"></a><a
name="_Toc45440211"></a><a name=CCC></a><a name="_Toc375545483"></a><a
name="_Toc24775856"></a><a name="_Toc40780418"></a><a name="_Toc45440210"></a><a
name="_Toc40780413"></a><a name="_Toc45440209"></a><a name="_Toc45440208"></a><a
name="_Toc45440207"></a><a name="_Toc40780410"></a><a name="_Toc45440206"></a><a
name=AAA></a><a name="_Toc24775853"></a><a name="_Toc40780417"></a><a
name="_Toc45440205"></a><a name="_Toc45440204"></a><a name="_Toc24775852"></a><a
name="_Toc40780416"></a><a name="_Toc45440203"></a><a name="_Toc375545482"></a><a
name="_Toc24775851"></a><a name="_Toc40780415"></a><a name="_Toc45440202"></a><a
name="_Toc24775850"></a><a name="_Toc40780414"></a><a name="_Toc45440201"></a><a
name="_Toc45440200"></a><a name="_Toc45440199"></a><a name="_Toc45440198"></a><a
name="_Toc375545479"></a><a name="_Toc24775846"></a><a name="_Toc40780409"></a><a
name="_Toc45440197"></a><a name="_Toc375545478"></a><a name="_Toc24775845"></a><a
name="_Toc40780408"></a><a name="_Toc45440196"></a><a name="_Toc40780405"></a><a
name="_Toc45440195"></a><a name="_Toc24775839"></a><a name="_Toc40780403"></a><a
name="_Toc45440194"></a><a name="_Toc40780402"></a><a name="_Toc45440193"></a><a
name="_Toc24775838"></a><a name="_Toc40780406"></a><a name="_Toc45440192"></a><a
name="_Toc40780399"></a><a name="_Toc45440191"></a><a name="_Toc45440190"></a><a
name="_Toc40780400"></a><a name="_Toc45440189"></a><a name="_Toc40780398"></a><a
name="_Toc45440188"></a><a name="_Toc24775837"></a><a name="_Toc40780397"></a><a
name="_Toc45440187"></a><a name="_Toc40780396"></a><a name="_Toc45440186"></a><a
name="_Toc40780395"></a><a name="_Toc45440185"></a><a name="_Toc24775836"></a><a
name="_Toc40780394"></a><a name="_Toc45440184"></a></p>

</div>

<div><br clear=all>

<hr align=left size=1 width="33%">

<div id=ftn1>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref1"
name="_ftn1" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[1]</span></sup></span></a></span></sup></span> You
might be surprised when you run the example—some C++ compilers have extended <b>longjmp(&nbsp;)</b>
to clean up objects on the stack. This behavior is nonportable.</p>

</div>

<div id=ftn2>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref2"
name="_ftn2" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[2]</span></sup></span></a></span></sup></span> Visual
Basic supports a limited form of resumptive exception handling with its ON
ERROR facility.</p>

</div>

<div id=ftn3>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref3"
name="_ftn3" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[3]</span></sup></span></a></span></sup></span> In
fact, you might want to always specify exception objects by const reference in
exception handlers. It’s very rare to modify and rethrow an exception. We are
not dogmatic about this practice however.</p>

</div>

<div id=ftn4>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref4"
name="_ftn4" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[4]</span></sup></span></a></span></sup></span> Only
<i>unambiguous, accessible base classes</i> can catch derived exceptions. This
rule minimizes the runtime overhead needed to validate exceptions. Remember
that exceptions are checked at runtime, not at compile time, and therefore the
extensive information available at compile time is not available during
exception handling.</p>

</div>

<div id=ftn5>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref5"
name="_ftn5" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[5]</span></sup></span></a></span></sup></span> For
more detail on <b>auto_ptr</b>, see Herb Sutter’s article entitled, “Using
auto_ptr Effectively” in the October 1999 issue of the <i>C/C++ Users Journal</i>,
pp. 63–67.</p>

</div>

<div id=ftn6>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref6"
name="_ftn6" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[6]</span></sup></span></a></span></sup></span> If
you’re interested in a more in-depth analysis of exception safety issues, the
definitive reference is Herb Sutter’s <i>Exceptional C++</i>, Addison-Wesley,
2000.</p>

</div>

<div id=ftn7>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref7"
name="_ftn7" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[7]</span></sup></span></a></span></sup></span> The
library function <b>uncaught_exception( )</b> returns <b>true</b> in the middle
of stack unwinding, so technically you can test <b>uncaught_exeption( )</b> for
<b>false</b> and let an exception escape from a destructor. We’ve never seen a
situation in which this constituted good design, however, so we only mention it
in this footnote. </p>

</div>

<div id=ftn8>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref8"
name="_ftn8" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[8]</span></sup></span></a></span></sup></span> Some
compilers do throw exceptions in these cases, but they usually provide a
compiler option to disable this (unusual) behavior.</p>

</div>

<div id=ftn9>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref9"
name="_ftn9" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[9]</span></sup></span></a></span></sup></span> This
depends, of course, on how much checking of return codes you would have to
insert if you weren’t using exceptions.</p>

</div>

<div id=ftn10>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref10"
name="_ftn10" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[10]</span></sup></span></a></span></sup></span> Borland
enables exceptions by default; to disable exceptions use the <b>-x</b>-
compiler option. Microsoft disables support by default; to turn it on, use the <b>-GX</b>
option. With both compilers use the <b>-c</b> option to compile only.</p>

</div>

<div id=ftn11>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref11"
name="_ftn11" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[11]</span></sup></span></a></span></sup></span> The
GNU C++ compiler uses the zero-cost model by default. Metrowerks Code Warrior
for C++ also has an option to use the zero-cost model.</p>

</div>

<div id=ftn12>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref12"
name="_ftn12" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[12]</span></sup></span></a></span></sup></span> Thanks
to Scott Meyers and Josee Lajoie for their insights on the zero-cost model. You
can find more information on how exceptions work in Josee’s excellent article,
&quot;Exception Handling: Behind the Scenes,&quot; <i>C++ Gems</i>, SIGS, 1996.</p>

</div>

<div id=ftn13>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref13"
name="_ftn13" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[13]</span></sup></span></a></span></sup></span> Among
other things he invented Quicksort.</p>

</div>

<div id=ftn14>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref14"
name="_ftn14" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[14]</span></sup></span></a></span></sup></span> As
quoted in <i>Programming Language Pragmatics</i>, by Michael L. Scott,
Morgan-Kaufmann, 2000.</p>

</div>

<div id=ftn15>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref15"
name="_ftn15" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[15]</span></sup></span></a></span></sup></span> See
his book, <i>Object-Oriented Software Construction</i>, Prentice-Hall, 1994.</p>

</div>

<div id=ftn16>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref16"
name="_ftn16" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[16]</span></sup></span></a></span></sup></span> This
is still an assertion <i>conceptually</i>, but since we don’t want to halt
execution, the <b>assert(&nbsp;)</b> macro is not appropriate. Java 1.4, for
example, throws an exception when an assertion fails.</p>

</div>

<div id=ftn17>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref17"
name="_ftn17" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[17]</span></sup></span></a></span></sup></span> There
is a nice phrase to help remember this phenomenon: “Require no more; promise no
less,” first coined in <i>C++ FAQs</i>, by Marshall Cline and Greg Lomow
(Addison-Wesley, 1994). Since pre-conditions can weaken in derived classes, we
say that they are <i>contravariant</i>, and, conversely, post-conditions are <i>covariant</i>
(which explains why we mentioned the covariance of exception specifications in
Chapter 1).</p>

</div>

<div id=ftn18>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref18"
name="_ftn18" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[18]</span></sup></span></a></span></sup></span> This
section is based on Chuck’s article, “The Simplest Automated Unit Test
Framework That Could Possibly Work”, C/C++ Users Journal, Sept. 2000.</p>

</div>

<div id=ftn19>

<p class=MsoFootnoteText><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'><a href="#_ftnref19"
name="_ftn19" title=""><span class=MsoFootnoteReference><sup><span
style='font-size:8.0pt;position:relative;top:0pt'>[19]</span></sup></span></a></span></sup></span> A
good read on this subject is Martin Fowler's <i>Refactoring: Improving the
Design of Existing Code</i> (Addison-Wesley, 2000). See also <a
href="http://www.refactoring.com/">www.refactoring.com</a>. Refactoring is a
crucial practice of Extreme Programming (XP). The title of this section is a
variation on the theme, “TheSimplestThingThatCouldPossiblyWork,” another XP
staple. XP is a code-centric discipline for getting software done right, on
time, within budget, while having fun along the way. Visit <a
href="http://www.xprogramming.com/">www.xprogramming.com</a> for more detail.</p>

</div>

<div id=ftn20>

<p class=MsoFootnoteText><a href="#_ftnref20" name="_ftn20" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[20]</span></sup></span></span></sup></span></a> Lightweight
methodologies such as XP have “joined forces” in the Agile Alliance (see
http://www.agilealliance.org/home).</p>

</div>

<div id=ftn21>

<p class=MsoFootnoteText><a href="#_ftnref21" name="_ftn21" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[21]</span></sup></span></span></sup></span></a> Our
Date class is also “internationalized”, in that it supports wide character
sets. This is introduced at the end of the next chapter.</p>

</div>

<div id=ftn22>

<p class=MsoFootnoteText><a href="#_ftnref22" name="_ftn22" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[22]</span></sup></span></span></sup></span></a> See
<a href="http://sourceforge.net/projects/cppunit">http://sourceforge.net/projects/cppunit</a>
for more information.</p>

</div>

<div id=ftn23>

<p class=MsoFootnoteText><a href="#_ftnref23" name="_ftn23" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[23]</span></sup></span></span></sup></span></a> “Runtime
Type Identification”, discussed in chapter 9. Specifically, we use the <b>name(&nbsp;)</b>
member function of the <b>typeinfo</b> class. By the way, if you're using
Microsoft Visual C++, you need to specify the compile option <b>/GR</b>. If you
don't, you'll get an access violation at runtime.</p>

</div>

<div id=ftn24>

<p class=MsoFootnoteText><a href="#_ftnref24" name="_ftn24" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[24]</span></sup></span></span></sup></span></a> In
particular, we use <i>stringizing</i> (via the <b>#</b> operator) and the
predefined macros <b>__FILE</b>__ and <b>__LINE__</b>. See the code later in
the chapter.</p>

</div>

<div id=ftn25>

<p class=MsoFootnoteText><a href="#_ftnref25" name="_ftn25" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[25]</span></sup></span></span></sup></span></a> Batch
files and shell scripts work well for this, of course. The <b>Suite</b> class
is a C++-based way of organizing related tests.</p>

</div>

<div id=ftn26>

<p class=MsoFootnoteText><a href="#_ftnref26" name="_ftn26" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[26]</span></sup></span></span></sup></span></a> Our
key technical reviewer, Pete Becker of Dinkumware. Ltd., brought to our
attention that it is illegal to use macros to replace C++ keywords. His take on
this technique was as follows: “&quot;This is a dirty trick. Dirty tricks are
sometimes necessary to figure out why code isn't working, so you may want to
keep this in your toolbox, but <br>
don't ship any code with it.&quot; Caveat programmor :-).</p>

</div>

<div id=ftn27>

<p class=MsoFootnoteText><a href="#_ftnref27" name="_ftn27" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[27]</span></sup></span></span></sup></span></a> Thanks
to Reg Charney of the C++ Standards Committee for suggesting this trick.</p>

</div>

<div id=ftn28>

<p class=MsoFootnoteText><a href="#_ftnref28" name="_ftn28" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[28]</span></sup></span></span></sup></span></a> Some
of the material in this chapter was originally created by Nancy Nicolaisen.</p>

</div>

<div id=ftn29>

<p class=MsoFootnoteText><a href="#_ftnref29" name="_ftn29" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[29]</span></sup></span></span></sup></span></a> It’s
difficult to make reference-counting implementations thread safe. (See Herb
Sutter, <i>More Exceptional C++</i>, pp. 104–14). See Chapter 10 for more on
programming with multiple threads.</p>

</div>

<div id=ftn30>

<p class=MsoFootnoteText><a href="#_ftnref30" name="_ftn30" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[30]</span></sup></span></span></sup></span></a> It
as an abbreviation for “no position.”</p>

</div>

<div id=ftn31>

<p class=MsoFootnoteText><a href="#_ftnref31" name="_ftn31" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[31]</span></sup></span></span></sup></span></a> Discussed
in depth in Chapter 6.</p>

</div>

<div id=ftn32>

<p class=MsoFootnoteText><a href="#_ftnref32" name="_ftn32" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[32]</span></sup></span></span></sup></span></a> To
keep the exposition simple, this version does not handle nested tags, such as
comments.</p>

</div>

<div id=ftn33>

<p class=MsoFootnoteText><a href="#_ftnref33" name="_ftn33" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[33]</span></sup></span></span></sup></span></a> It
is tempting to use mathematics here to factor out some of these calls to <b>erase(&nbsp;)</b>,
but since in some cases one of the operands is <b>string::npos</b> (the largest
unsigned integer available), integer overflow occurs and wrecks the algorithm.</p>

</div>

<div id=ftn34>

<p class=MsoFootnoteText><a href="#_ftnref34" name="_ftn34" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[34]</span></sup></span></span></sup></span></a> Alert:
For the safety reasons mentioned, the C++ Standards Committee is considering a
proposal to redefine <b>string::operator[]</b> to behave identically to <b>string::at()</b>
for C++0x.</p>

</div>

<div id=ftn35>

<p class=MsoFootnoteText><a href="#_ftnref35" name="_ftn35" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[35]</span></sup></span></span></sup></span></a> Your
implementation can define all three template arguments here. Because the last
two template parameters have default arguments, such a declaration is
equivalent to what we show here.</p>

</div>

<div id=ftn36>

<p class=MsoFootnoteText><a href="#_ftnref36" name="_ftn36" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[36]</span></sup></span></span></sup></span></a> POSIX,
an IEEE standard, stands for “Portable Operating System Interface” and is a
generalization of many of the low-level system calls found in UNIX systems.</p>

</div>

<div id=ftn37>

<p class=MsoFootnoteText><a href="#_ftnref37" name="_ftn37" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[37]</span></sup></span></span></sup></span></a> The
implementation and test files for FULLWRAP are available in the freely
distributed source code for this book. See the preface for details.</p>

</div>

<div id=ftn38>

<p class=MsoFootnoteText><a href="#_ftnref38" name="_ftn38" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[38]</span></sup></span></span></sup></span></a> Explained
in depth in Chapter 5.</p>

</div>

<div id=ftn39>

<p class=MsoFootnoteText><a href="#_ftnref39" name="_ftn39" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[39]</span></sup></span></span></sup></span></a> For
this reason, we can write <b>ios::failbit</b> instead of <b>ios_base::failbit</b>
to save typing.</p>

</div>

<div id=ftn40>

<p class=MsoFootnoteText><a href="#_ftnref40" name="_ftn40" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[40]</span></sup></span></span></sup></span></a> It
is customary to use <b>operator void*(&nbsp;)</b> in preference to <b>operator
bool(&nbsp;)</b> because the implicit conversions from <b>bool</b> to <b>int</b>
may cause surprises, should you errantly place a stream in a context where an
integer conversion can be applied. The <b>operator void*(&nbsp;)</b> function
will only implicitly be called in the body of a Boolean expression.</p>

</div>

<div id=ftn41>

<p class=MsoFootnoteText><a href="#_ftnref41" name="_ftn41" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[41]</span></sup></span></span></sup></span></a> An
integral type used to hold single-bit flags.</p>

</div>

<div id=ftn42>

<p class=MsoFootnoteText><a href="#_ftnref42" name="_ftn42" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[42]</span></sup></span></span></sup></span></a> A
more in-depth treatment of stream buffers and streams in general can be found
in Langer &amp; Kreft’s, <i>Standard C++ IOStreams and Locales</i>,
Addison-Wesley, 1999.</p>

</div>

<div id=ftn43>

<p class=MsoFootnoteText><a href="#_ftnref43" name="_ftn43" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[43]</span></sup></span></span></sup></span></a> For
more information on machine epsilon and floating-point computation in general,
see Chuck’s article, “The Standard C Library, Part 3”, <i>C/C++ Users Journal</i>,
March 1995, also available at www.freshsources.com/1995006a.htm.</p>

</div>

<div id=ftn44>

<p class=MsoFootnoteText><a href="#_ftnref44" name="_ftn44" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[44]</span></sup></span></span></sup></span></a> Before
putting <b>nl</b> into a header file, make it an <b>inline</b> function (see
Chapter 7).</p>

</div>

<div id=ftn45>

<p class=MsoFootnoteText><a href="#_ftnref45" name="_ftn45" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[45]</span></sup></span></span></sup></span></a> Jerry
Schwarz is the designer of iostreams.</p>

</div>

<div id=ftn46>

<p class=MsoFootnoteText><a href="#_ftnref46" name="_ftn46" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[46]</span></sup></span></span></sup></span></a> See
the Langer &amp; Kreft book mentioned earlier for more detailed information.</p>

</div>

<div id=ftn47>

<p class=MsoFootnoteText><a href="#_ftnref47" name="_ftn47" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[47]</span></sup></span></span></sup></span></a> See,
for example, Dinkumware’s Abridged library at <a
href="http://www.dinkumware.com/">www.dinkumware.com</a>. This library omits
locale support. and exception support is optional.</p>

</div>

<div id=ftn48>

<p class=MsoFootnoteText><a href="#_ftnref48" name="_ftn48" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[48]</span></sup></span></span></sup></span></a> Vandevoorde
and Josuttis, <i>C++ Templates: The Complete Guide</i>, Addison-Wesley, 2003.</p>

</div>

<div id=ftn49>

<p class=MsoFootnoteText><a href="#_ftnref49" name="_ftn49" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[49]</span></sup></span></span></sup></span></a> To
save space, we will sometimes use <b>class</b> instead of <b>typename</b> in
this book, but most of the time, we will just go with whatever suits our fancy <span
style='font-family:Wingdings'>J</span>.</p>

</div>

<div id=ftn50>

<p class=MsoFootnoteText><a href="#_ftnref50" name="_ftn50" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[50]</span></sup></span></span></sup></span></a> The
C++ standards committee is considering relaxing the only-within-a-template rule
for these disambiguation hints, and some compilers are allowing then in
non-template code already.</p>

</div>

<div id=ftn51>

<p class=MsoFootnoteText><a href="#_ftnref51" name="_ftn51" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[51]</span></sup></span></span></sup></span></a> See
Stroustrup, <i>The C++ Programming Language</i>, 3<sup>rd</sup> Edition,
Addison-Wesley, pp. 335-336.</p>

</div>

<div id=ftn52>

<p class=MsoFootnoteText><a href="#_ftnref52" name="_ftn52" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[52]</span></sup></span></span></sup></span></a> We
are indebted to Nathan Myers for this example.</p>

</div>

<div id=ftn53>

<p class=MsoFootnoteText><a href="#_ftnref53" name="_ftn53" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[53]</span></sup></span></span></sup></span></a> For
those keeping track, it’s Core Issue 352.</p>

</div>

<div id=ftn54>

<p class=MsoFootnoteText><a href="#_ftnref54" name="_ftn54" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[54]</span></sup></span></span></sup></span></a> A
reference to the British animated short feature <i>The Wrong Trousers</i> by
Nick Park.</p>

</div>

<div id=ftn55>

<p class=MsoFootnoteText><a href="#_ftnref55" name="_ftn55" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[55]</span></sup></span></span></sup></span></a> We
discuss <b>vector&lt;bool&gt;</b> in depth in Chapter 7.</p>

</div>

<div id=ftn56>

<p class=MsoFootnoteText><a href="#_ftnref56" name="_ftn56" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[56]</span></sup></span></span></sup></span></a> Also
called <i>Koenig lookup</i>, after Andrew Koenig, who first proposed the
technique to the C++ standards committee. ADL applies universally, whether
templates are involved or not.</p>

</div>

<div id=ftn57>

<p class=MsoFootnoteText><a href="#_ftnref57" name="_ftn57" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[57]</span></sup></span></span></sup></span></a> In
a talk given at <i>The C++ Seminar</i>, Portland, OR, September, 2001.</p>

</div>

<div id=ftn58>

<p class=MsoFootnoteText><a href="#_ftnref58" name="_ftn58" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[58]</span></sup></span></span></sup></span></a> Another
template idiom, mixin inheritance, is covered in Chapter 9.</p>

</div>

<div id=ftn59>

<p class=MsoFootnoteText><a href="#_ftnref59" name="_ftn59" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[59]</span></sup></span></span></sup></span></a> The
fact that <b>char_traits&lt;&gt;::compare(&nbsp;)</b> may call <b>strcmp(&nbsp;)</b>
in one instance vs. <b>wcscmp(&nbsp;)</b> in another, for example, is
immaterial to the point we make here: the function performed by <b>compare(&nbsp;)</b>
is the same.</p>

</div>

<div id=ftn60>

<p class=MsoFootnoteText><a href="#_ftnref60" name="_ftn60" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[60]</span></sup></span></span></sup></span></a> <i>Modern
C++ Design: Generic Programming and Design Patterns Applied</i>,
Addison-Wesley, 2001.</p>

</div>

<div id=ftn61>

<p class=MsoFootnoteText><a href="#_ftnref61" name="_ftn61" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[61]</span></sup></span></span></sup></span></a> <i>C++
Gems</i>, edited by Stan Lippman, SIGS, 1996.</p>

</div>

<div id=ftn62>

<p class=MsoFootnoteText><a href="#_ftnref62" name="_ftn62" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[62]</span></sup></span></span></sup></span></a> Floating-point
values are not compile-time constants, and therefore cannot be used in compile-time
arithmetic.</p>

</div>

<div id=ftn63>

<p class=MsoFootnoteText><a href="#_ftnref63" name="_ftn63" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[63]</span></sup></span></span></sup></span></a> In
1966 Böhm and Jacopini proved that any language supporting selection and
repetition, along with the ability to use an arbitrary number of variables, is
equivalent to to Turing machine, which can implement any algorithm.</p>

</div>

<div id=ftn64>

<p class=MsoFootnoteText><a href="#_ftnref64" name="_ftn64" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[64]</span></sup></span></span></sup></span></a> Czarnecki
and Eisenecker, <i>Generative Programming: Methods, Tools, and Applications</i>,
Addison-Wesley, 2000, p. 417.</p>

</div>

<div id=ftn65>

<p class=MsoFootnoteText><a href="#_ftnref65" name="_ftn65" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[65]</span></sup></span></span></sup></span></a> <i>Modern
C++ Design</i>, pp. 23-26.</p>

</div>

<div id=ftn66>

<p class=MsoFootnoteText><a href="#_ftnref66" name="_ftn66" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[66]</span></sup></span></span></sup></span></a> Or
something that is callable as a function, as you’ll see shortly.</p>

</div>

<div id=ftn67>

<p class=MsoFootnoteText><a href="#_ftnref67" name="_ftn67" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[67]</span></sup></span></span></sup></span></a> This
is simply an English rendition of <b>O(n log n)</b>, which is the mathematical
way of saying that for large <b>n</b>, the number of comparisons grows in
direct proportion to the function <b>f(n) = n log n</b>.</p>

</div>

<div id=ftn68>

<p class=MsoFootnoteText><a href="#_ftnref68" name="_ftn68" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[68]</span></sup></span></span></sup></span></a> Unless
you do something ungainly like use global variables.</p>

</div>

<div id=ftn69>

<p class=MsoFootnoteText><a href="#_ftnref69" name="_ftn69" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[69]</span></sup></span></span></sup></span></a> Function
objects are also called <i>functors</i>, after a mathematical concept with
similar behavior.</p>

</div>

<div id=ftn70>

<p class=MsoFootnoteText><a href="#_ftnref70" name="_ftn70" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[70]</span></sup></span></span></sup></span></a> All
standard iterators define a number of nested types, including <b>value_type</b>,
which represents the type the iterator refers to. See Chapter 7 for more
detail.</p>

</div>

<div id=ftn71>

<p class=MsoFootnoteText><a href="#_ftnref71" name="_ftn71" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[71]</span></sup></span></span></sup></span></a> If
a compiler were to define <b>string::empty</b> with default arguments (which is
allowed), then the expression <b>&amp;string::empty</b> would define a pointer
to a member function taking the total number of arguments. Since there is no
way for the compiler to provide the extra defaults, there would be a “missing
argument” error when an algorithm applied <b>string::empty</b> via <b>mem_fun_ref</b>.</p>

</div>

<div id=ftn72>

<p class=MsoFootnoteText><a href="#_ftnref72" name="_ftn72" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[72]</span></sup></span></span></sup></span></a> STLPort,
for instance, which comes with version 6 of Borland C++ Builder and is based on
SGI STL.</p>

</div>

<div id=ftn73>

<p class=MsoFootnoteText><a href="#_ftnref73" name="_ftn73" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[73]</span></sup></span></span></sup></span></a> The
<b>stable_sort(&nbsp;)</b> algorithm uses <i>mergesort</i>, which is indeed
stable, but tends to run slower than <i>quicksort</i> on average.</p>

</div>

<div id=ftn74>

<p class=MsoFootnoteText><a href="#_ftnref74" name="_ftn74" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[74]</span></sup></span></span></sup></span></a> Iterators
are discussed in more depth in the next chapter.</p>

</div>

<div id=ftn75>

<p class=MsoFootnoteText><a href="#_ftnref75" name="_ftn75" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[75]</span></sup></span></span></sup></span></a> Algorithms
can determine the type of an iterator by reading its <b>tag</b>, discussed in
the next chapter.</p>

</div>

<div id=ftn76>

<p class=MsoFootnoteText><a href="#_ftnref76" name="_ftn76" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[76]</span></sup></span></span></sup></span></a> We’re
ignoring the copy constructor and assignment operator in this example, since
they don’t apply.</p>

</div>

<div id=ftn77>

<p class=MsoFootnoteText><a href="#_ftnref77" name="_ftn77" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[77]</span></sup></span></span></sup></span></a> Without
violating any copyright laws, of course.</p>

</div>

<div id=ftn78>

<p class=MsoFootnoteText><a href="#_ftnref78" name="_ftn78" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[78]</span></sup></span></span></sup></span></a> Visit
<a href="http://www.dinkumware.com/">http://www.dinkumware.com</a>,
http://www.sgi.com/tech/stl, or http://www.stlport.org.</p>

</div>

<div id=ftn79>

<p class=MsoFootnoteText><a href="#_ftnref79" name="_ftn79" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[79]</span></sup></span></span></sup></span></a> The
container adaptors, stack, queue, and priority_queue do not support iterators,
since they do not behave as sequences from the user’s point of view.</p>

</div>

<div id=ftn80>

<p class=MsoFootnoteText><a href="#_ftnref80" name="_ftn80" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[80]</span></sup></span></span></sup></span></a> It
will only work for implementations of vector that uses a <i>pointer</i> (a <b>T*</b>)
as the iterator type, like STLPort does.</p>

</div>

<div id=ftn81>

<p class=MsoFootnoteText><a href="#_ftnref81" name="_ftn81" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[81]</span></sup></span></span></sup></span></a> These
were actually created to abstract the “locale” facets away from iostreams, so
that locale facets could operate on any sequence of characters, not only
iostreams. Locales allow iostreams to easily handle culturally-different
formatting (such as the representation of money) and are beyond the scope of
this book.</p>

</div>

<div id=ftn82>

<p class=MsoFootnoteText><a href="#_ftnref82" name="_ftn82" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[82]</span></sup></span></span></sup></span></a> You
will need to provide a <b>char_traits</b> specialization for any other argument
type.</p>

</div>

<div id=ftn83>

<p class=MsoFootnoteText><a href="#_ftnref83" name="_ftn83" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[83]</span></sup></span></span></sup></span></a> We
are indebted to Nathan Myers for explaining this.</p>

</div>

<div id=ftn84>

<p class=MsoFootnoteText><a href="#_ftnref84" name="_ftn84" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[84]</span></sup></span></span></sup></span></a> This
is another example coached by Nathan Myers.</p>

</div>

<div id=ftn85>

<p class=MsoFootnoteText><a href="#_ftnref85" name="_ftn85" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[85]</span></sup></span></span></sup></span></a> For
a detailed explanation of this oddity, see Items 6 and 29 in Scott Meyer’s <i>Effective
STL</i>.</p>

</div>

<div id=ftn86>

<p class=MsoFootnoteText><a href="#_ftnref86" name="_ftn86" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[86]</span></sup></span></span></sup></span></a> We
revisit multi-threading issues in Chapter 11.</p>

</div>

<div id=ftn87>

<p class=MsoFootnoteText><a href="#_ftnref87" name="_ftn87" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[87]</span></sup></span></span></sup></span></a> Chuck
designed and provided the original reference implementations for <b>bitset</b>
and also <b>bitstring</b>, the precursor to <b>vector&lt;bool&gt;</b>, while an
active member of the C++ standards committee in the early 1990s.</p>

</div>

<div id=ftn88>

<p class=MsoFootnoteText><a href="#_ftnref88" name="_ftn88" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[88]</span></sup></span></span></sup></span></a> They
will likely appear in the next revision of Standard C++.</p>

</div>

<div id=ftn89>

<p class=MsoFootnoteText><a href="#_ftnref89" name="_ftn89" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[89]</span></sup></span></span></sup></span></a> Available
at http://www.sgi.com/tech/stl.</p>

</div>

<div id=ftn90>

<p class=MsoFootnoteText><a href="#_ftnref90" name="_ftn90" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[90]</span></sup></span></span></sup></span></a> As
we explained earlier, the <b>vector&lt;bool&gt;</b> specialization is also a
non-STL container to some degree.</p>

</div>

<div id=ftn91>

<p class=MsoFootnoteText><a href="#_ftnref91" name="_ftn91" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[91]</span></sup></span></span></sup></span></a> With
Microsoft’s compilers you will have to enable RTTI; it’s disabled by default.
The command-line option enable it is <b>/GR</b>.</p>

</div>

<div id=ftn92>

<p class=MsoFootnoteText><a href="#_ftnref92" name="_ftn92" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[92]</span></sup></span></span></sup></span></a> Compilers
typically insert a pointer to a class’s RTTI table inside of its virtual
function table.</p>

</div>

<div id=ftn93>

<p class=MsoFootnoteText><a href="#_ftnref93" name="_ftn93" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[93]</span></sup></span></span></sup></span></a> A <b>dynamic_cast&lt;void*&gt;</b>
always gives the address of the full object—not a subobject. This will be
explained more fully in the next chapter.</p>

</div>

<div id=ftn94>

<p class=MsoFootnoteText><a href="#_ftnref94" name="_ftn94" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[94]</span></sup></span></span></sup></span></a> Even
more importantly, we don’t want undefined behavior. It is an error for a base
class not to have a virtual destructor.</p>

</div>

<div id=ftn95>

<p class=MsoFootnoteText><a href="#_ftnref95" name="_ftn95" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[95]</span></sup></span></span></sup></span></a> The
actual layout is of course implementation specific.</p>

</div>

<div id=ftn96>

<p class=MsoFootnoteText><a href="#_ftnref96" name="_ftn96" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[96]</span></sup></span></span></sup></span></a> But
not detected as an error.  <b>dynamic_cast</b>, however can solve this problem.
See the next chapter for details.</p>

</div>

<div id=ftn97>

<p class=MsoFootnoteText><a href="#_ftnref97" name="_ftn97" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[97]</span></sup></span></span></sup></span></a> Compilers
can add arbitrary padding, so the size of an object must be at least as large
as the sum of its parts, but can be larger.</p>

</div>

<div id=ftn98>

<p class=MsoFootnoteText><a href="#_ftnref98" name="_ftn98" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[98]</span></sup></span></span></sup></span></a> We
use the term <i>hierarchy</i> because everyone else does, but the graph
representing multiple inheritance relationships is in general a <i>directed
acyclic graph</i> (DAG), also called a <i>lattice</i>, for obvious reasons.</p>

</div>

<div id=ftn99>

<p class=MsoFootnoteText><a href="#_ftnref99" name="_ftn99" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[99]</span></sup></span></span></sup></span></a> The
presence of these pointers explains why the size of <b>b</b> is much larger
than the size of four integers.  This is (part of) the cost of virtual base
classes. There is also VPTR overhead due to the virtual constructor.</p>

</div>

<div id=ftn100>

<p class=MsoFootnoteText><a href="#_ftnref100" name="_ftn100" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[100]</span></sup></span></span></sup></span></a> Note
that the virtual inheritance is crucial to this example. If <b>Top</b> were not
a virtual base class, there would be multiple <b>Top</b> subobjects, and the
ambiguity would remain. Dominance with multiple inheritance only comes into
play with virtual base classes.</p>

</div>

<div id=ftn101>

<p class=MsoFootnoteText><a href="#_ftnref101" name="_ftn101" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[101]</span></sup></span></span></sup></span></a> Jerry
Schwarz, the author of IOStreams, has remarked to both of us on separate
occasions that if he had it to do over again, he would probably remove MI from
the design of IOStreams and use multiple stream buffers and conversion
operators instead.</p>

</div>

<div id=ftn102>

<p class=MsoFootnoteText><a href="#_ftnref102" name="_ftn102" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[102]</span></sup></span></span></sup></span></a> A
phrase coined by Zack Urlocker.</p>

</div>

<div id=ftn103>

<p class=MsoFootnoteText><a href="#_ftnref103" name="_ftn103" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[103]</span></sup></span></span></sup></span></a> Also
known as the “Gang of Four” book (GoF). Conveniently, the examples are in C++.</p>

</div>

<div id=ftn104>

<p class=MsoFootnoteText><a href="#_ftnref104" name="_ftn104" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[104]</span></sup></span></span></sup></span></a> This
is known as Meyers’ Singleton, after its creator, Scott Meyers.</p>

</div>

<div id=ftn105>

<p class=MsoFootnoteText><a href="#_ftnref105" name="_ftn105" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[105]</span></sup></span></span></sup></span></a> Andrei
Alexandrescu develops a superior, policy-based solution to implementing the
Singleton pattern in <i>Modern C++ Design</i>.</p>

</div>

<div id=ftn106>

<p class=MsoFootnoteText><a href="#_ftnref106" name="_ftn106" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[106]</span></sup></span></span></sup></span></a> For
more information, see the article “Once is Not Enough” by Hyslop and Sutter in
the March 2003 issue of <i>CUJ</i>.</p>

</div>

<div id=ftn107>

<p class=MsoFootnoteText><a href="#_ftnref107" name="_ftn107" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[107]</span></sup></span></span></sup></span></a> For
up-to-date information, visit http://hillside.net/patterns.</p>

</div>

<div id=ftn108>

<p class=MsoFootnoteText><a href="#_ftnref108" name="_ftn108" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[108]</span></sup></span></span></sup></span></a>James
O. Coplien, <i>Advanced C++ Programming Styles and Idioms</i>, Addison-Wesley,
1992.</p>

</div>

<div id=ftn109>

<p class=MsoFootnoteText><a href="#_ftnref109" name="_ftn109" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[109]</span></sup></span></span></sup></span></a> It
differs from Java in that <b>java.util.Observable.notifyObservers(&nbsp;)</b>
doesn't call <b>clearChanged(&nbsp;)</b> until after notifying all the
observers</p>

</div>

<div id=ftn110>

<p class=MsoFootnoteText><a href="#_ftnref110" name="_ftn110" title=""><span
class=MsoFootnoteReference><sup><span style='font-size:8.0pt;position:relative;
top:0pt'><span class=MsoFootnoteReference><sup><span style='font-size:8.0pt;
position:relative;top:0pt'>[110]</span></sup></span></span></sup></span></a> There
is some similarity between inner classes and <i>subroutine closures</i>, which
save the reference environment of a function call so it can be reproduced
later.</p>

</div>

</div>

<div>

<hr class=msocomoff align=left size=1 width="33%">

<div>

<div id="_com_1" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_1','_com_1')"
onmouseout="msoCommentHide('_com_1')"><a name="_msocom_1"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_1" class=msocomoff>[DwH1]</a></span></span>First—I’ve
reduced the text size to 10.5. Georgia is a <i>big</i> x-height font, so even
at 10 it will be fine. I can’t believe it was actually 12 before. We could go
to 11 if you want to make it a little bigger, but I know fitting into the
allotted pages used to be a problem, so putting it at 10.5 will help. I’</p>

<p class=MsoCommentText>For on-screen reading it may seem too small, but in
print it should look right—try it. If you want to have two versions, one for
print and one for screen, then give the screen version 12 point type with 15pt
line height (the single spacing line height isn’t enough for Georgia because of
its x-height)</p>

</div>

</div>

<div>

<div id="_com_2" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_2','_com_2')"
onmouseout="msoCommentHide('_com_2')"><a name="_msocom_2"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_2" class=msocomoff>[DwH2]</a></span></span>I’ve
changed both the Heading 1, and TOC pages.</p>

<p class=MsoCommentText>Heading 1’s are now reversed and bleed off the side of
the page. This will make it easier for people to flip through and see where the
chapters start, because there’ll be a little black bit visible on the side of
the book.</p>

<p class=MsoCommentText>About the “part” heading on the next page:</p>

<p class=MsoCommentText>The “Part #” banner is a text box. The reason it’s a
text box is because it bleeds off the top, as well as the sides, so it’s more
easily seen.</p>

<p class=MsoCommentText>It should be formatted to this location on the page:</p>

<p class=MsoCommentText>-1.27&quot; from column</p>

<p class=MsoCommentText>-1.09 from paragraph</p>

<p class=MsoCommentText>And should be set so that text wrap is <i>square.</i></p>

<p class=MsoCommentText><b>Ideally: </b>The chapter titles would also be in
text boxes and bleed off the top, this would just make the more apparent from
the top and sides of the book and therefore easier to find. I’m concerned,
however, that it’ll be too much of a hassle for you to keep in place while
editing.</p>

<p class=MsoCommentText>So, we can either forget that idea as potentially
impractical, so you can hand it over to me when you’re closer to the end and I
can add it to all the chapters as I paginate.</p>

<p class=MsoCommentText>&nbsp;</p>

</div>

</div>

<div>

<div id="_com_3" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_3','_com_3')"
onmouseout="msoCommentHide('_com_3')"><a name="_msocom_3"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_3" class=msocomoff>[DwH3]</a></span></span>This
is how tables with a horizontal access should be formatted. Only horizontal
lines. Also notice that I got rid of the left margin of .25 which is on normal
text—this has a new tag, table text. I tried to create a macro in your doc
which would reformat them, but your macros are locked (I guess it does this for
security). So I created a macro that reformats the lines neatly, Here it is:</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>Sub
tableformat()</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>'</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>'
tableformat Macro</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>' Macro
recorded 6/27/2003 by  Daniel Will-Harris</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>'</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderTop).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderLeft).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderBottom).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderRight).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderHorizontal).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderVertical).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderDiagonalDown).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderDiagonalUp).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
With Selection.Borders(wdBorderHorizontal)</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineStyle = Options.DefaultBorderLineStyle</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineWidth = Options.DefaultBorderLineWidth</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.Color = Options.DefaultBorderColor</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>    End
With</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
Selection.Borders(wdBorderHorizontal).LineStyle = wdLineStyleNone</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
With Selection.Borders(wdBorderHorizontal)</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineStyle = Options.DefaultBorderLineStyle</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineWidth = Options.DefaultBorderLineWidth</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.Color = Options.DefaultBorderColor</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>    End
With</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
With Selection.Borders(wdBorderTop)</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineStyle = Options.DefaultBorderLineStyle</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineWidth = Options.DefaultBorderLineWidth</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.Color = Options.DefaultBorderColor</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>    End
With</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>   
With Selection.Borders(wdBorderBottom)</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineStyle = Options.DefaultBorderLineStyle</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.LineWidth = Options.DefaultBorderLineWidth</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>       
.Color = Options.DefaultBorderColor</p>

<p class=MsoCommentText style='margin-bottom:0in;margin-bottom:.0001pt'>    End
With</p>

<p class=MsoCommentText>End Sub</p>

</div>

</div>

<div>

<div id="_com_4" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_4','_com_4')"
onmouseout="msoCommentHide('_com_4')"><a name="_msocom_4"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_4" class=msocomoff>[DwH4]</a></span></span>I
put a page break before this to keep it on the same page. You’ll have to search
for manual page breaks to make sure things haven’t changed to make them
inappropriate.</p>

</div>

</div>

<div>

<div id="_com_5" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_5','_com_5')"
onmouseout="msoCommentHide('_com_5')"><a name="_msocom_5"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_5" class=msocomoff>[DwH5]</a></span></span>
I used shift-enter on headings when they didn’t break logically, but I doubt I
got them all, so if you see one that has a single word on the second line, or
just seems awkward, break it up logically.</p>

</div>

</div>

<div>

<div id="_com_6" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_6','_com_6')"
onmouseout="msoCommentHide('_com_6')"><a name="_msocom_6"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span style='font-size:8.0pt'>&nbsp;<a href="#_msoanchor_6" class=msocomoff>[DwH6]</a></span></span>This
table text tag has “keep together” turned on, so it shouldn’t break it in the
middle of a pargraph, but of course it does anyway, so you need to be aware of
page breaks in tables. </p>

</div>

</div>

</div>

</body>

</html>
